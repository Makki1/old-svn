
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  00002eac  00002f40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002eac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012af  00800146  00800146  00002f86  2**0
                  ALLOC
  3 .stab         00001110  00000000  00000000  00002f88  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009e0  00000000  00000000  00004098  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000004d8  00000000  00000000  00004a78  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000cec  00000000  00000000  00004f50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000848e  00000000  00000000  00005c3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002630  00000000  00000000  0000e0ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00005ff0  00000000  00000000  000106fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000006d0  00000000  00000000  000166ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000030ba  00000000  00000000  00016dbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000034b3  00000000  00000000  00019e76  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000538  00000000  00000000  0001d329  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       0:	1d c2       	rjmp	.+1082   	; 0x43c <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       4:	39 c2       	rjmp	.+1138   	; 0x478 <__bad_interrupt>

	return Serial_ReceiveByte();
}

int Serial_getchar_Blocking(FILE *Stream)
{
       6:	00 00       	nop
       8:	37 c2       	rjmp	.+1134   	; 0x478 <__bad_interrupt>
       a:	00 00       	nop
       c:	35 c2       	rjmp	.+1130   	; 0x478 <__bad_interrupt>
       e:	00 00       	nop
      10:	33 c2       	rjmp	.+1126   	; 0x478 <__bad_interrupt>
      12:	00 00       	nop
      14:	31 c2       	rjmp	.+1122   	; 0x478 <__bad_interrupt>
      16:	00 00       	nop
      18:	2f c2       	rjmp	.+1118   	; 0x478 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	2d c2       	rjmp	.+1114   	; 0x478 <__bad_interrupt>
      1e:	00 00       	nop
      20:	2b c2       	rjmp	.+1110   	; 0x478 <__bad_interrupt>
      22:	00 00       	nop
      24:	29 c2       	rjmp	.+1106   	; 0x478 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 d2 12 	jmp	0x25a4	; 0x25a4 <__vector_10>
      2c:	25 c2       	rjmp	.+1098   	; 0x478 <__bad_interrupt>
      2e:	00 00       	nop
      30:	23 c2       	rjmp	.+1094   	; 0x478 <__bad_interrupt>
      32:	00 00       	nop
      34:	21 c2       	rjmp	.+1090   	; 0x478 <__bad_interrupt>
      36:	00 00       	nop
      38:	1f c2       	rjmp	.+1086   	; 0x478 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	1d c2       	rjmp	.+1082   	; 0x478 <__bad_interrupt>
      3e:	00 00       	nop
      40:	1b c2       	rjmp	.+1078   	; 0x478 <__bad_interrupt>
      42:	00 00       	nop
      44:	19 c2       	rjmp	.+1074   	; 0x478 <__bad_interrupt>
      46:	00 00       	nop
      48:	17 c2       	rjmp	.+1070   	; 0x478 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	15 c2       	rjmp	.+1066   	; 0x478 <__bad_interrupt>
      4e:	00 00       	nop
      50:	13 c2       	rjmp	.+1062   	; 0x478 <__bad_interrupt>
      52:	00 00       	nop
      54:	11 c2       	rjmp	.+1058   	; 0x478 <__bad_interrupt>
      56:	00 00       	nop
      58:	0f c2       	rjmp	.+1054   	; 0x478 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0d c2       	rjmp	.+1050   	; 0x478 <__bad_interrupt>
      5e:	00 00       	nop
      60:	0b c2       	rjmp	.+1046   	; 0x478 <__bad_interrupt>
      62:	00 00       	nop
      64:	09 c2       	rjmp	.+1042   	; 0x478 <__bad_interrupt>
      66:	00 00       	nop
      68:	07 c2       	rjmp	.+1038   	; 0x478 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	05 c2       	rjmp	.+1034   	; 0x478 <__bad_interrupt>
      6e:	00 00       	nop
      70:	03 c2       	rjmp	.+1030   	; 0x478 <__bad_interrupt>
      72:	00 00       	nop
      74:	01 c2       	rjmp	.+1026   	; 0x478 <__bad_interrupt>
      76:	00 00       	nop
      78:	ff c1       	rjmp	.+1022   	; 0x478 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	fd c1       	rjmp	.+1018   	; 0x478 <__bad_interrupt>
      7e:	00 00       	nop
      80:	fb c1       	rjmp	.+1014   	; 0x478 <__bad_interrupt>
      82:	00 00       	nop
      84:	f9 c1       	rjmp	.+1010   	; 0x478 <__bad_interrupt>
      86:	00 00       	nop
      88:	f7 c1       	rjmp	.+1006   	; 0x478 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	f5 c1       	rjmp	.+1002   	; 0x478 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f3 c1       	rjmp	.+998    	; 0x478 <__bad_interrupt>
      92:	00 00       	nop
      94:	f1 c1       	rjmp	.+994    	; 0x478 <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 58 58 58 58 58 58 09 09 3c 2f 70 3e     </i>XXXXXX..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <AdapterVendorDescription>:
     422:	4c 55 46 41 20 52 4e 44 49 53 20 41 64 61 70 74     LUFA RNDIS Adapt
     432:	65 72 00                                            er.

00000435 <AdapterMACAddress>:
     435:	02 00 02 00 02 00 00                                .......

0000043c <__ctors_end>:
     43c:	11 24       	eor	r1, r1
     43e:	1f be       	out	0x3f, r1	; 63
     440:	cf ef       	ldi	r28, 0xFF	; 255
     442:	d0 e2       	ldi	r29, 0x20	; 32
     444:	de bf       	out	0x3e, r29	; 62
     446:	cd bf       	out	0x3d, r28	; 61

00000448 <__do_copy_data>:
     448:	11 e0       	ldi	r17, 0x01	; 1
     44a:	a0 e0       	ldi	r26, 0x00	; 0
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	ec ea       	ldi	r30, 0xAC	; 172
     450:	fe e2       	ldi	r31, 0x2E	; 46
     452:	00 e0       	ldi	r16, 0x00	; 0
     454:	0b bf       	out	0x3b, r16	; 59
     456:	02 c0       	rjmp	.+4      	; 0x45c <__do_copy_data+0x14>
     458:	07 90       	elpm	r0, Z+
     45a:	0d 92       	st	X+, r0
     45c:	a6 34       	cpi	r26, 0x46	; 70
     45e:	b1 07       	cpc	r27, r17
     460:	d9 f7       	brne	.-10     	; 0x458 <__do_copy_data+0x10>

00000462 <__do_clear_bss>:
     462:	13 e1       	ldi	r17, 0x13	; 19
     464:	a6 e4       	ldi	r26, 0x46	; 70
     466:	b1 e0       	ldi	r27, 0x01	; 1
     468:	01 c0       	rjmp	.+2      	; 0x46c <.do_clear_bss_start>

0000046a <.do_clear_bss_loop>:
     46a:	1d 92       	st	X+, r1

0000046c <.do_clear_bss_start>:
     46c:	a5 3f       	cpi	r26, 0xF5	; 245
     46e:	b1 07       	cpc	r27, r17
     470:	e1 f7       	brne	.-8      	; 0x46a <.do_clear_bss_loop>
     472:	bf d1       	rcall	.+894    	; 0x7f2 <main>
     474:	0c 94 54 17 	jmp	0x2ea8	; 0x2ea8 <_exit>

00000478 <__bad_interrupt>:
     478:	c3 cd       	rjmp	.-1146   	; 0x0 <__vectors>

0000047a <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     47a:	8b b1       	in	r24, 0x0b	; 11
     47c:	8f 70       	andi	r24, 0x0F	; 15
     47e:	80 6a       	ori	r24, 0xA0	; 160
     480:	8b b9       	out	0x0b, r24	; 11
 */
void EVENT_USB_Device_Connect(void)
{
	/* Indicate USB enumerating */
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     482:	08 95       	ret

00000484 <EVENT_USB_Device_Disconnect>:
     484:	8b b1       	in	r24, 0x0b	; 11
     486:	8f 70       	andi	r24, 0x0F	; 15
     488:	80 61       	ori	r24, 0x10	; 16
     48a:	8b b9       	out	0x0b, r24	; 11
 */
void EVENT_USB_Device_Disconnect(void)
{
	/* Indicate USB not ready */
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     48c:	08 95       	ret

0000048e <Ethernet_Task>:
	/* Task for Ethernet processing. Incoming ethernet frames are loaded into the FrameIN structure, and
	   outgoing frames should be loaded into the FrameOUT structure. Both structures can only hold a single
	   Ethernet frame at a time, so the FrameInBuffer bool is used to indicate when the buffers contain data. */

	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
     48e:	80 91 d8 13 	lds	r24, 0x13D8
     492:	84 30       	cpi	r24, 0x04	; 4
     494:	79 f4       	brne	.+30     	; 0x4b4 <Ethernet_Task+0x26>
	  return;

	/* Check if a frame has been written to the IN frame buffer */
	if (FrameIN.FrameLength)
     496:	80 91 29 07 	lds	r24, 0x0729
     49a:	90 91 2a 07 	lds	r25, 0x072A
     49e:	89 2b       	or	r24, r25
     4a0:	49 f0       	breq	.+18     	; 0x4b4 <Ethernet_Task+0x26>
     4a2:	8b b1       	in	r24, 0x0b	; 11
     4a4:	8f 70       	andi	r24, 0x0F	; 15
     4a6:	80 62       	ori	r24, 0x20	; 32
     4a8:	8b b9       	out	0x0b, r24	; 11
	{
		/* Indicate packet processing started */
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		/* Process the ethernet frame - replace this with your own Ethernet handler code as desired */
		Ethernet_ProcessPacket();
     4aa:	12 d2       	rcall	.+1060   	; 0x8d0 <Ethernet_ProcessPacket>
     4ac:	8b b1       	in	r24, 0x0b	; 11
     4ae:	8f 70       	andi	r24, 0x0F	; 15
     4b0:	80 66       	ori	r24, 0x60	; 96
     4b2:	8b b9       	out	0x0b, r24	; 11
     4b4:	08 95       	ret

000004b6 <RNDIS_Task>:
/** Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS
 *  wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper
 *  to a frame in the FrameOUT global before sending the buffer contents to the host.
 */
void RNDIS_Task(void)
{
     4b6:	df 93       	push	r29
     4b8:	cf 93       	push	r28
     4ba:	cd b7       	in	r28, 0x3d	; 61
     4bc:	de b7       	in	r29, 0x3e	; 62
     4be:	ac 97       	sbiw	r28, 0x2c	; 44
     4c0:	0f b6       	in	r0, 0x3f	; 63
     4c2:	f8 94       	cli
     4c4:	de bf       	out	0x3e, r29	; 62
     4c6:	0f be       	out	0x3f, r0	; 63
     4c8:	cd bf       	out	0x3d, r28	; 61
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     4ca:	83 e0       	ldi	r24, 0x03	; 3
     4cc:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     4d0:	80 91 e8 00 	lds	r24, 0x00E8
	/* Select the notification endpoint */
	Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

	/* Check if a message response is ready for the host */
	if (Endpoint_IsINReady() && ResponseReady)
     4d4:	80 ff       	sbrs	r24, 0
     4d6:	1c c0       	rjmp	.+56     	; 0x510 <RNDIS_Task+0x5a>
     4d8:	80 91 47 01 	lds	r24, 0x0147
     4dc:	88 23       	and	r24, r24
     4de:	c1 f0       	breq	.+48     	; 0x510 <RNDIS_Task+0x5a>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = 0,
				.wIndex        = 0,
				.wLength       = 0,
			};
     4e0:	de 01       	movw	r26, r28
     4e2:	11 96       	adiw	r26, 0x01	; 1
     4e4:	e0 e0       	ldi	r30, 0x00	; 0
     4e6:	f1 e0       	ldi	r31, 0x01	; 1
     4e8:	88 e0       	ldi	r24, 0x08	; 8
     4ea:	01 90       	ld	r0, Z+
     4ec:	0d 92       	st	X+, r0
     4ee:	81 50       	subi	r24, 0x01	; 1
     4f0:	e1 f7       	brne	.-8      	; 0x4ea <RNDIS_Task+0x34>

		/* Indicate that a message response is ready for the host */
		Endpoint_Write_Stream_LE(&Notification, sizeof(Notification), NULL);
     4f2:	ce 01       	movw	r24, r28
     4f4:	01 96       	adiw	r24, 0x01	; 1
     4f6:	68 e0       	ldi	r22, 0x08	; 8
     4f8:	70 e0       	ldi	r23, 0x00	; 0
     4fa:	40 e0       	ldi	r20, 0x00	; 0
     4fc:	50 e0       	ldi	r21, 0x00	; 0
     4fe:	0e 94 ee 14 	call	0x29dc	; 0x29dc <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     502:	80 91 e8 00 	lds	r24, 0x00E8
     506:	8e 77       	andi	r24, 0x7E	; 126
     508:	80 93 e8 00 	sts	0x00E8, r24

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();

		/* Indicate a response is no longer ready */
		ResponseReady = false;
     50c:	10 92 47 01 	sts	0x0147, r1
	}

	/* Don't process the data endpoints until the system is in the data initialized state, and the buffer is free */
	if ((CurrRNDISState == RNDIS_Data_Initialized) && !(MessageHeader->MessageLength))
     510:	20 91 48 01 	lds	r18, 0x0148
     514:	22 30       	cpi	r18, 0x02	; 2
     516:	09 f0       	breq	.+2      	; 0x51a <RNDIS_Task+0x64>
     518:	95 c0       	rjmp	.+298    	; 0x644 <RNDIS_Task+0x18e>
     51a:	e0 91 44 01 	lds	r30, 0x0144
     51e:	f0 91 45 01 	lds	r31, 0x0145
     522:	84 81       	ldd	r24, Z+4	; 0x04
     524:	95 81       	ldd	r25, Z+5	; 0x05
     526:	a6 81       	ldd	r26, Z+6	; 0x06
     528:	b7 81       	ldd	r27, Z+7	; 0x07
     52a:	00 97       	sbiw	r24, 0x00	; 0
     52c:	a1 05       	cpc	r26, r1
     52e:	b1 05       	cpc	r27, r1
     530:	09 f0       	breq	.+2      	; 0x534 <RNDIS_Task+0x7e>
     532:	88 c0       	rjmp	.+272    	; 0x644 <RNDIS_Task+0x18e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     534:	20 93 e9 00 	sts	0x00E9, r18
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     538:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data OUT endpoint */
		Endpoint_SelectEndpoint(CDC_RX_EPNUM);

		/* Check if the data OUT endpoint contains data, and that the IN buffer is empty */
		if (Endpoint_IsOUTReceived() && !(FrameIN.FrameLength))
     53c:	82 ff       	sbrs	r24, 2
     53e:	32 c0       	rjmp	.+100    	; 0x5a4 <RNDIS_Task+0xee>
     540:	80 91 29 07 	lds	r24, 0x0729
     544:	90 91 2a 07 	lds	r25, 0x072A
     548:	89 2b       	or	r24, r25
     54a:	61 f5       	brne	.+88     	; 0x5a4 <RNDIS_Task+0xee>
		{
			/* Read in the packet message header */
			Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     54c:	ce 01       	movw	r24, r28
     54e:	01 96       	adiw	r24, 0x01	; 1
     550:	6c e2       	ldi	r22, 0x2C	; 44
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	40 e0       	ldi	r20, 0x00	; 0
     556:	50 e0       	ldi	r21, 0x00	; 0
     558:	0e 94 9c 14 	call	0x2938	; 0x2938 <Endpoint_Read_Stream_LE>

			/* Stall the request if the data is too large */
			if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX)
     55c:	2d 85       	ldd	r18, Y+13	; 0x0d
     55e:	3e 85       	ldd	r19, Y+14	; 0x0e
     560:	4f 85       	ldd	r20, Y+15	; 0x0f
     562:	58 89       	ldd	r21, Y+16	; 0x10
     564:	2d 3d       	cpi	r18, 0xDD	; 221
     566:	85 e0       	ldi	r24, 0x05	; 5
     568:	38 07       	cpc	r19, r24
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	48 07       	cpc	r20, r24
     56e:	80 e0       	ldi	r24, 0x00	; 0
     570:	58 07       	cpc	r21, r24
     572:	30 f0       	brcs	.+12     	; 0x580 <RNDIS_Task+0xca>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     574:	80 91 eb 00 	lds	r24, 0x00EB
     578:	80 62       	ori	r24, 0x20	; 32
     57a:	80 93 eb 00 	sts	0x00EB, r24
     57e:	62 c0       	rjmp	.+196    	; 0x644 <RNDIS_Task+0x18e>
				Endpoint_StallTransaction();
				return;
			}

			/* Read in the Ethernet frame into the buffer */
			Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength, NULL);
     580:	8d e4       	ldi	r24, 0x4D	; 77
     582:	91 e0       	ldi	r25, 0x01	; 1
     584:	b9 01       	movw	r22, r18
     586:	40 e0       	ldi	r20, 0x00	; 0
     588:	50 e0       	ldi	r21, 0x00	; 0
     58a:	0e 94 9c 14 	call	0x2938	; 0x2938 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     58e:	80 91 e8 00 	lds	r24, 0x00E8
     592:	8b 77       	andi	r24, 0x7B	; 123
     594:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearOUT();

			/* Store the size of the Ethernet frame */
			FrameIN.FrameLength = RNDISPacketHeader.DataLength;
     598:	8d 85       	ldd	r24, Y+13	; 0x0d
     59a:	9e 85       	ldd	r25, Y+14	; 0x0e
     59c:	90 93 2a 07 	sts	0x072A, r25
     5a0:	80 93 29 07 	sts	0x0729, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     5a4:	81 e0       	ldi	r24, 0x01	; 1
     5a6:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     5aa:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data IN endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPNUM);

		/* Check if the data IN endpoint is ready for more data, and that the IN buffer is full */
		if (Endpoint_IsINReady() && FrameOUT.FrameLength)
     5ae:	80 ff       	sbrs	r24, 0
     5b0:	49 c0       	rjmp	.+146    	; 0x644 <RNDIS_Task+0x18e>
     5b2:	20 91 07 0d 	lds	r18, 0x0D07
     5b6:	30 91 08 0d 	lds	r19, 0x0D08
     5ba:	21 15       	cp	r18, r1
     5bc:	31 05       	cpc	r19, r1
     5be:	09 f4       	brne	.+2      	; 0x5c2 <RNDIS_Task+0x10c>
     5c0:	41 c0       	rjmp	.+130    	; 0x644 <RNDIS_Task+0x18e>
		{
			/* Clear the packet header with all 0s so that the relevant fields can be filled */
			memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
     5c2:	fe 01       	movw	r30, r28
     5c4:	31 96       	adiw	r30, 0x01	; 1
     5c6:	8c e2       	ldi	r24, 0x2C	; 44
     5c8:	df 01       	movw	r26, r30
     5ca:	1d 92       	st	X+, r1
     5cc:	8a 95       	dec	r24
     5ce:	e9 f7       	brne	.-6      	; 0x5ca <RNDIS_Task+0x114>

			/* Construct the required packet header fields in the buffer */
			RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
     5d0:	81 e0       	ldi	r24, 0x01	; 1
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	a0 e0       	ldi	r26, 0x00	; 0
     5d6:	b0 e0       	ldi	r27, 0x00	; 0
     5d8:	89 83       	std	Y+1, r24	; 0x01
     5da:	9a 83       	std	Y+2, r25	; 0x02
     5dc:	ab 83       	std	Y+3, r26	; 0x03
     5de:	bc 83       	std	Y+4, r27	; 0x04
			RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
     5e0:	24 5d       	subi	r18, 0xD4	; 212
     5e2:	3f 4f       	sbci	r19, 0xFF	; 255
     5e4:	c9 01       	movw	r24, r18
     5e6:	a0 e0       	ldi	r26, 0x00	; 0
     5e8:	b0 e0       	ldi	r27, 0x00	; 0
     5ea:	2c 52       	subi	r18, 0x2C	; 44
     5ec:	30 40       	sbci	r19, 0x00	; 0
     5ee:	8d 83       	std	Y+5, r24	; 0x05
     5f0:	9e 83       	std	Y+6, r25	; 0x06
     5f2:	af 83       	std	Y+7, r26	; 0x07
     5f4:	b8 87       	std	Y+8, r27	; 0x08
			RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
     5f6:	84 e2       	ldi	r24, 0x24	; 36
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	a0 e0       	ldi	r26, 0x00	; 0
     5fc:	b0 e0       	ldi	r27, 0x00	; 0
     5fe:	89 87       	std	Y+9, r24	; 0x09
     600:	9a 87       	std	Y+10, r25	; 0x0a
     602:	ab 87       	std	Y+11, r26	; 0x0b
     604:	bc 87       	std	Y+12, r27	; 0x0c
			RNDISPacketHeader.DataLength    = FrameOUT.FrameLength;
     606:	c9 01       	movw	r24, r18
     608:	a0 e0       	ldi	r26, 0x00	; 0
     60a:	b0 e0       	ldi	r27, 0x00	; 0
     60c:	8d 87       	std	Y+13, r24	; 0x0d
     60e:	9e 87       	std	Y+14, r25	; 0x0e
     610:	af 87       	std	Y+15, r26	; 0x0f
     612:	b8 8b       	std	Y+16, r27	; 0x10

			/* Send the packet header to the host */
			Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     614:	cf 01       	movw	r24, r30
     616:	6c e2       	ldi	r22, 0x2C	; 44
     618:	70 e0       	ldi	r23, 0x00	; 0
     61a:	40 e0       	ldi	r20, 0x00	; 0
     61c:	50 e0       	ldi	r21, 0x00	; 0
     61e:	0e 94 ee 14 	call	0x29dc	; 0x29dc <Endpoint_Write_Stream_LE>

			/* Send the Ethernet frame data to the host */
			Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength, NULL);
     622:	6d 85       	ldd	r22, Y+13	; 0x0d
     624:	7e 85       	ldd	r23, Y+14	; 0x0e
     626:	8b e2       	ldi	r24, 0x2B	; 43
     628:	97 e0       	ldi	r25, 0x07	; 7
     62a:	40 e0       	ldi	r20, 0x00	; 0
     62c:	50 e0       	ldi	r21, 0x00	; 0
     62e:	0e 94 ee 14 	call	0x29dc	; 0x29dc <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     632:	80 91 e8 00 	lds	r24, 0x00E8
     636:	8e 77       	andi	r24, 0x7E	; 126
     638:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearIN();

			/* Indicate Ethernet OUT buffer no longer full */
			FrameOUT.FrameLength = 0;
     63c:	10 92 08 0d 	sts	0x0D08, r1
     640:	10 92 07 0d 	sts	0x0D07, r1
		}
	}
}
     644:	ac 96       	adiw	r28, 0x2c	; 44
     646:	0f b6       	in	r0, 0x3f	; 63
     648:	f8 94       	cli
     64a:	de bf       	out	0x3e, r29	; 62
     64c:	0f be       	out	0x3f, r0	; 63
     64e:	cd bf       	out	0x3d, r28	; 61
     650:	cf 91       	pop	r28
     652:	df 91       	pop	r29
     654:	08 95       	ret

00000656 <EVENT_USB_Device_ControlRequest>:
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
	/* Process RNDIS class commands */
	switch (USB_ControlRequest.bRequest)
     656:	80 91 da 13 	lds	r24, 0x13DA
     65a:	88 23       	and	r24, r24
     65c:	21 f0       	breq	.+8      	; 0x666 <EVENT_USB_Device_ControlRequest+0x10>
     65e:	81 30       	cpi	r24, 0x01	; 1
     660:	09 f0       	breq	.+2      	; 0x664 <EVENT_USB_Device_ControlRequest+0xe>
     662:	50 c0       	rjmp	.+160    	; 0x704 <EVENT_USB_Device_ControlRequest+0xae>
     664:	19 c0       	rjmp	.+50     	; 0x698 <EVENT_USB_Device_ControlRequest+0x42>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     666:	80 91 d9 13 	lds	r24, 0x13D9
     66a:	81 32       	cpi	r24, 0x21	; 33
     66c:	09 f0       	breq	.+2      	; 0x670 <EVENT_USB_Device_ControlRequest+0x1a>
     66e:	4a c0       	rjmp	.+148    	; 0x704 <EVENT_USB_Device_ControlRequest+0xae>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     670:	80 91 e8 00 	lds	r24, 0x00E8
     674:	87 7f       	andi	r24, 0xF7	; 247
     676:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();

				/* Read in the RNDIS message into the message buffer */
				Endpoint_Read_Control_Stream_LE(RNDISMessageBuffer, USB_ControlRequest.wLength);
     67a:	60 91 df 13 	lds	r22, 0x13DF
     67e:	70 91 e0 13 	lds	r23, 0x13E0
     682:	80 e5       	ldi	r24, 0x50	; 80
     684:	93 e1       	ldi	r25, 0x13	; 19
     686:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     68a:	80 91 e8 00 	lds	r24, 0x00E8
     68e:	8e 77       	andi	r24, 0x7E	; 126
     690:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();

				/* Process the RNDIS message */
				ProcessRNDISControlMessage();
     694:	0c 94 17 0f 	jmp	0x1e2e	; 0x1e2e <ProcessRNDISControlMessage>
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     698:	80 91 d9 13 	lds	r24, 0x13D9
     69c:	81 3a       	cpi	r24, 0xA1	; 161
     69e:	91 f5       	brne	.+100    	; 0x704 <EVENT_USB_Device_ControlRequest+0xae>
			{
				/* Check if a response to the last message is ready */
				if (!(MessageHeader->MessageLength))
     6a0:	e0 91 44 01 	lds	r30, 0x0144
     6a4:	f0 91 45 01 	lds	r31, 0x0145
     6a8:	84 81       	ldd	r24, Z+4	; 0x04
     6aa:	95 81       	ldd	r25, Z+5	; 0x05
     6ac:	a6 81       	ldd	r26, Z+6	; 0x06
     6ae:	b7 81       	ldd	r27, Z+7	; 0x07
     6b0:	00 97       	sbiw	r24, 0x00	; 0
     6b2:	a1 05       	cpc	r26, r1
     6b4:	b1 05       	cpc	r27, r1
     6b6:	51 f4       	brne	.+20     	; 0x6cc <EVENT_USB_Device_ControlRequest+0x76>
				{
					/* Set the response to a single 0x00 byte to indicate that no response is ready */
					RNDISMessageBuffer[0] = 0;
     6b8:	10 92 50 13 	sts	0x1350, r1
					MessageHeader->MessageLength = 1;
     6bc:	81 e0       	ldi	r24, 0x01	; 1
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	a0 e0       	ldi	r26, 0x00	; 0
     6c2:	b0 e0       	ldi	r27, 0x00	; 0
     6c4:	84 83       	std	Z+4, r24	; 0x04
     6c6:	95 83       	std	Z+5, r25	; 0x05
     6c8:	a6 83       	std	Z+6, r26	; 0x06
     6ca:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     6cc:	80 91 e8 00 	lds	r24, 0x00E8
     6d0:	87 7f       	andi	r24, 0xF7	; 247
     6d2:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();

				/* Write the message response data to the endpoint */
				Endpoint_Write_Control_Stream_LE(RNDISMessageBuffer, MessageHeader->MessageLength);
     6d6:	e0 91 44 01 	lds	r30, 0x0144
     6da:	f0 91 45 01 	lds	r31, 0x0145
     6de:	64 81       	ldd	r22, Z+4	; 0x04
     6e0:	75 81       	ldd	r23, Z+5	; 0x05
     6e2:	80 e5       	ldi	r24, 0x50	; 80
     6e4:	93 e1       	ldi	r25, 0x13	; 19
     6e6:	0e 94 9c 13 	call	0x2738	; 0x2738 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     6ea:	80 91 e8 00 	lds	r24, 0x00E8
     6ee:	8b 77       	andi	r24, 0x7B	; 123
     6f0:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				/* Reset the message header once again after transmission */
				MessageHeader->MessageLength = 0;
     6f4:	e0 91 44 01 	lds	r30, 0x0144
     6f8:	f0 91 45 01 	lds	r31, 0x0145
     6fc:	14 82       	std	Z+4, r1	; 0x04
     6fe:	15 82       	std	Z+5, r1	; 0x05
     700:	16 82       	std	Z+6, r1	; 0x06
     702:	17 82       	std	Z+7, r1	; 0x07
     704:	08 95       	ret

00000706 <EVENT_USB_Device_ConfigurationChanged>:

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the RNDIS device endpoints and starts the relevant tasks.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     706:	ef 92       	push	r14
     708:	ff 92       	push	r15
     70a:	0f 93       	push	r16
     70c:	1f 93       	push	r17
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	61 e8       	ldi	r22, 0x81	; 129
     712:	42 e3       	ldi	r20, 0x32	; 50
     714:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <Endpoint_ConfigureEndpoint_Prv>
     718:	08 2f       	mov	r16, r24
     71a:	82 e0       	ldi	r24, 0x02	; 2
     71c:	60 e8       	ldi	r22, 0x80	; 128
     71e:	42 e3       	ldi	r20, 0x32	; 50
     720:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <Endpoint_ConfigureEndpoint_Prv>
     724:	e8 2e       	mov	r14, r24
     726:	83 e0       	ldi	r24, 0x03	; 3
     728:	61 ec       	ldi	r22, 0xC1	; 193
     72a:	42 e0       	ldi	r20, 0x02	; 2
     72c:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <Endpoint_ConfigureEndpoint_Prv>
	                                            CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
	                                            CDC_NOTIFICATION_EPSIZE, ENDPOINT_BANK_SINGLE);

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     730:	10 e0       	ldi	r17, 0x00	; 0
     732:	ff 24       	eor	r15, r15
     734:	0e 21       	and	r16, r14
     736:	1f 21       	and	r17, r15
     738:	01 70       	andi	r16, 0x01	; 1
     73a:	10 70       	andi	r17, 0x00	; 0
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	08 23       	and	r16, r24
     740:	19 23       	and	r17, r25
     742:	01 2b       	or	r16, r17
     744:	11 f4       	brne	.+4      	; 0x74a <EVENT_USB_Device_ConfigurationChanged+0x44>
     746:	90 e9       	ldi	r25, 0x90	; 144
     748:	01 c0       	rjmp	.+2      	; 0x74c <EVENT_USB_Device_ConfigurationChanged+0x46>
     74a:	90 e6       	ldi	r25, 0x60	; 96
     74c:	8b b1       	in	r24, 0x0b	; 11
     74e:	8f 70       	andi	r24, 0x0F	; 15
     750:	98 2b       	or	r25, r24
     752:	9b b9       	out	0x0b, r25	; 11
}
     754:	1f 91       	pop	r17
     756:	0f 91       	pop	r16
     758:	ff 90       	pop	r15
     75a:	ef 90       	pop	r14
     75c:	08 95       	ret

0000075e <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     75e:	84 b7       	in	r24, 0x34	; 52
     760:	87 7f       	andi	r24, 0xF7	; 247
     762:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     764:	28 e1       	ldi	r18, 0x18	; 24
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	20 93 60 00 	sts	0x0060, r18
     76e:	10 92 60 00 	sts	0x0060, r1
     772:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     774:	90 e0       	ldi	r25, 0x00	; 0
     776:	80 e8       	ldi	r24, 0x80	; 128
     778:	0f b6       	in	r0, 0x3f	; 63
     77a:	f8 94       	cli
     77c:	80 93 61 00 	sts	0x0061, r24
     780:	90 93 61 00 	sts	0x0061, r25
     784:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     786:	8a b1       	in	r24, 0x0a	; 10
     788:	80 6f       	ori	r24, 0xF0	; 240
     78a:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     78c:	8b b1       	in	r24, 0x0b	; 11
     78e:	8f 70       	andi	r24, 0x0F	; 15
     790:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     792:	83 e3       	ldi	r24, 0x33	; 51
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	90 93 cd 00 	sts	0x00CD, r25
     79a:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     79e:	86 e0       	ldi	r24, 0x06	; 6
     7a0:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     7a4:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     7a8:	20 93 c9 00 	sts	0x00C9, r18

				DDRD  |= (1 << 3);
     7ac:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     7ae:	5a 9a       	sbi	0x0b, 2	; 11
	clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     7b0:	0e 94 bc 12 	call	0x2578	; 0x2578 <USB_Init>
			static inline void Serial_CreateStream(FILE* Stream)
			{
				if (!(Stream))
				{
					Stream = &USARTSerialStream;
					stdin  = Stream;
     7b4:	e1 ee       	ldi	r30, 0xE1	; 225
     7b6:	f3 e1       	ldi	r31, 0x13	; 19
     7b8:	f0 93 f0 13 	sts	0x13F0, r31
     7bc:	e0 93 ef 13 	sts	0x13EF, r30
					stdout = Stream;
     7c0:	f0 93 f2 13 	sts	0x13F2, r31
     7c4:	e0 93 f1 13 	sts	0x13F1, r30
				}
			
				*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
     7c8:	8e e0       	ldi	r24, 0x0E	; 14
     7ca:	df 01       	movw	r26, r30
     7cc:	1d 92       	st	X+, r1
     7ce:	8a 95       	dec	r24
     7d0:	e9 f7       	brne	.-6      	; 0x7cc <SetupHardware+0x6e>
     7d2:	83 e0       	ldi	r24, 0x03	; 3
     7d4:	80 93 e4 13 	sts	0x13E4, r24
     7d8:	89 ed       	ldi	r24, 0xD9	; 217
     7da:	96 e1       	ldi	r25, 0x16	; 22
     7dc:	90 93 ea 13 	sts	0x13EA, r25
     7e0:	80 93 e9 13 	sts	0x13E9, r24
     7e4:	83 ee       	ldi	r24, 0xE3	; 227
     7e6:	96 e1       	ldi	r25, 0x16	; 22
     7e8:	90 93 ec 13 	sts	0x13EC, r25
     7ec:	80 93 eb 13 	sts	0x13EB, r24
	
	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);	
}
     7f0:	08 95       	ret

000007f2 <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     7f2:	b5 df       	rcall	.-150    	; 0x75e <SetupHardware>

	/* Webserver Initialization */
	TCP_Init();
     7f4:	1b d1       	rcall	.+566    	; 0xa2c <TCP_Init>
	Webserver_Init();
     7f6:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <Webserver_Init>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     7fa:	8b b1       	in	r24, 0x0b	; 11
     7fc:	8f 70       	andi	r24, 0x0F	; 15
     7fe:	80 61       	ori	r24, 0x10	; 16
     800:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     802:	78 94       	sei

	for (;;)
	{
		Ethernet_Task();
     804:	44 de       	rcall	.-888    	; 0x48e <Ethernet_Task>
		TCP_Task();
     806:	8c d6       	rcall	.+3352   	; 0x1520 <TCP_Task>
		RNDIS_Task();
     808:	56 de       	rcall	.-852    	; 0x4b6 <RNDIS_Task>
		USB_USBTask();
     80a:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <USB_USBTask>
     80e:	fa cf       	rjmp	.-12     	; 0x804 <main+0x12>

00000810 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     810:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     812:	92 30       	cpi	r25, 0x02	; 2
     814:	49 f0       	breq	.+18     	; 0x828 <CALLBACK_USB_GetDescriptor+0x18>
     816:	93 30       	cpi	r25, 0x03	; 3
     818:	61 f0       	breq	.+24     	; 0x832 <CALLBACK_USB_GetDescriptor+0x22>
     81a:	91 30       	cpi	r25, 0x01	; 1
     81c:	f9 f4       	brne	.+62     	; 0x85c <CALLBACK_USB_GetDescriptor+0x4c>
     81e:	e8 e9       	ldi	r30, 0x98	; 152
     820:	f0 e0       	ldi	r31, 0x00	; 0
     822:	22 e1       	ldi	r18, 0x12	; 18
     824:	30 e0       	ldi	r19, 0x00	; 0
     826:	1e c0       	rjmp	.+60     	; 0x864 <CALLBACK_USB_GetDescriptor+0x54>
     828:	ea ea       	ldi	r30, 0xAA	; 170
     82a:	f0 e0       	ldi	r31, 0x00	; 0
     82c:	2e e3       	ldi	r18, 0x3E	; 62
     82e:	30 e0       	ldi	r19, 0x00	; 0
     830:	19 c0       	rjmp	.+50     	; 0x864 <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     832:	81 30       	cpi	r24, 0x01	; 1
     834:	49 f0       	breq	.+18     	; 0x848 <CALLBACK_USB_GetDescriptor+0x38>
     836:	81 30       	cpi	r24, 0x01	; 1
     838:	18 f0       	brcs	.+6      	; 0x840 <CALLBACK_USB_GetDescriptor+0x30>
     83a:	82 30       	cpi	r24, 0x02	; 2
     83c:	79 f4       	brne	.+30     	; 0x85c <CALLBACK_USB_GetDescriptor+0x4c>
     83e:	08 c0       	rjmp	.+16     	; 0x850 <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     840:	e8 ee       	ldi	r30, 0xE8	; 232
     842:	f0 e0       	ldi	r31, 0x00	; 0
     844:	84 91       	lpm	r24, Z+
     846:	07 c0       	rjmp	.+14     	; 0x856 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     848:	ec ee       	ldi	r30, 0xEC	; 236
     84a:	f0 e0       	ldi	r31, 0x00	; 0
     84c:	84 91       	lpm	r24, Z+
     84e:	03 c0       	rjmp	.+6      	; 0x856 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     850:	e6 e0       	ldi	r30, 0x06	; 6
     852:	f1 e0       	ldi	r31, 0x01	; 1
     854:	84 91       	lpm	r24, Z+
     856:	28 2f       	mov	r18, r24
     858:	30 e0       	ldi	r19, 0x00	; 0
     85a:	04 c0       	rjmp	.+8      	; 0x864 <CALLBACK_USB_GetDescriptor+0x54>
     85c:	e0 e0       	ldi	r30, 0x00	; 0
     85e:	f0 e0       	ldi	r31, 0x00	; 0
     860:	20 e0       	ldi	r18, 0x00	; 0
     862:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     864:	ed 93       	st	X+, r30
     866:	fc 93       	st	X, r31
	return Size;
}
     868:	c9 01       	movw	r24, r18
     86a:	08 95       	ret

0000086c <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     86c:	cf 93       	push	r28
     86e:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     870:	76 95       	lsr	r23
     872:	67 95       	ror	r22
     874:	ec 01       	movw	r28, r24
     876:	20 e0       	ldi	r18, 0x00	; 0
     878:	30 e0       	ldi	r19, 0x00	; 0
     87a:	40 e0       	ldi	r20, 0x00	; 0
     87c:	50 e0       	ldi	r21, 0x00	; 0
     87e:	e0 e0       	ldi	r30, 0x00	; 0
     880:	f0 e0       	ldi	r31, 0x00	; 0
     882:	09 c0       	rjmp	.+18     	; 0x896 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     884:	89 91       	ld	r24, Y+
     886:	99 91       	ld	r25, Y+
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	28 0f       	add	r18, r24
     88e:	39 1f       	adc	r19, r25
     890:	4a 1f       	adc	r20, r26
     892:	5b 1f       	adc	r21, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     894:	31 96       	adiw	r30, 0x01	; 1
     896:	e6 17       	cp	r30, r22
     898:	f7 07       	cpc	r31, r23
     89a:	a0 f3       	brcs	.-24     	; 0x884 <Ethernet_Checksum16+0x18>
     89c:	0b c0       	rjmp	.+22     	; 0x8b4 <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     89e:	da 01       	movw	r26, r20
     8a0:	c9 01       	movw	r24, r18
     8a2:	a0 70       	andi	r26, 0x00	; 0
     8a4:	b0 70       	andi	r27, 0x00	; 0
     8a6:	9a 01       	movw	r18, r20
     8a8:	44 27       	eor	r20, r20
     8aa:	55 27       	eor	r21, r21
     8ac:	28 0f       	add	r18, r24
     8ae:	39 1f       	adc	r19, r25
     8b0:	4a 1f       	adc	r20, r26
     8b2:	5b 1f       	adc	r21, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     8b4:	da 01       	movw	r26, r20
     8b6:	c9 01       	movw	r24, r18
     8b8:	80 70       	andi	r24, 0x00	; 0
     8ba:	90 70       	andi	r25, 0x00	; 0
     8bc:	00 97       	sbiw	r24, 0x00	; 0
     8be:	a1 05       	cpc	r26, r1
     8c0:	b1 05       	cpc	r27, r1
     8c2:	69 f7       	brne	.-38     	; 0x89e <Ethernet_Checksum16+0x32>
     8c4:	20 95       	com	r18
     8c6:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     8c8:	c9 01       	movw	r24, r18
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <Ethernet_ProcessPacket>:

/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(void)
{
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
	DecodeEthernetFrameHeader(FrameIN.FrameData);
     8d4:	cd e4       	ldi	r28, 0x4D	; 77
     8d6:	d1 e0       	ldi	r29, 0x01	; 1
     8d8:	ce 01       	movw	r24, r28
     8da:	68 d0       	rcall	.+208    	; 0x9ac <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     8dc:	ce 01       	movw	r24, r28
     8de:	68 e0       	ldi	r22, 0x08	; 8
     8e0:	71 e0       	ldi	r23, 0x01	; 1
     8e2:	46 e0       	ldi	r20, 0x06	; 6
     8e4:	50 e0       	ldi	r21, 0x00	; 0
     8e6:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
     8ea:	00 97       	sbiw	r24, 0x00	; 0
     8ec:	51 f0       	breq	.+20     	; 0x902 <Ethernet_ProcessPacket+0x32>
     8ee:	ce 01       	movw	r24, r28
     8f0:	62 e1       	ldi	r22, 0x12	; 18
     8f2:	71 e0       	ldi	r23, 0x01	; 1
     8f4:	46 e0       	ldi	r20, 0x06	; 6
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
     8fc:	00 97       	sbiw	r24, 0x00	; 0
     8fe:	09 f0       	breq	.+2      	; 0x902 <Ethernet_ProcessPacket+0x32>
     900:	4e c0       	rjmp	.+156    	; 0x99e <Ethernet_ProcessPacket+0xce>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     902:	80 91 29 07 	lds	r24, 0x0729
     906:	90 91 2a 07 	lds	r25, 0x072A

				Temp = Data.Bytes[0];
     90a:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
     90c:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
     90e:	92 2f       	mov	r25, r18
     910:	81 50       	subi	r24, 0x01	; 1
     912:	96 40       	sbci	r25, 0x06	; 6
     914:	08 f4       	brcc	.+2      	; 0x918 <Ethernet_ProcessPacket+0x48>
     916:	43 c0       	rjmp	.+134    	; 0x99e <Ethernet_ProcessPacket+0xce>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     918:	20 91 59 01 	lds	r18, 0x0159
     91c:	30 91 5a 01 	lds	r19, 0x015A

				Temp = Data.Bytes[0];
     920:	82 2f       	mov	r24, r18
				Data.Bytes[0] = Data.Bytes[1];
     922:	23 2f       	mov	r18, r19
				Data.Bytes[1] = Temp;
     924:	38 2f       	mov	r19, r24
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		(SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     926:	88 e0       	ldi	r24, 0x08	; 8
     928:	20 30       	cpi	r18, 0x00	; 0
     92a:	38 07       	cpc	r19, r24
     92c:	51 f0       	breq	.+20     	; 0x942 <Ethernet_ProcessPacket+0x72>
     92e:	26 50       	subi	r18, 0x06	; 6
     930:	38 40       	sbci	r19, 0x08	; 8
     932:	a9 f5       	brne	.+106    	; 0x99e <Ethernet_ProcessPacket+0xce>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     934:	8b e5       	ldi	r24, 0x5B	; 91
     936:	91 e0       	ldi	r25, 0x01	; 1
     938:	69 e3       	ldi	r22, 0x39	; 57
     93a:	77 e0       	ldi	r23, 0x07	; 7
     93c:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <ARP_ProcessARPPacket>
     940:	06 c0       	rjmp	.+12     	; 0x94e <Ethernet_ProcessPacket+0x7e>
				                               &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     942:	8b e5       	ldi	r24, 0x5B	; 91
     944:	91 e0       	ldi	r25, 0x01	; 1
     946:	69 e3       	ldi	r22, 0x39	; 57
     948:	77 e0       	ldi	r23, 0x07	; 7
     94a:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <IP_ProcessIPPacket>
     94e:	9c 01       	movw	r18, r24
				                             &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     950:	18 16       	cp	r1, r24
     952:	19 06       	cpc	r1, r25
     954:	0c f5       	brge	.+66     	; 0x998 <Ethernet_ProcessPacket+0xc8>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     956:	a1 e3       	ldi	r26, 0x31	; 49
     958:	b7 e0       	ldi	r27, 0x07	; 7
     95a:	e8 e0       	ldi	r30, 0x08	; 8
     95c:	f1 e0       	ldi	r31, 0x01	; 1
     95e:	86 e0       	ldi	r24, 0x06	; 6
     960:	01 90       	ld	r0, Z+
     962:	0d 92       	st	X+, r0
     964:	81 50       	subi	r24, 0x01	; 1
     966:	e1 f7       	brne	.-8      	; 0x960 <Ethernet_ProcessPacket+0x90>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     968:	ab e2       	ldi	r26, 0x2B	; 43
     96a:	b7 e0       	ldi	r27, 0x07	; 7
     96c:	e3 e5       	ldi	r30, 0x53	; 83
     96e:	f1 e0       	ldi	r31, 0x01	; 1
     970:	86 e0       	ldi	r24, 0x06	; 6
     972:	01 90       	ld	r0, Z+
     974:	0d 92       	st	X+, r0
     976:	81 50       	subi	r24, 0x01	; 1
     978:	e1 f7       	brne	.-8      	; 0x972 <Ethernet_ProcessPacket+0xa2>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     97a:	80 91 59 01 	lds	r24, 0x0159
     97e:	90 91 5a 01 	lds	r25, 0x015A
     982:	90 93 38 07 	sts	0x0738, r25
     986:	80 93 37 07 	sts	0x0737, r24

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     98a:	22 5f       	subi	r18, 0xF2	; 242
     98c:	3f 4f       	sbci	r19, 0xFF	; 255
     98e:	30 93 08 0d 	sts	0x0D08, r19
     992:	20 93 07 0d 	sts	0x0D07, r18
     996:	03 c0       	rjmp	.+6      	; 0x99e <Ethernet_ProcessPacket+0xce>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     998:	2f 5f       	subi	r18, 0xFF	; 255
     99a:	3f 4f       	sbci	r19, 0xFF	; 255
     99c:	21 f0       	breq	.+8      	; 0x9a6 <Ethernet_ProcessPacket+0xd6>
	{
		/* Clear the frame buffer */
		FrameIN.FrameLength = 0;
     99e:	10 92 2a 07 	sts	0x072A, r1
     9a2:	10 92 29 07 	sts	0x0729, r1
	}
}
     9a6:	df 91       	pop	r29
     9a8:	cf 91       	pop	r28
     9aa:	08 95       	ret

000009ac <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     9ac:	08 95       	ret

000009ae <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     9ae:	08 95       	ret

000009b0 <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     9b0:	08 95       	ret

000009b2 <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     9b2:	08 95       	ret

000009b4 <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     9b4:	08 95       	ret

000009b6 <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     9b6:	08 95       	ret

000009b8 <DecodeDHCPHeader>:
		}

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}
	#endif
}
     9b8:	08 95       	ret

000009ba <ICMP_ProcessICMPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(void* InDataStart,
                               void* OutDataStart)
{
     9ba:	0f 93       	push	r16
     9bc:	1f 93       	push	r17
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	8c 01       	movw	r16, r24
     9c4:	eb 01       	movw	r28, r22
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     9c6:	f5 df       	rcall	.-22     	; 0x9b2 <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     9c8:	f8 01       	movw	r30, r16
     9ca:	80 81       	ld	r24, Z
     9cc:	88 30       	cpi	r24, 0x08	; 8
     9ce:	19 f0       	breq	.+6      	; 0x9d6 <ICMP_ProcessICMPPacket+0x1c>
     9d0:	20 e0       	ldi	r18, 0x00	; 0
     9d2:	30 e0       	ldi	r19, 0x00	; 0
     9d4:	25 c0       	rjmp	.+74     	; 0xa20 <ICMP_ProcessICMPPacket+0x66>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     9d6:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     9d8:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     9da:	1b 82       	std	Y+3, r1	; 0x03
     9dc:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     9de:	f8 01       	movw	r30, r16
     9e0:	84 81       	ldd	r24, Z+4	; 0x04
     9e2:	95 81       	ldd	r25, Z+5	; 0x05
     9e4:	9d 83       	std	Y+5, r25	; 0x05
     9e6:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     9e8:	86 81       	ldd	r24, Z+6	; 0x06
     9ea:	97 81       	ldd	r25, Z+7	; 0x07
     9ec:	9f 83       	std	Y+7, r25	; 0x07
     9ee:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN.FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN.FrameData));
     9f0:	b8 01       	movw	r22, r16
     9f2:	68 5f       	subi	r22, 0xF8	; 248
     9f4:	7f 4f       	sbci	r23, 0xFF	; 255
     9f6:	00 91 29 07 	lds	r16, 0x0729
     9fa:	10 91 2a 07 	lds	r17, 0x072A
     9fe:	03 5b       	subi	r16, 0xB3	; 179
     a00:	1e 4f       	sbci	r17, 0xFE	; 254
     a02:	06 1b       	sub	r16, r22
     a04:	17 0b       	sbc	r17, r23

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     a06:	ce 01       	movw	r24, r28
     a08:	08 96       	adiw	r24, 0x08	; 8
     a0a:	a8 01       	movw	r20, r16
     a0c:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     a10:	08 5f       	subi	r16, 0xF8	; 248
     a12:	1f 4f       	sbci	r17, 0xFF	; 255
     a14:	ce 01       	movw	r24, r28
     a16:	b8 01       	movw	r22, r16
     a18:	29 df       	rcall	.-430    	; 0x86c <Ethernet_Checksum16>
     a1a:	9b 83       	std	Y+3, r25	; 0x03
     a1c:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     a1e:	98 01       	movw	r18, r16
	}

	return NO_RESPONSE;
}
     a20:	c9 01       	movw	r24, r18
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	1f 91       	pop	r17
     a28:	0f 91       	pop	r16
     a2a:	08 95       	ret

00000a2c <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     a2c:	10 92 4d 13 	sts	0x134D, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     a30:	8a e0       	ldi	r24, 0x0A	; 10
     a32:	80 93 1e 0f 	sts	0x0F1E, r24
     a36:	80 93 34 11 	sts	0x1134, r24
     a3a:	80 93 4a 13 	sts	0x134A, r24
}
     a3e:	08 95       	ret

00000a40 <TCP_SetPortState>:
 *  \return Boolean true if the port state was set, false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     a40:	9c 01       	movw	r18, r24

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     a42:	80 91 4b 13 	lds	r24, 0x134B
     a46:	90 91 4c 13 	lds	r25, 0x134C
     a4a:	82 17       	cp	r24, r18
     a4c:	93 07       	cpc	r25, r19
     a4e:	19 f4       	brne	.+6      	; 0xa56 <TCP_SetPortState+0x16>
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	13 c0       	rjmp	.+38     	; 0xa7c <TCP_SetPortState+0x3c>
     a56:	80 91 50 13 	lds	r24, 0x1350
     a5a:	90 91 51 13 	lds	r25, 0x1351
     a5e:	82 17       	cp	r24, r18
     a60:	93 07       	cpc	r25, r19
     a62:	19 f4       	brne	.+6      	; 0xa6a <TCP_SetPortState+0x2a>
     a64:	81 e0       	ldi	r24, 0x01	; 1
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	09 c0       	rjmp	.+18     	; 0xa7c <TCP_SetPortState+0x3c>
     a6a:	80 91 55 13 	lds	r24, 0x1355
     a6e:	90 91 56 13 	lds	r25, 0x1356
     a72:	82 17       	cp	r24, r18
     a74:	93 07       	cpc	r25, r19
     a76:	79 f4       	brne	.+30     	; 0xa96 <TCP_SetPortState+0x56>
     a78:	82 e0       	ldi	r24, 0x02	; 2
     a7a:	90 e0       	ldi	r25, 0x00	; 0
		{
			PortStateTable[PTableEntry].State = State;
     a7c:	fc 01       	movw	r30, r24
     a7e:	ee 0f       	add	r30, r30
     a80:	ff 1f       	adc	r31, r31
     a82:	ee 0f       	add	r30, r30
     a84:	ff 1f       	adc	r31, r31
     a86:	e8 0f       	add	r30, r24
     a88:	f9 1f       	adc	r31, r25
     a8a:	e5 5b       	subi	r30, 0xB5	; 181
     a8c:	fc 4e       	sbci	r31, 0xEC	; 236
     a8e:	62 83       	std	Z+2, r22	; 0x02
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     a90:	54 83       	std	Z+4, r21	; 0x04
     a92:	43 83       	std	Z+3, r20	; 0x03
     a94:	02 c0       	rjmp	.+4      	; 0xa9a <TCP_SetPortState+0x5a>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     a96:	61 30       	cpi	r22, 0x01	; 1
     a98:	11 f0       	breq	.+4      	; 0xa9e <TCP_SetPortState+0x5e>
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	08 95       	ret
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     a9e:	80 91 4d 13 	lds	r24, 0x134D
     aa2:	88 23       	and	r24, r24
     aa4:	19 f4       	brne	.+6      	; 0xaac <TCP_SetPortState+0x6c>
     aa6:	80 e0       	ldi	r24, 0x00	; 0
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	0f c0       	rjmp	.+30     	; 0xaca <TCP_SetPortState+0x8a>
     aac:	80 91 52 13 	lds	r24, 0x1352
     ab0:	88 23       	and	r24, r24
     ab2:	19 f4       	brne	.+6      	; 0xaba <TCP_SetPortState+0x7a>
     ab4:	81 e0       	ldi	r24, 0x01	; 1
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	08 c0       	rjmp	.+16     	; 0xaca <TCP_SetPortState+0x8a>
     aba:	80 91 57 13 	lds	r24, 0x1357
     abe:	88 23       	and	r24, r24
     ac0:	11 f0       	breq	.+4      	; 0xac6 <TCP_SetPortState+0x86>
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	08 95       	ret
     ac6:	82 e0       	ldi	r24, 0x02	; 2
     ac8:	90 e0       	ldi	r25, 0x00	; 0
			{
				PortStateTable[PTableEntry].Port  = Port;
     aca:	fc 01       	movw	r30, r24
     acc:	ee 0f       	add	r30, r30
     ace:	ff 1f       	adc	r31, r31
     ad0:	ee 0f       	add	r30, r30
     ad2:	ff 1f       	adc	r31, r31
     ad4:	e8 0f       	add	r30, r24
     ad6:	f9 1f       	adc	r31, r25
     ad8:	e5 5b       	subi	r30, 0xB5	; 181
     ada:	fc 4e       	sbci	r31, 0xEC	; 236
     adc:	31 83       	std	Z+1, r19	; 0x01
     ade:	20 83       	st	Z, r18
				PortStateTable[PTableEntry].State = State;
     ae0:	81 e0       	ldi	r24, 0x01	; 1
     ae2:	82 83       	std	Z+2, r24	; 0x02
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     ae4:	54 83       	std	Z+4, r21	; 0x04
     ae6:	43 83       	std	Z+3, r20	; 0x03
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     ae8:	08 95       	ret

00000aea <TCP_GetPortState>:
 *  \param[in] Port  TCP port whose state is to be retrieved, given in big-endian
 *
 *  \return A value from the \ref TCP_PortStates_t enum
 */
uint8_t TCP_GetPortState(const uint16_t Port)
{
     aea:	9c 01       	movw	r18, r24
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     aec:	80 91 4b 13 	lds	r24, 0x134B
     af0:	90 91 4c 13 	lds	r25, 0x134C
     af4:	82 17       	cp	r24, r18
     af6:	93 07       	cpc	r25, r19
     af8:	19 f4       	brne	.+6      	; 0xb00 <TCP_GetPortState+0x16>
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	15 c0       	rjmp	.+42     	; 0xb2a <TCP_GetPortState+0x40>
     b00:	80 91 50 13 	lds	r24, 0x1350
     b04:	90 91 51 13 	lds	r25, 0x1351
     b08:	82 17       	cp	r24, r18
     b0a:	93 07       	cpc	r25, r19
     b0c:	19 f4       	brne	.+6      	; 0xb14 <TCP_GetPortState+0x2a>
     b0e:	81 e0       	ldi	r24, 0x01	; 1
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	0b c0       	rjmp	.+22     	; 0xb2a <TCP_GetPortState+0x40>
     b14:	80 91 55 13 	lds	r24, 0x1355
     b18:	90 91 56 13 	lds	r25, 0x1356
     b1c:	82 17       	cp	r24, r18
     b1e:	93 07       	cpc	r25, r19
     b20:	11 f0       	breq	.+4      	; 0xb26 <TCP_GetPortState+0x3c>
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	08 95       	ret
     b26:	82 e0       	ldi	r24, 0x02	; 2
     b28:	90 e0       	ldi	r25, 0x00	; 0
		  return PortStateTable[PTableEntry].State;
     b2a:	fc 01       	movw	r30, r24
     b2c:	ee 0f       	add	r30, r30
     b2e:	ff 1f       	adc	r31, r31
     b30:	ee 0f       	add	r30, r30
     b32:	ff 1f       	adc	r31, r31
     b34:	e8 0f       	add	r30, r24
     b36:	f9 1f       	adc	r31, r25
     b38:	e5 5b       	subi	r30, 0xB5	; 181
     b3a:	fc 4e       	sbci	r31, 0xEC	; 236
     b3c:	82 81       	ldd	r24, Z+2	; 0x02
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
}
     b3e:	08 95       	ret

00000b40 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               uint16_t TCPOutSize)
{
     b40:	2f 92       	push	r2
     b42:	3f 92       	push	r3
     b44:	4f 92       	push	r4
     b46:	5f 92       	push	r5
     b48:	6f 92       	push	r6
     b4a:	7f 92       	push	r7
     b4c:	8f 92       	push	r8
     b4e:	9f 92       	push	r9
     b50:	af 92       	push	r10
     b52:	bf 92       	push	r11
     b54:	cf 92       	push	r12
     b56:	df 92       	push	r13
     b58:	ef 92       	push	r14
     b5a:	ff 92       	push	r15
     b5c:	0f 93       	push	r16
     b5e:	1f 93       	push	r17
     b60:	df 93       	push	r29
     b62:	cf 93       	push	r28
     b64:	cd b7       	in	r28, 0x3d	; 61
     b66:	de b7       	in	r29, 0x3e	; 62
     b68:	2a 97       	sbiw	r28, 0x0a	; 10
     b6a:	0f b6       	in	r0, 0x3f	; 63
     b6c:	f8 94       	cli
     b6e:	de bf       	out	0x3e, r29	; 62
     b70:	0f be       	out	0x3f, r0	; 63
     b72:	cd bf       	out	0x3d, r28	; 61
     b74:	9a 87       	std	Y+10, r25	; 0x0a
     b76:	89 87       	std	Y+9, r24	; 0x09
     b78:	3a 01       	movw	r6, r20
     b7a:	49 83       	std	Y+1, r20	; 0x01
     b7c:	5a 83       	std	Y+2, r21	; 0x02
     b7e:	6b 83       	std	Y+3, r22	; 0x03
     b80:	7c 83       	std	Y+4, r23	; 0x04
     b82:	58 01       	movw	r10, r16
     b84:	0d 83       	std	Y+5, r16	; 0x05
     b86:	1e 83       	std	Y+6, r17	; 0x06
     b88:	2f 83       	std	Y+7, r18	; 0x07
     b8a:	38 87       	std	Y+8, r19	; 0x08
     b8c:	b7 01       	movw	r22, r14
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
     b8e:	88 24       	eor	r8, r8
     b90:	99 24       	eor	r9, r9
	Checksum += ((uint16_t*)&SourceAddress)[1];
     b92:	eb 80       	ldd	r14, Y+3	; 0x03
     b94:	fc 80       	ldd	r15, Y+4	; 0x04
     b96:	00 e0       	ldi	r16, 0x00	; 0
     b98:	10 e0       	ldi	r17, 0x00	; 0
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     b9a:	cc 24       	eor	r12, r12
     b9c:	dd 24       	eor	r13, r13
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     b9e:	2f 81       	ldd	r18, Y+7	; 0x07
     ba0:	38 85       	ldd	r19, Y+8	; 0x08
     ba2:	40 e0       	ldi	r20, 0x00	; 0
     ba4:	50 e0       	ldi	r21, 0x00	; 0
				} Data;

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
     ba6:	87 2f       	mov	r24, r23
				Data.Bytes[1] = Temp;
     ba8:	96 2f       	mov	r25, r22

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     baa:	1c 01       	movw	r2, r24
     bac:	44 24       	eor	r4, r4
     bae:	55 24       	eor	r5, r5
     bb0:	80 e0       	ldi	r24, 0x00	; 0
     bb2:	96 e0       	ldi	r25, 0x06	; 6
     bb4:	a0 e0       	ldi	r26, 0x00	; 0
     bb6:	b0 e0       	ldi	r27, 0x00	; 0
     bb8:	28 0e       	add	r2, r24
     bba:	39 1e       	adc	r3, r25
     bbc:	4a 1e       	adc	r4, r26
     bbe:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     bc0:	26 0c       	add	r2, r6
     bc2:	37 1c       	adc	r3, r7
     bc4:	48 1c       	adc	r4, r8
     bc6:	59 1c       	adc	r5, r9
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     bc8:	2a 0c       	add	r2, r10
     bca:	3b 1c       	adc	r3, r11
     bcc:	4c 1c       	adc	r4, r12
     bce:	5d 1c       	adc	r5, r13
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     bd0:	2e 0c       	add	r2, r14
     bd2:	3f 1c       	adc	r3, r15
     bd4:	40 1e       	adc	r4, r16
     bd6:	51 1e       	adc	r5, r17
	Checksum += SwapEndian_16(TCPOutSize);
     bd8:	22 0e       	add	r2, r18
     bda:	33 1e       	adc	r3, r19
     bdc:	44 1e       	adc	r4, r20
     bde:	55 1e       	adc	r5, r21

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     be0:	fb 01       	movw	r30, r22
     be2:	f6 95       	lsr	r31
     be4:	e7 95       	ror	r30
     be6:	49 85       	ldd	r20, Y+9	; 0x09
     be8:	5a 85       	ldd	r21, Y+10	; 0x0a
     bea:	20 e0       	ldi	r18, 0x00	; 0
     bec:	30 e0       	ldi	r19, 0x00	; 0
     bee:	0c c0       	rjmp	.+24     	; 0xc08 <TCP_Checksum16+0xc8>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     bf0:	da 01       	movw	r26, r20
     bf2:	8d 91       	ld	r24, X+
     bf4:	9d 91       	ld	r25, X+
     bf6:	ad 01       	movw	r20, r26
     bf8:	a0 e0       	ldi	r26, 0x00	; 0
     bfa:	b0 e0       	ldi	r27, 0x00	; 0
     bfc:	28 0e       	add	r2, r24
     bfe:	39 1e       	adc	r3, r25
     c00:	4a 1e       	adc	r4, r26
     c02:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     c04:	2f 5f       	subi	r18, 0xFF	; 255
     c06:	3f 4f       	sbci	r19, 0xFF	; 255
     c08:	2e 17       	cp	r18, r30
     c0a:	3f 07       	cpc	r19, r31
     c0c:	88 f3       	brcs	.-30     	; 0xbf0 <TCP_Checksum16+0xb0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     c0e:	60 ff       	sbrs	r22, 0
     c10:	17 c0       	rjmp	.+46     	; 0xc40 <TCP_Checksum16+0x100>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     c12:	ee 0f       	add	r30, r30
     c14:	ff 1f       	adc	r31, r31
     c16:	89 85       	ldd	r24, Y+9	; 0x09
     c18:	9a 85       	ldd	r25, Y+10	; 0x0a
     c1a:	e8 0f       	add	r30, r24
     c1c:	f9 1f       	adc	r31, r25
     c1e:	80 81       	ld	r24, Z
     c20:	28 0e       	add	r2, r24
     c22:	31 1c       	adc	r3, r1
     c24:	41 1c       	adc	r4, r1
     c26:	51 1c       	adc	r5, r1
     c28:	0b c0       	rjmp	.+22     	; 0xc40 <TCP_Checksum16+0x100>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     c2a:	d2 01       	movw	r26, r4
     c2c:	c1 01       	movw	r24, r2
     c2e:	a0 70       	andi	r26, 0x00	; 0
     c30:	b0 70       	andi	r27, 0x00	; 0
     c32:	12 01       	movw	r2, r4
     c34:	44 24       	eor	r4, r4
     c36:	55 24       	eor	r5, r5
     c38:	28 0e       	add	r2, r24
     c3a:	39 1e       	adc	r3, r25
     c3c:	4a 1e       	adc	r4, r26
     c3e:	5b 1e       	adc	r5, r27
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     c40:	d2 01       	movw	r26, r4
     c42:	c1 01       	movw	r24, r2
     c44:	80 70       	andi	r24, 0x00	; 0
     c46:	90 70       	andi	r25, 0x00	; 0
     c48:	00 97       	sbiw	r24, 0x00	; 0
     c4a:	a1 05       	cpc	r26, r1
     c4c:	b1 05       	cpc	r27, r1
     c4e:	69 f7       	brne	.-38     	; 0xc2a <TCP_Checksum16+0xea>
     c50:	91 01       	movw	r18, r2
     c52:	20 95       	com	r18
     c54:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     c56:	c9 01       	movw	r24, r18
     c58:	2a 96       	adiw	r28, 0x0a	; 10
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	cf 91       	pop	r28
     c66:	df 91       	pop	r29
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	bf 90       	pop	r11
     c76:	af 90       	pop	r10
     c78:	9f 90       	pop	r9
     c7a:	8f 90       	pop	r8
     c7c:	7f 90       	pop	r7
     c7e:	6f 90       	pop	r6
     c80:	5f 90       	pop	r5
     c82:	4f 90       	pop	r4
     c84:	3f 90       	pop	r3
     c86:	2f 90       	pop	r2
     c88:	08 95       	ret

00000c8a <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     c8a:	4f 92       	push	r4
     c8c:	5f 92       	push	r5
     c8e:	6f 92       	push	r6
     c90:	7f 92       	push	r7
     c92:	8f 92       	push	r8
     c94:	9f 92       	push	r9
     c96:	af 92       	push	r10
     c98:	bf 92       	push	r11
     c9a:	cf 92       	push	r12
     c9c:	df 92       	push	r13
     c9e:	ef 92       	push	r14
     ca0:	ff 92       	push	r15
     ca2:	0f 93       	push	r16
     ca4:	1f 93       	push	r17
     ca6:	df 93       	push	r29
     ca8:	cf 93       	push	r28
     caa:	00 d0       	rcall	.+0      	; 0xcac <TCP_GetConnectionInfo+0x22>
     cac:	00 d0       	rcall	.+0      	; 0xcae <TCP_GetConnectionInfo+0x24>
     cae:	cd b7       	in	r28, 0x3d	; 61
     cb0:	de b7       	in	r29, 0x3e	; 62
     cb2:	4c 01       	movw	r8, r24
     cb4:	49 83       	std	Y+1, r20	; 0x01
     cb6:	5a 83       	std	Y+2, r21	; 0x02
     cb8:	6b 83       	std	Y+3, r22	; 0x03
     cba:	7c 83       	std	Y+4, r23	; 0x04
     cbc:	59 01       	movw	r10, r18
     cbe:	29 e0       	ldi	r18, 0x09	; 9
     cc0:	e2 2e       	mov	r14, r18
     cc2:	2d e0       	ldi	r18, 0x0D	; 13
     cc4:	f2 2e       	mov	r15, r18
     cc6:	00 e0       	ldi	r16, 0x00	; 0
     cc8:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     cca:	96 e1       	ldi	r25, 0x16	; 22
     ccc:	49 2e       	mov	r4, r25
     cce:	92 e0       	ldi	r25, 0x02	; 2
     cd0:	59 2e       	mov	r5, r25
     cd2:	3e 01       	movw	r6, r28
     cd4:	08 94       	sec
     cd6:	61 1c       	adc	r6, r1
     cd8:	71 1c       	adc	r7, r1
     cda:	f7 01       	movw	r30, r14
     cdc:	80 81       	ld	r24, Z
     cde:	91 81       	ldd	r25, Z+1	; 0x01
     ce0:	88 15       	cp	r24, r8
     ce2:	99 05       	cpc	r25, r9
     ce4:	d9 f4       	brne	.+54     	; 0xd1c <TCP_GetConnectionInfo+0x92>
     ce6:	04 9d       	mul	r16, r4
     ce8:	60 01       	movw	r12, r0
     cea:	05 9d       	mul	r16, r5
     cec:	d0 0c       	add	r13, r0
     cee:	14 9d       	mul	r17, r4
     cf0:	d0 0c       	add	r13, r0
     cf2:	11 24       	eor	r1, r1
     cf4:	c6 01       	movw	r24, r12
     cf6:	83 5f       	subi	r24, 0xF3	; 243
     cf8:	92 4f       	sbci	r25, 0xF2	; 242
     cfa:	b3 01       	movw	r22, r6
     cfc:	44 e0       	ldi	r20, 0x04	; 4
     cfe:	50 e0       	ldi	r21, 0x00	; 0
     d00:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
     d04:	00 97       	sbiw	r24, 0x00	; 0
     d06:	51 f4       	brne	.+20     	; 0xd1c <TCP_GetConnectionInfo+0x92>
     d08:	f7 01       	movw	r30, r14
     d0a:	82 81       	ldd	r24, Z+2	; 0x02
     d0c:	93 81       	ldd	r25, Z+3	; 0x03
     d0e:	8a 15       	cp	r24, r10
     d10:	9b 05       	cpc	r25, r11
     d12:	21 f4       	brne	.+8      	; 0xd1c <TCP_GetConnectionInfo+0x92>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     d14:	96 01       	movw	r18, r12
     d16:	2f 5e       	subi	r18, 0xEF	; 239
     d18:	32 4f       	sbci	r19, 0xF2	; 242
     d1a:	0b c0       	rjmp	.+22     	; 0xd32 <TCP_GetConnectionInfo+0xa8>
     d1c:	0f 5f       	subi	r16, 0xFF	; 255
     d1e:	1f 4f       	sbci	r17, 0xFF	; 255
     d20:	86 e1       	ldi	r24, 0x16	; 22
     d22:	92 e0       	ldi	r25, 0x02	; 2
     d24:	e8 0e       	add	r14, r24
     d26:	f9 1e       	adc	r15, r25
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     d28:	03 30       	cpi	r16, 0x03	; 3
     d2a:	11 05       	cpc	r17, r1
     d2c:	b1 f6       	brne	.-84     	; 0xcda <TCP_GetConnectionInfo+0x50>
     d2e:	20 e0       	ldi	r18, 0x00	; 0
     d30:	30 e0       	ldi	r19, 0x00	; 0
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
}
     d32:	c9 01       	movw	r24, r18
     d34:	0f 90       	pop	r0
     d36:	0f 90       	pop	r0
     d38:	0f 90       	pop	r0
     d3a:	0f 90       	pop	r0
     d3c:	cf 91       	pop	r28
     d3e:	df 91       	pop	r29
     d40:	1f 91       	pop	r17
     d42:	0f 91       	pop	r16
     d44:	ff 90       	pop	r15
     d46:	ef 90       	pop	r14
     d48:	df 90       	pop	r13
     d4a:	cf 90       	pop	r12
     d4c:	bf 90       	pop	r11
     d4e:	af 90       	pop	r10
     d50:	9f 90       	pop	r9
     d52:	8f 90       	pop	r8
     d54:	7f 90       	pop	r7
     d56:	6f 90       	pop	r6
     d58:	5f 90       	pop	r5
     d5a:	4f 90       	pop	r4
     d5c:	08 95       	ret

00000d5e <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     d5e:	4f 92       	push	r4
     d60:	5f 92       	push	r5
     d62:	6f 92       	push	r6
     d64:	7f 92       	push	r7
     d66:	8f 92       	push	r8
     d68:	9f 92       	push	r9
     d6a:	af 92       	push	r10
     d6c:	bf 92       	push	r11
     d6e:	cf 92       	push	r12
     d70:	df 92       	push	r13
     d72:	ef 92       	push	r14
     d74:	ff 92       	push	r15
     d76:	0f 93       	push	r16
     d78:	1f 93       	push	r17
     d7a:	df 93       	push	r29
     d7c:	cf 93       	push	r28
     d7e:	00 d0       	rcall	.+0      	; 0xd80 <TCP_GetConnectionState+0x22>
     d80:	00 d0       	rcall	.+0      	; 0xd82 <TCP_GetConnectionState+0x24>
     d82:	cd b7       	in	r28, 0x3d	; 61
     d84:	de b7       	in	r29, 0x3e	; 62
     d86:	4c 01       	movw	r8, r24
     d88:	49 83       	std	Y+1, r20	; 0x01
     d8a:	5a 83       	std	Y+2, r21	; 0x02
     d8c:	6b 83       	std	Y+3, r22	; 0x03
     d8e:	7c 83       	std	Y+4, r23	; 0x04
     d90:	59 01       	movw	r10, r18
     d92:	49 e0       	ldi	r20, 0x09	; 9
     d94:	e4 2e       	mov	r14, r20
     d96:	4d e0       	ldi	r20, 0x0D	; 13
     d98:	f4 2e       	mov	r15, r20
     d9a:	00 e0       	ldi	r16, 0x00	; 0
     d9c:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     d9e:	36 e1       	ldi	r19, 0x16	; 22
     da0:	43 2e       	mov	r4, r19
     da2:	32 e0       	ldi	r19, 0x02	; 2
     da4:	53 2e       	mov	r5, r19
     da6:	3e 01       	movw	r6, r28
     da8:	08 94       	sec
     daa:	61 1c       	adc	r6, r1
     dac:	71 1c       	adc	r7, r1
     dae:	f7 01       	movw	r30, r14
     db0:	80 81       	ld	r24, Z
     db2:	91 81       	ldd	r25, Z+1	; 0x01
     db4:	88 15       	cp	r24, r8
     db6:	99 05       	cpc	r25, r9
     db8:	e1 f4       	brne	.+56     	; 0xdf2 <TCP_GetConnectionState+0x94>
     dba:	04 9d       	mul	r16, r4
     dbc:	60 01       	movw	r12, r0
     dbe:	05 9d       	mul	r16, r5
     dc0:	d0 0c       	add	r13, r0
     dc2:	14 9d       	mul	r17, r4
     dc4:	d0 0c       	add	r13, r0
     dc6:	11 24       	eor	r1, r1
     dc8:	c6 01       	movw	r24, r12
     dca:	83 5f       	subi	r24, 0xF3	; 243
     dcc:	92 4f       	sbci	r25, 0xF2	; 242
     dce:	b3 01       	movw	r22, r6
     dd0:	44 e0       	ldi	r20, 0x04	; 4
     dd2:	50 e0       	ldi	r21, 0x00	; 0
     dd4:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
     dd8:	00 97       	sbiw	r24, 0x00	; 0
     dda:	59 f4       	brne	.+22     	; 0xdf2 <TCP_GetConnectionState+0x94>
     ddc:	f7 01       	movw	r30, r14
     dde:	82 81       	ldd	r24, Z+2	; 0x02
     de0:	93 81       	ldd	r25, Z+3	; 0x03
     de2:	8a 15       	cp	r24, r10
     de4:	9b 05       	cpc	r25, r11
     de6:	29 f4       	brne	.+10     	; 0xdf2 <TCP_GetConnectionState+0x94>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     de8:	f6 01       	movw	r30, r12
     dea:	e2 5e       	subi	r30, 0xE2	; 226
     dec:	f0 4f       	sbci	r31, 0xF0	; 240
     dee:	80 81       	ld	r24, Z
     df0:	0a c0       	rjmp	.+20     	; 0xe06 <TCP_GetConnectionState+0xa8>
     df2:	0f 5f       	subi	r16, 0xFF	; 255
     df4:	1f 4f       	sbci	r17, 0xFF	; 255
     df6:	86 e1       	ldi	r24, 0x16	; 22
     df8:	92 e0       	ldi	r25, 0x02	; 2
     dfa:	e8 0e       	add	r14, r24
     dfc:	f9 1e       	adc	r15, r25
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     dfe:	03 30       	cpi	r16, 0x03	; 3
     e00:	11 05       	cpc	r17, r1
     e02:	a9 f6       	brne	.-86     	; 0xdae <TCP_GetConnectionState+0x50>
     e04:	8a e0       	ldi	r24, 0x0A	; 10
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
}
     e06:	0f 90       	pop	r0
     e08:	0f 90       	pop	r0
     e0a:	0f 90       	pop	r0
     e0c:	0f 90       	pop	r0
     e0e:	cf 91       	pop	r28
     e10:	df 91       	pop	r29
     e12:	1f 91       	pop	r17
     e14:	0f 91       	pop	r16
     e16:	ff 90       	pop	r15
     e18:	ef 90       	pop	r14
     e1a:	df 90       	pop	r13
     e1c:	cf 90       	pop	r12
     e1e:	bf 90       	pop	r11
     e20:	af 90       	pop	r10
     e22:	9f 90       	pop	r9
     e24:	8f 90       	pop	r8
     e26:	7f 90       	pop	r7
     e28:	6f 90       	pop	r6
     e2a:	5f 90       	pop	r5
     e2c:	4f 90       	pop	r4
     e2e:	08 95       	ret

00000e30 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     e30:	3f 92       	push	r3
     e32:	4f 92       	push	r4
     e34:	5f 92       	push	r5
     e36:	6f 92       	push	r6
     e38:	7f 92       	push	r7
     e3a:	8f 92       	push	r8
     e3c:	9f 92       	push	r9
     e3e:	af 92       	push	r10
     e40:	bf 92       	push	r11
     e42:	cf 92       	push	r12
     e44:	df 92       	push	r13
     e46:	ef 92       	push	r14
     e48:	ff 92       	push	r15
     e4a:	0f 93       	push	r16
     e4c:	1f 93       	push	r17
     e4e:	df 93       	push	r29
     e50:	cf 93       	push	r28
     e52:	00 d0       	rcall	.+0      	; 0xe54 <TCP_SetConnectionState+0x24>
     e54:	00 d0       	rcall	.+0      	; 0xe56 <TCP_SetConnectionState+0x26>
     e56:	cd b7       	in	r28, 0x3d	; 61
     e58:	de b7       	in	r29, 0x3e	; 62
     e5a:	5c 01       	movw	r10, r24
     e5c:	49 83       	std	Y+1, r20	; 0x01
     e5e:	5a 83       	std	Y+2, r21	; 0x02
     e60:	6b 83       	std	Y+3, r22	; 0x03
     e62:	7c 83       	std	Y+4, r23	; 0x04
     e64:	49 01       	movw	r8, r18
     e66:	30 2e       	mov	r3, r16
     e68:	79 e0       	ldi	r23, 0x09	; 9
     e6a:	e7 2e       	mov	r14, r23
     e6c:	7d e0       	ldi	r23, 0x0D	; 13
     e6e:	f7 2e       	mov	r15, r23
     e70:	00 e0       	ldi	r16, 0x00	; 0
     e72:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     e74:	66 e1       	ldi	r22, 0x16	; 22
     e76:	46 2e       	mov	r4, r22
     e78:	62 e0       	ldi	r22, 0x02	; 2
     e7a:	56 2e       	mov	r5, r22
     e7c:	3e 01       	movw	r6, r28
     e7e:	08 94       	sec
     e80:	61 1c       	adc	r6, r1
     e82:	71 1c       	adc	r7, r1
     e84:	f7 01       	movw	r30, r14
     e86:	80 81       	ld	r24, Z
     e88:	91 81       	ldd	r25, Z+1	; 0x01
     e8a:	8a 15       	cp	r24, r10
     e8c:	9b 05       	cpc	r25, r11
     e8e:	d9 f4       	brne	.+54     	; 0xec6 <TCP_SetConnectionState+0x96>
     e90:	04 9d       	mul	r16, r4
     e92:	60 01       	movw	r12, r0
     e94:	05 9d       	mul	r16, r5
     e96:	d0 0c       	add	r13, r0
     e98:	14 9d       	mul	r17, r4
     e9a:	d0 0c       	add	r13, r0
     e9c:	11 24       	eor	r1, r1
     e9e:	c6 01       	movw	r24, r12
     ea0:	83 5f       	subi	r24, 0xF3	; 243
     ea2:	92 4f       	sbci	r25, 0xF2	; 242
     ea4:	b3 01       	movw	r22, r6
     ea6:	44 e0       	ldi	r20, 0x04	; 4
     ea8:	50 e0       	ldi	r21, 0x00	; 0
     eaa:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
     eae:	00 97       	sbiw	r24, 0x00	; 0
     eb0:	51 f4       	brne	.+20     	; 0xec6 <TCP_SetConnectionState+0x96>
     eb2:	f7 01       	movw	r30, r14
     eb4:	82 81       	ldd	r24, Z+2	; 0x02
     eb6:	93 81       	ldd	r25, Z+3	; 0x03
     eb8:	88 15       	cp	r24, r8
     eba:	99 05       	cpc	r25, r9
     ebc:	21 f4       	brne	.+8      	; 0xec6 <TCP_SetConnectionState+0x96>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     ebe:	f6 01       	movw	r30, r12
     ec0:	e2 5e       	subi	r30, 0xE2	; 226
     ec2:	f0 4f       	sbci	r31, 0xF0	; 240
     ec4:	47 c0       	rjmp	.+142    	; 0xf54 <TCP_SetConnectionState+0x124>
			return true;
     ec6:	0f 5f       	subi	r16, 0xFF	; 255
     ec8:	1f 4f       	sbci	r17, 0xFF	; 255
     eca:	86 e1       	ldi	r24, 0x16	; 22
     ecc:	92 e0       	ldi	r25, 0x02	; 2
     ece:	e8 0e       	add	r14, r24
     ed0:	f9 1e       	adc	r15, r25
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     ed2:	03 30       	cpi	r16, 0x03	; 3
     ed4:	11 05       	cpc	r17, r1
     ed6:	b1 f6       	brne	.-84     	; 0xe84 <TCP_SetConnectionState+0x54>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     ed8:	80 91 1e 0f 	lds	r24, 0x0F1E
     edc:	8a 30       	cpi	r24, 0x0A	; 10
     ede:	19 f4       	brne	.+6      	; 0xee6 <TCP_SetConnectionState+0xb6>
     ee0:	40 e0       	ldi	r20, 0x00	; 0
     ee2:	50 e0       	ldi	r21, 0x00	; 0
     ee4:	0f c0       	rjmp	.+30     	; 0xf04 <TCP_SetConnectionState+0xd4>
     ee6:	80 91 34 11 	lds	r24, 0x1134
     eea:	8a 30       	cpi	r24, 0x0A	; 10
     eec:	19 f4       	brne	.+6      	; 0xef4 <TCP_SetConnectionState+0xc4>
     eee:	41 e0       	ldi	r20, 0x01	; 1
     ef0:	50 e0       	ldi	r21, 0x00	; 0
     ef2:	08 c0       	rjmp	.+16     	; 0xf04 <TCP_SetConnectionState+0xd4>
     ef4:	80 91 4a 13 	lds	r24, 0x134A
     ef8:	8a 30       	cpi	r24, 0x0A	; 10
     efa:	11 f0       	breq	.+4      	; 0xf00 <TCP_SetConnectionState+0xd0>
     efc:	80 e0       	ldi	r24, 0x00	; 0
     efe:	2c c0       	rjmp	.+88     	; 0xf58 <TCP_SetConnectionState+0x128>
     f00:	42 e0       	ldi	r20, 0x02	; 2
     f02:	50 e0       	ldi	r21, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     f04:	86 e1       	ldi	r24, 0x16	; 22
     f06:	92 e0       	ldi	r25, 0x02	; 2
     f08:	48 9f       	mul	r20, r24
     f0a:	90 01       	movw	r18, r0
     f0c:	49 9f       	mul	r20, r25
     f0e:	30 0d       	add	r19, r0
     f10:	58 9f       	mul	r21, r24
     f12:	30 0d       	add	r19, r0
     f14:	11 24       	eor	r1, r1
     f16:	27 5f       	subi	r18, 0xF7	; 247
     f18:	32 4f       	sbci	r19, 0xF2	; 242
     f1a:	f9 01       	movw	r30, r18
     f1c:	b1 82       	std	Z+1, r11	; 0x01
     f1e:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     f20:	89 81       	ldd	r24, Y+1	; 0x01
     f22:	9a 81       	ldd	r25, Y+2	; 0x02
     f24:	ab 81       	ldd	r26, Y+3	; 0x03
     f26:	bc 81       	ldd	r27, Y+4	; 0x04
     f28:	84 83       	std	Z+4, r24	; 0x04
     f2a:	95 83       	std	Z+5, r25	; 0x05
     f2c:	a6 83       	std	Z+6, r26	; 0x06
     f2e:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     f30:	8b e0       	ldi	r24, 0x0B	; 11
     f32:	91 e0       	ldi	r25, 0x01	; 1
     f34:	48 9f       	mul	r20, r24
     f36:	f0 01       	movw	r30, r0
     f38:	49 9f       	mul	r20, r25
     f3a:	f0 0d       	add	r31, r0
     f3c:	58 9f       	mul	r21, r24
     f3e:	f0 0d       	add	r31, r0
     f40:	11 24       	eor	r1, r1
     f42:	ee 0f       	add	r30, r30
     f44:	ff 1f       	adc	r31, r31
     f46:	e5 5f       	subi	r30, 0xF5	; 245
     f48:	f2 4f       	sbci	r31, 0xF2	; 242
     f4a:	91 82       	std	Z+1, r9	; 0x01
     f4c:	80 82       	st	Z, r8
			ConnectionStateTable[CSTableEntry].State         = State;
     f4e:	2b 5e       	subi	r18, 0xEB	; 235
     f50:	3d 4f       	sbci	r19, 0xFD	; 253
     f52:	f9 01       	movw	r30, r18
     f54:	30 82       	st	Z, r3
     f56:	81 e0       	ldi	r24, 0x01	; 1
			return true;
		}
	}

	return false;
}
     f58:	0f 90       	pop	r0
     f5a:	0f 90       	pop	r0
     f5c:	0f 90       	pop	r0
     f5e:	0f 90       	pop	r0
     f60:	cf 91       	pop	r28
     f62:	df 91       	pop	r29
     f64:	1f 91       	pop	r17
     f66:	0f 91       	pop	r16
     f68:	ff 90       	pop	r15
     f6a:	ef 90       	pop	r14
     f6c:	df 90       	pop	r13
     f6e:	cf 90       	pop	r12
     f70:	bf 90       	pop	r11
     f72:	af 90       	pop	r10
     f74:	9f 90       	pop	r9
     f76:	8f 90       	pop	r8
     f78:	7f 90       	pop	r7
     f7a:	6f 90       	pop	r6
     f7c:	5f 90       	pop	r5
     f7e:	4f 90       	pop	r4
     f80:	3f 90       	pop	r3
     f82:	08 95       	ret

00000f84 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     f84:	af 92       	push	r10
     f86:	bf 92       	push	r11
     f88:	cf 92       	push	r12
     f8a:	df 92       	push	r13
     f8c:	ef 92       	push	r14
     f8e:	ff 92       	push	r15
     f90:	0f 93       	push	r16
     f92:	1f 93       	push	r17
     f94:	cf 93       	push	r28
     f96:	df 93       	push	r29
     f98:	7b 01       	movw	r14, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     f9a:	5c 01       	movw	r10, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     f9c:	6a 01       	movw	r12, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     f9e:	cb 01       	movw	r24, r22
     fa0:	09 dd       	rcall	.-1518   	; 0x9b4 <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     fa2:	d7 01       	movw	r26, r14
     fa4:	12 96       	adiw	r26, 0x02	; 2
     fa6:	8d 91       	ld	r24, X+
     fa8:	9c 91       	ld	r25, X
     faa:	13 97       	sbiw	r26, 0x03	; 3
     fac:	9e dd       	rcall	.-1220   	; 0xaea <TCP_GetPortState>
     fae:	81 30       	cpi	r24, 0x01	; 1
     fb0:	09 f0       	breq	.+2      	; 0xfb4 <TCP_ProcessTCPPacket+0x30>
     fb2:	2a c2       	rjmp	.+1108   	; 0x1408 <TCP_ProcessTCPPacket+0x484>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     fb4:	e7 01       	movw	r28, r14
     fb6:	8d 85       	ldd	r24, Y+13	; 0x0d
     fb8:	81 ff       	sbrs	r24, 1
     fba:	0b c0       	rjmp	.+22     	; 0xfd2 <TCP_ProcessTCPPacket+0x4e>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     fbc:	f5 01       	movw	r30, r10
     fbe:	44 85       	ldd	r20, Z+12	; 0x0c
     fc0:	55 85       	ldd	r21, Z+13	; 0x0d
     fc2:	66 85       	ldd	r22, Z+14	; 0x0e
     fc4:	77 85       	ldd	r23, Z+15	; 0x0f
     fc6:	28 81       	ld	r18, Y
     fc8:	39 81       	ldd	r19, Y+1	; 0x01
     fca:	8a 81       	ldd	r24, Y+2	; 0x02
     fcc:	9b 81       	ldd	r25, Y+3	; 0x03
     fce:	00 e0       	ldi	r16, 0x00	; 0
     fd0:	2f df       	rcall	.-418    	; 0xe30 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     fd2:	d7 01       	movw	r26, r14
     fd4:	1d 96       	adiw	r26, 0x0d	; 13
     fd6:	8c 91       	ld	r24, X
     fd8:	1d 97       	sbiw	r26, 0x0d	; 13
     fda:	12 96       	adiw	r26, 0x02	; 2
     fdc:	ed 91       	ld	r30, X+
     fde:	fc 91       	ld	r31, X
     fe0:	13 97       	sbiw	r26, 0x03	; 3
     fe2:	e5 01       	movw	r28, r10
     fe4:	4c 85       	ldd	r20, Y+12	; 0x0c
     fe6:	5d 85       	ldd	r21, Y+13	; 0x0d
     fe8:	6e 85       	ldd	r22, Y+14	; 0x0e
     fea:	7f 85       	ldd	r23, Y+15	; 0x0f
     fec:	2d 91       	ld	r18, X+
     fee:	3c 91       	ld	r19, X
     ff0:	82 ff       	sbrs	r24, 2
     ff2:	08 c0       	rjmp	.+16     	; 0x1004 <TCP_ProcessTCPPacket+0x80>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     ff4:	cf 01       	movw	r24, r30
     ff6:	0a e0       	ldi	r16, 0x0A	; 10
     ff8:	1b df       	rcall	.-458    	; 0xe30 <TCP_SetConnectionState>
     ffa:	88 23       	and	r24, r24
     ffc:	09 f4       	brne	.+2      	; 0x1000 <TCP_ProcessTCPPacket+0x7c>
     ffe:	38 c2       	rjmp	.+1136   	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1000:	84 e1       	ldi	r24, 0x14	; 20
    1002:	5d c0       	rjmp	.+186    	; 0x10be <TCP_ProcessTCPPacket+0x13a>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
    1004:	cf 01       	movw	r24, r30
    1006:	ab de       	rcall	.-682    	; 0xd5e <TCP_GetConnectionState>
    1008:	84 30       	cpi	r24, 0x04	; 4
    100a:	09 f4       	brne	.+2      	; 0x100e <TCP_ProcessTCPPacket+0x8a>
    100c:	68 c1       	rjmp	.+720    	; 0x12de <TCP_ProcessTCPPacket+0x35a>
    100e:	85 30       	cpi	r24, 0x05	; 5
    1010:	48 f4       	brcc	.+18     	; 0x1024 <TCP_ProcessTCPPacket+0xa0>
    1012:	82 30       	cpi	r24, 0x02	; 2
    1014:	09 f4       	brne	.+2      	; 0x1018 <TCP_ProcessTCPPacket+0x94>
    1016:	56 c0       	rjmp	.+172    	; 0x10c4 <TCP_ProcessTCPPacket+0x140>
    1018:	83 30       	cpi	r24, 0x03	; 3
    101a:	08 f0       	brcs	.+2      	; 0x101e <TCP_ProcessTCPPacket+0x9a>
    101c:	7f c0       	rjmp	.+254    	; 0x111c <TCP_ProcessTCPPacket+0x198>
    101e:	88 23       	and	r24, r24
    1020:	59 f0       	breq	.+22     	; 0x1038 <TCP_ProcessTCPPacket+0xb4>
    1022:	26 c2       	rjmp	.+1100   	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
    1024:	86 30       	cpi	r24, 0x06	; 6
    1026:	09 f4       	brne	.+2      	; 0x102a <TCP_ProcessTCPPacket+0xa6>
    1028:	dc c1       	rjmp	.+952    	; 0x13e2 <TCP_ProcessTCPPacket+0x45e>
    102a:	86 30       	cpi	r24, 0x06	; 6
    102c:	08 f4       	brcc	.+2      	; 0x1030 <TCP_ProcessTCPPacket+0xac>
    102e:	9e c1       	rjmp	.+828    	; 0x136c <TCP_ProcessTCPPacket+0x3e8>
    1030:	87 30       	cpi	r24, 0x07	; 7
    1032:	09 f0       	breq	.+2      	; 0x1036 <TCP_ProcessTCPPacket+0xb2>
    1034:	1d c2       	rjmp	.+1082   	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
    1036:	35 c1       	rjmp	.+618    	; 0x12a2 <TCP_ProcessTCPPacket+0x31e>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
    1038:	d7 01       	movw	r26, r14
    103a:	1d 96       	adiw	r26, 0x0d	; 13
    103c:	8c 91       	ld	r24, X
    103e:	1d 97       	sbiw	r26, 0x0d	; 13
    1040:	82 30       	cpi	r24, 0x02	; 2
    1042:	09 f0       	breq	.+2      	; 0x1046 <TCP_ProcessTCPPacket+0xc2>
    1044:	15 c2       	rjmp	.+1066   	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1046:	e5 01       	movw	r28, r10
    1048:	4c 85       	ldd	r20, Y+12	; 0x0c
    104a:	5d 85       	ldd	r21, Y+13	; 0x0d
    104c:	6e 85       	ldd	r22, Y+14	; 0x0e
    104e:	7f 85       	ldd	r23, Y+15	; 0x0f
    1050:	2d 91       	ld	r18, X+
    1052:	3c 91       	ld	r19, X
    1054:	11 97       	sbiw	r26, 0x01	; 1
    1056:	12 96       	adiw	r26, 0x02	; 2
    1058:	8d 91       	ld	r24, X+
    105a:	9c 91       	ld	r25, X
    105c:	13 97       	sbiw	r26, 0x03	; 3
    105e:	02 e0       	ldi	r16, 0x02	; 2
    1060:	e7 de       	rcall	.-562    	; 0xe30 <TCP_SetConnectionState>
    1062:	88 23       	and	r24, r24
    1064:	59 f1       	breq	.+86     	; 0x10bc <TCP_ProcessTCPPacket+0x138>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
    1066:	82 e1       	ldi	r24, 0x12	; 18
    1068:	f6 01       	movw	r30, r12
    106a:	85 87       	std	Z+13, r24	; 0x0d

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
    106c:	4c 85       	ldd	r20, Y+12	; 0x0c
    106e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1070:	6e 85       	ldd	r22, Y+14	; 0x0e
    1072:	7f 85       	ldd	r23, Y+15	; 0x0f
    1074:	d7 01       	movw	r26, r14
    1076:	2d 91       	ld	r18, X+
    1078:	3c 91       	ld	r19, X
    107a:	11 97       	sbiw	r26, 0x01	; 1
    107c:	12 96       	adiw	r26, 0x02	; 2
    107e:	8d 91       	ld	r24, X+
    1080:	9c 91       	ld	r25, X
    1082:	13 97       	sbiw	r26, 0x03	; 3
    1084:	02 de       	rcall	.-1020   	; 0xc8a <TCP_GetConnectionInfo>
    1086:	fc 01       	movw	r30, r24
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
    1088:	e7 01       	movw	r28, r14
    108a:	8c 81       	ldd	r24, Y+4	; 0x04
    108c:	9d 81       	ldd	r25, Y+5	; 0x05
    108e:	ae 81       	ldd	r26, Y+6	; 0x06
    1090:	bf 81       	ldd	r27, Y+7	; 0x07

				Temp = Data.Bytes[0];
    1092:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[3];
    1094:	8b 2f       	mov	r24, r27
				Data.Bytes[3] = Temp;
    1096:	b2 2f       	mov	r27, r18

				Temp = Data.Bytes[1];
    1098:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
    109a:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
    109c:	a2 2f       	mov	r26, r18

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
    109e:	01 96       	adiw	r24, 0x01	; 1
    10a0:	a1 1d       	adc	r26, r1
    10a2:	b1 1d       	adc	r27, r1
    10a4:	80 83       	st	Z, r24
    10a6:	91 83       	std	Z+1, r25	; 0x01
    10a8:	a2 83       	std	Z+2, r26	; 0x02
    10aa:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
    10ac:	14 82       	std	Z+4, r1	; 0x04
    10ae:	15 82       	std	Z+5, r1	; 0x05
    10b0:	16 82       	std	Z+6, r1	; 0x06
    10b2:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
    10b4:	e4 5f       	subi	r30, 0xF4	; 244
    10b6:	fd 4f       	sbci	r31, 0xFD	; 253
    10b8:	10 82       	st	Z, r1
    10ba:	e8 c1       	rjmp	.+976    	; 0x148c <TCP_ProcessTCPPacket+0x508>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
    10bc:	84 e0       	ldi	r24, 0x04	; 4
    10be:	f6 01       	movw	r30, r12
    10c0:	85 87       	std	Z+13, r24	; 0x0d
    10c2:	e4 c1       	rjmp	.+968    	; 0x148c <TCP_ProcessTCPPacket+0x508>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    10c4:	d7 01       	movw	r26, r14
    10c6:	1d 96       	adiw	r26, 0x0d	; 13
    10c8:	8c 91       	ld	r24, X
    10ca:	1d 97       	sbiw	r26, 0x0d	; 13
    10cc:	80 31       	cpi	r24, 0x10	; 16
    10ce:	09 f0       	breq	.+2      	; 0x10d2 <TCP_ProcessTCPPacket+0x14e>
    10d0:	cf c1       	rjmp	.+926    	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10d2:	e5 01       	movw	r28, r10
    10d4:	4c 85       	ldd	r20, Y+12	; 0x0c
    10d6:	5d 85       	ldd	r21, Y+13	; 0x0d
    10d8:	6e 85       	ldd	r22, Y+14	; 0x0e
    10da:	7f 85       	ldd	r23, Y+15	; 0x0f
    10dc:	2d 91       	ld	r18, X+
    10de:	3c 91       	ld	r19, X
    10e0:	11 97       	sbiw	r26, 0x01	; 1
    10e2:	12 96       	adiw	r26, 0x02	; 2
    10e4:	8d 91       	ld	r24, X+
    10e6:	9c 91       	ld	r25, X
    10e8:	13 97       	sbiw	r26, 0x03	; 3
    10ea:	03 e0       	ldi	r16, 0x03	; 3
    10ec:	a1 de       	rcall	.-702    	; 0xe30 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10ee:	4c 85       	ldd	r20, Y+12	; 0x0c
    10f0:	5d 85       	ldd	r21, Y+13	; 0x0d
    10f2:	6e 85       	ldd	r22, Y+14	; 0x0e
    10f4:	7f 85       	ldd	r23, Y+15	; 0x0f
    10f6:	f7 01       	movw	r30, r14
    10f8:	20 81       	ld	r18, Z
    10fa:	31 81       	ldd	r19, Z+1	; 0x01
    10fc:	82 81       	ldd	r24, Z+2	; 0x02
    10fe:	93 81       	ldd	r25, Z+3	; 0x03
    1100:	c4 dd       	rcall	.-1144   	; 0xc8a <TCP_GetConnectionInfo>
    1102:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
    1104:	84 81       	ldd	r24, Z+4	; 0x04
    1106:	95 81       	ldd	r25, Z+5	; 0x05
    1108:	a6 81       	ldd	r26, Z+6	; 0x06
    110a:	b7 81       	ldd	r27, Z+7	; 0x07
    110c:	01 96       	adiw	r24, 0x01	; 1
    110e:	a1 1d       	adc	r26, r1
    1110:	b1 1d       	adc	r27, r1
    1112:	84 83       	std	Z+4, r24	; 0x04
    1114:	95 83       	std	Z+5, r25	; 0x05
    1116:	a6 83       	std	Z+6, r26	; 0x06
    1118:	b7 83       	std	Z+7, r27	; 0x07
    111a:	aa c1       	rjmp	.+852    	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    111c:	d7 01       	movw	r26, r14
    111e:	1d 96       	adiw	r26, 0x0d	; 13
    1120:	8c 91       	ld	r24, X
    1122:	1d 97       	sbiw	r26, 0x0d	; 13
    1124:	81 31       	cpi	r24, 0x11	; 17
    1126:	a9 f5       	brne	.+106    	; 0x1192 <TCP_ProcessTCPPacket+0x20e>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
    1128:	e6 01       	movw	r28, r12
    112a:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    112c:	f5 01       	movw	r30, r10
    112e:	44 85       	ldd	r20, Z+12	; 0x0c
    1130:	55 85       	ldd	r21, Z+13	; 0x0d
    1132:	66 85       	ldd	r22, Z+14	; 0x0e
    1134:	77 85       	ldd	r23, Z+15	; 0x0f
    1136:	2d 91       	ld	r18, X+
    1138:	3c 91       	ld	r19, X
    113a:	11 97       	sbiw	r26, 0x01	; 1
    113c:	12 96       	adiw	r26, 0x02	; 2
    113e:	8d 91       	ld	r24, X+
    1140:	9c 91       	ld	r25, X
    1142:	13 97       	sbiw	r26, 0x03	; 3
    1144:	06 e0       	ldi	r16, 0x06	; 6
    1146:	74 de       	rcall	.-792    	; 0xe30 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1148:	d5 01       	movw	r26, r10
    114a:	1c 96       	adiw	r26, 0x0c	; 12
    114c:	4d 91       	ld	r20, X+
    114e:	5d 91       	ld	r21, X+
    1150:	6d 91       	ld	r22, X+
    1152:	7c 91       	ld	r23, X
    1154:	1f 97       	sbiw	r26, 0x0f	; 15
    1156:	e7 01       	movw	r28, r14
    1158:	28 81       	ld	r18, Y
    115a:	39 81       	ldd	r19, Y+1	; 0x01
    115c:	8a 81       	ldd	r24, Y+2	; 0x02
    115e:	9b 81       	ldd	r25, Y+3	; 0x03
    1160:	94 dd       	rcall	.-1240   	; 0xc8a <TCP_GetConnectionInfo>
    1162:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
    1164:	80 81       	ld	r24, Z
    1166:	91 81       	ldd	r25, Z+1	; 0x01
    1168:	a2 81       	ldd	r26, Z+2	; 0x02
    116a:	b3 81       	ldd	r27, Z+3	; 0x03
    116c:	01 96       	adiw	r24, 0x01	; 1
    116e:	a1 1d       	adc	r26, r1
    1170:	b1 1d       	adc	r27, r1
    1172:	80 83       	st	Z, r24
    1174:	91 83       	std	Z+1, r25	; 0x01
    1176:	a2 83       	std	Z+2, r26	; 0x02
    1178:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    117a:	84 81       	ldd	r24, Z+4	; 0x04
    117c:	95 81       	ldd	r25, Z+5	; 0x05
    117e:	a6 81       	ldd	r26, Z+6	; 0x06
    1180:	b7 81       	ldd	r27, Z+7	; 0x07
    1182:	01 96       	adiw	r24, 0x01	; 1
    1184:	a1 1d       	adc	r26, r1
    1186:	b1 1d       	adc	r27, r1
    1188:	84 83       	std	Z+4, r24	; 0x04
    118a:	95 83       	std	Z+5, r25	; 0x05
    118c:	a6 83       	std	Z+6, r26	; 0x06
    118e:	b7 83       	std	Z+7, r27	; 0x07
    1190:	7d c1       	rjmp	.+762    	; 0x148c <TCP_ProcessTCPPacket+0x508>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
    1192:	80 31       	cpi	r24, 0x10	; 16
    1194:	19 f0       	breq	.+6      	; 0x119c <TCP_ProcessTCPPacket+0x218>
    1196:	88 31       	cpi	r24, 0x18	; 24
    1198:	09 f0       	breq	.+2      	; 0x119c <TCP_ProcessTCPPacket+0x218>
    119a:	6a c1       	rjmp	.+724    	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    119c:	f5 01       	movw	r30, r10
    119e:	44 85       	ldd	r20, Z+12	; 0x0c
    11a0:	55 85       	ldd	r21, Z+13	; 0x0d
    11a2:	66 85       	ldd	r22, Z+14	; 0x0e
    11a4:	77 85       	ldd	r23, Z+15	; 0x0f
    11a6:	d7 01       	movw	r26, r14
    11a8:	2d 91       	ld	r18, X+
    11aa:	3c 91       	ld	r19, X
    11ac:	11 97       	sbiw	r26, 0x01	; 1
    11ae:	12 96       	adiw	r26, 0x02	; 2
    11b0:	8d 91       	ld	r24, X+
    11b2:	9c 91       	ld	r25, X
    11b4:	13 97       	sbiw	r26, 0x03	; 3
    11b6:	69 dd       	rcall	.-1326   	; 0xc8a <TCP_GetConnectionInfo>
    11b8:	ec 01       	movw	r28, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
    11ba:	fc 01       	movw	r30, r24
    11bc:	e4 5f       	subi	r30, 0xF4	; 244
    11be:	fd 4f       	sbci	r31, 0xFD	; 253
    11c0:	80 81       	ld	r24, Z
    11c2:	88 23       	and	r24, r24
    11c4:	81 f4       	brne	.+32     	; 0x11e6 <TCP_ProcessTCPPacket+0x262>
    11c6:	c5 5f       	subi	r28, 0xF5	; 245
    11c8:	dd 4f       	sbci	r29, 0xFD	; 253
    11ca:	88 81       	ld	r24, Y
    11cc:	cb 50       	subi	r28, 0x0B	; 11
    11ce:	d2 40       	sbci	r29, 0x02	; 2
    11d0:	88 23       	and	r24, r24
    11d2:	49 f4       	brne	.+18     	; 0x11e6 <TCP_ProcessTCPPacket+0x262>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
    11d4:	c6 5f       	subi	r28, 0xF6	; 246
    11d6:	dd 4f       	sbci	r29, 0xFD	; 253
    11d8:	18 82       	st	Y, r1
    11da:	ca 50       	subi	r28, 0x0A	; 10
    11dc:	d2 40       	sbci	r29, 0x02	; 2
							ConnectionInfo->Buffer.InUse     = true;
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
    11e2:	19 86       	std	Y+9, r1	; 0x09
    11e4:	18 86       	std	Y+8, r1	; 0x08
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    11e6:	c6 5f       	subi	r28, 0xF6	; 246
    11e8:	dd 4f       	sbci	r29, 0xFD	; 253
    11ea:	88 81       	ld	r24, Y
    11ec:	ca 50       	subi	r28, 0x0A	; 10
    11ee:	d2 40       	sbci	r29, 0x02	; 2
    11f0:	88 23       	and	r24, r24
    11f2:	09 f0       	breq	.+2      	; 0x11f6 <TCP_ProcessTCPPacket+0x272>
    11f4:	3a c1       	rjmp	.+628    	; 0x146a <TCP_ProcessTCPPacket+0x4e6>
    11f6:	68 85       	ldd	r22, Y+8	; 0x08
    11f8:	79 85       	ldd	r23, Y+9	; 0x09
    11fa:	b2 e0       	ldi	r27, 0x02	; 2
    11fc:	60 30       	cpi	r22, 0x00	; 0
    11fe:	7b 07       	cpc	r23, r27
    1200:	09 f4       	brne	.+2      	; 0x1204 <TCP_ProcessTCPPacket+0x280>
    1202:	33 c1       	rjmp	.+614    	; 0x146a <TCP_ProcessTCPPacket+0x4e6>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1204:	f5 01       	movw	r30, r10
    1206:	20 81       	ld	r18, Z
    1208:	2f 70       	andi	r18, 0x0F	; 15
    120a:	30 e0       	ldi	r19, 0x00	; 0
    120c:	22 0f       	add	r18, r18
    120e:	33 1f       	adc	r19, r19
    1210:	22 0f       	add	r18, r18
    1212:	33 1f       	adc	r19, r19
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    1214:	d7 01       	movw	r26, r14
    1216:	1c 96       	adiw	r26, 0x0c	; 12
    1218:	8c 91       	ld	r24, X
    121a:	82 95       	swap	r24
    121c:	8f 70       	andi	r24, 0x0F	; 15
    121e:	90 e0       	ldi	r25, 0x00	; 0
    1220:	88 0f       	add	r24, r24
    1222:	99 1f       	adc	r25, r25
    1224:	88 0f       	add	r24, r24
    1226:	99 1f       	adc	r25, r25
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1228:	02 81       	ldd	r16, Z+2	; 0x02
    122a:	13 81       	ldd	r17, Z+3	; 0x03

				Temp = Data.Bytes[0];
    122c:	40 2f       	mov	r20, r16
				Data.Bytes[0] = Data.Bytes[1];
    122e:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
    1230:	14 2f       	mov	r17, r20
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    1232:	02 1b       	sub	r16, r18
    1234:	13 0b       	sbc	r17, r19
    1236:	08 1b       	sub	r16, r24
    1238:	19 0b       	sbc	r17, r25

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    123a:	9b 01       	movw	r18, r22
    123c:	26 5f       	subi	r18, 0xF6	; 246
    123e:	3f 4f       	sbci	r19, 0xFF	; 255
    1240:	2c 0f       	add	r18, r28
    1242:	3d 1f       	adc	r19, r29
    1244:	a7 01       	movw	r20, r14
    1246:	48 0f       	add	r20, r24
    1248:	59 1f       	adc	r21, r25
    124a:	c9 01       	movw	r24, r18
    124c:	ba 01       	movw	r22, r20
    124e:	a8 01       	movw	r20, r16
    1250:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1254:	98 01       	movw	r18, r16
    1256:	40 e0       	ldi	r20, 0x00	; 0
    1258:	50 e0       	ldi	r21, 0x00	; 0
    125a:	88 81       	ld	r24, Y
    125c:	99 81       	ldd	r25, Y+1	; 0x01
    125e:	aa 81       	ldd	r26, Y+2	; 0x02
    1260:	bb 81       	ldd	r27, Y+3	; 0x03
    1262:	82 0f       	add	r24, r18
    1264:	93 1f       	adc	r25, r19
    1266:	a4 1f       	adc	r26, r20
    1268:	b5 1f       	adc	r27, r21
    126a:	88 83       	st	Y, r24
    126c:	99 83       	std	Y+1, r25	; 0x01
    126e:	aa 83       	std	Y+2, r26	; 0x02
    1270:	bb 83       	std	Y+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    1272:	88 85       	ldd	r24, Y+8	; 0x08
    1274:	99 85       	ldd	r25, Y+9	; 0x09
    1276:	80 0f       	add	r24, r16
    1278:	91 1f       	adc	r25, r17
    127a:	99 87       	std	Y+9, r25	; 0x09
    127c:	88 87       	std	Y+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    127e:	80 50       	subi	r24, 0x00	; 0
    1280:	92 40       	sbci	r25, 0x02	; 2
    1282:	21 f0       	breq	.+8      	; 0x128c <TCP_ProcessTCPPacket+0x308>
    1284:	f7 01       	movw	r30, r14
    1286:	85 85       	ldd	r24, Z+13	; 0x0d
    1288:	83 ff       	sbrs	r24, 3
    128a:	f2 c0       	rjmp	.+484    	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
							{
								ConnectionInfo->Buffer.InUse = false;
    128c:	c4 5f       	subi	r28, 0xF4	; 244
    128e:	dd 4f       	sbci	r29, 0xFD	; 253
    1290:	18 82       	st	Y, r1
								ConnectionInfo->Buffer.Ready = true;
    1292:	fe 01       	movw	r30, r28
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	82 93       	st	-Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1298:	80 e1       	ldi	r24, 0x10	; 16
    129a:	d6 01       	movw	r26, r12
    129c:	1d 96       	adiw	r26, 0x0d	; 13
    129e:	8c 93       	st	X, r24
    12a0:	f5 c0       	rjmp	.+490    	; 0x148c <TCP_ProcessTCPPacket+0x508>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12a2:	e5 01       	movw	r28, r10
    12a4:	4c 85       	ldd	r20, Y+12	; 0x0c
    12a6:	5d 85       	ldd	r21, Y+13	; 0x0d
    12a8:	6e 85       	ldd	r22, Y+14	; 0x0e
    12aa:	7f 85       	ldd	r23, Y+15	; 0x0f
    12ac:	f7 01       	movw	r30, r14
    12ae:	20 81       	ld	r18, Z
    12b0:	31 81       	ldd	r19, Z+1	; 0x01
    12b2:	82 81       	ldd	r24, Z+2	; 0x02
    12b4:	93 81       	ldd	r25, Z+3	; 0x03
    12b6:	e9 dc       	rcall	.-1582   	; 0xc8a <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    12b8:	21 e1       	ldi	r18, 0x11	; 17
    12ba:	d6 01       	movw	r26, r12
    12bc:	1d 96       	adiw	r26, 0x0d	; 13
    12be:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    12c0:	fc 01       	movw	r30, r24
    12c2:	e4 5f       	subi	r30, 0xF4	; 244
    12c4:	fd 4f       	sbci	r31, 0xFD	; 253
    12c6:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12c8:	4c 85       	ldd	r20, Y+12	; 0x0c
    12ca:	5d 85       	ldd	r21, Y+13	; 0x0d
    12cc:	6e 85       	ldd	r22, Y+14	; 0x0e
    12ce:	7f 85       	ldd	r23, Y+15	; 0x0f
    12d0:	e7 01       	movw	r28, r14
    12d2:	28 81       	ld	r18, Y
    12d4:	39 81       	ldd	r19, Y+1	; 0x01
    12d6:	8a 81       	ldd	r24, Y+2	; 0x02
    12d8:	9b 81       	ldd	r25, Y+3	; 0x03
    12da:	04 e0       	ldi	r16, 0x04	; 4
    12dc:	80 c0       	rjmp	.+256    	; 0x13de <TCP_ProcessTCPPacket+0x45a>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    12de:	f7 01       	movw	r30, r14
    12e0:	85 85       	ldd	r24, Z+13	; 0x0d
    12e2:	81 31       	cpi	r24, 0x11	; 17
    12e4:	a1 f5       	brne	.+104    	; 0x134e <TCP_ProcessTCPPacket+0x3ca>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12e6:	d5 01       	movw	r26, r10
    12e8:	1c 96       	adiw	r26, 0x0c	; 12
    12ea:	4d 91       	ld	r20, X+
    12ec:	5d 91       	ld	r21, X+
    12ee:	6d 91       	ld	r22, X+
    12f0:	7c 91       	ld	r23, X
    12f2:	1f 97       	sbiw	r26, 0x0f	; 15
    12f4:	20 81       	ld	r18, Z
    12f6:	31 81       	ldd	r19, Z+1	; 0x01
    12f8:	82 81       	ldd	r24, Z+2	; 0x02
    12fa:	93 81       	ldd	r25, Z+3	; 0x03
    12fc:	c6 dc       	rcall	.-1652   	; 0xc8a <TCP_GetConnectionInfo>
    12fe:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1300:	80 e1       	ldi	r24, 0x10	; 16
    1302:	e6 01       	movw	r28, r12
    1304:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1306:	80 81       	ld	r24, Z
    1308:	91 81       	ldd	r25, Z+1	; 0x01
    130a:	a2 81       	ldd	r26, Z+2	; 0x02
    130c:	b3 81       	ldd	r27, Z+3	; 0x03
    130e:	01 96       	adiw	r24, 0x01	; 1
    1310:	a1 1d       	adc	r26, r1
    1312:	b1 1d       	adc	r27, r1
    1314:	80 83       	st	Z, r24
    1316:	91 83       	std	Z+1, r25	; 0x01
    1318:	a2 83       	std	Z+2, r26	; 0x02
    131a:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    131c:	84 81       	ldd	r24, Z+4	; 0x04
    131e:	95 81       	ldd	r25, Z+5	; 0x05
    1320:	a6 81       	ldd	r26, Z+6	; 0x06
    1322:	b7 81       	ldd	r27, Z+7	; 0x07
    1324:	01 96       	adiw	r24, 0x01	; 1
    1326:	a1 1d       	adc	r26, r1
    1328:	b1 1d       	adc	r27, r1
    132a:	84 83       	std	Z+4, r24	; 0x04
    132c:	95 83       	std	Z+5, r25	; 0x05
    132e:	a6 83       	std	Z+6, r26	; 0x06
    1330:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1332:	f5 01       	movw	r30, r10
    1334:	44 85       	ldd	r20, Z+12	; 0x0c
    1336:	55 85       	ldd	r21, Z+13	; 0x0d
    1338:	66 85       	ldd	r22, Z+14	; 0x0e
    133a:	77 85       	ldd	r23, Z+15	; 0x0f
    133c:	d7 01       	movw	r26, r14
    133e:	2d 91       	ld	r18, X+
    1340:	3c 91       	ld	r19, X
    1342:	11 97       	sbiw	r26, 0x01	; 1
    1344:	12 96       	adiw	r26, 0x02	; 2
    1346:	8d 91       	ld	r24, X+
    1348:	9c 91       	ld	r25, X
    134a:	13 97       	sbiw	r26, 0x03	; 3
    134c:	47 c0       	rjmp	.+142    	; 0x13dc <TCP_ProcessTCPPacket+0x458>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    134e:	80 31       	cpi	r24, 0x10	; 16
    1350:	09 f0       	breq	.+2      	; 0x1354 <TCP_ProcessTCPPacket+0x3d0>
    1352:	8e c0       	rjmp	.+284    	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1354:	e5 01       	movw	r28, r10
    1356:	4c 85       	ldd	r20, Y+12	; 0x0c
    1358:	5d 85       	ldd	r21, Y+13	; 0x0d
    135a:	6e 85       	ldd	r22, Y+14	; 0x0e
    135c:	7f 85       	ldd	r23, Y+15	; 0x0f
    135e:	f7 01       	movw	r30, r14
    1360:	20 81       	ld	r18, Z
    1362:	31 81       	ldd	r19, Z+1	; 0x01
    1364:	82 81       	ldd	r24, Z+2	; 0x02
    1366:	93 81       	ldd	r25, Z+3	; 0x03
    1368:	05 e0       	ldi	r16, 0x05	; 5
    136a:	4c c0       	rjmp	.+152    	; 0x1404 <TCP_ProcessTCPPacket+0x480>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    136c:	d7 01       	movw	r26, r14
    136e:	1d 96       	adiw	r26, 0x0d	; 13
    1370:	8c 91       	ld	r24, X
    1372:	1d 97       	sbiw	r26, 0x0d	; 13
    1374:	81 31       	cpi	r24, 0x11	; 17
    1376:	09 f0       	breq	.+2      	; 0x137a <TCP_ProcessTCPPacket+0x3f6>
    1378:	7b c0       	rjmp	.+246    	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    137a:	e5 01       	movw	r28, r10
    137c:	4c 85       	ldd	r20, Y+12	; 0x0c
    137e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1380:	6e 85       	ldd	r22, Y+14	; 0x0e
    1382:	7f 85       	ldd	r23, Y+15	; 0x0f
    1384:	2d 91       	ld	r18, X+
    1386:	3c 91       	ld	r19, X
    1388:	11 97       	sbiw	r26, 0x01	; 1
    138a:	12 96       	adiw	r26, 0x02	; 2
    138c:	8d 91       	ld	r24, X+
    138e:	9c 91       	ld	r25, X
    1390:	13 97       	sbiw	r26, 0x03	; 3
    1392:	7b dc       	rcall	.-1802   	; 0xc8a <TCP_GetConnectionInfo>
    1394:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1396:	80 e1       	ldi	r24, 0x10	; 16
    1398:	d6 01       	movw	r26, r12
    139a:	1d 96       	adiw	r26, 0x0d	; 13
    139c:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    139e:	80 81       	ld	r24, Z
    13a0:	91 81       	ldd	r25, Z+1	; 0x01
    13a2:	a2 81       	ldd	r26, Z+2	; 0x02
    13a4:	b3 81       	ldd	r27, Z+3	; 0x03
    13a6:	01 96       	adiw	r24, 0x01	; 1
    13a8:	a1 1d       	adc	r26, r1
    13aa:	b1 1d       	adc	r27, r1
    13ac:	80 83       	st	Z, r24
    13ae:	91 83       	std	Z+1, r25	; 0x01
    13b0:	a2 83       	std	Z+2, r26	; 0x02
    13b2:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    13b4:	84 81       	ldd	r24, Z+4	; 0x04
    13b6:	95 81       	ldd	r25, Z+5	; 0x05
    13b8:	a6 81       	ldd	r26, Z+6	; 0x06
    13ba:	b7 81       	ldd	r27, Z+7	; 0x07
    13bc:	01 96       	adiw	r24, 0x01	; 1
    13be:	a1 1d       	adc	r26, r1
    13c0:	b1 1d       	adc	r27, r1
    13c2:	84 83       	std	Z+4, r24	; 0x04
    13c4:	95 83       	std	Z+5, r25	; 0x05
    13c6:	a6 83       	std	Z+6, r26	; 0x06
    13c8:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    13ca:	4c 85       	ldd	r20, Y+12	; 0x0c
    13cc:	5d 85       	ldd	r21, Y+13	; 0x0d
    13ce:	6e 85       	ldd	r22, Y+14	; 0x0e
    13d0:	7f 85       	ldd	r23, Y+15	; 0x0f
    13d2:	e7 01       	movw	r28, r14
    13d4:	28 81       	ld	r18, Y
    13d6:	39 81       	ldd	r19, Y+1	; 0x01
    13d8:	8a 81       	ldd	r24, Y+2	; 0x02
    13da:	9b 81       	ldd	r25, Y+3	; 0x03
    13dc:	0a e0       	ldi	r16, 0x0A	; 10
    13de:	28 dd       	rcall	.-1456   	; 0xe30 <TCP_SetConnectionState>
    13e0:	55 c0       	rjmp	.+170    	; 0x148c <TCP_ProcessTCPPacket+0x508>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    13e2:	f7 01       	movw	r30, r14
    13e4:	85 85       	ldd	r24, Z+13	; 0x0d
    13e6:	80 31       	cpi	r24, 0x10	; 16
    13e8:	09 f0       	breq	.+2      	; 0x13ec <TCP_ProcessTCPPacket+0x468>
    13ea:	42 c0       	rjmp	.+132    	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    13ec:	d5 01       	movw	r26, r10
    13ee:	1c 96       	adiw	r26, 0x0c	; 12
    13f0:	4d 91       	ld	r20, X+
    13f2:	5d 91       	ld	r21, X+
    13f4:	6d 91       	ld	r22, X+
    13f6:	7c 91       	ld	r23, X
    13f8:	1f 97       	sbiw	r26, 0x0f	; 15
    13fa:	20 81       	ld	r18, Z
    13fc:	31 81       	ldd	r19, Z+1	; 0x01
    13fe:	82 81       	ldd	r24, Z+2	; 0x02
    1400:	93 81       	ldd	r25, Z+3	; 0x03
    1402:	0a e0       	ldi	r16, 0x0A	; 10
    1404:	15 dd       	rcall	.-1494   	; 0xe30 <TCP_SetConnectionState>
    1406:	34 c0       	rjmp	.+104    	; 0x1470 <TCP_ProcessTCPPacket+0x4ec>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1408:	84 e1       	ldi	r24, 0x14	; 20
    140a:	e6 01       	movw	r28, r12
    140c:	8d 87       	std	Y+13, r24	; 0x0d
    140e:	3e c0       	rjmp	.+124    	; 0x148c <TCP_ProcessTCPPacket+0x508>
    1410:	82 e0       	ldi	r24, 0x02	; 2
    1412:	90 e0       	ldi	r25, 0x00	; 0
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    1414:	f6 01       	movw	r30, r12
    1416:	97 87       	std	Z+15, r25	; 0x0f
    1418:	86 87       	std	Z+14, r24	; 0x0e
    141a:	0c c0       	rjmp	.+24     	; 0x1434 <TCP_ProcessTCPPacket+0x4b0>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    141c:	80 e0       	ldi	r24, 0x00	; 0
    141e:	92 e0       	ldi	r25, 0x02	; 2
    1420:	20 85       	ldd	r18, Z+8	; 0x08
    1422:	31 85       	ldd	r19, Z+9	; 0x09
    1424:	82 1b       	sub	r24, r18
    1426:	93 0b       	sbc	r25, r19
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    1428:	d6 01       	movw	r26, r12
    142a:	1e 96       	adiw	r26, 0x0e	; 14
    142c:	9c 93       	st	X, r25
    142e:	1e 97       	sbiw	r26, 0x0e	; 14
    1430:	1f 96       	adiw	r26, 0x0f	; 15
    1432:	8c 93       	st	X, r24

		TCPHeaderOUT->UrgentPointer        = 0;
    1434:	e6 01       	movw	r28, r12
    1436:	1b 8a       	std	Y+19, r1	; 0x13
    1438:	1a 8a       	std	Y+18, r1	; 0x12
		TCPHeaderOUT->Checksum             = 0;
    143a:	19 8a       	std	Y+17, r1	; 0x11
    143c:	18 8a       	std	Y+16, r1	; 0x10
		TCPHeaderOUT->Reserved             = 0;
    143e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1440:	80 7f       	andi	r24, 0xF0	; 240
    1442:	8c 87       	std	Y+12, r24	; 0x0c

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    1444:	f5 01       	movw	r30, r10
    1446:	40 89       	ldd	r20, Z+16	; 0x10
    1448:	51 89       	ldd	r21, Z+17	; 0x11
    144a:	62 89       	ldd	r22, Z+18	; 0x12
    144c:	73 89       	ldd	r23, Z+19	; 0x13
    144e:	04 85       	ldd	r16, Z+12	; 0x0c
    1450:	15 85       	ldd	r17, Z+13	; 0x0d
    1452:	26 85       	ldd	r18, Z+14	; 0x0e
    1454:	37 85       	ldd	r19, Z+15	; 0x0f
    1456:	c6 01       	movw	r24, r12
    1458:	e4 e1       	ldi	r30, 0x14	; 20
    145a:	ee 2e       	mov	r14, r30
    145c:	f1 2c       	mov	r15, r1
    145e:	70 db       	rcall	.-2336   	; 0xb40 <TCP_Checksum16>
    1460:	99 8b       	std	Y+17, r25	; 0x11
    1462:	88 8b       	std	Y+16, r24	; 0x10
    1464:	24 e1       	ldi	r18, 0x14	; 20
    1466:	30 e0       	ldi	r19, 0x00	; 0
    1468:	05 c0       	rjmp	.+10     	; 0x1474 <TCP_ProcessTCPPacket+0x4f0>
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    146a:	2f ef       	ldi	r18, 0xFF	; 255
    146c:	3f ef       	ldi	r19, 0xFF	; 255
    146e:	02 c0       	rjmp	.+4      	; 0x1474 <TCP_ProcessTCPPacket+0x4f0>
    1470:	20 e0       	ldi	r18, 0x00	; 0
    1472:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1474:	c9 01       	movw	r24, r18
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	1f 91       	pop	r17
    147c:	0f 91       	pop	r16
    147e:	ff 90       	pop	r15
    1480:	ef 90       	pop	r14
    1482:	df 90       	pop	r13
    1484:	cf 90       	pop	r12
    1486:	bf 90       	pop	r11
    1488:	af 90       	pop	r10
    148a:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    148c:	d5 01       	movw	r26, r10
    148e:	1c 96       	adiw	r26, 0x0c	; 12
    1490:	4d 91       	ld	r20, X+
    1492:	5d 91       	ld	r21, X+
    1494:	6d 91       	ld	r22, X+
    1496:	7c 91       	ld	r23, X
    1498:	1f 97       	sbiw	r26, 0x0f	; 15
    149a:	e7 01       	movw	r28, r14
    149c:	28 81       	ld	r18, Y
    149e:	39 81       	ldd	r19, Y+1	; 0x01
    14a0:	8a 81       	ldd	r24, Y+2	; 0x02
    14a2:	9b 81       	ldd	r25, Y+3	; 0x03
    14a4:	f2 db       	rcall	.-2076   	; 0xc8a <TCP_GetConnectionInfo>
    14a6:	fc 01       	movw	r30, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    14a8:	8a 81       	ldd	r24, Y+2	; 0x02
    14aa:	9b 81       	ldd	r25, Y+3	; 0x03
    14ac:	d6 01       	movw	r26, r12
    14ae:	11 96       	adiw	r26, 0x01	; 1
    14b0:	9c 93       	st	X, r25
    14b2:	8e 93       	st	-X, r24
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    14b4:	88 81       	ld	r24, Y
    14b6:	99 81       	ldd	r25, Y+1	; 0x01
    14b8:	13 96       	adiw	r26, 0x03	; 3
    14ba:	9c 93       	st	X, r25
    14bc:	8e 93       	st	-X, r24
    14be:	12 97       	sbiw	r26, 0x02	; 2
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
    14c0:	34 81       	ldd	r19, Z+4	; 0x04
    14c2:	25 81       	ldd	r18, Z+5	; 0x05
    14c4:	96 81       	ldd	r25, Z+6	; 0x06
    14c6:	87 81       	ldd	r24, Z+7	; 0x07
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    14c8:	14 96       	adiw	r26, 0x04	; 4
    14ca:	8c 93       	st	X, r24
    14cc:	14 97       	sbiw	r26, 0x04	; 4
    14ce:	15 96       	adiw	r26, 0x05	; 5
    14d0:	9c 93       	st	X, r25
    14d2:	15 97       	sbiw	r26, 0x05	; 5
    14d4:	16 96       	adiw	r26, 0x06	; 6
    14d6:	2c 93       	st	X, r18
    14d8:	16 97       	sbiw	r26, 0x06	; 6
    14da:	17 96       	adiw	r26, 0x07	; 7
    14dc:	3c 93       	st	X, r19
    14de:	17 97       	sbiw	r26, 0x07	; 7
    14e0:	30 81       	ld	r19, Z
    14e2:	21 81       	ldd	r18, Z+1	; 0x01
    14e4:	92 81       	ldd	r25, Z+2	; 0x02
    14e6:	83 81       	ldd	r24, Z+3	; 0x03
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    14e8:	18 96       	adiw	r26, 0x08	; 8
    14ea:	8c 93       	st	X, r24
    14ec:	18 97       	sbiw	r26, 0x08	; 8
    14ee:	19 96       	adiw	r26, 0x09	; 9
    14f0:	9c 93       	st	X, r25
    14f2:	19 97       	sbiw	r26, 0x09	; 9
    14f4:	1a 96       	adiw	r26, 0x0a	; 10
    14f6:	2c 93       	st	X, r18
    14f8:	1a 97       	sbiw	r26, 0x0a	; 10
    14fa:	1b 96       	adiw	r26, 0x0b	; 11
    14fc:	3c 93       	st	X, r19
    14fe:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    1500:	1c 96       	adiw	r26, 0x0c	; 12
    1502:	8c 91       	ld	r24, X
    1504:	1c 97       	sbiw	r26, 0x0c	; 12
    1506:	8f 70       	andi	r24, 0x0F	; 15
    1508:	80 65       	ori	r24, 0x50	; 80
    150a:	1c 96       	adiw	r26, 0x0c	; 12
    150c:	8c 93       	st	X, r24

		if (!(ConnectionInfo->Buffer.InUse))
    150e:	e4 5f       	subi	r30, 0xF4	; 244
    1510:	fd 4f       	sbci	r31, 0xFD	; 253
    1512:	80 81       	ld	r24, Z
    1514:	ec 50       	subi	r30, 0x0C	; 12
    1516:	f2 40       	sbci	r31, 0x02	; 2
    1518:	88 23       	and	r24, r24
    151a:	09 f4       	brne	.+2      	; 0x151e <TCP_ProcessTCPPacket+0x59a>
    151c:	79 cf       	rjmp	.-270    	; 0x1410 <TCP_ProcessTCPPacket+0x48c>
    151e:	7e cf       	rjmp	.-260    	; 0x141c <TCP_ProcessTCPPacket+0x498>

00001520 <TCP_Task>:
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
    1520:	2f 92       	push	r2
    1522:	3f 92       	push	r3
    1524:	4f 92       	push	r4
    1526:	5f 92       	push	r5
    1528:	6f 92       	push	r6
    152a:	7f 92       	push	r7
    152c:	8f 92       	push	r8
    152e:	9f 92       	push	r9
    1530:	af 92       	push	r10
    1532:	bf 92       	push	r11
    1534:	cf 92       	push	r12
    1536:	df 92       	push	r13
    1538:	ef 92       	push	r14
    153a:	ff 92       	push	r15
    153c:	0f 93       	push	r16
    153e:	1f 93       	push	r17
    1540:	df 93       	push	r29
    1542:	cf 93       	push	r28
    1544:	00 d0       	rcall	.+0      	; 0x1546 <TCP_Task+0x26>
    1546:	cd b7       	in	r28, 0x3d	; 61
    1548:	de b7       	in	r29, 0x3e	; 62
    154a:	39 e0       	ldi	r19, 0x09	; 9
    154c:	c3 2e       	mov	r12, r19
    154e:	3d e0       	ldi	r19, 0x0D	; 13
    1550:	d3 2e       	mov	r13, r19
    1552:	00 e0       	ldi	r16, 0x00	; 0
    1554:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1556:	26 e1       	ldi	r18, 0x16	; 22
    1558:	e2 2e       	mov	r14, r18
    155a:	22 e0       	ldi	r18, 0x02	; 2
    155c:	f2 2e       	mov	r15, r18
    155e:	1c c0       	rjmp	.+56     	; 0x1598 <TCP_Task+0x78>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1560:	80 91 4d 13 	lds	r24, 0x134D
    1564:	81 30       	cpi	r24, 0x01	; 1
    1566:	79 f4       	brne	.+30     	; 0x1586 <TCP_Task+0x66>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1568:	0e 9d       	mul	r16, r14
    156a:	b0 01       	movw	r22, r0
    156c:	0f 9d       	mul	r16, r15
    156e:	70 0d       	add	r23, r0
    1570:	1e 9d       	mul	r17, r14
    1572:	70 0d       	add	r23, r0
    1574:	11 24       	eor	r1, r1
    1576:	67 5e       	subi	r22, 0xE7	; 231
    1578:	72 4f       	sbci	r23, 0xF2	; 242
    157a:	e0 91 4e 13 	lds	r30, 0x134E
    157e:	f0 91 4f 13 	lds	r31, 0x134F
    1582:	c6 01       	movw	r24, r12
    1584:	09 95       	icall
    1586:	0f 5f       	subi	r16, 0xFF	; 255
    1588:	1f 4f       	sbci	r17, 0xFF	; 255
    158a:	26 e1       	ldi	r18, 0x16	; 22
    158c:	32 e0       	ldi	r19, 0x02	; 2
    158e:	c2 0e       	add	r12, r18
    1590:	d3 1e       	adc	r13, r19
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1592:	03 30       	cpi	r16, 0x03	; 3
    1594:	11 05       	cpc	r17, r1
    1596:	59 f0       	breq	.+22     	; 0x15ae <TCP_Task+0x8e>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1598:	20 91 4b 13 	lds	r18, 0x134B
    159c:	30 91 4c 13 	lds	r19, 0x134C
    15a0:	d6 01       	movw	r26, r12
    15a2:	8d 91       	ld	r24, X+
    15a4:	9c 91       	ld	r25, X
    15a6:	28 17       	cp	r18, r24
    15a8:	39 07       	cpc	r19, r25
    15aa:	69 f7       	brne	.-38     	; 0x1586 <TCP_Task+0x66>
    15ac:	d9 cf       	rjmp	.-78     	; 0x1560 <TCP_Task+0x40>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
    15ae:	80 91 07 0d 	lds	r24, 0x0D07
    15b2:	90 91 08 0d 	lds	r25, 0x0D08
    15b6:	89 2b       	or	r24, r25
    15b8:	09 f0       	breq	.+2      	; 0x15bc <TCP_Task+0x9c>
    15ba:	1d c1       	rjmp	.+570    	; 0x17f6 <TCP_Task+0x2d6>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    15bc:	80 91 1b 0f 	lds	r24, 0x0F1B
    15c0:	88 23       	and	r24, r24
    15c2:	39 f0       	breq	.+14     	; 0x15d2 <TCP_Task+0xb2>
    15c4:	80 91 1c 0f 	lds	r24, 0x0F1C
    15c8:	88 23       	and	r24, r24
    15ca:	19 f0       	breq	.+6      	; 0x15d2 <TCP_Task+0xb2>
    15cc:	1a 82       	std	Y+2, r1	; 0x02
    15ce:	19 82       	std	Y+1, r1	; 0x01
    15d0:	1b c0       	rjmp	.+54     	; 0x1608 <TCP_Task+0xe8>
    15d2:	80 91 31 11 	lds	r24, 0x1131
    15d6:	88 23       	and	r24, r24
    15d8:	49 f0       	breq	.+18     	; 0x15ec <TCP_Task+0xcc>
    15da:	80 91 32 11 	lds	r24, 0x1132
    15de:	88 23       	and	r24, r24
    15e0:	29 f0       	breq	.+10     	; 0x15ec <TCP_Task+0xcc>
    15e2:	e1 e0       	ldi	r30, 0x01	; 1
    15e4:	f0 e0       	ldi	r31, 0x00	; 0
    15e6:	fa 83       	std	Y+2, r31	; 0x02
    15e8:	e9 83       	std	Y+1, r30	; 0x01
    15ea:	0e c0       	rjmp	.+28     	; 0x1608 <TCP_Task+0xe8>
    15ec:	80 91 47 13 	lds	r24, 0x1347
    15f0:	88 23       	and	r24, r24
    15f2:	09 f4       	brne	.+2      	; 0x15f6 <TCP_Task+0xd6>
    15f4:	00 c1       	rjmp	.+512    	; 0x17f6 <TCP_Task+0x2d6>
    15f6:	80 91 48 13 	lds	r24, 0x1348
    15fa:	88 23       	and	r24, r24
    15fc:	09 f4       	brne	.+2      	; 0x1600 <TCP_Task+0xe0>
    15fe:	fb c0       	rjmp	.+502    	; 0x17f6 <TCP_Task+0x2d6>
    1600:	22 e0       	ldi	r18, 0x02	; 2
    1602:	30 e0       	ldi	r19, 0x00	; 0
    1604:	3a 83       	std	Y+2, r19	; 0x02
    1606:	29 83       	std	Y+1, r18	; 0x01
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)];
    1608:	9b e2       	ldi	r25, 0x2B	; 43
    160a:	a9 2e       	mov	r10, r25
    160c:	97 e0       	ldi	r25, 0x07	; 7
    160e:	b9 2e       	mov	r11, r25
    1610:	8e e0       	ldi	r24, 0x0E	; 14
    1612:	90 e0       	ldi	r25, 0x00	; 0
    1614:	a8 0e       	add	r10, r24
    1616:	b9 1e       	adc	r11, r25
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                             sizeof(IP_Header_t)];
    1618:	8b e2       	ldi	r24, 0x2B	; 43
    161a:	c8 2e       	mov	r12, r24
    161c:	87 e0       	ldi	r24, 0x07	; 7
    161e:	d8 2e       	mov	r13, r24
    1620:	a2 e2       	ldi	r26, 0x22	; 34
    1622:	b0 e0       	ldi	r27, 0x00	; 0
    1624:	ca 0e       	add	r12, r26
    1626:	db 1e       	adc	r13, r27
			void*                    TCPDataOUT     = &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                              sizeof(IP_Header_t) +
			                                                              sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    1628:	86 e1       	ldi	r24, 0x16	; 22
    162a:	92 e0       	ldi	r25, 0x02	; 2
    162c:	e9 81       	ldd	r30, Y+1	; 0x01
    162e:	fa 81       	ldd	r31, Y+2	; 0x02
    1630:	e8 9f       	mul	r30, r24
    1632:	a0 01       	movw	r20, r0
    1634:	e9 9f       	mul	r30, r25
    1636:	50 0d       	add	r21, r0
    1638:	f8 9f       	mul	r31, r24
    163a:	50 0d       	add	r21, r0
    163c:	11 24       	eor	r1, r1
    163e:	09 e0       	ldi	r16, 0x09	; 9
    1640:	80 2e       	mov	r8, r16
    1642:	0d e0       	ldi	r16, 0x0D	; 13
    1644:	90 2e       	mov	r9, r16
    1646:	84 0e       	add	r8, r20
    1648:	95 1e       	adc	r9, r21
    164a:	d4 01       	movw	r26, r8
    164c:	50 96       	adiw	r26, 0x10	; 16
    164e:	6d 90       	ld	r6, X+
    1650:	7c 90       	ld	r7, X
    1652:	51 97       	sbiw	r26, 0x11	; 17

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    1654:	8d 91       	ld	r24, X+
    1656:	9c 91       	ld	r25, X
    1658:	90 93 4e 07 	sts	0x074E, r25
    165c:	80 93 4d 07 	sts	0x074D, r24
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    1660:	8b e0       	ldi	r24, 0x0B	; 11
    1662:	91 e0       	ldi	r25, 0x01	; 1
    1664:	9f 01       	movw	r18, r30
    1666:	28 9f       	mul	r18, r24
    1668:	f0 01       	movw	r30, r0
    166a:	29 9f       	mul	r18, r25
    166c:	f0 0d       	add	r31, r0
    166e:	38 9f       	mul	r19, r24
    1670:	f0 0d       	add	r31, r0
    1672:	11 24       	eor	r1, r1
    1674:	ee 0f       	add	r30, r30
    1676:	ff 1f       	adc	r31, r31
    1678:	e5 5f       	subi	r30, 0xF5	; 245
    167a:	f2 4f       	sbci	r31, 0xF2	; 242
    167c:	80 81       	ld	r24, Z
    167e:	91 81       	ldd	r25, Z+1	; 0x01
    1680:	d6 01       	movw	r26, r12
    1682:	13 96       	adiw	r26, 0x03	; 3
    1684:	9c 93       	st	X, r25
    1686:	8e 93       	st	-X, r24
    1688:	12 97       	sbiw	r26, 0x02	; 2
    168a:	f4 01       	movw	r30, r8
    168c:	3c 96       	adiw	r30, 0x0c	; 12
    168e:	d4 01       	movw	r26, r8
    1690:	1c 96       	adiw	r26, 0x0c	; 12
    1692:	3c 91       	ld	r19, X
    1694:	1c 97       	sbiw	r26, 0x0c	; 12
    1696:	21 81       	ldd	r18, Z+1	; 0x01
    1698:	92 81       	ldd	r25, Z+2	; 0x02
    169a:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    169c:	f6 01       	movw	r30, r12
    169e:	84 83       	std	Z+4, r24	; 0x04
    16a0:	95 83       	std	Z+5, r25	; 0x05
    16a2:	26 83       	std	Z+6, r18	; 0x06
    16a4:	37 83       	std	Z+7, r19	; 0x07
    16a6:	f4 01       	movw	r30, r8
    16a8:	38 96       	adiw	r30, 0x08	; 8
    16aa:	18 96       	adiw	r26, 0x08	; 8
    16ac:	3c 91       	ld	r19, X
    16ae:	21 81       	ldd	r18, Z+1	; 0x01
    16b0:	92 81       	ldd	r25, Z+2	; 0x02
    16b2:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    16b4:	f6 01       	movw	r30, r12
    16b6:	80 87       	std	Z+8, r24	; 0x08
    16b8:	91 87       	std	Z+9, r25	; 0x09
    16ba:	22 87       	std	Z+10, r18	; 0x0a
    16bc:	33 87       	std	Z+11, r19	; 0x0b

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;
    16be:	82 e0       	ldi	r24, 0x02	; 2
    16c0:	90 e0       	ldi	r25, 0x00	; 0
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    16c2:	97 87       	std	Z+15, r25	; 0x0f
    16c4:	86 87       	std	Z+14, r24	; 0x0e

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    16c6:	80 e1       	ldi	r24, 0x10	; 16
    16c8:	85 87       	std	Z+13, r24	; 0x0d
			TCPHeaderOUT->UrgentPointer        = 0;
    16ca:	13 8a       	std	Z+19, r1	; 0x13
    16cc:	12 8a       	std	Z+18, r1	; 0x12
			TCPHeaderOUT->Checksum             = 0;
    16ce:	11 8a       	std	Z+17, r1	; 0x11
    16d0:	10 8a       	std	Z+16, r1	; 0x10
			TCPHeaderOUT->Reserved             = 0;
    16d2:	80 e5       	ldi	r24, 0x50	; 80
    16d4:	84 87       	std	Z+12, r24	; 0x0c

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    16d6:	2b e2       	ldi	r18, 0x2B	; 43
    16d8:	37 e0       	ldi	r19, 0x07	; 7
    16da:	2a 5c       	subi	r18, 0xCA	; 202
    16dc:	3f 4f       	sbci	r19, 0xFF	; 255
    16de:	45 5e       	subi	r20, 0xE5	; 229
    16e0:	52 4f       	sbci	r21, 0xF2	; 242
    16e2:	c9 01       	movw	r24, r18
    16e4:	ba 01       	movw	r22, r20
    16e6:	a3 01       	movw	r20, r6
    16e8:	0e 94 2c 17 	call	0x2e58	; 0x2e58 <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    16ec:	c3 01       	movw	r24, r6
    16ee:	a0 e0       	ldi	r26, 0x00	; 0
    16f0:	b0 e0       	ldi	r27, 0x00	; 0
    16f2:	f4 01       	movw	r30, r8
    16f4:	24 85       	ldd	r18, Z+12	; 0x0c
    16f6:	35 85       	ldd	r19, Z+13	; 0x0d
    16f8:	46 85       	ldd	r20, Z+14	; 0x0e
    16fa:	57 85       	ldd	r21, Z+15	; 0x0f
    16fc:	82 0f       	add	r24, r18
    16fe:	93 1f       	adc	r25, r19
    1700:	a4 1f       	adc	r26, r20
    1702:	b5 1f       	adc	r27, r21
    1704:	84 87       	std	Z+12, r24	; 0x0c
    1706:	95 87       	std	Z+13, r25	; 0x0d
    1708:	a6 87       	std	Z+14, r26	; 0x0e
    170a:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
    170c:	24 e1       	ldi	r18, 0x14	; 20
    170e:	30 e0       	ldi	r19, 0x00	; 0
    1710:	62 0e       	add	r6, r18
    1712:	73 1e       	adc	r7, r19
    1714:	20 90 0e 01 	lds	r2, 0x010E
    1718:	30 90 0f 01 	lds	r3, 0x010F
    171c:	40 90 10 01 	lds	r4, 0x0110
    1720:	50 90 11 01 	lds	r5, 0x0111
    1724:	04 81       	ldd	r16, Z+4	; 0x04
    1726:	15 81       	ldd	r17, Z+5	; 0x05
    1728:	26 81       	ldd	r18, Z+6	; 0x06
    172a:	37 81       	ldd	r19, Z+7	; 0x07
    172c:	c6 01       	movw	r24, r12
    172e:	b2 01       	movw	r22, r4
    1730:	a1 01       	movw	r20, r2
    1732:	73 01       	movw	r14, r6
    1734:	05 da       	rcall	.-3062   	; 0xb40 <TCP_Checksum16>
    1736:	d6 01       	movw	r26, r12
    1738:	51 96       	adiw	r26, 0x11	; 17
    173a:	9c 93       	st	X, r25
    173c:	8e 93       	st	-X, r24
    173e:	50 97       	sbiw	r26, 0x10	; 16
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    1740:	83 01       	movw	r16, r6
    1742:	0c 5e       	subi	r16, 0xEC	; 236
    1744:	1f 4f       	sbci	r17, 0xFF	; 255
    1746:	f5 01       	movw	r30, r10
    1748:	12 83       	std	Z+2, r17	; 0x02
    174a:	03 83       	std	Z+3, r16	; 0x03
			IPHeaderOUT->TypeOfService      = 0;
    174c:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    174e:	85 e4       	ldi	r24, 0x45	; 69
    1750:	80 93 39 07 	sts	0x0739, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    1754:	16 82       	std	Z+6, r1	; 0x06
    1756:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    1758:	15 82       	std	Z+5, r1	; 0x05
    175a:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    175c:	13 86       	std	Z+11, r1	; 0x0b
    175e:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    1760:	86 e0       	ldi	r24, 0x06	; 6
    1762:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    1764:	80 e8       	ldi	r24, 0x80	; 128
    1766:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    1768:	d5 01       	movw	r26, r10
    176a:	1c 96       	adiw	r26, 0x0c	; 12
    176c:	2d 92       	st	X+, r2
    176e:	3d 92       	st	X+, r3
    1770:	4d 92       	st	X+, r4
    1772:	5c 92       	st	X, r5
    1774:	1f 97       	sbiw	r26, 0x0f	; 15
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    1776:	f4 01       	movw	r30, r8
    1778:	84 81       	ldd	r24, Z+4	; 0x04
    177a:	95 81       	ldd	r25, Z+5	; 0x05
    177c:	a6 81       	ldd	r26, Z+6	; 0x06
    177e:	b7 81       	ldd	r27, Z+7	; 0x07
    1780:	f5 01       	movw	r30, r10
    1782:	80 8b       	std	Z+16, r24	; 0x10
    1784:	91 8b       	std	Z+17, r25	; 0x11
    1786:	a2 8b       	std	Z+18, r26	; 0x12
    1788:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    178a:	c5 01       	movw	r24, r10
    178c:	64 e1       	ldi	r22, 0x14	; 20
    178e:	70 e0       	ldi	r23, 0x00	; 0
    1790:	6d d8       	rcall	.-3878   	; 0x86c <Ethernet_Checksum16>
    1792:	d5 01       	movw	r26, r10
    1794:	1b 96       	adiw	r26, 0x0b	; 11
    1796:	9c 93       	st	X, r25
    1798:	8e 93       	st	-X, r24
    179a:	1a 97       	sbiw	r26, 0x0a	; 10

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    179c:	ab e2       	ldi	r26, 0x2B	; 43
    179e:	b7 e0       	ldi	r27, 0x07	; 7
    17a0:	16 96       	adiw	r26, 0x06	; 6
    17a2:	e8 e0       	ldi	r30, 0x08	; 8
    17a4:	f1 e0       	ldi	r31, 0x01	; 1
    17a6:	86 e0       	ldi	r24, 0x06	; 6
    17a8:	01 90       	ld	r0, Z+
    17aa:	0d 92       	st	X+, r0
    17ac:	81 50       	subi	r24, 0x01	; 1
    17ae:	e1 f7       	brne	.-8      	; 0x17a8 <TCP_Task+0x288>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    17b0:	ab e2       	ldi	r26, 0x2B	; 43
    17b2:	b7 e0       	ldi	r27, 0x07	; 7
    17b4:	e0 e2       	ldi	r30, 0x20	; 32
    17b6:	f1 e0       	ldi	r31, 0x01	; 1
    17b8:	86 e0       	ldi	r24, 0x06	; 6
    17ba:	01 90       	ld	r0, Z+
    17bc:	0d 92       	st	X+, r0
    17be:	81 50       	subi	r24, 0x01	; 1
    17c0:	e1 f7       	brne	.-8      	; 0x17ba <TCP_Task+0x29a>
    17c2:	88 e0       	ldi	r24, 0x08	; 8
    17c4:	90 e0       	ldi	r25, 0x00	; 0
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    17c6:	90 93 38 07 	sts	0x0738, r25
    17ca:	80 93 37 07 	sts	0x0737, r24

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = PacketSize;
    17ce:	02 5f       	subi	r16, 0xF2	; 242
    17d0:	1f 4f       	sbci	r17, 0xFF	; 255
    17d2:	10 93 08 0d 	sts	0x0D08, r17
    17d6:	00 93 07 0d 	sts	0x0D07, r16

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    17da:	86 e1       	ldi	r24, 0x16	; 22
    17dc:	92 e0       	ldi	r25, 0x02	; 2
    17de:	29 81       	ldd	r18, Y+1	; 0x01
    17e0:	3a 81       	ldd	r19, Y+2	; 0x02
    17e2:	28 9f       	mul	r18, r24
    17e4:	f0 01       	movw	r30, r0
    17e6:	29 9f       	mul	r18, r25
    17e8:	f0 0d       	add	r31, r0
    17ea:	38 9f       	mul	r19, r24
    17ec:	f0 0d       	add	r31, r0
    17ee:	11 24       	eor	r1, r1
    17f0:	e4 5e       	subi	r30, 0xE4	; 228
    17f2:	f0 4f       	sbci	r31, 0xF0	; 240
    17f4:	10 82       	st	Z, r1

			break;
		}
	}
}
    17f6:	0f 90       	pop	r0
    17f8:	0f 90       	pop	r0
    17fa:	cf 91       	pop	r28
    17fc:	df 91       	pop	r29
    17fe:	1f 91       	pop	r17
    1800:	0f 91       	pop	r16
    1802:	ff 90       	pop	r15
    1804:	ef 90       	pop	r14
    1806:	df 90       	pop	r13
    1808:	cf 90       	pop	r12
    180a:	bf 90       	pop	r11
    180c:	af 90       	pop	r10
    180e:	9f 90       	pop	r9
    1810:	8f 90       	pop	r8
    1812:	7f 90       	pop	r7
    1814:	6f 90       	pop	r6
    1816:	5f 90       	pop	r5
    1818:	4f 90       	pop	r4
    181a:	3f 90       	pop	r3
    181c:	2f 90       	pop	r2
    181e:	08 95       	ret

00001820 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    1820:	ef 92       	push	r14
    1822:	ff 92       	push	r15
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	7c 01       	movw	r14, r24
    182e:	eb 01       	movw	r28, r22
    1830:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    1832:	cb 01       	movw	r24, r22
    1834:	c0 d8       	rcall	.-3712   	; 0x9b6 <DecodeUDPHeader>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1836:	8a 81       	ldd	r24, Y+2	; 0x02
    1838:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    183a:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    183c:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    183e:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    1840:	83 34       	cpi	r24, 0x43	; 67
    1842:	91 05       	cpc	r25, r1
    1844:	e9 f4       	brne	.+58     	; 0x1880 <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1846:	be 01       	movw	r22, r28
    1848:	68 5f       	subi	r22, 0xF8	; 248
    184a:	7f 4f       	sbci	r23, 0xFF	; 255
    184c:	a8 01       	movw	r20, r16
    184e:	48 5f       	subi	r20, 0xF8	; 248
    1850:	5f 4f       	sbci	r21, 0xFF	; 255
    1852:	c7 01       	movw	r24, r14
    1854:	1f d0       	rcall	.+62     	; 0x1894 <DHCP_ProcessDHCPPacket>
    1856:	9c 01       	movw	r18, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1858:	18 16       	cp	r1, r24
    185a:	19 06       	cpc	r1, r25
    185c:	8c f4       	brge	.+34     	; 0x1880 <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    185e:	8a 81       	ldd	r24, Y+2	; 0x02
    1860:	9b 81       	ldd	r25, Y+3	; 0x03
    1862:	f8 01       	movw	r30, r16
    1864:	91 83       	std	Z+1, r25	; 0x01
    1866:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1868:	88 81       	ld	r24, Y
    186a:	99 81       	ldd	r25, Y+1	; 0x01
    186c:	93 83       	std	Z+3, r25	; 0x03
    186e:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    1870:	17 82       	std	Z+7, r1	; 0x07
    1872:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1874:	c9 01       	movw	r24, r18
    1876:	08 96       	adiw	r24, 0x08	; 8
    1878:	94 83       	std	Z+4, r25	; 0x04
    187a:	85 83       	std	Z+5, r24	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    187c:	9c 01       	movw	r18, r24
    187e:	02 c0       	rjmp	.+4      	; 0x1884 <UDP_ProcessUDPPacket+0x64>
    1880:	20 e0       	ldi	r18, 0x00	; 0
    1882:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1884:	c9 01       	movw	r24, r18
    1886:	df 91       	pop	r29
    1888:	cf 91       	pop	r28
    188a:	1f 91       	pop	r17
    188c:	0f 91       	pop	r16
    188e:	ff 90       	pop	r15
    1890:	ef 90       	pop	r14
    1892:	08 95       	ret

00001894 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1894:	8f 92       	push	r8
    1896:	9f 92       	push	r9
    1898:	af 92       	push	r10
    189a:	bf 92       	push	r11
    189c:	cf 92       	push	r12
    189e:	df 92       	push	r13
    18a0:	ef 92       	push	r14
    18a2:	ff 92       	push	r15
    18a4:	0f 93       	push	r16
    18a6:	1f 93       	push	r17
    18a8:	cf 93       	push	r28
    18aa:	df 93       	push	r29
    18ac:	8b 01       	movw	r16, r22
    18ae:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    18b0:	5c 01       	movw	r10, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    18b2:	80 ef       	ldi	r24, 0xF0	; 240
    18b4:	88 2e       	mov	r8, r24
    18b6:	91 2c       	mov	r9, r1
    18b8:	86 0e       	add	r8, r22
    18ba:	97 1e       	adc	r9, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    18bc:	cb 01       	movw	r24, r22
    18be:	7c d8       	rcall	.-3848   	; 0x9b8 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    18c0:	80 ef       	ldi	r24, 0xF0	; 240
    18c2:	fe 01       	movw	r30, r28
    18c4:	11 92       	st	Z+, r1
    18c6:	8a 95       	dec	r24
    18c8:	e9 f7       	brne	.-6      	; 0x18c4 <DHCP_ProcessDHCPPacket+0x30>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    18ca:	f8 01       	movw	r30, r16
    18cc:	81 81       	ldd	r24, Z+1	; 0x01
    18ce:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    18d0:	82 e0       	ldi	r24, 0x02	; 2
    18d2:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    18d4:	82 81       	ldd	r24, Z+2	; 0x02
    18d6:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    18d8:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    18da:	84 81       	ldd	r24, Z+4	; 0x04
    18dc:	95 81       	ldd	r25, Z+5	; 0x05
    18de:	a6 81       	ldd	r26, Z+6	; 0x06
    18e0:	b7 81       	ldd	r27, Z+7	; 0x07
    18e2:	8c 83       	std	Y+4, r24	; 0x04
    18e4:	9d 83       	std	Y+5, r25	; 0x05
    18e6:	ae 83       	std	Y+6, r26	; 0x06
    18e8:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    18ea:	19 86       	std	Y+9, r1	; 0x09
    18ec:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    18ee:	82 85       	ldd	r24, Z+10	; 0x0a
    18f0:	93 85       	ldd	r25, Z+11	; 0x0b
    18f2:	9b 87       	std	Y+11, r25	; 0x0b
    18f4:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    18f6:	c0 90 1c 01 	lds	r12, 0x011C
    18fa:	d0 90 1d 01 	lds	r13, 0x011D
    18fe:	e0 90 1e 01 	lds	r14, 0x011E
    1902:	f0 90 1f 01 	lds	r15, 0x011F
    1906:	c8 8a       	std	Y+16, r12	; 0x10
    1908:	d9 8a       	std	Y+17, r13	; 0x11
    190a:	ea 8a       	std	Y+18, r14	; 0x12
    190c:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    190e:	04 5e       	subi	r16, 0xE4	; 228
    1910:	1f 4f       	sbci	r17, 0xFF	; 255
    1912:	ce 01       	movw	r24, r28
    1914:	4c 96       	adiw	r24, 0x1c	; 28
    1916:	b8 01       	movw	r22, r16
    1918:	46 e0       	ldi	r20, 0x06	; 6
    191a:	50 e0       	ldi	r21, 0x00	; 0
    191c:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <memmove>
				} Data;

				Data.DWord = DWord;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[3];
    1920:	83 e6       	ldi	r24, 0x63	; 99
    1922:	93 e5       	ldi	r25, 0x53	; 83
    1924:	a2 e8       	ldi	r26, 0x82	; 130
    1926:	b3 e6       	ldi	r27, 0x63	; 99
				Data.Bytes[3] = Temp;
    1928:	b3 e6       	ldi	r27, 0x63	; 99

				Temp = Data.Bytes[1];
    192a:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
    192c:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
    192e:	a2 2f       	mov	r26, r18
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    1930:	c4 51       	subi	r28, 0x14	; 20
    1932:	df 4f       	sbci	r29, 0xFF	; 255
    1934:	88 83       	st	Y, r24
    1936:	99 83       	std	Y+1, r25	; 0x01
    1938:	aa 83       	std	Y+2, r26	; 0x02
    193a:	bb 83       	std	Y+3, r27	; 0x03
    193c:	cc 5e       	subi	r28, 0xEC	; 236
    193e:	d0 40       	sbci	r29, 0x00	; 0

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    1940:	f5 01       	movw	r30, r10
    1942:	c4 86       	std	Z+12, r12	; 0x0c
    1944:	d5 86       	std	Z+13, r13	; 0x0d
    1946:	e6 86       	std	Z+14, r14	; 0x0e
    1948:	f7 86       	std	Z+15, r15	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    194a:	80 91 0e 01 	lds	r24, 0x010E
    194e:	90 91 0f 01 	lds	r25, 0x010F
    1952:	a0 91 10 01 	lds	r26, 0x0110
    1956:	b0 91 11 01 	lds	r27, 0x0111
    195a:	80 8b       	std	Z+16, r24	; 0x10
    195c:	91 8b       	std	Z+17, r25	; 0x11
    195e:	a2 8b       	std	Z+18, r26	; 0x12
    1960:	b3 8b       	std	Z+19, r27	; 0x13
    1962:	5b c0       	rjmp	.+182    	; 0x1a1a <DHCP_ProcessDHCPPacket+0x186>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    1964:	85 33       	cpi	r24, 0x35	; 53
    1966:	09 f0       	breq	.+2      	; 0x196a <DHCP_ProcessDHCPPacket+0xd6>
    1968:	4d c0       	rjmp	.+154    	; 0x1a04 <DHCP_ProcessDHCPPacket+0x170>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    196a:	94 01       	movw	r18, r8
    196c:	2e 5f       	subi	r18, 0xFE	; 254
    196e:	3f 4f       	sbci	r19, 0xFF	; 255
    1970:	f4 01       	movw	r30, r8
    1972:	82 81       	ldd	r24, Z+2	; 0x02
    1974:	81 30       	cpi	r24, 0x01	; 1
    1976:	19 f0       	breq	.+6      	; 0x197e <DHCP_ProcessDHCPPacket+0xea>
    1978:	83 30       	cpi	r24, 0x03	; 3
    197a:	09 f0       	breq	.+2      	; 0x197e <DHCP_ProcessDHCPPacket+0xea>
    197c:	48 c0       	rjmp	.+144    	; 0x1a0e <DHCP_ProcessDHCPPacket+0x17a>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    197e:	fe 01       	movw	r30, r28
    1980:	e0 51       	subi	r30, 0x10	; 16
    1982:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    1984:	df 01       	movw	r26, r30
    1986:	85 e3       	ldi	r24, 0x35	; 53
    1988:	8d 93       	st	X+, r24
				*(DHCPOptionsOUTStart++) = 1;
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	81 83       	std	Z+1, r24	; 0x01
    198e:	ed 01       	movw	r28, r26
    1990:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    1992:	f9 01       	movw	r30, r18
    1994:	80 81       	ld	r24, Z
    1996:	81 30       	cpi	r24, 0x01	; 1
    1998:	11 f0       	breq	.+4      	; 0x199e <DHCP_ProcessDHCPPacket+0x10a>
    199a:	85 e0       	ldi	r24, 0x05	; 5
    199c:	01 c0       	rjmp	.+2      	; 0x19a0 <DHCP_ProcessDHCPPacket+0x10c>
    199e:	82 e0       	ldi	r24, 0x02	; 2
    19a0:	11 96       	adiw	r26, 0x01	; 1
    19a2:	8c 93       	st	X, r24
    19a4:	fe 01       	movw	r30, r28
    19a6:	31 96       	adiw	r30, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    19a8:	81 e0       	ldi	r24, 0x01	; 1
    19aa:	89 83       	std	Y+1, r24	; 0x01
    19ac:	cf 01       	movw	r24, r30
    19ae:	01 96       	adiw	r24, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    19b0:	34 e0       	ldi	r19, 0x04	; 4
    19b2:	31 83       	std	Z+1, r19	; 0x01
    19b4:	dc 01       	movw	r26, r24
    19b6:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    19b8:	2f ef       	ldi	r18, 0xFF	; 255
    19ba:	fc 01       	movw	r30, r24
    19bc:	21 83       	std	Z+1, r18	; 0x01
    19be:	fd 01       	movw	r30, r26
    19c0:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    19c2:	11 96       	adiw	r26, 0x01	; 1
    19c4:	2c 93       	st	X, r18
    19c6:	df 01       	movw	r26, r30
    19c8:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    19ca:	21 83       	std	Z+1, r18	; 0x01
    19cc:	fd 01       	movw	r30, r26
    19ce:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    19d0:	11 96       	adiw	r26, 0x01	; 1
    19d2:	1c 92       	st	X, r1
    19d4:	df 01       	movw	r26, r30
    19d6:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    19d8:	86 e3       	ldi	r24, 0x36	; 54
    19da:	81 83       	std	Z+1, r24	; 0x01
    19dc:	fd 01       	movw	r30, r26
    19de:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    19e0:	11 96       	adiw	r26, 0x01	; 1
    19e2:	3c 93       	st	X, r19
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    19e4:	80 91 0e 01 	lds	r24, 0x010E
    19e8:	90 91 0f 01 	lds	r25, 0x010F
    19ec:	a0 91 10 01 	lds	r26, 0x0110
    19f0:	b0 91 11 01 	lds	r27, 0x0111
    19f4:	81 83       	std	Z+1, r24	; 0x01
    19f6:	92 83       	std	Z+2, r25	; 0x02
    19f8:	a3 83       	std	Z+3, r26	; 0x03
    19fa:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    19fc:	25 83       	std	Z+5, r18	; 0x05
    19fe:	20 e0       	ldi	r18, 0x00	; 0
    1a00:	31 e0       	ldi	r19, 0x01	; 1
    1a02:	12 c0       	rjmp	.+36     	; 0x1a28 <DHCP_ProcessDHCPPacket+0x194>
				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    1a04:	88 23       	and	r24, r24
    1a06:	19 f4       	brne	.+6      	; 0x1a0e <DHCP_ProcessDHCPPacket+0x17a>
    1a08:	81 e0       	ldi	r24, 0x01	; 1
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	04 c0       	rjmp	.+8      	; 0x1a16 <DHCP_ProcessDHCPPacket+0x182>
    1a0e:	f4 01       	movw	r30, r8
    1a10:	81 81       	ldd	r24, Z+1	; 0x01
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	02 96       	adiw	r24, 0x02	; 2
    1a16:	88 0e       	add	r8, r24
    1a18:	99 1e       	adc	r9, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1a1a:	f4 01       	movw	r30, r8
    1a1c:	80 81       	ld	r24, Z
    1a1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a20:	09 f0       	breq	.+2      	; 0x1a24 <DHCP_ProcessDHCPPacket+0x190>
    1a22:	a0 cf       	rjmp	.-192    	; 0x1964 <DHCP_ProcessDHCPPacket+0xd0>
    1a24:	20 e0       	ldi	r18, 0x00	; 0
    1a26:	30 e0       	ldi	r19, 0x00	; 0
		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
}
    1a28:	c9 01       	movw	r24, r18
    1a2a:	df 91       	pop	r29
    1a2c:	cf 91       	pop	r28
    1a2e:	1f 91       	pop	r17
    1a30:	0f 91       	pop	r16
    1a32:	ff 90       	pop	r15
    1a34:	ef 90       	pop	r14
    1a36:	df 90       	pop	r13
    1a38:	cf 90       	pop	r12
    1a3a:	bf 90       	pop	r11
    1a3c:	af 90       	pop	r10
    1a3e:	9f 90       	pop	r9
    1a40:	8f 90       	pop	r8
    1a42:	08 95       	ret

00001a44 <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    1a44:	ef 92       	push	r14
    1a46:	ff 92       	push	r15
    1a48:	0f 93       	push	r16
    1a4a:	1f 93       	push	r17
    1a4c:	cf 93       	push	r28
    1a4e:	df 93       	push	r29
    1a50:	18 2f       	mov	r17, r24
    1a52:	09 2f       	mov	r16, r25
    1a54:	f6 2e       	mov	r15, r22
    1a56:	e7 2e       	mov	r14, r23
	DecodeARPHeader(InDataStart);
    1a58:	0e 94 d7 04 	call	0x9ae	; 0x9ae <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    1a5c:	c1 2f       	mov	r28, r17
    1a5e:	d0 2f       	mov	r29, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1a60:	8a 81       	ldd	r24, Y+2	; 0x02
    1a62:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1a64:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1a66:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1a68:	92 2f       	mov	r25, r18
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1a6a:	80 50       	subi	r24, 0x00	; 0
    1a6c:	98 40       	sbci	r25, 0x08	; 8
    1a6e:	09 f0       	breq	.+2      	; 0x1a72 <ARP_ProcessARPPacket+0x2e>
    1a70:	5e c0       	rjmp	.+188    	; 0x1b2e <ARP_ProcessARPPacket+0xea>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1a72:	8e 81       	ldd	r24, Y+6	; 0x06
    1a74:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    1a76:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1a78:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1a7a:	92 2f       	mov	r25, r18
    1a7c:	01 97       	sbiw	r24, 0x01	; 1
    1a7e:	09 f0       	breq	.+2      	; 0x1a82 <ARP_ProcessARPPacket+0x3e>
    1a80:	56 c0       	rjmp	.+172    	; 0x1b2e <ARP_ProcessARPPacket+0xea>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1a82:	ce 01       	movw	r24, r28
    1a84:	48 96       	adiw	r24, 0x18	; 24
    1a86:	6e e0       	ldi	r22, 0x0E	; 14
    1a88:	71 e0       	ldi	r23, 0x01	; 1
    1a8a:	44 e0       	ldi	r20, 0x04	; 4
    1a8c:	50 e0       	ldi	r21, 0x00	; 0
    1a8e:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
    1a92:	00 97       	sbiw	r24, 0x00	; 0
    1a94:	59 f0       	breq	.+22     	; 0x1aac <ARP_ProcessARPPacket+0x68>
    1a96:	ce 01       	movw	r24, r28
    1a98:	42 96       	adiw	r24, 0x12	; 18
    1a9a:	68 e0       	ldi	r22, 0x08	; 8
    1a9c:	71 e0       	ldi	r23, 0x01	; 1
    1a9e:	46 e0       	ldi	r20, 0x06	; 6
    1aa0:	50 e0       	ldi	r21, 0x00	; 0
    1aa2:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
    1aa6:	00 97       	sbiw	r24, 0x00	; 0
    1aa8:	09 f0       	breq	.+2      	; 0x1aac <ARP_ProcessARPPacket+0x68>
    1aaa:	41 c0       	rjmp	.+130    	; 0x1b2e <ARP_ProcessARPPacket+0xea>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    1aac:	ef 2d       	mov	r30, r15
    1aae:	fe 2d       	mov	r31, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    1ab0:	88 81       	ld	r24, Y
    1ab2:	99 81       	ldd	r25, Y+1	; 0x01
    1ab4:	91 83       	std	Z+1, r25	; 0x01
    1ab6:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    1aba:	9b 81       	ldd	r25, Y+3	; 0x03
    1abc:	93 83       	std	Z+3, r25	; 0x03
    1abe:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    1ac0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ac2:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    1ac4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ac6:	85 83       	std	Z+5, r24	; 0x05
    1ac8:	80 e0       	ldi	r24, 0x00	; 0
    1aca:	92 e0       	ldi	r25, 0x02	; 2
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1acc:	97 83       	std	Z+7, r25	; 0x07
    1ace:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    1ad0:	9f 01       	movw	r18, r30
    1ad2:	2e 5e       	subi	r18, 0xEE	; 238
    1ad4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ad6:	ae 01       	movw	r20, r28
    1ad8:	48 5f       	subi	r20, 0xF8	; 248
    1ada:	5f 4f       	sbci	r21, 0xFF	; 255
    1adc:	86 e0       	ldi	r24, 0x06	; 6
    1ade:	da 01       	movw	r26, r20
    1ae0:	0d 90       	ld	r0, X+
    1ae2:	ad 01       	movw	r20, r26
    1ae4:	d9 01       	movw	r26, r18
    1ae6:	0d 92       	st	X+, r0
    1ae8:	9d 01       	movw	r18, r26
    1aea:	81 50       	subi	r24, 0x01	; 1
    1aec:	c1 f7       	brne	.-16     	; 0x1ade <ARP_ProcessARPPacket+0x9a>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    1aee:	8e 85       	ldd	r24, Y+14	; 0x0e
    1af0:	9f 85       	ldd	r25, Y+15	; 0x0f
    1af2:	a8 89       	ldd	r26, Y+16	; 0x10
    1af4:	b9 89       	ldd	r27, Y+17	; 0x11
    1af6:	80 8f       	std	Z+24, r24	; 0x18
    1af8:	91 8f       	std	Z+25, r25	; 0x19
    1afa:	a2 8f       	std	Z+26, r26	; 0x1a
    1afc:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    1afe:	ef 01       	movw	r28, r30
    1b00:	28 96       	adiw	r28, 0x08	; 8
    1b02:	a8 e0       	ldi	r26, 0x08	; 8
    1b04:	b1 e0       	ldi	r27, 0x01	; 1
    1b06:	86 e0       	ldi	r24, 0x06	; 6
    1b08:	0d 90       	ld	r0, X+
    1b0a:	09 92       	st	Y+, r0
    1b0c:	81 50       	subi	r24, 0x01	; 1
    1b0e:	e1 f7       	brne	.-8      	; 0x1b08 <ARP_ProcessARPPacket+0xc4>
			ARPHeaderOUT->SPA = ServerIPAddress;
    1b10:	80 91 0e 01 	lds	r24, 0x010E
    1b14:	90 91 0f 01 	lds	r25, 0x010F
    1b18:	a0 91 10 01 	lds	r26, 0x0110
    1b1c:	b0 91 11 01 	lds	r27, 0x0111
    1b20:	86 87       	std	Z+14, r24	; 0x0e
    1b22:	97 87       	std	Z+15, r25	; 0x0f
    1b24:	a0 8b       	std	Z+16, r26	; 0x10
    1b26:	b1 8b       	std	Z+17, r27	; 0x11
    1b28:	2c e1       	ldi	r18, 0x1C	; 28
    1b2a:	30 e0       	ldi	r19, 0x00	; 0
    1b2c:	02 c0       	rjmp	.+4      	; 0x1b32 <ARP_ProcessARPPacket+0xee>

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    1b2e:	20 e0       	ldi	r18, 0x00	; 0
    1b30:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    1b32:	c9 01       	movw	r24, r18
    1b34:	df 91       	pop	r29
    1b36:	cf 91       	pop	r28
    1b38:	1f 91       	pop	r17
    1b3a:	0f 91       	pop	r16
    1b3c:	ff 90       	pop	r15
    1b3e:	ef 90       	pop	r14
    1b40:	08 95       	ret

00001b42 <IP_ProcessIPPacket>:
 *           response was generated, NO_PROCESS if the packet processing was deferred until the
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(void* InDataStart,
                           void* OutDataStart)
{
    1b42:	df 92       	push	r13
    1b44:	ef 92       	push	r14
    1b46:	ff 92       	push	r15
    1b48:	0f 93       	push	r16
    1b4a:	1f 93       	push	r17
    1b4c:	cf 93       	push	r28
    1b4e:	df 93       	push	r29
    1b50:	7c 01       	movw	r14, r24
    1b52:	eb 01       	movw	r28, r22
	DecodeIPHeader(InDataStart);
    1b54:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1b58:	f7 01       	movw	r30, r14
    1b5a:	d0 80       	ld	r13, Z
    1b5c:	ff e0       	ldi	r31, 0x0F	; 15
    1b5e:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1b60:	87 01       	movw	r16, r14
    1b62:	00 5f       	subi	r16, 0xF0	; 240
    1b64:	1f 4f       	sbci	r17, 0xFF	; 255
    1b66:	c8 01       	movw	r24, r16
    1b68:	6e e0       	ldi	r22, 0x0E	; 14
    1b6a:	71 e0       	ldi	r23, 0x01	; 1
    1b6c:	44 e0       	ldi	r20, 0x04	; 4
    1b6e:	50 e0       	ldi	r21, 0x00	; 0
    1b70:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
    1b74:	00 97       	sbiw	r24, 0x00	; 0
    1b76:	49 f0       	breq	.+18     	; 0x1b8a <IP_ProcessIPPacket+0x48>
    1b78:	c8 01       	movw	r24, r16
    1b7a:	68 e1       	ldi	r22, 0x18	; 24
    1b7c:	71 e0       	ldi	r23, 0x01	; 1
    1b7e:	44 e0       	ldi	r20, 0x04	; 4
    1b80:	50 e0       	ldi	r21, 0x00	; 0
    1b82:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <memcmp>
    1b86:	00 97       	sbiw	r24, 0x00	; 0
    1b88:	71 f4       	brne	.+28     	; 0x1ba6 <IP_ProcessIPPacket+0x64>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1b8a:	2d 2d       	mov	r18, r13
    1b8c:	30 e0       	ldi	r19, 0x00	; 0
    1b8e:	22 0f       	add	r18, r18
    1b90:	33 1f       	adc	r19, r19
    1b92:	22 0f       	add	r18, r18
    1b94:	33 1f       	adc	r19, r19
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1b96:	f7 01       	movw	r30, r14
    1b98:	81 85       	ldd	r24, Z+9	; 0x09
    1b9a:	86 30       	cpi	r24, 0x06	; 6
    1b9c:	81 f0       	breq	.+32     	; 0x1bbe <IP_ProcessIPPacket+0x7c>
    1b9e:	81 31       	cpi	r24, 0x11	; 17
    1ba0:	b9 f0       	breq	.+46     	; 0x1bd0 <IP_ProcessIPPacket+0x8e>
    1ba2:	81 30       	cpi	r24, 0x01	; 1
    1ba4:	19 f0       	breq	.+6      	; 0x1bac <IP_ProcessIPPacket+0x6a>
    1ba6:	20 e0       	ldi	r18, 0x00	; 0
    1ba8:	30 e0       	ldi	r19, 0x00	; 0
    1baa:	49 c0       	rjmp	.+146    	; 0x1c3e <IP_ProcessIPPacket+0xfc>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(&((uint8_t*)InDataStart)[HeaderLengthBytes],
    1bac:	be 01       	movw	r22, r28
    1bae:	6c 5e       	subi	r22, 0xEC	; 236
    1bb0:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb2:	c7 01       	movw	r24, r14
    1bb4:	82 0f       	add	r24, r18
    1bb6:	93 1f       	adc	r25, r19
    1bb8:	0e 94 dd 04 	call	0x9ba	; 0x9ba <ICMP_ProcessICMPPacket>
    1bbc:	11 c0       	rjmp	.+34     	; 0x1be0 <IP_ProcessIPPacket+0x9e>
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1bbe:	2e 0d       	add	r18, r14
    1bc0:	3f 1d       	adc	r19, r15
    1bc2:	ae 01       	movw	r20, r28
    1bc4:	4c 5e       	subi	r20, 0xEC	; 236
    1bc6:	5f 4f       	sbci	r21, 0xFF	; 255
    1bc8:	c7 01       	movw	r24, r14
    1bca:	b9 01       	movw	r22, r18
    1bcc:	db d9       	rcall	.-3146   	; 0xf84 <TCP_ProcessTCPPacket>
    1bce:	08 c0       	rjmp	.+16     	; 0x1be0 <IP_ProcessIPPacket+0x9e>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    1bd0:	2e 0d       	add	r18, r14
    1bd2:	3f 1d       	adc	r19, r15
    1bd4:	ae 01       	movw	r20, r28
    1bd6:	4c 5e       	subi	r20, 0xEC	; 236
    1bd8:	5f 4f       	sbci	r21, 0xFF	; 255
    1bda:	c7 01       	movw	r24, r14
    1bdc:	b9 01       	movw	r22, r18
    1bde:	20 de       	rcall	.-960    	; 0x1820 <UDP_ProcessUDPPacket>
    1be0:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1be2:	18 16       	cp	r1, r24
    1be4:	19 06       	cpc	r1, r25
    1be6:	5c f5       	brge	.+86     	; 0x1c3e <IP_ProcessIPPacket+0xfc>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1be8:	8c 01       	movw	r16, r24
    1bea:	0c 5e       	subi	r16, 0xEC	; 236
    1bec:	1f 4f       	sbci	r17, 0xFF	; 255
    1bee:	1a 83       	std	Y+2, r17	; 0x02
    1bf0:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    1bf2:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    1bf4:	85 e4       	ldi	r24, 0x45	; 69
    1bf6:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1bf8:	1e 82       	std	Y+6, r1	; 0x06
    1bfa:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    1bfc:	1d 82       	std	Y+5, r1	; 0x05
    1bfe:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    1c00:	1b 86       	std	Y+11, r1	; 0x0b
    1c02:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    1c04:	f7 01       	movw	r30, r14
    1c06:	81 85       	ldd	r24, Z+9	; 0x09
    1c08:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1c0a:	80 e8       	ldi	r24, 0x80	; 128
    1c0c:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    1c0e:	80 89       	ldd	r24, Z+16	; 0x10
    1c10:	91 89       	ldd	r25, Z+17	; 0x11
    1c12:	a2 89       	ldd	r26, Z+18	; 0x12
    1c14:	b3 89       	ldd	r27, Z+19	; 0x13
    1c16:	8c 87       	std	Y+12, r24	; 0x0c
    1c18:	9d 87       	std	Y+13, r25	; 0x0d
    1c1a:	ae 87       	std	Y+14, r26	; 0x0e
    1c1c:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1c1e:	84 85       	ldd	r24, Z+12	; 0x0c
    1c20:	95 85       	ldd	r25, Z+13	; 0x0d
    1c22:	a6 85       	ldd	r26, Z+14	; 0x0e
    1c24:	b7 85       	ldd	r27, Z+15	; 0x0f
    1c26:	88 8b       	std	Y+16, r24	; 0x10
    1c28:	99 8b       	std	Y+17, r25	; 0x11
    1c2a:	aa 8b       	std	Y+18, r26	; 0x12
    1c2c:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1c2e:	ce 01       	movw	r24, r28
    1c30:	64 e1       	ldi	r22, 0x14	; 20
    1c32:	70 e0       	ldi	r23, 0x00	; 0
    1c34:	0e 94 36 04 	call	0x86c	; 0x86c <Ethernet_Checksum16>
    1c38:	9b 87       	std	Y+11, r25	; 0x0b
    1c3a:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1c3c:	98 01       	movw	r18, r16
	}

	return RetSize;
}
    1c3e:	c9 01       	movw	r24, r18
    1c40:	df 91       	pop	r29
    1c42:	cf 91       	pop	r28
    1c44:	1f 91       	pop	r17
    1c46:	0f 91       	pop	r16
    1c48:	ff 90       	pop	r15
    1c4a:	ef 90       	pop	r14
    1c4c:	df 90       	pop	r13
    1c4e:	08 95       	ret

00001c50 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1c50:	db 01       	movw	r26, r22
    1c52:	0d 90       	ld	r0, X+
    1c54:	00 20       	and	r0, r0
    1c56:	e9 f7       	brne	.-6      	; 0x1c52 <IsHTTPCommand+0x2>
    1c58:	11 97       	sbiw	r26, 0x01	; 1
    1c5a:	a6 1b       	sub	r26, r22
    1c5c:	b7 0b       	sbc	r27, r23
    1c5e:	ad 01       	movw	r20, r26
    1c60:	0e 94 46 17 	call	0x2e8c	; 0x2e8c <strncmp>
    1c64:	9c 01       	movw	r18, r24
    1c66:	80 e0       	ldi	r24, 0x00	; 0
    1c68:	23 2b       	or	r18, r19
    1c6a:	09 f4       	brne	.+2      	; 0x1c6e <IsHTTPCommand+0x1e>
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
}
    1c6e:	08 95       	ret

00001c70 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1c70:	af 92       	push	r10
    1c72:	bf 92       	push	r11
    1c74:	cf 92       	push	r12
    1c76:	df 92       	push	r13
    1c78:	ef 92       	push	r14
    1c7a:	ff 92       	push	r15
    1c7c:	0f 93       	push	r16
    1c7e:	1f 93       	push	r17
    1c80:	cf 93       	push	r28
    1c82:	df 93       	push	r29
    1c84:	5c 01       	movw	r10, r24
    1c86:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1c88:	8b 01       	movw	r16, r22
    1c8a:	0e 5f       	subi	r16, 0xFE	; 254
    1c8c:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1c8e:	33 e0       	ldi	r19, 0x03	; 3
    1c90:	c3 2e       	mov	r12, r19
    1c92:	32 e0       	ldi	r19, 0x02	; 2
    1c94:	d3 2e       	mov	r13, r19
    1c96:	c6 0e       	add	r12, r22
    1c98:	d7 1e       	adc	r13, r23
    1c9a:	f6 01       	movw	r30, r12
    1c9c:	80 81       	ld	r24, Z
    1c9e:	88 23       	and	r24, r24
    1ca0:	09 f4       	brne	.+2      	; 0x1ca4 <Webserver_ApplicationCallback+0x34>
    1ca2:	68 c0       	rjmp	.+208    	; 0x1d74 <Webserver_ApplicationCallback+0x104>
    1ca4:	22 e0       	ldi	r18, 0x02	; 2
    1ca6:	e2 2e       	mov	r14, r18
    1ca8:	f2 2e       	mov	r15, r18
    1caa:	e6 0e       	add	r14, r22
    1cac:	f7 1e       	adc	r15, r23
    1cae:	f7 01       	movw	r30, r14
    1cb0:	80 81       	ld	r24, Z
    1cb2:	88 23       	and	r24, r24
    1cb4:	09 f0       	breq	.+2      	; 0x1cb8 <Webserver_ApplicationCallback+0x48>
    1cb6:	a9 c0       	rjmp	.+338    	; 0x1e0a <Webserver_ApplicationCallback+0x19a>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1cb8:	c8 01       	movw	r24, r16
    1cba:	66 e2       	ldi	r22, 0x26	; 38
    1cbc:	71 e0       	ldi	r23, 0x01	; 1
    1cbe:	c8 df       	rcall	.-112    	; 0x1c50 <IsHTTPCommand>
    1cc0:	88 23       	and	r24, r24
    1cc2:	09 f1       	breq	.+66     	; 0x1d06 <Webserver_ApplicationCallback+0x96>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1cc4:	c8 01       	movw	r24, r16
    1cc6:	6a e2       	ldi	r22, 0x2A	; 42
    1cc8:	71 e0       	ldi	r23, 0x01	; 1
    1cca:	c2 df       	rcall	.-124    	; 0x1c50 <IsHTTPCommand>
    1ccc:	88 23       	and	r24, r24
    1cce:	59 f1       	breq	.+86     	; 0x1d26 <Webserver_ApplicationCallback+0xb6>
			{
				PageBlock = 0;
    1cd0:	10 92 46 01 	sts	0x0146, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1cd4:	c8 01       	movw	r24, r16
    1cd6:	60 e3       	ldi	r22, 0x30	; 48
    1cd8:	71 e0       	ldi	r23, 0x01	; 1
    1cda:	0e 94 00 17 	call	0x2e00	; 0x2e00 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1cde:	81 e0       	ldi	r24, 0x01	; 1
    1ce0:	f7 01       	movw	r30, r14
    1ce2:	80 83       	st	Z, r24
    1ce4:	f8 01       	movw	r30, r16
    1ce6:	01 90       	ld	r0, Z+
    1ce8:	00 20       	and	r0, r0
    1cea:	e9 f7       	brne	.-6      	; 0x1ce6 <Webserver_ApplicationCallback+0x76>
    1cec:	31 97       	sbiw	r30, 0x01	; 1
    1cee:	e0 1b       	sub	r30, r16
    1cf0:	f1 0b       	sbc	r31, r17
    1cf2:	f9 83       	std	Y+1, r31	; 0x01
    1cf4:	e8 83       	st	Y, r30
    1cf6:	f6 01       	movw	r30, r12
    1cf8:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1cfa:	f7 01       	movw	r30, r14
    1cfc:	80 83       	st	Z, r24
    1cfe:	cc 5f       	subi	r28, 0xFC	; 252
    1d00:	dd 4f       	sbci	r29, 0xFD	; 253
    1d02:	88 83       	st	Y, r24
    1d04:	82 c0       	rjmp	.+260    	; 0x1e0a <Webserver_ApplicationCallback+0x19a>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1d06:	c8 01       	movw	r24, r16
    1d08:	61 e3       	ldi	r22, 0x31	; 49
    1d0a:	71 e0       	ldi	r23, 0x01	; 1
    1d0c:	a1 df       	rcall	.-190    	; 0x1c50 <IsHTTPCommand>
    1d0e:	88 23       	and	r24, r24
    1d10:	11 f1       	breq	.+68     	; 0x1d56 <Webserver_ApplicationCallback+0xe6>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1d12:	c8 01       	movw	r24, r16
    1d14:	66 e3       	ldi	r22, 0x36	; 54
    1d16:	71 e0       	ldi	r23, 0x01	; 1
    1d18:	9b df       	rcall	.-202    	; 0x1c50 <IsHTTPCommand>
    1d1a:	88 23       	and	r24, r24
    1d1c:	21 f0       	breq	.+8      	; 0x1d26 <Webserver_ApplicationCallback+0xb6>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1d1e:	c8 01       	movw	r24, r16
    1d20:	60 e3       	ldi	r22, 0x30	; 48
    1d22:	71 e0       	ldi	r23, 0x01	; 1
    1d24:	03 c0       	rjmp	.+6      	; 0x1d2c <Webserver_ApplicationCallback+0xbc>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1d26:	c8 01       	movw	r24, r16
    1d28:	64 e8       	ldi	r22, 0x84	; 132
    1d2a:	71 e0       	ldi	r23, 0x01	; 1
    1d2c:	0e 94 00 17 	call	0x2e00	; 0x2e00 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1d30:	81 e0       	ldi	r24, 0x01	; 1
    1d32:	f7 01       	movw	r30, r14
    1d34:	80 83       	st	Z, r24
    1d36:	f8 01       	movw	r30, r16
    1d38:	01 90       	ld	r0, Z+
    1d3a:	00 20       	and	r0, r0
    1d3c:	e9 f7       	brne	.-6      	; 0x1d38 <Webserver_ApplicationCallback+0xc8>
    1d3e:	31 97       	sbiw	r30, 0x01	; 1
    1d40:	e0 1b       	sub	r30, r16
    1d42:	f1 0b       	sbc	r31, r17
    1d44:	f9 83       	std	Y+1, r31	; 0x01
    1d46:	e8 83       	st	Y, r30
    1d48:	f6 01       	movw	r30, r12
    1d4a:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1d4c:	85 e1       	ldi	r24, 0x15	; 21
    1d4e:	92 e0       	ldi	r25, 0x02	; 2
    1d50:	a8 0e       	add	r10, r24
    1d52:	b9 1e       	adc	r11, r25
    1d54:	57 c0       	rjmp	.+174    	; 0x1e04 <Webserver_ApplicationCallback+0x194>
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1d56:	c8 01       	movw	r24, r16
    1d58:	6e e3       	ldi	r22, 0x3E	; 62
    1d5a:	71 e0       	ldi	r23, 0x01	; 1
    1d5c:	79 df       	rcall	.-270    	; 0x1c50 <IsHTTPCommand>
    1d5e:	88 23       	and	r24, r24
    1d60:	21 f0       	breq	.+8      	; 0x1d6a <Webserver_ApplicationCallback+0xfa>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1d62:	81 e0       	ldi	r24, 0x01	; 1
    1d64:	f7 01       	movw	r30, r14
    1d66:	80 83       	st	Z, r24
    1d68:	ef cf       	rjmp	.-34     	; 0x1d48 <Webserver_ApplicationCallback+0xd8>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1d6a:	f6 01       	movw	r30, r12
    1d6c:	10 82       	st	Z, r1
    1d6e:	19 82       	std	Y+1, r1	; 0x01
    1d70:	18 82       	st	Y, r1
    1d72:	4b c0       	rjmp	.+150    	; 0x1e0a <Webserver_ApplicationCallback+0x19a>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1d74:	cc 5f       	subi	r28, 0xFC	; 252
    1d76:	dd 4f       	sbci	r29, 0xFD	; 253
    1d78:	88 81       	ld	r24, Y
    1d7a:	c4 50       	subi	r28, 0x04	; 4
    1d7c:	d2 40       	sbci	r29, 0x02	; 2
    1d7e:	88 23       	and	r24, r24
    1d80:	09 f4       	brne	.+2      	; 0x1d84 <Webserver_ApplicationCallback+0x114>
    1d82:	43 c0       	rjmp	.+134    	; 0x1e0a <Webserver_ApplicationCallback+0x19a>
    1d84:	ce 5f       	subi	r28, 0xFE	; 254
    1d86:	dd 4f       	sbci	r29, 0xFD	; 253
    1d88:	88 81       	ld	r24, Y
    1d8a:	c2 50       	subi	r28, 0x02	; 2
    1d8c:	d2 40       	sbci	r29, 0x02	; 2
    1d8e:	88 23       	and	r24, r24
    1d90:	e1 f1       	breq	.+120    	; 0x1e0a <Webserver_ApplicationCallback+0x19a>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1d92:	80 91 46 01 	lds	r24, 0x0146
    1d96:	c8 2e       	mov	r12, r24
    1d98:	dd 24       	eor	r13, r13
    1d9a:	d6 94       	lsr	r13
    1d9c:	dc 2c       	mov	r13, r12
    1d9e:	cc 24       	eor	r12, r12
    1da0:	d7 94       	ror	r13
    1da2:	c7 94       	ror	r12
    1da4:	86 ec       	ldi	r24, 0xC6	; 198
    1da6:	91 e0       	ldi	r25, 0x01	; 1
    1da8:	c8 0e       	add	r12, r24
    1daa:	d9 1e       	adc	r13, r25
    1dac:	c6 01       	movw	r24, r12
    1dae:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = MIN(RemLength, HTTP_REPLY_BLOCK_SIZE);
    1db2:	7c 01       	movw	r14, r24
    1db4:	91 e8       	ldi	r25, 0x81	; 129
    1db6:	e9 16       	cp	r14, r25
    1db8:	f1 04       	cpc	r15, r1
    1dba:	18 f0       	brcs	.+6      	; 0x1dc2 <Webserver_ApplicationCallback+0x152>
    1dbc:	80 e8       	ldi	r24, 0x80	; 128
    1dbe:	e8 2e       	mov	r14, r24
    1dc0:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1dc2:	c8 01       	movw	r24, r16
    1dc4:	b6 01       	movw	r22, r12
    1dc6:	a7 01       	movw	r20, r14
    1dc8:	0e 94 10 17 	call	0x2e20	; 0x2e20 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1dcc:	ce 5f       	subi	r28, 0xFE	; 254
    1dce:	dd 4f       	sbci	r29, 0xFD	; 253
    1dd0:	81 e0       	ldi	r24, 0x01	; 1
    1dd2:	88 83       	st	Y, r24
    1dd4:	c2 50       	subi	r28, 0x02	; 2
    1dd6:	d2 40       	sbci	r29, 0x02	; 2
    1dd8:	f9 82       	std	Y+1, r15	; 0x01
    1dda:	e8 82       	st	Y, r14
    1ddc:	cd 5f       	subi	r28, 0xFD	; 253
    1dde:	dd 4f       	sbci	r29, 0xFD	; 253
    1de0:	88 83       	st	Y, r24
    1de2:	c3 50       	subi	r28, 0x03	; 3
    1de4:	d2 40       	sbci	r29, 0x02	; 2

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1de6:	80 91 46 01 	lds	r24, 0x0146
    1dea:	8f 5f       	subi	r24, 0xFF	; 255
    1dec:	80 93 46 01 	sts	0x0146, r24
    1df0:	81 50       	subi	r24, 0x01	; 1
    1df2:	83 30       	cpi	r24, 0x03	; 3
    1df4:	51 f4       	brne	.+20     	; 0x1e0a <Webserver_ApplicationCallback+0x19a>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1df6:	cc 5f       	subi	r28, 0xFC	; 252
    1df8:	dd 4f       	sbci	r29, 0xFD	; 253
    1dfa:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1dfc:	e5 e1       	ldi	r30, 0x15	; 21
    1dfe:	f2 e0       	ldi	r31, 0x02	; 2
    1e00:	ae 0e       	add	r10, r30
    1e02:	bf 1e       	adc	r11, r31
    1e04:	87 e0       	ldi	r24, 0x07	; 7
    1e06:	f5 01       	movw	r30, r10
    1e08:	80 83       	st	Z, r24
		}
	}
}
    1e0a:	df 91       	pop	r29
    1e0c:	cf 91       	pop	r28
    1e0e:	1f 91       	pop	r17
    1e10:	0f 91       	pop	r16
    1e12:	ff 90       	pop	r15
    1e14:	ef 90       	pop	r14
    1e16:	df 90       	pop	r13
    1e18:	cf 90       	pop	r12
    1e1a:	bf 90       	pop	r11
    1e1c:	af 90       	pop	r10
    1e1e:	08 95       	ret

00001e20 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1e20:	80 e0       	ldi	r24, 0x00	; 0
    1e22:	90 e5       	ldi	r25, 0x50	; 80
    1e24:	61 e0       	ldi	r22, 0x01	; 1
    1e26:	48 e3       	ldi	r20, 0x38	; 56
    1e28:	5e e0       	ldi	r21, 0x0E	; 14
    1e2a:	0c 94 20 05 	jmp	0xa40	; 0xa40 <TCP_SetPortState>

00001e2e <ProcessRNDISControlMessage>:
void ProcessRNDISControlMessage(void)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	switch (MessageHeader->MessageType)
    1e2e:	e0 91 44 01 	lds	r30, 0x0144
    1e32:	f0 91 45 01 	lds	r31, 0x0145
    1e36:	80 81       	ld	r24, Z
    1e38:	91 81       	ldd	r25, Z+1	; 0x01
    1e3a:	a2 81       	ldd	r26, Z+2	; 0x02
    1e3c:	b3 81       	ldd	r27, Z+3	; 0x03
    1e3e:	84 30       	cpi	r24, 0x04	; 4
    1e40:	91 05       	cpc	r25, r1
    1e42:	a1 05       	cpc	r26, r1
    1e44:	b1 05       	cpc	r27, r1
    1e46:	09 f4       	brne	.+2      	; 0x1e4a <ProcessRNDISControlMessage+0x1c>
    1e48:	a1 c0       	rjmp	.+322    	; 0x1f8c <ProcessRNDISControlMessage+0x15e>
    1e4a:	85 30       	cpi	r24, 0x05	; 5
    1e4c:	91 05       	cpc	r25, r1
    1e4e:	a1 05       	cpc	r26, r1
    1e50:	b1 05       	cpc	r27, r1
    1e52:	58 f4       	brcc	.+22     	; 0x1e6a <ProcessRNDISControlMessage+0x3c>
    1e54:	82 30       	cpi	r24, 0x02	; 2
    1e56:	91 05       	cpc	r25, r1
    1e58:	a1 05       	cpc	r26, r1
    1e5a:	b1 05       	cpc	r27, r1
    1e5c:	c1 f0       	breq	.+48     	; 0x1e8e <ProcessRNDISControlMessage+0x60>
    1e5e:	03 97       	sbiw	r24, 0x03	; 3
    1e60:	a1 05       	cpc	r26, r1
    1e62:	b1 05       	cpc	r27, r1
    1e64:	09 f0       	breq	.+2      	; 0x1e68 <ProcessRNDISControlMessage+0x3a>
    1e66:	b5 c2       	rjmp	.+1386   	; 0x23d2 <__stack+0x2d3>
    1e68:	88 c0       	rjmp	.+272    	; 0x1f7a <ProcessRNDISControlMessage+0x14c>
    1e6a:	86 30       	cpi	r24, 0x06	; 6
    1e6c:	91 05       	cpc	r25, r1
    1e6e:	a1 05       	cpc	r26, r1
    1e70:	b1 05       	cpc	r27, r1
    1e72:	09 f4       	brne	.+2      	; 0x1e76 <ProcessRNDISControlMessage+0x48>
    1e74:	34 c2       	rjmp	.+1128   	; 0x22de <__stack+0x1df>
    1e76:	86 30       	cpi	r24, 0x06	; 6
    1e78:	91 05       	cpc	r25, r1
    1e7a:	a1 05       	cpc	r26, r1
    1e7c:	b1 05       	cpc	r27, r1
    1e7e:	08 f4       	brcc	.+2      	; 0x1e82 <ProcessRNDISControlMessage+0x54>
    1e80:	d5 c1       	rjmp	.+938    	; 0x222c <__stack+0x12d>
    1e82:	08 97       	sbiw	r24, 0x08	; 8
    1e84:	a1 05       	cpc	r26, r1
    1e86:	b1 05       	cpc	r27, r1
    1e88:	09 f0       	breq	.+2      	; 0x1e8c <ProcessRNDISControlMessage+0x5e>
    1e8a:	a3 c2       	rjmp	.+1350   	; 0x23d2 <__stack+0x2d3>
    1e8c:	4c c2       	rjmp	.+1176   	; 0x2326 <__stack+0x227>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			/* Initialize the adapter - return information about the supported RNDIS version and buffer sizes */

			ResponseReady = true;
    1e8e:	21 e0       	ldi	r18, 0x01	; 1
    1e90:	20 93 47 01 	sts	0x0147, r18

			RNDIS_Initialize_Message_t*  INITIALIZE_Message  = (RNDIS_Initialize_Message_t*)&RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response = (RNDIS_Initialize_Complete_t*)&RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
    1e94:	82 e0       	ldi	r24, 0x02	; 2
    1e96:	90 e0       	ldi	r25, 0x00	; 0
    1e98:	a0 e0       	ldi	r26, 0x00	; 0
    1e9a:	b0 e8       	ldi	r27, 0x80	; 128
    1e9c:	80 93 50 13 	sts	0x1350, r24
    1ea0:	90 93 51 13 	sts	0x1351, r25
    1ea4:	a0 93 52 13 	sts	0x1352, r26
    1ea8:	b0 93 53 13 	sts	0x1353, r27
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
    1eac:	84 e3       	ldi	r24, 0x34	; 52
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	a0 e0       	ldi	r26, 0x00	; 0
    1eb2:	b0 e0       	ldi	r27, 0x00	; 0
    1eb4:	80 93 54 13 	sts	0x1354, r24
    1eb8:	90 93 55 13 	sts	0x1355, r25
    1ebc:	a0 93 56 13 	sts	0x1356, r26
    1ec0:	b0 93 57 13 	sts	0x1357, r27
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
    1ec4:	10 92 5c 13 	sts	0x135C, r1
    1ec8:	10 92 5d 13 	sts	0x135D, r1
    1ecc:	10 92 5e 13 	sts	0x135E, r1
    1ed0:	10 92 5f 13 	sts	0x135F, r1

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	a0 e0       	ldi	r26, 0x00	; 0
    1eda:	b0 e0       	ldi	r27, 0x00	; 0
    1edc:	80 93 60 13 	sts	0x1360, r24
    1ee0:	90 93 61 13 	sts	0x1361, r25
    1ee4:	a0 93 62 13 	sts	0x1362, r26
    1ee8:	b0 93 63 13 	sts	0x1363, r27
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
    1eec:	10 92 64 13 	sts	0x1364, r1
    1ef0:	10 92 65 13 	sts	0x1365, r1
    1ef4:	10 92 66 13 	sts	0x1366, r1
    1ef8:	10 92 67 13 	sts	0x1367, r1
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
    1efc:	80 93 68 13 	sts	0x1368, r24
    1f00:	90 93 69 13 	sts	0x1369, r25
    1f04:	a0 93 6a 13 	sts	0x136A, r26
    1f08:	b0 93 6b 13 	sts	0x136B, r27
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
    1f0c:	10 92 6c 13 	sts	0x136C, r1
    1f10:	10 92 6d 13 	sts	0x136D, r1
    1f14:	10 92 6e 13 	sts	0x136E, r1
    1f18:	10 92 6f 13 	sts	0x136F, r1
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
    1f1c:	80 93 70 13 	sts	0x1370, r24
    1f20:	90 93 71 13 	sts	0x1371, r25
    1f24:	a0 93 72 13 	sts	0x1372, r26
    1f28:	b0 93 73 13 	sts	0x1373, r27
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    1f2c:	88 e0       	ldi	r24, 0x08	; 8
    1f2e:	96 e0       	ldi	r25, 0x06	; 6
    1f30:	a0 e0       	ldi	r26, 0x00	; 0
    1f32:	b0 e0       	ldi	r27, 0x00	; 0
    1f34:	80 93 74 13 	sts	0x1374, r24
    1f38:	90 93 75 13 	sts	0x1375, r25
    1f3c:	a0 93 76 13 	sts	0x1376, r26
    1f40:	b0 93 77 13 	sts	0x1377, r27
			INITIALIZE_Response->PacketAlignmentFactor = 0;
    1f44:	10 92 78 13 	sts	0x1378, r1
    1f48:	10 92 79 13 	sts	0x1379, r1
    1f4c:	10 92 7a 13 	sts	0x137A, r1
    1f50:	10 92 7b 13 	sts	0x137B, r1
			INITIALIZE_Response->AFListOffset          = 0;
    1f54:	10 92 7c 13 	sts	0x137C, r1
    1f58:	10 92 7d 13 	sts	0x137D, r1
    1f5c:	10 92 7e 13 	sts	0x137E, r1
    1f60:	10 92 7f 13 	sts	0x137F, r1
			INITIALIZE_Response->AFListSize            = 0;
    1f64:	10 92 80 13 	sts	0x1380, r1
    1f68:	10 92 81 13 	sts	0x1381, r1
    1f6c:	10 92 82 13 	sts	0x1382, r1
    1f70:	10 92 83 13 	sts	0x1383, r1

			CurrRNDISState = RNDIS_Initialized;
    1f74:	20 93 48 01 	sts	0x0148, r18
    1f78:	08 95       	ret

			break;
		case REMOTE_NDIS_HALT_MSG:
			/* Halt the adapter, reset the adapter state - note that no response should be returned when completed */

			ResponseReady = false;
    1f7a:	10 92 47 01 	sts	0x0147, r1
			MessageHeader->MessageLength = 0;
    1f7e:	14 82       	std	Z+4, r1	; 0x04
    1f80:	15 82       	std	Z+5, r1	; 0x05
    1f82:	16 82       	std	Z+6, r1	; 0x06
    1f84:	17 82       	std	Z+7, r1	; 0x07

			CurrRNDISState = RNDIS_Uninitialized;
    1f86:	10 92 48 01 	sts	0x0148, r1
    1f8a:	08 95       	ret

			break;
		case REMOTE_NDIS_QUERY_MSG:
			/* Request for information about a parameter about the adapter, specified as an OID token */

			ResponseReady = true;
    1f8c:	81 e0       	ldi	r24, 0x01	; 1
    1f8e:	80 93 47 01 	sts	0x0147, r24

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISMessageBuffer;
    1f92:	60 e5       	ldi	r22, 0x50	; 80
    1f94:	73 e1       	ldi	r23, 0x13	; 19
			uint32_t                Query_Oid      = QUERY_Message->Oid;
    1f96:	20 91 5c 13 	lds	r18, 0x135C
    1f9a:	30 91 5d 13 	lds	r19, 0x135D
    1f9e:	40 91 5e 13 	lds	r20, 0x135E
    1fa2:	50 91 5f 13 	lds	r21, 0x135F
			void*     QueryData                 = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                          QUERY_Message->InformationBufferOffset];
			void*     ResponseData              = &RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
			uint16_t  ResponseSize;

			QUERY_Response->MessageType         = REMOTE_NDIS_QUERY_CMPLT;
    1fa6:	84 e0       	ldi	r24, 0x04	; 4
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	a0 e0       	ldi	r26, 0x00	; 0
    1fac:	b0 e8       	ldi	r27, 0x80	; 128
    1fae:	80 93 50 13 	sts	0x1350, r24
    1fb2:	90 93 51 13 	sts	0x1351, r25
    1fb6:	a0 93 52 13 	sts	0x1352, r26
    1fba:	b0 93 53 13 	sts	0x1353, r27
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);
    1fbe:	88 e1       	ldi	r24, 0x18	; 24
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	a0 e0       	ldi	r26, 0x00	; 0
    1fc4:	b0 e0       	ldi	r27, 0x00	; 0
    1fc6:	80 93 54 13 	sts	0x1354, r24
    1fca:	90 93 55 13 	sts	0x1355, r25
    1fce:	a0 93 56 13 	sts	0x1356, r26
    1fd2:	b0 93 57 13 	sts	0x1357, r27
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1fd6:	2e 30       	cpi	r18, 0x0E	; 14
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	38 07       	cpc	r19, r24
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	48 07       	cpc	r20, r24
    1fe0:	80 e0       	ldi	r24, 0x00	; 0
    1fe2:	58 07       	cpc	r21, r24
    1fe4:	09 f4       	brne	.+2      	; 0x1fe8 <ProcessRNDISControlMessage+0x1ba>
    1fe6:	e4 c0       	rjmp	.+456    	; 0x21b0 <__stack+0xb1>
    1fe8:	2f 30       	cpi	r18, 0x0F	; 15
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	38 07       	cpc	r19, r24
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	48 07       	cpc	r20, r24
    1ff2:	80 e0       	ldi	r24, 0x00	; 0
    1ff4:	58 07       	cpc	r21, r24
    1ff6:	08 f0       	brcs	.+2      	; 0x1ffa <ProcessRNDISControlMessage+0x1cc>
    1ff8:	58 c0       	rjmp	.+176    	; 0x20aa <ProcessRNDISControlMessage+0x27c>
    1ffa:	26 30       	cpi	r18, 0x06	; 6
    1ffc:	81 e0       	ldi	r24, 0x01	; 1
    1ffe:	38 07       	cpc	r19, r24
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	48 07       	cpc	r20, r24
    2004:	80 e0       	ldi	r24, 0x00	; 0
    2006:	58 07       	cpc	r21, r24
    2008:	09 f4       	brne	.+2      	; 0x200c <ProcessRNDISControlMessage+0x1de>
    200a:	af c0       	rjmp	.+350    	; 0x216a <__stack+0x6b>
    200c:	27 30       	cpi	r18, 0x07	; 7
    200e:	81 e0       	ldi	r24, 0x01	; 1
    2010:	38 07       	cpc	r19, r24
    2012:	81 e0       	ldi	r24, 0x01	; 1
    2014:	48 07       	cpc	r20, r24
    2016:	80 e0       	ldi	r24, 0x00	; 0
    2018:	58 07       	cpc	r21, r24
    201a:	f8 f4       	brcc	.+62     	; 0x205a <ProcessRNDISControlMessage+0x22c>
    201c:	22 30       	cpi	r18, 0x02	; 2
    201e:	81 e0       	ldi	r24, 0x01	; 1
    2020:	38 07       	cpc	r19, r24
    2022:	81 e0       	ldi	r24, 0x01	; 1
    2024:	48 07       	cpc	r20, r24
    2026:	80 e0       	ldi	r24, 0x00	; 0
    2028:	58 07       	cpc	r21, r24
    202a:	09 f4       	brne	.+2      	; 0x202e <ProcessRNDISControlMessage+0x200>
    202c:	ca c0       	rjmp	.+404    	; 0x21c2 <__stack+0xc3>
    202e:	23 30       	cpi	r18, 0x03	; 3
    2030:	81 e0       	ldi	r24, 0x01	; 1
    2032:	38 07       	cpc	r19, r24
    2034:	81 e0       	ldi	r24, 0x01	; 1
    2036:	48 07       	cpc	r20, r24
    2038:	80 e0       	ldi	r24, 0x00	; 0
    203a:	58 07       	cpc	r21, r24
    203c:	38 f4       	brcc	.+14     	; 0x204c <ProcessRNDISControlMessage+0x21e>
    203e:	21 50       	subi	r18, 0x01	; 1
    2040:	31 40       	sbci	r19, 0x01	; 1
    2042:	41 40       	sbci	r20, 0x01	; 1
    2044:	50 40       	sbci	r21, 0x00	; 0
    2046:	09 f0       	breq	.+2      	; 0x204a <ProcessRNDISControlMessage+0x21c>
    2048:	d4 c0       	rjmp	.+424    	; 0x21f2 <__stack+0xf3>
    204a:	80 c0       	rjmp	.+256    	; 0x214c <__stack+0x4d>
    204c:	25 50       	subi	r18, 0x05	; 5
    204e:	31 40       	sbci	r19, 0x01	; 1
    2050:	41 40       	sbci	r20, 0x01	; 1
    2052:	50 40       	sbci	r21, 0x00	; 0
    2054:	08 f0       	brcs	.+2      	; 0x2058 <ProcessRNDISControlMessage+0x22a>
    2056:	cd c0       	rjmp	.+410    	; 0x21f2 <__stack+0xf3>
    2058:	b4 c0       	rjmp	.+360    	; 0x21c2 <__stack+0xc3>
    205a:	2c 30       	cpi	r18, 0x0C	; 12
    205c:	81 e0       	ldi	r24, 0x01	; 1
    205e:	38 07       	cpc	r19, r24
    2060:	81 e0       	ldi	r24, 0x01	; 1
    2062:	48 07       	cpc	r20, r24
    2064:	80 e0       	ldi	r24, 0x00	; 0
    2066:	58 07       	cpc	r21, r24
    2068:	80 f4       	brcc	.+32     	; 0x208a <ProcessRNDISControlMessage+0x25c>
    206a:	2a 30       	cpi	r18, 0x0A	; 10
    206c:	61 e0       	ldi	r22, 0x01	; 1
    206e:	36 07       	cpc	r19, r22
    2070:	61 e0       	ldi	r22, 0x01	; 1
    2072:	46 07       	cpc	r20, r22
    2074:	60 e0       	ldi	r22, 0x00	; 0
    2076:	56 07       	cpc	r21, r22
    2078:	08 f0       	brcs	.+2      	; 0x207c <ProcessRNDISControlMessage+0x24e>
    207a:	77 c0       	rjmp	.+238    	; 0x216a <__stack+0x6b>
    207c:	27 50       	subi	r18, 0x07	; 7
    207e:	31 40       	sbci	r19, 0x01	; 1
    2080:	41 40       	sbci	r20, 0x01	; 1
    2082:	50 40       	sbci	r21, 0x00	; 0
    2084:	09 f0       	breq	.+2      	; 0x2088 <ProcessRNDISControlMessage+0x25a>
    2086:	b5 c0       	rjmp	.+362    	; 0x21f2 <__stack+0xf3>
    2088:	7f c0       	rjmp	.+254    	; 0x2188 <__stack+0x89>
    208a:	2c 30       	cpi	r18, 0x0C	; 12
    208c:	81 e0       	ldi	r24, 0x01	; 1
    208e:	38 07       	cpc	r19, r24
    2090:	81 e0       	ldi	r24, 0x01	; 1
    2092:	48 07       	cpc	r20, r24
    2094:	80 e0       	ldi	r24, 0x00	; 0
    2096:	58 07       	cpc	r21, r24
    2098:	09 f4       	brne	.+2      	; 0x209c <ProcessRNDISControlMessage+0x26e>
    209a:	62 c0       	rjmp	.+196    	; 0x2160 <__stack+0x61>
    209c:	2d 50       	subi	r18, 0x0D	; 13
    209e:	31 40       	sbci	r19, 0x01	; 1
    20a0:	41 40       	sbci	r20, 0x01	; 1
    20a2:	50 40       	sbci	r21, 0x00	; 0
    20a4:	09 f0       	breq	.+2      	; 0x20a8 <ProcessRNDISControlMessage+0x27a>
    20a6:	a5 c0       	rjmp	.+330    	; 0x21f2 <__stack+0xf3>
    20a8:	65 c0       	rjmp	.+202    	; 0x2174 <__stack+0x75>
    20aa:	26 30       	cpi	r18, 0x06	; 6
    20ac:	81 e0       	ldi	r24, 0x01	; 1
    20ae:	38 07       	cpc	r19, r24
    20b0:	82 e0       	ldi	r24, 0x02	; 2
    20b2:	48 07       	cpc	r20, r24
    20b4:	80 e0       	ldi	r24, 0x00	; 0
    20b6:	58 07       	cpc	r21, r24
    20b8:	10 f5       	brcc	.+68     	; 0x20fe <ProcessRNDISControlMessage+0x2d0>
    20ba:	21 30       	cpi	r18, 0x01	; 1
    20bc:	61 e0       	ldi	r22, 0x01	; 1
    20be:	36 07       	cpc	r19, r22
    20c0:	62 e0       	ldi	r22, 0x02	; 2
    20c2:	46 07       	cpc	r20, r22
    20c4:	60 e0       	ldi	r22, 0x00	; 0
    20c6:	56 07       	cpc	r21, r22
    20c8:	08 f0       	brcs	.+2      	; 0x20cc <ProcessRNDISControlMessage+0x29e>
    20ca:	7b c0       	rjmp	.+246    	; 0x21c2 <__stack+0xc3>
    20cc:	24 31       	cpi	r18, 0x14	; 20
    20ce:	81 e0       	ldi	r24, 0x01	; 1
    20d0:	38 07       	cpc	r19, r24
    20d2:	81 e0       	ldi	r24, 0x01	; 1
    20d4:	48 07       	cpc	r20, r24
    20d6:	80 e0       	ldi	r24, 0x00	; 0
    20d8:	58 07       	cpc	r21, r24
    20da:	09 f4       	brne	.+2      	; 0x20de <ProcessRNDISControlMessage+0x2b0>
    20dc:	72 c0       	rjmp	.+228    	; 0x21c2 <__stack+0xc3>
    20de:	22 30       	cpi	r18, 0x02	; 2
    20e0:	62 e0       	ldi	r22, 0x02	; 2
    20e2:	36 07       	cpc	r19, r22
    20e4:	61 e0       	ldi	r22, 0x01	; 1
    20e6:	46 07       	cpc	r20, r22
    20e8:	60 e0       	ldi	r22, 0x00	; 0
    20ea:	56 07       	cpc	r21, r22
    20ec:	09 f4       	brne	.+2      	; 0x20f0 <ProcessRNDISControlMessage+0x2c2>
    20ee:	69 c0       	rjmp	.+210    	; 0x21c2 <__stack+0xc3>
    20f0:	21 51       	subi	r18, 0x11	; 17
    20f2:	31 40       	sbci	r19, 0x01	; 1
    20f4:	41 40       	sbci	r20, 0x01	; 1
    20f6:	50 40       	sbci	r21, 0x00	; 0
    20f8:	09 f0       	breq	.+2      	; 0x20fc <ProcessRNDISControlMessage+0x2ce>
    20fa:	7b c0       	rjmp	.+246    	; 0x21f2 <__stack+0xf3>
    20fc:	6b c0       	rjmp	.+214    	; 0x21d4 <__stack+0xd5>
    20fe:	24 30       	cpi	r18, 0x04	; 4
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	38 07       	cpc	r19, r24
    2104:	81 e0       	ldi	r24, 0x01	; 1
    2106:	48 07       	cpc	r20, r24
    2108:	81 e0       	ldi	r24, 0x01	; 1
    210a:	58 07       	cpc	r21, r24
    210c:	09 f4       	brne	.+2      	; 0x2110 <__stack+0x11>
    210e:	4b c0       	rjmp	.+150    	; 0x21a6 <__stack+0xa7>
    2110:	25 30       	cpi	r18, 0x05	; 5
    2112:	81 e0       	ldi	r24, 0x01	; 1
    2114:	38 07       	cpc	r19, r24
    2116:	81 e0       	ldi	r24, 0x01	; 1
    2118:	48 07       	cpc	r20, r24
    211a:	81 e0       	ldi	r24, 0x01	; 1
    211c:	58 07       	cpc	r21, r24
    211e:	58 f4       	brcc	.+22     	; 0x2136 <__stack+0x37>
    2120:	21 50       	subi	r18, 0x01	; 1
    2122:	31 40       	sbci	r19, 0x01	; 1
    2124:	41 40       	sbci	r20, 0x01	; 1
    2126:	51 40       	sbci	r21, 0x01	; 1
    2128:	22 30       	cpi	r18, 0x02	; 2
    212a:	31 05       	cpc	r19, r1
    212c:	41 05       	cpc	r20, r1
    212e:	51 05       	cpc	r21, r1
    2130:	08 f0       	brcs	.+2      	; 0x2134 <__stack+0x35>
    2132:	5f c0       	rjmp	.+190    	; 0x21f2 <__stack+0xf3>
    2134:	2e c0       	rjmp	.+92     	; 0x2192 <__stack+0x93>
    2136:	21 50       	subi	r18, 0x01	; 1
    2138:	31 40       	sbci	r19, 0x01	; 1
    213a:	42 40       	sbci	r20, 0x02	; 2
    213c:	51 40       	sbci	r21, 0x01	; 1
    213e:	23 30       	cpi	r18, 0x03	; 3
    2140:	31 05       	cpc	r19, r1
    2142:	41 05       	cpc	r20, r1
    2144:	51 05       	cpc	r21, r1
    2146:	08 f0       	brcs	.+2      	; 0x214a <__stack+0x4b>
    2148:	54 c0       	rjmp	.+168    	; 0x21f2 <__stack+0xf3>
    214a:	3b c0       	rjmp	.+118    	; 0x21c2 <__stack+0xc3>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			/* Copy the list of supported NDIS OID tokens to the response buffer */
			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    214c:	cb 01       	movw	r24, r22
    214e:	48 96       	adiw	r24, 0x18	; 24
    2150:	66 eb       	ldi	r22, 0xB6	; 182
    2152:	73 e0       	ldi	r23, 0x03	; 3
    2154:	4c e6       	ldi	r20, 0x6C	; 108
    2156:	50 e0       	ldi	r21, 0x00	; 0
    2158:	4a d6       	rcall	.+3220   	; 0x2dee <memcpy_P>
    215a:	8c e6       	ldi	r24, 0x6C	; 108
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	07 c1       	rjmp	.+526    	; 0x236e <__stack+0x26f>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
    2160:	8f ef       	ldi	r24, 0xFF	; 255
    2162:	9f ef       	ldi	r25, 0xFF	; 255
    2164:	af ef       	ldi	r26, 0xFF	; 255
    2166:	b0 e0       	ldi	r27, 0x00	; 0
    2168:	39 c0       	rjmp	.+114    	; 0x21dc <__stack+0xdd>
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
    216a:	8c ed       	ldi	r24, 0xDC	; 220
    216c:	95 e0       	ldi	r25, 0x05	; 5
    216e:	a0 e0       	ldi	r26, 0x00	; 0
    2170:	b0 e0       	ldi	r27, 0x00	; 0
    2172:	34 c0       	rjmp	.+104    	; 0x21dc <__stack+0xdd>
			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);

			/* Copy vendor description string to the response buffer */
			memcpy_P(ResponseData, AdapterVendorDescription, sizeof(AdapterVendorDescription));
    2174:	cb 01       	movw	r24, r22
    2176:	48 96       	adiw	r24, 0x18	; 24
    2178:	62 e2       	ldi	r22, 0x22	; 34
    217a:	74 e0       	ldi	r23, 0x04	; 4
    217c:	43 e1       	ldi	r20, 0x13	; 19
    217e:	50 e0       	ldi	r21, 0x00	; 0
    2180:	36 d6       	rcall	.+3180   	; 0x2dee <memcpy_P>
    2182:	83 e1       	ldi	r24, 0x13	; 19
    2184:	90 e0       	ldi	r25, 0x00	; 0
    2186:	f3 c0       	rjmp	.+486    	; 0x236e <__stack+0x26f>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
    2188:	80 ea       	ldi	r24, 0xA0	; 160
    218a:	96 e8       	ldi	r25, 0x86	; 134
    218c:	a1 e0       	ldi	r26, 0x01	; 1
    218e:	b0 e0       	ldi	r27, 0x00	; 0
    2190:	25 c0       	rjmp	.+74     	; 0x21dc <__stack+0xdd>
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			/* Copy over the fixed adapter MAC to the response buffer */
			memcpy_P(ResponseData, &AdapterMACAddress, sizeof(MAC_Address_t));
    2192:	cb 01       	movw	r24, r22
    2194:	48 96       	adiw	r24, 0x18	; 24
    2196:	65 e3       	ldi	r22, 0x35	; 53
    2198:	74 e0       	ldi	r23, 0x04	; 4
    219a:	46 e0       	ldi	r20, 0x06	; 6
    219c:	50 e0       	ldi	r21, 0x00	; 0
    219e:	27 d6       	rcall	.+3150   	; 0x2dee <memcpy_P>
    21a0:	86 e0       	ldi	r24, 0x06	; 6
    21a2:	90 e0       	ldi	r25, 0x00	; 0
    21a4:	e4 c0       	rjmp	.+456    	; 0x236e <__stack+0x26f>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
    21a6:	81 e0       	ldi	r24, 0x01	; 1
    21a8:	90 e0       	ldi	r25, 0x00	; 0
    21aa:	a0 e0       	ldi	r26, 0x00	; 0
    21ac:	b0 e0       	ldi	r27, 0x00	; 0
    21ae:	16 c0       	rjmp	.+44     	; 0x21dc <__stack+0xdd>
			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate the current packet filter mask */
			*((uint32_t*)ResponseData) = CurrPacketFilter;
    21b0:	80 91 49 01 	lds	r24, 0x0149
    21b4:	90 91 4a 01 	lds	r25, 0x014A
    21b8:	a0 91 4b 01 	lds	r26, 0x014B
    21bc:	b0 91 4c 01 	lds	r27, 0x014C
    21c0:	0d c0       	rjmp	.+26     	; 0x21dc <__stack+0xdd>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
    21c2:	10 92 68 13 	sts	0x1368, r1
    21c6:	10 92 69 13 	sts	0x1369, r1
    21ca:	10 92 6a 13 	sts	0x136A, r1
    21ce:	10 92 6b 13 	sts	0x136B, r1
    21d2:	0c c0       	rjmp	.+24     	; 0x21ec <__stack+0xed>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
    21d4:	80 e6       	ldi	r24, 0x60	; 96
    21d6:	96 e0       	ldi	r25, 0x06	; 6
    21d8:	a0 e0       	ldi	r26, 0x00	; 0
    21da:	b0 e0       	ldi	r27, 0x00	; 0
    21dc:	80 93 68 13 	sts	0x1368, r24
    21e0:	90 93 69 13 	sts	0x1369, r25
    21e4:	a0 93 6a 13 	sts	0x136A, r26
    21e8:	b0 93 6b 13 	sts	0x136B, r27
    21ec:	84 e0       	ldi	r24, 0x04	; 4
    21ee:	90 e0       	ldi	r25, 0x00	; 0
    21f0:	be c0       	rjmp	.+380    	; 0x236e <__stack+0x26f>
				QUERY_Response->InformationBufferLength = ResponseSize;
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    21f2:	8b eb       	ldi	r24, 0xBB	; 187
    21f4:	90 e0       	ldi	r25, 0x00	; 0
    21f6:	a0 e0       	ldi	r26, 0x00	; 0
    21f8:	b0 ec       	ldi	r27, 0xC0	; 192
    21fa:	80 93 5c 13 	sts	0x135C, r24
    21fe:	90 93 5d 13 	sts	0x135D, r25
    2202:	a0 93 5e 13 	sts	0x135E, r26
    2206:	b0 93 5f 13 	sts	0x135F, r27

				QUERY_Response->InformationBufferLength = 0;
    220a:	10 92 60 13 	sts	0x1360, r1
    220e:	10 92 61 13 	sts	0x1361, r1
    2212:	10 92 62 13 	sts	0x1362, r1
    2216:	10 92 63 13 	sts	0x1363, r1
				QUERY_Response->InformationBufferOffset = 0;
    221a:	10 92 64 13 	sts	0x1364, r1
    221e:	10 92 65 13 	sts	0x1365, r1
    2222:	10 92 66 13 	sts	0x1366, r1
    2226:	10 92 67 13 	sts	0x1367, r1
    222a:	08 95       	ret

			break;
		case REMOTE_NDIS_SET_MSG:
			/* Request to set a parameter of the adapter, specified as an OID token */

			ResponseReady = true;
    222c:	81 e0       	ldi	r24, 0x01	; 1
    222e:	80 93 47 01 	sts	0x0147, r24

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
    2232:	20 91 5c 13 	lds	r18, 0x135C
    2236:	30 91 5d 13 	lds	r19, 0x135D
    223a:	40 91 5e 13 	lds	r20, 0x135E
    223e:	50 91 5f 13 	lds	r21, 0x135F

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
    2242:	85 e0       	ldi	r24, 0x05	; 5
    2244:	90 e0       	ldi	r25, 0x00	; 0
    2246:	a0 e0       	ldi	r26, 0x00	; 0
    2248:	b0 e8       	ldi	r27, 0x80	; 128
    224a:	80 93 50 13 	sts	0x1350, r24
    224e:	90 93 51 13 	sts	0x1351, r25
    2252:	a0 93 52 13 	sts	0x1352, r26
    2256:	b0 93 53 13 	sts	0x1353, r27
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
    225a:	80 e1       	ldi	r24, 0x10	; 16
    225c:	90 e0       	ldi	r25, 0x00	; 0
    225e:	a0 e0       	ldi	r26, 0x00	; 0
    2260:	b0 e0       	ldi	r27, 0x00	; 0
    2262:	80 93 54 13 	sts	0x1354, r24
    2266:	90 93 55 13 	sts	0x1355, r25
    226a:	a0 93 56 13 	sts	0x1356, r26
    226e:	b0 93 57 13 	sts	0x1357, r27
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                      SET_Message->InformationBufferOffset];
    2272:	80 91 64 13 	lds	r24, 0x1364
    2276:	90 91 65 13 	lds	r25, 0x1365
    227a:	a0 91 66 13 	lds	r26, 0x1366
    227e:	b0 91 67 13 	lds	r27, 0x1367
 */
static bool ProcessNDISSet(uint32_t OId, void* SetData, uint16_t SetSize)
{
	/* Handler for REMOTE_NDIS_SET_MSG messages */

	switch (OId)
    2282:	2e 30       	cpi	r18, 0x0E	; 14
    2284:	61 e0       	ldi	r22, 0x01	; 1
    2286:	36 07       	cpc	r19, r22
    2288:	61 e0       	ldi	r22, 0x01	; 1
    228a:	46 07       	cpc	r20, r22
    228c:	60 e0       	ldi	r22, 0x00	; 0
    228e:	56 07       	cpc	r21, r22
    2290:	31 f0       	breq	.+12     	; 0x229e <__stack+0x19f>
    2292:	23 50       	subi	r18, 0x03	; 3
    2294:	31 40       	sbci	r19, 0x01	; 1
    2296:	41 40       	sbci	r20, 0x01	; 1
    2298:	51 40       	sbci	r21, 0x01	; 1
    229a:	a1 f4       	brne	.+40     	; 0x22c4 <__stack+0x1c5>
    229c:	5f c0       	rjmp	.+190    	; 0x235c <__stack+0x25d>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			/* Save the packet filter mask in case the host queries it again later */
			CurrPacketFilter = *((uint32_t*)SetData);
    229e:	fc 01       	movw	r30, r24
    22a0:	e8 5a       	subi	r30, 0xA8	; 168
    22a2:	fc 4e       	sbci	r31, 0xEC	; 236
    22a4:	80 81       	ld	r24, Z
    22a6:	91 81       	ldd	r25, Z+1	; 0x01
    22a8:	a2 81       	ldd	r26, Z+2	; 0x02
    22aa:	b3 81       	ldd	r27, Z+3	; 0x03
    22ac:	80 93 49 01 	sts	0x0149, r24
    22b0:	90 93 4a 01 	sts	0x014A, r25
    22b4:	a0 93 4b 01 	sts	0x014B, r26
    22b8:	b0 93 4c 01 	sts	0x014C, r27

			/* Set the RNDIS state to initialized if the packet filter is non-zero */
			CurrRNDISState = ((CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Data_Initialized);
    22bc:	82 e0       	ldi	r24, 0x02	; 2
    22be:	80 93 48 01 	sts	0x0148, r24
    22c2:	4c c0       	rjmp	.+152    	; 0x235c <__stack+0x25d>
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
			else
			  SET_Response->Status        = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    22c4:	8b eb       	ldi	r24, 0xBB	; 187
    22c6:	90 e0       	ldi	r25, 0x00	; 0
    22c8:	a0 e0       	ldi	r26, 0x00	; 0
    22ca:	b0 ec       	ldi	r27, 0xC0	; 192
    22cc:	80 93 5c 13 	sts	0x135C, r24
    22d0:	90 93 5d 13 	sts	0x135D, r25
    22d4:	a0 93 5e 13 	sts	0x135E, r26
    22d8:	b0 93 5f 13 	sts	0x135F, r27
    22dc:	08 95       	ret

			break;
		case REMOTE_NDIS_RESET_MSG:
			/* Soft reset the adapter */

			ResponseReady = true;
    22de:	81 e0       	ldi	r24, 0x01	; 1
    22e0:	80 93 47 01 	sts	0x0147, r24

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISMessageBuffer;

			RESET_Response->MessageType         = REMOTE_NDIS_RESET_CMPLT;
    22e4:	86 e0       	ldi	r24, 0x06	; 6
    22e6:	90 e0       	ldi	r25, 0x00	; 0
    22e8:	a0 e0       	ldi	r26, 0x00	; 0
    22ea:	b0 e8       	ldi	r27, 0x80	; 128
    22ec:	80 93 50 13 	sts	0x1350, r24
    22f0:	90 93 51 13 	sts	0x1351, r25
    22f4:	a0 93 52 13 	sts	0x1352, r26
    22f8:	b0 93 53 13 	sts	0x1353, r27
			RESET_Response->MessageLength       = sizeof(RNDIS_Reset_Complete_t);
    22fc:	80 e1       	ldi	r24, 0x10	; 16
    22fe:	90 e0       	ldi	r25, 0x00	; 0
    2300:	a0 e0       	ldi	r26, 0x00	; 0
    2302:	b0 e0       	ldi	r27, 0x00	; 0
    2304:	80 93 54 13 	sts	0x1354, r24
    2308:	90 93 55 13 	sts	0x1355, r25
    230c:	a0 93 56 13 	sts	0x1356, r26
    2310:	b0 93 57 13 	sts	0x1357, r27
			RESET_Response->Status              = REMOTE_NDIS_STATUS_SUCCESS;
    2314:	10 92 58 13 	sts	0x1358, r1
    2318:	10 92 59 13 	sts	0x1359, r1
    231c:	10 92 5a 13 	sts	0x135A, r1
    2320:	10 92 5b 13 	sts	0x135B, r1
    2324:	1b c0       	rjmp	.+54     	; 0x235c <__stack+0x25d>

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			/* Keep alive message sent to the adapter every 5 seconds when idle to ensure it is still responding */

			ResponseReady = true;
    2326:	81 e0       	ldi	r24, 0x01	; 1
    2328:	80 93 47 01 	sts	0x0147, r24

			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  = (RNDIS_KeepAlive_Message_t*)&RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response = (RNDIS_KeepAlive_Complete_t*)&RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType     = REMOTE_NDIS_KEEPALIVE_CMPLT;
    232c:	88 e0       	ldi	r24, 0x08	; 8
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	a0 e0       	ldi	r26, 0x00	; 0
    2332:	b0 e8       	ldi	r27, 0x80	; 128
    2334:	80 93 50 13 	sts	0x1350, r24
    2338:	90 93 51 13 	sts	0x1351, r25
    233c:	a0 93 52 13 	sts	0x1352, r26
    2340:	b0 93 53 13 	sts	0x1353, r27
			KEEPALIVE_Response->MessageLength   = sizeof(RNDIS_KeepAlive_Complete_t);
    2344:	80 e1       	ldi	r24, 0x10	; 16
    2346:	90 e0       	ldi	r25, 0x00	; 0
    2348:	a0 e0       	ldi	r26, 0x00	; 0
    234a:	b0 e0       	ldi	r27, 0x00	; 0
    234c:	80 93 54 13 	sts	0x1354, r24
    2350:	90 93 55 13 	sts	0x1355, r25
    2354:	a0 93 56 13 	sts	0x1356, r26
    2358:	b0 93 57 13 	sts	0x1357, r27
			KEEPALIVE_Response->RequestId       = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status          = REMOTE_NDIS_STATUS_SUCCESS;
    235c:	10 92 5c 13 	sts	0x135C, r1
    2360:	10 92 5d 13 	sts	0x135D, r1
    2364:	10 92 5e 13 	sts	0x135E, r1
    2368:	10 92 5f 13 	sts	0x135F, r1
    236c:	08 95       	ret
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);

			if (ProcessNDISQuery(Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                     ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
    236e:	10 92 5c 13 	sts	0x135C, r1
    2372:	10 92 5d 13 	sts	0x135D, r1
    2376:	10 92 5e 13 	sts	0x135E, r1
    237a:	10 92 5f 13 	sts	0x135F, r1
				QUERY_Response->MessageLength          += ResponseSize;
    237e:	a0 e0       	ldi	r26, 0x00	; 0
    2380:	b0 e0       	ldi	r27, 0x00	; 0
    2382:	20 91 54 13 	lds	r18, 0x1354
    2386:	30 91 55 13 	lds	r19, 0x1355
    238a:	40 91 56 13 	lds	r20, 0x1356
    238e:	50 91 57 13 	lds	r21, 0x1357
    2392:	28 0f       	add	r18, r24
    2394:	39 1f       	adc	r19, r25
    2396:	4a 1f       	adc	r20, r26
    2398:	5b 1f       	adc	r21, r27
    239a:	20 93 54 13 	sts	0x1354, r18
    239e:	30 93 55 13 	sts	0x1355, r19
    23a2:	40 93 56 13 	sts	0x1356, r20
    23a6:	50 93 57 13 	sts	0x1357, r21

				QUERY_Response->InformationBufferLength = ResponseSize;
    23aa:	80 93 60 13 	sts	0x1360, r24
    23ae:	90 93 61 13 	sts	0x1361, r25
    23b2:	a0 93 62 13 	sts	0x1362, r26
    23b6:	b0 93 63 13 	sts	0x1363, r27
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    23ba:	80 e1       	ldi	r24, 0x10	; 16
    23bc:	90 e0       	ldi	r25, 0x00	; 0
    23be:	a0 e0       	ldi	r26, 0x00	; 0
    23c0:	b0 e0       	ldi	r27, 0x00	; 0
    23c2:	80 93 64 13 	sts	0x1364, r24
    23c6:	90 93 65 13 	sts	0x1365, r25
    23ca:	a0 93 66 13 	sts	0x1366, r26
    23ce:	b0 93 67 13 	sts	0x1367, r27
    23d2:	08 95       	ret

000023d4 <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
    23d4:	38 2f       	mov	r19, r24
    23d6:	28 2f       	mov	r18, r24
    23d8:	2c c0       	rjmp	.+88     	; 0x2432 <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    23da:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);
		
		if (EPNum == Number)
    23de:	23 17       	cp	r18, r19
    23e0:	21 f4       	brne	.+8      	; 0x23ea <Endpoint_ConfigureEndpoint_Prv+0x16>
    23e2:	76 2f       	mov	r23, r22
    23e4:	94 2f       	mov	r25, r20
    23e6:	50 e0       	ldi	r21, 0x00	; 0
    23e8:	06 c0       	rjmp	.+12     	; 0x23f6 <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    23ea:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    23ee:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
    23f2:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    23f6:	91 ff       	sbrs	r25, 1
    23f8:	1b c0       	rjmp	.+54     	; 0x2430 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    23fa:	80 91 eb 00 	lds	r24, 0x00EB
    23fe:	8e 7f       	andi	r24, 0xFE	; 254
    2400:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    2404:	80 91 ed 00 	lds	r24, 0x00ED
    2408:	8d 7f       	andi	r24, 0xFD	; 253
    240a:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    240e:	80 91 eb 00 	lds	r24, 0x00EB
    2412:	81 60       	ori	r24, 0x01	; 1
    2414:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    2418:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    241c:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
    2420:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    2424:	80 91 ee 00 	lds	r24, 0x00EE
			
		if (!(Endpoint_IsConfigured()))
    2428:	87 fd       	sbrc	r24, 7
    242a:	02 c0       	rjmp	.+4      	; 0x2430 <Endpoint_ConfigureEndpoint_Prv+0x5c>
    242c:	80 e0       	ldi	r24, 0x00	; 0
    242e:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else	
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    2430:	2f 5f       	subi	r18, 0xFF	; 255
    2432:	27 30       	cpi	r18, 0x07	; 7
    2434:	90 f2       	brcs	.-92     	; 0x23da <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2436:	30 93 e9 00 	sts	0x00E9, r19
    243a:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    243c:	08 95       	ret

0000243e <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    243e:	80 91 d9 13 	lds	r24, 0x13D9
    2442:	88 23       	and	r24, r24
    2444:	9c f4       	brge	.+38     	; 0x246c <Endpoint_ClearStatusStage+0x2e>
    2446:	04 c0       	rjmp	.+8      	; 0x2450 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2448:	80 91 d8 13 	lds	r24, 0x13D8
    244c:	88 23       	and	r24, r24
    244e:	b9 f0       	breq	.+46     	; 0x247e <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2450:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    2454:	82 ff       	sbrs	r24, 2
    2456:	f8 cf       	rjmp	.-16     	; 0x2448 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2458:	80 91 e8 00 	lds	r24, 0x00E8
    245c:	8b 77       	andi	r24, 0x7B	; 123
    245e:	80 93 e8 00 	sts	0x00E8, r24
    2462:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2464:	80 91 d8 13 	lds	r24, 0x13D8
    2468:	88 23       	and	r24, r24
    246a:	49 f0       	breq	.+18     	; 0x247e <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    246c:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    2470:	80 ff       	sbrs	r24, 0
    2472:	f8 cf       	rjmp	.-16     	; 0x2464 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2474:	80 91 e8 00 	lds	r24, 0x00E8
    2478:	8e 77       	andi	r24, 0x7E	; 126
    247a:	80 93 e8 00 	sts	0x00E8, r24
    247e:	08 95       	ret

00002480 <Endpoint_WaitUntilReady>:
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    2480:	40 91 e4 00 	lds	r20, 0x00E4
    2484:	50 91 e5 00 	lds	r21, 0x00E5
    2488:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
    248a:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    248e:	80 78       	andi	r24, 0x80	; 128
    2490:	80 38       	cpi	r24, 0x80	; 128
    2492:	29 f4       	brne	.+10     	; 0x249e <Endpoint_WaitUntilReady+0x1e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2494:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
    2498:	80 ff       	sbrs	r24, 0
    249a:	05 c0       	rjmp	.+10     	; 0x24a6 <Endpoint_WaitUntilReady+0x26>
    249c:	22 c0       	rjmp	.+68     	; 0x24e2 <Endpoint_WaitUntilReady+0x62>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    249e:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    24a2:	82 fd       	sbrc	r24, 2
    24a4:	1e c0       	rjmp	.+60     	; 0x24e2 <Endpoint_WaitUntilReady+0x62>
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    24a6:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    24aa:	88 23       	and	r24, r24
    24ac:	11 f4       	brne	.+4      	; 0x24b2 <Endpoint_WaitUntilReady+0x32>
    24ae:	82 e0       	ldi	r24, 0x02	; 2
    24b0:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    24b2:	85 30       	cpi	r24, 0x05	; 5
    24b4:	11 f4       	brne	.+4      	; 0x24ba <Endpoint_WaitUntilReady+0x3a>
    24b6:	83 e0       	ldi	r24, 0x03	; 3
    24b8:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    24ba:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    24be:	85 ff       	sbrs	r24, 5
    24c0:	02 c0       	rjmp	.+4      	; 0x24c6 <Endpoint_WaitUntilReady+0x46>
    24c2:	81 e0       	ldi	r24, 0x01	; 1
    24c4:	08 95       	ret
    24c6:	80 91 e4 00 	lds	r24, 0x00E4
    24ca:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    24ce:	84 17       	cp	r24, r20
    24d0:	95 07       	cpc	r25, r21
    24d2:	d9 f2       	breq	.-74     	; 0x248a <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    24d4:	22 23       	and	r18, r18
    24d6:	11 f4       	brne	.+4      	; 0x24dc <Endpoint_WaitUntilReady+0x5c>
    24d8:	84 e0       	ldi	r24, 0x04	; 4
    24da:	08 95       	ret
    24dc:	21 50       	subi	r18, 0x01	; 1
    24de:	ac 01       	movw	r20, r24
    24e0:	d4 cf       	rjmp	.-88     	; 0x248a <Endpoint_WaitUntilReady+0xa>
    24e2:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    24e4:	08 95       	ret

000024e6 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    24e6:	ef 92       	push	r14
    24e8:	ff 92       	push	r15
    24ea:	0f 93       	push	r16
    24ec:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    24ee:	4d d0       	rcall	.+154    	; 0x258a <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    24f0:	54 d0       	rcall	.+168    	; 0x259a <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    24f2:	08 ed       	ldi	r16, 0xD8	; 216
    24f4:	10 e0       	ldi	r17, 0x00	; 0
    24f6:	f8 01       	movw	r30, r16
    24f8:	80 81       	ld	r24, Z
    24fa:	8f 77       	andi	r24, 0x7F	; 127
    24fc:	80 83       	st	Z, r24
				USBCON |=  (1 << USBE);
    24fe:	80 81       	ld	r24, Z
    2500:	80 68       	ori	r24, 0x80	; 128
    2502:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    2504:	80 81       	ld	r24, Z
    2506:	8f 7d       	andi	r24, 0xDF	; 223
    2508:	80 83       	st	Z, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    250a:	e7 ed       	ldi	r30, 0xD7	; 215
    250c:	f0 e0       	ldi	r31, 0x00	; 0
    250e:	80 81       	ld	r24, Z
    2510:	80 68       	ori	r24, 0x80	; 128
    2512:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2514:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    2516:	10 92 d8 13 	sts	0x13D8, r1
	USB_Device_ConfigurationNumber  = 0;
    251a:	10 92 d4 13 	sts	0x13D4, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    251e:	10 92 d6 13 	sts	0x13D6, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    2522:	10 92 d5 13 	sts	0x13D5, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    2526:	80 ee       	ldi	r24, 0xE0	; 224
    2528:	e8 2e       	mov	r14, r24
    252a:	f1 2c       	mov	r15, r1
    252c:	f7 01       	movw	r30, r14
    252e:	80 81       	ld	r24, Z
    2530:	8b 7f       	andi	r24, 0xFB	; 251
    2532:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    2534:	f8 01       	movw	r30, r16
    2536:	80 81       	ld	r24, Z
    2538:	81 60       	ori	r24, 0x01	; 1
    253a:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    253c:	80 e0       	ldi	r24, 0x00	; 0
    253e:	60 e0       	ldi	r22, 0x00	; 0
    2540:	42 e0       	ldi	r20, 0x02	; 2
    2542:	48 df       	rcall	.-368    	; 0x23d4 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    2544:	e1 ee       	ldi	r30, 0xE1	; 225
    2546:	f0 e0       	ldi	r31, 0x00	; 0
    2548:	80 81       	ld	r24, Z
    254a:	8e 7f       	andi	r24, 0xFE	; 254
    254c:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    254e:	e2 ee       	ldi	r30, 0xE2	; 226
    2550:	f0 e0       	ldi	r31, 0x00	; 0
    2552:	80 81       	ld	r24, Z
    2554:	81 60       	ori	r24, 0x01	; 1
    2556:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    2558:	80 81       	ld	r24, Z
    255a:	88 60       	ori	r24, 0x08	; 8
    255c:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    255e:	f7 01       	movw	r30, r14
    2560:	80 81       	ld	r24, Z
    2562:	8e 7f       	andi	r24, 0xFE	; 254
    2564:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    2566:	f8 01       	movw	r30, r16
    2568:	80 81       	ld	r24, Z
    256a:	80 61       	ori	r24, 0x10	; 16
    256c:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    256e:	1f 91       	pop	r17
    2570:	0f 91       	pop	r16
    2572:	ff 90       	pop	r15
    2574:	ef 90       	pop	r14
    2576:	08 95       	ret

00002578 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    2578:	e7 ed       	ldi	r30, 0xD7	; 215
    257a:	f0 e0       	ldi	r31, 0x00	; 0
    257c:	80 81       	ld	r24, Z
    257e:	81 60       	ori	r24, 0x01	; 1
    2580:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	80 93 d7 13 	sts	0x13D7, r24

	USB_ResetInterface();
}
    2588:	ae cf       	rjmp	.-164    	; 0x24e6 <USB_ResetInterface>

0000258a <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    258a:	e8 ed       	ldi	r30, 0xD8	; 216
    258c:	f0 e0       	ldi	r31, 0x00	; 0
    258e:	80 81       	ld	r24, Z
    2590:	8c 7f       	andi	r24, 0xFC	; 252
    2592:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    2594:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    2598:	08 95       	ret

0000259a <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    259a:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    259e:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    25a2:	08 95       	ret

000025a4 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    25a4:	1f 92       	push	r1
    25a6:	0f 92       	push	r0
    25a8:	0f b6       	in	r0, 0x3f	; 63
    25aa:	0f 92       	push	r0
    25ac:	0b b6       	in	r0, 0x3b	; 59
    25ae:	0f 92       	push	r0
    25b0:	11 24       	eor	r1, r1
    25b2:	2f 93       	push	r18
    25b4:	3f 93       	push	r19
    25b6:	4f 93       	push	r20
    25b8:	5f 93       	push	r21
    25ba:	6f 93       	push	r22
    25bc:	7f 93       	push	r23
    25be:	8f 93       	push	r24
    25c0:	9f 93       	push	r25
    25c2:	af 93       	push	r26
    25c4:	bf 93       	push	r27
    25c6:	ef 93       	push	r30
    25c8:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    25ca:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    25ce:	82 ff       	sbrs	r24, 2
    25d0:	0a c0       	rjmp	.+20     	; 0x25e6 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    25d2:	80 91 e2 00 	lds	r24, 0x00E2
    25d6:	82 ff       	sbrs	r24, 2
    25d8:	06 c0       	rjmp	.+12     	; 0x25e6 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    25da:	80 91 e1 00 	lds	r24, 0x00E1
    25de:	8b 7f       	andi	r24, 0xFB	; 251
    25e0:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    25e4:	d2 d3       	rcall	.+1956   	; 0x2d8a <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    25e6:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    25ea:	80 ff       	sbrs	r24, 0
    25ec:	1f c0       	rjmp	.+62     	; 0x262c <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    25ee:	80 91 d8 00 	lds	r24, 0x00D8
    25f2:	80 ff       	sbrs	r24, 0
    25f4:	1b c0       	rjmp	.+54     	; 0x262c <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    25f6:	80 91 da 00 	lds	r24, 0x00DA
    25fa:	8e 7f       	andi	r24, 0xFE	; 254
    25fc:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    2600:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    2604:	80 ff       	sbrs	r24, 0
    2606:	0d c0       	rjmp	.+26     	; 0x2622 <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2608:	8c e0       	ldi	r24, 0x0C	; 12
    260a:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    260c:	8e e0       	ldi	r24, 0x0E	; 14
    260e:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    2610:	09 b4       	in	r0, 0x29	; 41
    2612:	00 fe       	sbrs	r0, 0
    2614:	fd cf       	rjmp	.-6      	; 0x2610 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    2616:	81 e0       	ldi	r24, 0x01	; 1
    2618:	80 93 d8 13 	sts	0x13D8, r24
			EVENT_USB_Device_Connect();
    261c:	0e 94 3d 02 	call	0x47a	; 0x47a <EVENT_USB_Device_Connect>
    2620:	05 c0       	rjmp	.+10     	; 0x262c <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2622:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    2624:	10 92 d8 13 	sts	0x13D8, r1
			EVENT_USB_Device_Disconnect();
    2628:	0e 94 42 02 	call	0x484	; 0x484 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    262c:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    2630:	80 ff       	sbrs	r24, 0
    2632:	18 c0       	rjmp	.+48     	; 0x2664 <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    2634:	80 91 e2 00 	lds	r24, 0x00E2
    2638:	80 ff       	sbrs	r24, 0
    263a:	14 c0       	rjmp	.+40     	; 0x2664 <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    263c:	80 91 e2 00 	lds	r24, 0x00E2
    2640:	8e 7f       	andi	r24, 0xFE	; 254
    2642:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    2646:	80 91 e2 00 	lds	r24, 0x00E2
    264a:	80 61       	ori	r24, 0x10	; 16
    264c:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    2650:	80 91 d8 00 	lds	r24, 0x00D8
    2654:	80 62       	ori	r24, 0x20	; 32
    2656:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    265a:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    265c:	85 e0       	ldi	r24, 0x05	; 5
    265e:	80 93 d8 13 	sts	0x13D8, r24
		EVENT_USB_Device_Suspend();
    2662:	93 d3       	rcall	.+1830   	; 0x2d8a <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    2664:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    2668:	84 ff       	sbrs	r24, 4
    266a:	2d c0       	rjmp	.+90     	; 0x26c6 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    266c:	80 91 e2 00 	lds	r24, 0x00E2
    2670:	84 ff       	sbrs	r24, 4
    2672:	29 c0       	rjmp	.+82     	; 0x26c6 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2674:	8c e0       	ldi	r24, 0x0C	; 12
    2676:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    2678:	8e e0       	ldi	r24, 0x0E	; 14
    267a:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    267c:	09 b4       	in	r0, 0x29	; 41
    267e:	00 fe       	sbrs	r0, 0
    2680:	fd cf       	rjmp	.-6      	; 0x267c <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    2682:	80 91 d8 00 	lds	r24, 0x00D8
    2686:	8f 7d       	andi	r24, 0xDF	; 223
    2688:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    268c:	80 91 e1 00 	lds	r24, 0x00E1
    2690:	8f 7e       	andi	r24, 0xEF	; 239
    2692:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    2696:	80 91 e2 00 	lds	r24, 0x00E2
    269a:	8f 7e       	andi	r24, 0xEF	; 239
    269c:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    26a0:	80 91 e2 00 	lds	r24, 0x00E2
    26a4:	81 60       	ori	r24, 0x01	; 1
    26a6:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    26aa:	80 91 d4 13 	lds	r24, 0x13D4
    26ae:	88 23       	and	r24, r24
    26b0:	31 f4       	brne	.+12     	; 0x26be <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    26b2:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    26b6:	87 fd       	sbrc	r24, 7
    26b8:	02 c0       	rjmp	.+4      	; 0x26be <__vector_10+0x11a>
    26ba:	81 e0       	ldi	r24, 0x01	; 1
    26bc:	01 c0       	rjmp	.+2      	; 0x26c0 <__vector_10+0x11c>
    26be:	84 e0       	ldi	r24, 0x04	; 4
    26c0:	80 93 d8 13 	sts	0x13D8, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    26c4:	62 d3       	rcall	.+1732   	; 0x2d8a <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    26c6:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    26ca:	83 ff       	sbrs	r24, 3
    26cc:	22 c0       	rjmp	.+68     	; 0x2712 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    26ce:	80 91 e2 00 	lds	r24, 0x00E2
    26d2:	83 ff       	sbrs	r24, 3
    26d4:	1e c0       	rjmp	.+60     	; 0x2712 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    26d6:	80 91 e1 00 	lds	r24, 0x00E1
    26da:	87 7f       	andi	r24, 0xF7	; 247
    26dc:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    26e0:	82 e0       	ldi	r24, 0x02	; 2
    26e2:	80 93 d8 13 	sts	0x13D8, r24
		USB_Device_ConfigurationNumber = 0;
    26e6:	10 92 d4 13 	sts	0x13D4, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    26ea:	80 91 e1 00 	lds	r24, 0x00E1
    26ee:	8e 7f       	andi	r24, 0xFE	; 254
    26f0:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    26f4:	80 91 e2 00 	lds	r24, 0x00E2
    26f8:	8e 7f       	andi	r24, 0xFE	; 254
    26fa:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    26fe:	80 91 e2 00 	lds	r24, 0x00E2
    2702:	80 61       	ori	r24, 0x10	; 16
    2704:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	60 e0       	ldi	r22, 0x00	; 0
    270c:	42 e0       	ldi	r20, 0x02	; 2
    270e:	62 de       	rcall	.-828    	; 0x23d4 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    2710:	3c d3       	rcall	.+1656   	; 0x2d8a <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    2712:	ff 91       	pop	r31
    2714:	ef 91       	pop	r30
    2716:	bf 91       	pop	r27
    2718:	af 91       	pop	r26
    271a:	9f 91       	pop	r25
    271c:	8f 91       	pop	r24
    271e:	7f 91       	pop	r23
    2720:	6f 91       	pop	r22
    2722:	5f 91       	pop	r21
    2724:	4f 91       	pop	r20
    2726:	3f 91       	pop	r19
    2728:	2f 91       	pop	r18
    272a:	0f 90       	pop	r0
    272c:	0b be       	out	0x3b, r0	; 59
    272e:	0f 90       	pop	r0
    2730:	0f be       	out	0x3f, r0	; 63
    2732:	0f 90       	pop	r0
    2734:	1f 90       	pop	r1
    2736:	18 95       	reti

00002738 <Endpoint_Write_Control_Stream_LE>:
    2738:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    273a:	40 91 df 13 	lds	r20, 0x13DF
    273e:	50 91 e0 13 	lds	r21, 0x13E0
    2742:	46 17       	cp	r20, r22
    2744:	57 07       	cpc	r21, r23
    2746:	18 f4       	brcc	.+6      	; 0x274e <Endpoint_Write_Control_Stream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2748:	f9 01       	movw	r30, r18
    274a:	90 e0       	ldi	r25, 0x00	; 0
    274c:	3d c0       	rjmp	.+122    	; 0x27c8 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    274e:	61 15       	cp	r22, r1
    2750:	71 05       	cpc	r23, r1
    2752:	11 f0       	breq	.+4      	; 0x2758 <Endpoint_Write_Control_Stream_LE+0x20>
    2754:	ab 01       	movw	r20, r22
    2756:	f8 cf       	rjmp	.-16     	; 0x2748 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2758:	80 91 e8 00 	lds	r24, 0x00E8
    275c:	8e 77       	andi	r24, 0x7E	; 126
    275e:	80 93 e8 00 	sts	0x00E8, r24
    2762:	40 e0       	ldi	r20, 0x00	; 0
    2764:	50 e0       	ldi	r21, 0x00	; 0
    2766:	f0 cf       	rjmp	.-32     	; 0x2748 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2768:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    276c:	88 23       	and	r24, r24
    276e:	f1 f1       	breq	.+124    	; 0x27ec <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2770:	85 30       	cpi	r24, 0x05	; 5
    2772:	f1 f1       	breq	.+124    	; 0x27f0 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2774:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2778:	83 ff       	sbrs	r24, 3
    277a:	02 c0       	rjmp	.+4      	; 0x2780 <Endpoint_Write_Control_Stream_LE+0x48>
    277c:	81 e0       	ldi	r24, 0x01	; 1
    277e:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2780:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2784:	82 fd       	sbrc	r24, 2
    2786:	2c c0       	rjmp	.+88     	; 0x27e0 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2788:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    278c:	80 ff       	sbrs	r24, 0
    278e:	1c c0       	rjmp	.+56     	; 0x27c8 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2790:	20 91 f2 00 	lds	r18, 0x00F2
    2794:	30 91 f3 00 	lds	r19, 0x00F3
    2798:	07 c0       	rjmp	.+14     	; 0x27a8 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    279a:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    279c:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    27a0:	41 50       	subi	r20, 0x01	; 1
    27a2:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    27a4:	2f 5f       	subi	r18, 0xFF	; 255
    27a6:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    27a8:	41 15       	cp	r20, r1
    27aa:	51 05       	cpc	r21, r1
    27ac:	19 f0       	breq	.+6      	; 0x27b4 <Endpoint_Write_Control_Stream_LE+0x7c>
    27ae:	28 30       	cpi	r18, 0x08	; 8
    27b0:	31 05       	cpc	r19, r1
    27b2:	98 f3       	brcs	.-26     	; 0x279a <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    27b4:	90 e0       	ldi	r25, 0x00	; 0
    27b6:	28 30       	cpi	r18, 0x08	; 8
    27b8:	31 05       	cpc	r19, r1
    27ba:	09 f4       	brne	.+2      	; 0x27be <Endpoint_Write_Control_Stream_LE+0x86>
    27bc:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    27be:	80 91 e8 00 	lds	r24, 0x00E8
    27c2:	8e 77       	andi	r24, 0x7E	; 126
    27c4:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    27c8:	41 15       	cp	r20, r1
    27ca:	51 05       	cpc	r21, r1
    27cc:	69 f6       	brne	.-102    	; 0x2768 <Endpoint_Write_Control_Stream_LE+0x30>
    27ce:	99 23       	and	r25, r25
    27d0:	59 f6       	brne	.-106    	; 0x2768 <Endpoint_Write_Control_Stream_LE+0x30>
    27d2:	06 c0       	rjmp	.+12     	; 0x27e0 <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    27d4:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    27d8:	88 23       	and	r24, r24
    27da:	41 f0       	breq	.+16     	; 0x27ec <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    27dc:	85 30       	cpi	r24, 0x05	; 5
    27de:	41 f0       	breq	.+16     	; 0x27f0 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    27e0:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    27e4:	82 ff       	sbrs	r24, 2
    27e6:	f6 cf       	rjmp	.-20     	; 0x27d4 <Endpoint_Write_Control_Stream_LE+0x9c>
    27e8:	80 e0       	ldi	r24, 0x00	; 0
    27ea:	08 95       	ret
    27ec:	82 e0       	ldi	r24, 0x02	; 2
    27ee:	08 95       	ret
    27f0:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    27f2:	08 95       	ret

000027f4 <Endpoint_Read_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    27f4:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    27f6:	61 15       	cp	r22, r1
    27f8:	71 05       	cpc	r23, r1
    27fa:	29 f4       	brne	.+10     	; 0x2806 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    27fc:	80 91 e8 00 	lds	r24, 0x00E8
    2800:	8b 77       	andi	r24, 0x7B	; 123
    2802:	80 93 e8 00 	sts	0x00E8, r24
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2806:	f9 01       	movw	r30, r18
    2808:	22 c0       	rjmp	.+68     	; 0x284e <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    280a:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    280e:	88 23       	and	r24, r24
    2810:	71 f1       	breq	.+92     	; 0x286e <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2812:	85 30       	cpi	r24, 0x05	; 5
    2814:	71 f1       	breq	.+92     	; 0x2872 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2816:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    281a:	83 ff       	sbrs	r24, 3
    281c:	02 c0       	rjmp	.+4      	; 0x2822 <Endpoint_Read_Control_Stream_LE+0x2e>
    281e:	81 e0       	ldi	r24, 0x01	; 1
    2820:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2822:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    2826:	82 ff       	sbrs	r24, 2
    2828:	f0 cf       	rjmp	.-32     	; 0x280a <Endpoint_Read_Control_Stream_LE+0x16>
    282a:	06 c0       	rjmp	.+12     	; 0x2838 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    282c:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2830:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    2832:	61 50       	subi	r22, 0x01	; 1
    2834:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    2836:	31 f0       	breq	.+12     	; 0x2844 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2838:	80 91 f2 00 	lds	r24, 0x00F2
    283c:	90 91 f3 00 	lds	r25, 0x00F3
    2840:	89 2b       	or	r24, r25
    2842:	a1 f7       	brne	.-24     	; 0x282c <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2844:	80 91 e8 00 	lds	r24, 0x00E8
    2848:	8b 77       	andi	r24, 0x7B	; 123
    284a:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    284e:	61 15       	cp	r22, r1
    2850:	71 05       	cpc	r23, r1
    2852:	d9 f6       	brne	.-74     	; 0x280a <Endpoint_Read_Control_Stream_LE+0x16>
    2854:	06 c0       	rjmp	.+12     	; 0x2862 <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2856:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    285a:	88 23       	and	r24, r24
    285c:	41 f0       	breq	.+16     	; 0x286e <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    285e:	85 30       	cpi	r24, 0x05	; 5
    2860:	41 f0       	breq	.+16     	; 0x2872 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2862:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    2866:	80 ff       	sbrs	r24, 0
    2868:	f6 cf       	rjmp	.-20     	; 0x2856 <Endpoint_Read_Control_Stream_LE+0x62>
    286a:	80 e0       	ldi	r24, 0x00	; 0
    286c:	08 95       	ret
    286e:	82 e0       	ldi	r24, 0x02	; 2
    2870:	08 95       	ret
    2872:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2874:	08 95       	ret

00002876 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    2876:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    2878:	40 91 df 13 	lds	r20, 0x13DF
    287c:	50 91 e0 13 	lds	r21, 0x13E0
    2880:	46 17       	cp	r20, r22
    2882:	57 07       	cpc	r21, r23
    2884:	18 f4       	brcc	.+6      	; 0x288c <Endpoint_Write_Control_PStream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2886:	f9 01       	movw	r30, r18
    2888:	90 e0       	ldi	r25, 0x00	; 0
    288a:	40 c0       	rjmp	.+128    	; 0x290c <Endpoint_Write_Control_PStream_LE+0x96>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    288c:	61 15       	cp	r22, r1
    288e:	71 05       	cpc	r23, r1
    2890:	11 f0       	breq	.+4      	; 0x2896 <Endpoint_Write_Control_PStream_LE+0x20>
    2892:	ab 01       	movw	r20, r22
    2894:	f8 cf       	rjmp	.-16     	; 0x2886 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2896:	80 91 e8 00 	lds	r24, 0x00E8
    289a:	8e 77       	andi	r24, 0x7E	; 126
    289c:	80 93 e8 00 	sts	0x00E8, r24
    28a0:	40 e0       	ldi	r20, 0x00	; 0
    28a2:	50 e0       	ldi	r21, 0x00	; 0
    28a4:	f0 cf       	rjmp	.-32     	; 0x2886 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    28a6:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    28aa:	88 23       	and	r24, r24
    28ac:	09 f4       	brne	.+2      	; 0x28b0 <Endpoint_Write_Control_PStream_LE+0x3a>
    28ae:	40 c0       	rjmp	.+128    	; 0x2930 <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    28b0:	85 30       	cpi	r24, 0x05	; 5
    28b2:	09 f4       	brne	.+2      	; 0x28b6 <Endpoint_Write_Control_PStream_LE+0x40>
    28b4:	3f c0       	rjmp	.+126    	; 0x2934 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    28b6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    28ba:	83 ff       	sbrs	r24, 3
    28bc:	02 c0       	rjmp	.+4      	; 0x28c2 <Endpoint_Write_Control_PStream_LE+0x4c>
    28be:	81 e0       	ldi	r24, 0x01	; 1
    28c0:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    28c2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    28c6:	82 fd       	sbrc	r24, 2
    28c8:	2d c0       	rjmp	.+90     	; 0x2924 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    28ca:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    28ce:	80 ff       	sbrs	r24, 0
    28d0:	1d c0       	rjmp	.+58     	; 0x290c <Endpoint_Write_Control_PStream_LE+0x96>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    28d2:	20 91 f2 00 	lds	r18, 0x00F2
    28d6:	30 91 f3 00 	lds	r19, 0x00F3
    28da:	08 c0       	rjmp	.+16     	; 0x28ec <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    28dc:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    28de:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    28e2:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    28e4:	41 50       	subi	r20, 0x01	; 1
    28e6:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    28e8:	2f 5f       	subi	r18, 0xFF	; 255
    28ea:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    28ec:	41 15       	cp	r20, r1
    28ee:	51 05       	cpc	r21, r1
    28f0:	19 f0       	breq	.+6      	; 0x28f8 <Endpoint_Write_Control_PStream_LE+0x82>
    28f2:	28 30       	cpi	r18, 0x08	; 8
    28f4:	31 05       	cpc	r19, r1
    28f6:	90 f3       	brcs	.-28     	; 0x28dc <Endpoint_Write_Control_PStream_LE+0x66>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    28f8:	90 e0       	ldi	r25, 0x00	; 0
    28fa:	28 30       	cpi	r18, 0x08	; 8
    28fc:	31 05       	cpc	r19, r1
    28fe:	09 f4       	brne	.+2      	; 0x2902 <Endpoint_Write_Control_PStream_LE+0x8c>
    2900:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2902:	80 91 e8 00 	lds	r24, 0x00E8
    2906:	8e 77       	andi	r24, 0x7E	; 126
    2908:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    290c:	41 15       	cp	r20, r1
    290e:	51 05       	cpc	r21, r1
    2910:	51 f6       	brne	.-108    	; 0x28a6 <Endpoint_Write_Control_PStream_LE+0x30>
    2912:	99 23       	and	r25, r25
    2914:	41 f6       	brne	.-112    	; 0x28a6 <Endpoint_Write_Control_PStream_LE+0x30>
    2916:	06 c0       	rjmp	.+12     	; 0x2924 <Endpoint_Write_Control_PStream_LE+0xae>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2918:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    291c:	88 23       	and	r24, r24
    291e:	41 f0       	breq	.+16     	; 0x2930 <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2920:	85 30       	cpi	r24, 0x05	; 5
    2922:	41 f0       	breq	.+16     	; 0x2934 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2924:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2928:	82 ff       	sbrs	r24, 2
    292a:	f6 cf       	rjmp	.-20     	; 0x2918 <Endpoint_Write_Control_PStream_LE+0xa2>
    292c:	80 e0       	ldi	r24, 0x00	; 0
    292e:	08 95       	ret
    2930:	82 e0       	ldi	r24, 0x02	; 2
    2932:	08 95       	ret
    2934:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2936:	08 95       	ret

00002938 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2938:	bf 92       	push	r11
    293a:	cf 92       	push	r12
    293c:	df 92       	push	r13
    293e:	ef 92       	push	r14
    2940:	ff 92       	push	r15
    2942:	0f 93       	push	r16
    2944:	1f 93       	push	r17
    2946:	cf 93       	push	r28
    2948:	df 93       	push	r29
    294a:	18 2f       	mov	r17, r24
    294c:	09 2f       	mov	r16, r25
    294e:	7b 01       	movw	r14, r22
    2950:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2952:	96 dd       	rcall	.-1236   	; 0x2480 <Endpoint_WaitUntilReady>
    2954:	b8 2e       	mov	r11, r24
    2956:	88 23       	and	r24, r24
    2958:	b1 f5       	brne	.+108    	; 0x29c6 <Endpoint_Read_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    295a:	81 2f       	mov	r24, r17
    295c:	90 2f       	mov	r25, r16
    295e:	9c 01       	movw	r18, r24
    2960:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2962:	c1 14       	cp	r12, r1
    2964:	d1 04       	cpc	r13, r1
    2966:	39 f0       	breq	.+14     	; 0x2976 <Endpoint_Read_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    2968:	f6 01       	movw	r30, r12
    296a:	80 81       	ld	r24, Z
    296c:	91 81       	ldd	r25, Z+1	; 0x01
    296e:	e8 1a       	sub	r14, r24
    2970:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2972:	c8 0f       	add	r28, r24
    2974:	d9 1f       	adc	r29, r25
    2976:	00 e0       	ldi	r16, 0x00	; 0
    2978:	10 e0       	ldi	r17, 0x00	; 0
    297a:	22 c0       	rjmp	.+68     	; 0x29c0 <Endpoint_Read_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    297c:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2980:	85 fd       	sbrc	r24, 5
    2982:	16 c0       	rjmp	.+44     	; 0x29b0 <Endpoint_Read_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2984:	80 91 e8 00 	lds	r24, 0x00E8
    2988:	8b 77       	andi	r24, 0x7B	; 123
    298a:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    298e:	c1 14       	cp	r12, r1
    2990:	d1 04       	cpc	r13, r1
    2992:	49 f0       	breq	.+18     	; 0x29a6 <Endpoint_Read_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
    2994:	f6 01       	movw	r30, r12
    2996:	80 81       	ld	r24, Z
    2998:	91 81       	ldd	r25, Z+1	; 0x01
    299a:	80 0f       	add	r24, r16
    299c:	91 1f       	adc	r25, r17
    299e:	91 83       	std	Z+1, r25	; 0x01
    29a0:	80 83       	st	Z, r24
    29a2:	85 e0       	ldi	r24, 0x05	; 5
    29a4:	11 c0       	rjmp	.+34     	; 0x29c8 <Endpoint_Read_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    29a6:	f2 d1       	rcall	.+996    	; 0x2d8c <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    29a8:	6b dd       	rcall	.-1322   	; 0x2480 <Endpoint_WaitUntilReady>
    29aa:	88 23       	and	r24, r24
    29ac:	49 f0       	breq	.+18     	; 0x29c0 <Endpoint_Read_Stream_LE+0x88>
    29ae:	0c c0       	rjmp	.+24     	; 0x29c8 <Endpoint_Read_Stream_LE+0x90>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    29b0:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    29b4:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    29b6:	08 94       	sec
    29b8:	e1 08       	sbc	r14, r1
    29ba:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    29bc:	0f 5f       	subi	r16, 0xFF	; 255
    29be:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    29c0:	e1 14       	cp	r14, r1
    29c2:	f1 04       	cpc	r15, r1
    29c4:	d9 f6       	brne	.-74     	; 0x297c <Endpoint_Read_Stream_LE+0x44>
    29c6:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    29c8:	df 91       	pop	r29
    29ca:	cf 91       	pop	r28
    29cc:	1f 91       	pop	r17
    29ce:	0f 91       	pop	r16
    29d0:	ff 90       	pop	r15
    29d2:	ef 90       	pop	r14
    29d4:	df 90       	pop	r13
    29d6:	cf 90       	pop	r12
    29d8:	bf 90       	pop	r11
    29da:	08 95       	ret

000029dc <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    29dc:	bf 92       	push	r11
    29de:	cf 92       	push	r12
    29e0:	df 92       	push	r13
    29e2:	ef 92       	push	r14
    29e4:	ff 92       	push	r15
    29e6:	0f 93       	push	r16
    29e8:	1f 93       	push	r17
    29ea:	cf 93       	push	r28
    29ec:	df 93       	push	r29
    29ee:	18 2f       	mov	r17, r24
    29f0:	09 2f       	mov	r16, r25
    29f2:	7b 01       	movw	r14, r22
    29f4:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    29f6:	44 dd       	rcall	.-1400   	; 0x2480 <Endpoint_WaitUntilReady>
    29f8:	b8 2e       	mov	r11, r24
    29fa:	88 23       	and	r24, r24
    29fc:	b1 f5       	brne	.+108    	; 0x2a6a <Endpoint_Write_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    29fe:	81 2f       	mov	r24, r17
    2a00:	90 2f       	mov	r25, r16
    2a02:	9c 01       	movw	r18, r24
    2a04:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2a06:	c1 14       	cp	r12, r1
    2a08:	d1 04       	cpc	r13, r1
    2a0a:	39 f0       	breq	.+14     	; 0x2a1a <Endpoint_Write_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    2a0c:	f6 01       	movw	r30, r12
    2a0e:	80 81       	ld	r24, Z
    2a10:	91 81       	ldd	r25, Z+1	; 0x01
    2a12:	e8 1a       	sub	r14, r24
    2a14:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2a16:	c8 0f       	add	r28, r24
    2a18:	d9 1f       	adc	r29, r25
    2a1a:	00 e0       	ldi	r16, 0x00	; 0
    2a1c:	10 e0       	ldi	r17, 0x00	; 0
    2a1e:	22 c0       	rjmp	.+68     	; 0x2a64 <Endpoint_Write_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2a20:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2a24:	85 fd       	sbrc	r24, 5
    2a26:	16 c0       	rjmp	.+44     	; 0x2a54 <Endpoint_Write_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2a28:	80 91 e8 00 	lds	r24, 0x00E8
    2a2c:	8e 77       	andi	r24, 0x7E	; 126
    2a2e:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    2a32:	c1 14       	cp	r12, r1
    2a34:	d1 04       	cpc	r13, r1
    2a36:	49 f0       	breq	.+18     	; 0x2a4a <Endpoint_Write_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
    2a38:	f6 01       	movw	r30, r12
    2a3a:	80 81       	ld	r24, Z
    2a3c:	91 81       	ldd	r25, Z+1	; 0x01
    2a3e:	80 0f       	add	r24, r16
    2a40:	91 1f       	adc	r25, r17
    2a42:	91 83       	std	Z+1, r25	; 0x01
    2a44:	80 83       	st	Z, r24
    2a46:	85 e0       	ldi	r24, 0x05	; 5
    2a48:	11 c0       	rjmp	.+34     	; 0x2a6c <Endpoint_Write_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2a4a:	a0 d1       	rcall	.+832    	; 0x2d8c <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2a4c:	19 dd       	rcall	.-1486   	; 0x2480 <Endpoint_WaitUntilReady>
    2a4e:	88 23       	and	r24, r24
    2a50:	49 f0       	breq	.+18     	; 0x2a64 <Endpoint_Write_Stream_LE+0x88>
    2a52:	0c c0       	rjmp	.+24     	; 0x2a6c <Endpoint_Write_Stream_LE+0x90>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2a54:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2a56:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    2a5a:	08 94       	sec
    2a5c:	e1 08       	sbc	r14, r1
    2a5e:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    2a60:	0f 5f       	subi	r16, 0xFF	; 255
    2a62:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    2a64:	e1 14       	cp	r14, r1
    2a66:	f1 04       	cpc	r15, r1
    2a68:	d9 f6       	brne	.-74     	; 0x2a20 <Endpoint_Write_Stream_LE+0x44>
    2a6a:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2a6c:	df 91       	pop	r29
    2a6e:	cf 91       	pop	r28
    2a70:	1f 91       	pop	r17
    2a72:	0f 91       	pop	r16
    2a74:	ff 90       	pop	r15
    2a76:	ef 90       	pop	r14
    2a78:	df 90       	pop	r13
    2a7a:	cf 90       	pop	r12
    2a7c:	bf 90       	pop	r11
    2a7e:	08 95       	ret

00002a80 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    2a80:	0f 93       	push	r16
    2a82:	1f 93       	push	r17
    2a84:	df 93       	push	r29
    2a86:	cf 93       	push	r28
    2a88:	cd b7       	in	r28, 0x3d	; 61
    2a8a:	de b7       	in	r29, 0x3e	; 62
    2a8c:	ac 97       	sbiw	r28, 0x2c	; 44
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	de bf       	out	0x3e, r29	; 62
    2a94:	0f be       	out	0x3f, r0	; 63
    2a96:	cd bf       	out	0x3d, r28	; 61
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2a98:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bmRequestType = Endpoint_Read_8();
    2a9c:	80 93 d9 13 	sts	0x13D9, r24
    2aa0:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
    2aa4:	80 93 da 13 	sts	0x13DA, r24
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    2aa8:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    2aac:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
    2ab0:	eb ed       	ldi	r30, 0xDB	; 219
    2ab2:	f3 e1       	ldi	r31, 0x13	; 19
    2ab4:	80 93 db 13 	sts	0x13DB, r24
    2ab8:	90 93 dc 13 	sts	0x13DC, r25
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    2abc:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    2ac0:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
    2ac4:	80 93 dd 13 	sts	0x13DD, r24
    2ac8:	93 83       	std	Z+3, r25	; 0x03
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    2aca:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    2ace:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
    2ad2:	80 93 df 13 	sts	0x13DF, r24
    2ad6:	95 83       	std	Z+5, r25	; 0x05

	EVENT_USB_Device_ControlRequest();
    2ad8:	0e 94 2b 03 	call	0x656	; 0x656 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2adc:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    2ae0:	83 ff       	sbrs	r24, 3
    2ae2:	3a c1       	rjmp	.+628    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    2ae4:	80 91 d9 13 	lds	r24, 0x13D9

		switch (USB_ControlRequest.bRequest)
    2ae8:	30 91 da 13 	lds	r19, 0x13DA
    2aec:	35 30       	cpi	r19, 0x05	; 5
    2aee:	09 f4       	brne	.+2      	; 0x2af2 <USB_Device_ProcessControlRequest+0x72>
    2af0:	87 c0       	rjmp	.+270    	; 0x2c00 <USB_Device_ProcessControlRequest+0x180>
    2af2:	36 30       	cpi	r19, 0x06	; 6
    2af4:	40 f4       	brcc	.+16     	; 0x2b06 <USB_Device_ProcessControlRequest+0x86>
    2af6:	31 30       	cpi	r19, 0x01	; 1
    2af8:	c9 f1       	breq	.+114    	; 0x2b6c <USB_Device_ProcessControlRequest+0xec>
    2afa:	31 30       	cpi	r19, 0x01	; 1
    2afc:	70 f0       	brcs	.+28     	; 0x2b1a <USB_Device_ProcessControlRequest+0x9a>
    2afe:	33 30       	cpi	r19, 0x03	; 3
    2b00:	09 f0       	breq	.+2      	; 0x2b04 <USB_Device_ProcessControlRequest+0x84>
    2b02:	2a c1       	rjmp	.+596    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
    2b04:	33 c0       	rjmp	.+102    	; 0x2b6c <USB_Device_ProcessControlRequest+0xec>
    2b06:	38 30       	cpi	r19, 0x08	; 8
    2b08:	09 f4       	brne	.+2      	; 0x2b0c <USB_Device_ProcessControlRequest+0x8c>
    2b0a:	f7 c0       	rjmp	.+494    	; 0x2cfa <USB_Device_ProcessControlRequest+0x27a>
    2b0c:	39 30       	cpi	r19, 0x09	; 9
    2b0e:	09 f4       	brne	.+2      	; 0x2b12 <USB_Device_ProcessControlRequest+0x92>
    2b10:	06 c1       	rjmp	.+524    	; 0x2d1e <USB_Device_ProcessControlRequest+0x29e>
    2b12:	36 30       	cpi	r19, 0x06	; 6
    2b14:	09 f0       	breq	.+2      	; 0x2b18 <USB_Device_ProcessControlRequest+0x98>
    2b16:	20 c1       	rjmp	.+576    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
    2b18:	97 c0       	rjmp	.+302    	; 0x2c48 <USB_Device_ProcessControlRequest+0x1c8>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2b1a:	80 38       	cpi	r24, 0x80	; 128
    2b1c:	21 f0       	breq	.+8      	; 0x2b26 <USB_Device_ProcessControlRequest+0xa6>
    2b1e:	82 38       	cpi	r24, 0x82	; 130
    2b20:	09 f0       	breq	.+2      	; 0x2b24 <USB_Device_ProcessControlRequest+0xa4>
    2b22:	1a c1       	rjmp	.+564    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
    2b24:	08 c0       	rjmp	.+16     	; 0x2b36 <USB_Device_ProcessControlRequest+0xb6>
    2b26:	90 91 d5 13 	lds	r25, 0x13D5
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    2b2a:	80 91 d6 13 	lds	r24, 0x13D6
    2b2e:	88 23       	and	r24, r24
    2b30:	99 f0       	breq	.+38     	; 0x2b58 <USB_Device_ProcessControlRequest+0xd8>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    2b32:	92 60       	ori	r25, 0x02	; 2
    2b34:	11 c0       	rjmp	.+34     	; 0x2b58 <USB_Device_ProcessControlRequest+0xd8>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2b36:	80 91 dd 13 	lds	r24, 0x13DD
    2b3a:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2b3c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2b40:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    2b44:	90 e0       	ldi	r25, 0x00	; 0
    2b46:	25 e0       	ldi	r18, 0x05	; 5
    2b48:	96 95       	lsr	r25
    2b4a:	87 95       	ror	r24
    2b4c:	2a 95       	dec	r18
    2b4e:	e1 f7       	brne	.-8      	; 0x2b48 <USB_Device_ProcessControlRequest+0xc8>
    2b50:	98 2f       	mov	r25, r24
    2b52:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2b54:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2b58:	80 91 e8 00 	lds	r24, 0x00E8
    2b5c:	87 7f       	andi	r24, 0xF7	; 247
    2b5e:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    2b62:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
    2b66:	10 92 f1 00 	sts	0x00F1, r1
    2b6a:	d2 c0       	rjmp	.+420    	; 0x2d10 <USB_Device_ProcessControlRequest+0x290>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2b6c:	88 23       	and	r24, r24
    2b6e:	19 f0       	breq	.+6      	; 0x2b76 <USB_Device_ProcessControlRequest+0xf6>
    2b70:	82 30       	cpi	r24, 0x02	; 2
    2b72:	09 f0       	breq	.+2      	; 0x2b76 <USB_Device_ProcessControlRequest+0xf6>
    2b74:	f1 c0       	rjmp	.+482    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    2b76:	90 e0       	ldi	r25, 0x00	; 0
    2b78:	8f 71       	andi	r24, 0x1F	; 31
    2b7a:	90 70       	andi	r25, 0x00	; 0
    2b7c:	00 97       	sbiw	r24, 0x00	; 0
    2b7e:	21 f0       	breq	.+8      	; 0x2b88 <USB_Device_ProcessControlRequest+0x108>
    2b80:	02 97       	sbiw	r24, 0x02	; 2
    2b82:	09 f0       	breq	.+2      	; 0x2b86 <USB_Device_ProcessControlRequest+0x106>
    2b84:	e9 c0       	rjmp	.+466    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
    2b86:	0c c0       	rjmp	.+24     	; 0x2ba0 <USB_Device_ProcessControlRequest+0x120>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    2b88:	80 91 db 13 	lds	r24, 0x13DB
    2b8c:	81 30       	cpi	r24, 0x01	; 1
    2b8e:	09 f0       	breq	.+2      	; 0x2b92 <USB_Device_ProcessControlRequest+0x112>
    2b90:	e3 c0       	rjmp	.+454    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    2b92:	10 92 d6 13 	sts	0x13D6, r1
    2b96:	33 30       	cpi	r19, 0x03	; 3
    2b98:	69 f5       	brne	.+90     	; 0x2bf4 <USB_Device_ProcessControlRequest+0x174>
    2b9a:	80 93 d6 13 	sts	0x13D6, r24
    2b9e:	2a c0       	rjmp	.+84     	; 0x2bf4 <USB_Device_ProcessControlRequest+0x174>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    2ba0:	80 91 db 13 	lds	r24, 0x13DB
    2ba4:	88 23       	and	r24, r24
    2ba6:	31 f5       	brne	.+76     	; 0x2bf4 <USB_Device_ProcessControlRequest+0x174>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2ba8:	20 91 dd 13 	lds	r18, 0x13DD
    2bac:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    2bae:	09 f4       	brne	.+2      	; 0x2bb2 <USB_Device_ProcessControlRequest+0x132>
    2bb0:	d3 c0       	rjmp	.+422    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2bb2:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    2bb6:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    2bba:	80 ff       	sbrs	r24, 0
    2bbc:	1b c0       	rjmp	.+54     	; 0x2bf4 <USB_Device_ProcessControlRequest+0x174>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    2bbe:	33 30       	cpi	r19, 0x03	; 3
    2bc0:	21 f4       	brne	.+8      	; 0x2bca <USB_Device_ProcessControlRequest+0x14a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2bc2:	80 91 eb 00 	lds	r24, 0x00EB
    2bc6:	80 62       	ori	r24, 0x20	; 32
    2bc8:	13 c0       	rjmp	.+38     	; 0x2bf0 <USB_Device_ProcessControlRequest+0x170>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    2bca:	80 91 eb 00 	lds	r24, 0x00EB
    2bce:	80 61       	ori	r24, 0x10	; 16
    2bd0:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    2bd4:	81 e0       	ldi	r24, 0x01	; 1
    2bd6:	90 e0       	ldi	r25, 0x00	; 0
    2bd8:	02 c0       	rjmp	.+4      	; 0x2bde <USB_Device_ProcessControlRequest+0x15e>
    2bda:	88 0f       	add	r24, r24
    2bdc:	99 1f       	adc	r25, r25
    2bde:	2a 95       	dec	r18
    2be0:	e2 f7       	brpl	.-8      	; 0x2bda <USB_Device_ProcessControlRequest+0x15a>
    2be2:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    2be6:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2bea:	80 91 eb 00 	lds	r24, 0x00EB
    2bee:	88 60       	ori	r24, 0x08	; 8
    2bf0:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2bf4:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2bf8:	80 91 e8 00 	lds	r24, 0x00E8
    2bfc:	87 7f       	andi	r24, 0xF7	; 247
    2bfe:	8b c0       	rjmp	.+278    	; 0x2d16 <USB_Device_ProcessControlRequest+0x296>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2c00:	88 23       	and	r24, r24
    2c02:	09 f0       	breq	.+2      	; 0x2c06 <USB_Device_ProcessControlRequest+0x186>
    2c04:	a9 c0       	rjmp	.+338    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    2c06:	10 91 db 13 	lds	r17, 0x13DB
    2c0a:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2c0c:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2c0e:	f8 94       	cli
    2c10:	80 91 e8 00 	lds	r24, 0x00E8
    2c14:	87 7f       	andi	r24, 0xF7	; 247
    2c16:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    2c1a:	11 dc       	rcall	.-2014   	; 0x243e <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2c1c:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    2c20:	80 ff       	sbrs	r24, 0
    2c22:	fc cf       	rjmp	.-8      	; 0x2c1c <USB_Device_ProcessControlRequest+0x19c>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2c24:	80 91 e3 00 	lds	r24, 0x00E3
    2c28:	80 78       	andi	r24, 0x80	; 128
    2c2a:	81 2b       	or	r24, r17

				UDADDR = Temp;
    2c2c:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR = Temp | (1 << ADDEN);
    2c30:	80 68       	ori	r24, 0x80	; 128
    2c32:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2c36:	11 23       	and	r17, r17
    2c38:	11 f4       	brne	.+4      	; 0x2c3e <USB_Device_ProcessControlRequest+0x1be>
    2c3a:	82 e0       	ldi	r24, 0x02	; 2
    2c3c:	01 c0       	rjmp	.+2      	; 0x2c40 <USB_Device_ProcessControlRequest+0x1c0>
    2c3e:	83 e0       	ldi	r24, 0x03	; 3
    2c40:	80 93 d8 13 	sts	0x13D8, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2c44:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    2c46:	88 c0       	rjmp	.+272    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2c48:	80 58       	subi	r24, 0x80	; 128
    2c4a:	82 30       	cpi	r24, 0x02	; 2
    2c4c:	08 f0       	brcs	.+2      	; 0x2c50 <USB_Device_ProcessControlRequest+0x1d0>
    2c4e:	84 c0       	rjmp	.+264    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    2c50:	80 91 db 13 	lds	r24, 0x13DB
    2c54:	90 91 dc 13 	lds	r25, 0x13DC
    2c58:	23 e0       	ldi	r18, 0x03	; 3
    2c5a:	8c 3d       	cpi	r24, 0xDC	; 220
    2c5c:	92 07       	cpc	r25, r18
    2c5e:	09 f0       	breq	.+2      	; 0x2c62 <USB_Device_ProcessControlRequest+0x1e2>
    2c60:	33 c0       	rjmp	.+102    	; 0x2cc8 <USB_Device_ProcessControlRequest+0x248>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    2c62:	83 e0       	ldi	r24, 0x03	; 3
    2c64:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    2c66:	8a e2       	ldi	r24, 0x2A	; 42
    2c68:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2c6a:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2c6c:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    2c6e:	de 01       	movw	r26, r28
    2c70:	15 96       	adiw	r26, 0x05	; 5
    2c72:	6e e0       	ldi	r22, 0x0E	; 14
    2c74:	40 e0       	ldi	r20, 0x00	; 0
    2c76:	50 e0       	ldi	r21, 0x00	; 0
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    2c78:	11 e2       	ldi	r17, 0x21	; 33
    2c7a:	e6 2f       	mov	r30, r22
    2c7c:	f0 e0       	ldi	r31, 0x00	; 0
    2c7e:	10 93 57 00 	sts	0x0057, r17
    2c82:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
    2c84:	40 ff       	sbrs	r20, 0
    2c86:	03 c0       	rjmp	.+6      	; 0x2c8e <USB_Device_ProcessControlRequest+0x20e>
					{
						SerialByte >>= 4;
    2c88:	82 95       	swap	r24
    2c8a:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    2c8c:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    2c8e:	8f 70       	andi	r24, 0x0F	; 15
    2c90:	28 2f       	mov	r18, r24
    2c92:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    2c94:	8a 30       	cpi	r24, 0x0A	; 10
    2c96:	18 f0       	brcs	.+6      	; 0x2c9e <USB_Device_ProcessControlRequest+0x21e>
    2c98:	c9 01       	movw	r24, r18
    2c9a:	c7 96       	adiw	r24, 0x37	; 55
    2c9c:	02 c0       	rjmp	.+4      	; 0x2ca2 <USB_Device_ProcessControlRequest+0x222>
    2c9e:	c9 01       	movw	r24, r18
    2ca0:	c0 96       	adiw	r24, 0x30	; 48
    2ca2:	8d 93       	st	X+, r24
    2ca4:	9d 93       	st	X+, r25
    2ca6:	4f 5f       	subi	r20, 0xFF	; 255
    2ca8:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    2caa:	44 31       	cpi	r20, 0x14	; 20
    2cac:	51 05       	cpc	r21, r1
    2cae:	29 f7       	brne	.-54     	; 0x2c7a <USB_Device_ProcessControlRequest+0x1fa>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2cb0:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2cb2:	80 91 e8 00 	lds	r24, 0x00E8
    2cb6:	87 7f       	andi	r24, 0xF7	; 247
    2cb8:	80 93 e8 00 	sts	0x00E8, r24
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    2cbc:	ce 01       	movw	r24, r28
    2cbe:	03 96       	adiw	r24, 0x03	; 3
    2cc0:	6a e2       	ldi	r22, 0x2A	; 42
    2cc2:	70 e0       	ldi	r23, 0x00	; 0
    2cc4:	39 dd       	rcall	.-1422   	; 0x2738 <Endpoint_Write_Control_Stream_LE>
    2cc6:	13 c0       	rjmp	.+38     	; 0x2cee <USB_Device_ProcessControlRequest+0x26e>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    2cc8:	60 91 dd 13 	lds	r22, 0x13DD
    2ccc:	ae 01       	movw	r20, r28
    2cce:	4f 5f       	subi	r20, 0xFF	; 255
    2cd0:	5f 4f       	sbci	r21, 0xFF	; 255
    2cd2:	0e 94 08 04 	call	0x810	; 0x810 <CALLBACK_USB_GetDescriptor>
    2cd6:	bc 01       	movw	r22, r24
    2cd8:	00 97       	sbiw	r24, 0x00	; 0
    2cda:	09 f4       	brne	.+2      	; 0x2cde <USB_Device_ProcessControlRequest+0x25e>
    2cdc:	3d c0       	rjmp	.+122    	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
    2cde:	80 91 e8 00 	lds	r24, 0x00E8
    2ce2:	87 7f       	andi	r24, 0xF7	; 247
    2ce4:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2ce8:	89 81       	ldd	r24, Y+1	; 0x01
    2cea:	9a 81       	ldd	r25, Y+2	; 0x02
    2cec:	c4 dd       	rcall	.-1144   	; 0x2876 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2cee:	80 91 e8 00 	lds	r24, 0x00E8
    2cf2:	8b 77       	andi	r24, 0x7B	; 123
    2cf4:	80 93 e8 00 	sts	0x00E8, r24
    2cf8:	2f c0       	rjmp	.+94     	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    2cfa:	80 38       	cpi	r24, 0x80	; 128
    2cfc:	69 f5       	brne	.+90     	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2cfe:	80 91 e8 00 	lds	r24, 0x00E8
    2d02:	87 7f       	andi	r24, 0xF7	; 247
    2d04:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2d08:	80 91 d4 13 	lds	r24, 0x13D4
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2d0c:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2d10:	80 91 e8 00 	lds	r24, 0x00E8
    2d14:	8e 77       	andi	r24, 0x7E	; 126
    2d16:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2d1a:	91 db       	rcall	.-2270   	; 0x243e <Endpoint_ClearStatusStage>
    2d1c:	1d c0       	rjmp	.+58     	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2d1e:	88 23       	and	r24, r24
    2d20:	d9 f4       	brne	.+54     	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2d22:	90 91 db 13 	lds	r25, 0x13DB
    2d26:	92 30       	cpi	r25, 0x02	; 2
    2d28:	b8 f4       	brcc	.+46     	; 0x2d58 <USB_Device_ProcessControlRequest+0x2d8>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2d2a:	80 91 e8 00 	lds	r24, 0x00E8
    2d2e:	87 7f       	andi	r24, 0xF7	; 247
    2d30:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2d34:	90 93 d4 13 	sts	0x13D4, r25

	Endpoint_ClearStatusStage();
    2d38:	82 db       	rcall	.-2300   	; 0x243e <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    2d3a:	80 91 d4 13 	lds	r24, 0x13D4
    2d3e:	88 23       	and	r24, r24
    2d40:	31 f4       	brne	.+12     	; 0x2d4e <USB_Device_ProcessControlRequest+0x2ce>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2d42:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2d46:	87 fd       	sbrc	r24, 7
    2d48:	02 c0       	rjmp	.+4      	; 0x2d4e <USB_Device_ProcessControlRequest+0x2ce>
    2d4a:	81 e0       	ldi	r24, 0x01	; 1
    2d4c:	01 c0       	rjmp	.+2      	; 0x2d50 <USB_Device_ProcessControlRequest+0x2d0>
    2d4e:	84 e0       	ldi	r24, 0x04	; 4
    2d50:	80 93 d8 13 	sts	0x13D8, r24

	EVENT_USB_Device_ConfigurationChanged();
    2d54:	0e 94 83 03 	call	0x706	; 0x706 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2d58:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2d5c:	83 ff       	sbrs	r24, 3
    2d5e:	0a c0       	rjmp	.+20     	; 0x2d74 <USB_Device_ProcessControlRequest+0x2f4>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2d60:	80 91 eb 00 	lds	r24, 0x00EB
    2d64:	80 62       	ori	r24, 0x20	; 32
    2d66:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2d6a:	80 91 e8 00 	lds	r24, 0x00E8
    2d6e:	87 7f       	andi	r24, 0xF7	; 247
    2d70:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    2d74:	ac 96       	adiw	r28, 0x2c	; 44
    2d76:	0f b6       	in	r0, 0x3f	; 63
    2d78:	f8 94       	cli
    2d7a:	de bf       	out	0x3e, r29	; 62
    2d7c:	0f be       	out	0x3f, r0	; 63
    2d7e:	cd bf       	out	0x3d, r28	; 61
    2d80:	cf 91       	pop	r28
    2d82:	df 91       	pop	r29
    2d84:	1f 91       	pop	r17
    2d86:	0f 91       	pop	r16
    2d88:	08 95       	ret

00002d8a <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    2d8a:	08 95       	ret

00002d8c <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    2d8c:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    2d8e:	80 91 d8 13 	lds	r24, 0x13D8
    2d92:	88 23       	and	r24, r24
    2d94:	61 f0       	breq	.+24     	; 0x2dae <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    2d96:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2d9a:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2d9e:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    2da2:	83 ff       	sbrs	r24, 3
    2da4:	01 c0       	rjmp	.+2      	; 0x2da8 <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    2da6:	6c de       	rcall	.-808    	; 0x2a80 <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    2da8:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2daa:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    2dae:	1f 91       	pop	r17
    2db0:	08 95       	ret

00002db2 <Serial_putchar>:

FILE USARTSerialStream;

int Serial_putchar(char DataByte,
                   FILE *Stream)
{
    2db2:	98 2f       	mov	r25, r24
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2db4:	80 91 c8 00 	lds	r24, 0x00C8
    2db8:	85 ff       	sbrs	r24, 5
    2dba:	fc cf       	rjmp	.-8      	; 0x2db4 <Serial_putchar+0x2>
				UDR1 = DataByte;
    2dbc:	90 93 ce 00 	sts	0x00CE, r25
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2dc0:	80 e0       	ldi	r24, 0x00	; 0
    2dc2:	90 e0       	ldi	r25, 0x00	; 0
    2dc4:	08 95       	ret

00002dc6 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2dc6:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2dca:	87 fd       	sbrc	r24, 7
    2dcc:	03 c0       	rjmp	.+6      	; 0x2dd4 <Serial_getchar+0xe>
    2dce:	2e ef       	ldi	r18, 0xFE	; 254
    2dd0:	3f ef       	ldi	r19, 0xFF	; 255
    2dd2:	0b c0       	rjmp	.+22     	; 0x2dea <Serial_getchar+0x24>
    2dd4:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2dd8:	87 fd       	sbrc	r24, 7
    2dda:	03 c0       	rjmp	.+6      	; 0x2de2 <Serial_getchar+0x1c>
    2ddc:	2f ef       	ldi	r18, 0xFF	; 255
    2dde:	3f ef       	ldi	r19, 0xFF	; 255
    2de0:	04 c0       	rjmp	.+8      	; 0x2dea <Serial_getchar+0x24>
				  return -1;
				
				return UDR1;
    2de2:	80 91 ce 00 	lds	r24, 0x00CE
    2de6:	28 2f       	mov	r18, r24
    2de8:	30 e0       	ldi	r19, 0x00	; 0
	  return _FDEV_EOF;

	return Serial_ReceiveByte();
}
    2dea:	c9 01       	movw	r24, r18
    2dec:	08 95       	ret

00002dee <memcpy_P>:
    2dee:	fb 01       	movw	r30, r22
    2df0:	dc 01       	movw	r26, r24
    2df2:	02 c0       	rjmp	.+4      	; 0x2df8 <memcpy_P+0xa>
    2df4:	05 90       	lpm	r0, Z+
    2df6:	0d 92       	st	X+, r0
    2df8:	41 50       	subi	r20, 0x01	; 1
    2dfa:	50 40       	sbci	r21, 0x00	; 0
    2dfc:	d8 f7       	brcc	.-10     	; 0x2df4 <memcpy_P+0x6>
    2dfe:	08 95       	ret

00002e00 <strcpy_P>:
    2e00:	fb 01       	movw	r30, r22
    2e02:	dc 01       	movw	r26, r24
    2e04:	05 90       	lpm	r0, Z+
    2e06:	0d 92       	st	X+, r0
    2e08:	00 20       	and	r0, r0
    2e0a:	e1 f7       	brne	.-8      	; 0x2e04 <strcpy_P+0x4>
    2e0c:	08 95       	ret

00002e0e <strlen_P>:
    2e0e:	fc 01       	movw	r30, r24
    2e10:	05 90       	lpm	r0, Z+
    2e12:	00 20       	and	r0, r0
    2e14:	e9 f7       	brne	.-6      	; 0x2e10 <strlen_P+0x2>
    2e16:	80 95       	com	r24
    2e18:	90 95       	com	r25
    2e1a:	8e 0f       	add	r24, r30
    2e1c:	9f 1f       	adc	r25, r31
    2e1e:	08 95       	ret

00002e20 <strncpy_P>:
    2e20:	fb 01       	movw	r30, r22
    2e22:	dc 01       	movw	r26, r24
    2e24:	41 50       	subi	r20, 0x01	; 1
    2e26:	50 40       	sbci	r21, 0x00	; 0
    2e28:	48 f0       	brcs	.+18     	; 0x2e3c <strncpy_P+0x1c>
    2e2a:	05 90       	lpm	r0, Z+
    2e2c:	0d 92       	st	X+, r0
    2e2e:	00 20       	and	r0, r0
    2e30:	c9 f7       	brne	.-14     	; 0x2e24 <strncpy_P+0x4>
    2e32:	01 c0       	rjmp	.+2      	; 0x2e36 <strncpy_P+0x16>
    2e34:	1d 92       	st	X+, r1
    2e36:	41 50       	subi	r20, 0x01	; 1
    2e38:	50 40       	sbci	r21, 0x00	; 0
    2e3a:	e0 f7       	brcc	.-8      	; 0x2e34 <strncpy_P+0x14>
    2e3c:	08 95       	ret

00002e3e <memcmp>:
    2e3e:	fb 01       	movw	r30, r22
    2e40:	dc 01       	movw	r26, r24
    2e42:	04 c0       	rjmp	.+8      	; 0x2e4c <memcmp+0xe>
    2e44:	8d 91       	ld	r24, X+
    2e46:	01 90       	ld	r0, Z+
    2e48:	80 19       	sub	r24, r0
    2e4a:	21 f4       	brne	.+8      	; 0x2e54 <memcmp+0x16>
    2e4c:	41 50       	subi	r20, 0x01	; 1
    2e4e:	50 40       	sbci	r21, 0x00	; 0
    2e50:	c8 f7       	brcc	.-14     	; 0x2e44 <memcmp+0x6>
    2e52:	88 1b       	sub	r24, r24
    2e54:	99 0b       	sbc	r25, r25
    2e56:	08 95       	ret

00002e58 <memcpy>:
    2e58:	fb 01       	movw	r30, r22
    2e5a:	dc 01       	movw	r26, r24
    2e5c:	02 c0       	rjmp	.+4      	; 0x2e62 <memcpy+0xa>
    2e5e:	01 90       	ld	r0, Z+
    2e60:	0d 92       	st	X+, r0
    2e62:	41 50       	subi	r20, 0x01	; 1
    2e64:	50 40       	sbci	r21, 0x00	; 0
    2e66:	d8 f7       	brcc	.-10     	; 0x2e5e <memcpy+0x6>
    2e68:	08 95       	ret

00002e6a <memmove>:
    2e6a:	68 17       	cp	r22, r24
    2e6c:	79 07       	cpc	r23, r25
    2e6e:	68 f4       	brcc	.+26     	; 0x2e8a <memmove+0x20>
    2e70:	fb 01       	movw	r30, r22
    2e72:	dc 01       	movw	r26, r24
    2e74:	e4 0f       	add	r30, r20
    2e76:	f5 1f       	adc	r31, r21
    2e78:	a4 0f       	add	r26, r20
    2e7a:	b5 1f       	adc	r27, r21
    2e7c:	02 c0       	rjmp	.+4      	; 0x2e82 <memmove+0x18>
    2e7e:	02 90       	ld	r0, -Z
    2e80:	0e 92       	st	-X, r0
    2e82:	41 50       	subi	r20, 0x01	; 1
    2e84:	50 40       	sbci	r21, 0x00	; 0
    2e86:	d8 f7       	brcc	.-10     	; 0x2e7e <memmove+0x14>
    2e88:	08 95       	ret
    2e8a:	e6 cf       	rjmp	.-52     	; 0x2e58 <memcpy>

00002e8c <strncmp>:
    2e8c:	fb 01       	movw	r30, r22
    2e8e:	dc 01       	movw	r26, r24
    2e90:	41 50       	subi	r20, 0x01	; 1
    2e92:	50 40       	sbci	r21, 0x00	; 0
    2e94:	30 f0       	brcs	.+12     	; 0x2ea2 <strncmp+0x16>
    2e96:	8d 91       	ld	r24, X+
    2e98:	01 90       	ld	r0, Z+
    2e9a:	80 19       	sub	r24, r0
    2e9c:	19 f4       	brne	.+6      	; 0x2ea4 <strncmp+0x18>
    2e9e:	00 20       	and	r0, r0
    2ea0:	b9 f7       	brne	.-18     	; 0x2e90 <strncmp+0x4>
    2ea2:	88 1b       	sub	r24, r24
    2ea4:	99 0b       	sbc	r25, r25
    2ea6:	08 95       	ret

00002ea8 <_exit>:
    2ea8:	f8 94       	cli

00002eaa <__stop_program>:
    2eaa:	ff cf       	rjmp	.-2      	; 0x2eaa <__stop_program>
