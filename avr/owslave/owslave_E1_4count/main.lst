   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	__vector_1
  11               	__vector_1:
  12               	.LFB0:
  13               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * OWSlave
   3:main.c        ****  *
   4:main.c        ****  * This program is free software: you can redistribute it and/or modify
   5:main.c        ****  * it under the terms of the GNU General Public License as published by
   6:main.c        ****  * the Free Software Foundation, either version 3 of the License, or
   7:main.c        ****  *  any later version.
   8:main.c        ****  *
   9:main.c        ****  * This program is distributed in the hope that it will be useful,
  10:main.c        ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:main.c        ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:main.c        ****  * GNU General Public License for more details.
  13:main.c        ****  *
  14:main.c        ****  * You should have received a copy of the GNU General Public License
  15:main.c        ****  * along with this program.  If not, see <http: * www.gnu.org/licenses/>.
  16:main.c        ****  *
  17:main.c        ****  * based on owdevice - A small 1-Wire emulator for AVR Microcontroller
  18:main.c        ****  *
  19:main.c        ****  * Copyright (C) 2012  Tobias Mueller mail (at) tobynet.de
  20:main.c        ****  *
  21:main.c        ****  * VERSION 1.3pre2 for ATmega48
  22:main.c        ****  *
  23:main.c        ****  * Created: 15.05.2013 13:36:59
  24:main.c        ****  *  Author: Michael Markstaller
  25:main.c        ****  *
  26:main.c        ****  * use included Makefile: just change target MCU and avrdude params
  27:main.c        ****  *
  28:main.c        ****  * Notes:
  29:main.c        ****  * - Default: with internal or external pullup to Vcc on counters: counting on FALLING edge
  30:main.c        ****  * - OWRXLED is connected with the ANODE to PAx
  31:main.c        ****  *
  32:main.c        ****  *
  33:main.c        ****  * Changelog:
  34:main.c        ****  * v1.52(->1.06) 2013-12-06 - !!!PENDING!!!
  35:main.c        ****  * - Add PA0 / PA1 as 2bit output OUT.A / OUT.B -> Active low
  36:main.c        ****  *
  37:main.c        ****  * v1.51 2013-11-10:
  38:main.c        ****  * - change OWRXLED from PA7 to PA2 on Attiny84 - keep PA7(ICP) free for possible Ehz/sml serial in
  39:main.c        ****  * v1.5:
  40:main.c        ****  *  - changed timing OWT_READLINE 3->2 in RM-code, ported forward
  41:main.c        ****  *  - configurable pullups
  42:main.c        ****  * v1.4pre - switched back from RM-code 1.3 - attiny84 counter etc.
  43:main.c        ****  * v1.3pre2
  44:main.c        ****  *  - combined prototype for Counter / RM with full owfs-support as family E1
  45:main.c        ****  * v1.3pre1:
  46:main.c        ****  *  - Major cleanup code: define serial & debug-macros
  47:main.c        ****  *  - adjust ISR to exact current defines in avr-libc, add uartlib (tiny24|44|84/25|45|85 missing y
  48:main.c        ****  *  - add EEPROM-functions
  49:main.c        ****  *  - add basic ow function-commands instead of page/memory access used in DS2423
  50:main.c        ****  *  - Family E1 introduced
  51:main.c        ****  *  - much testcode
  52:main.c        ****  * v1.2: basic code
  53:main.c        ****  */
  54:main.c        **** 
  55:main.c        **** 
  56:main.c        **** #include <stdlib.h>
  57:main.c        **** #include <avr/io.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/eeprom.h>
  60:main.c        **** #include <avr/sleep.h>
  61:main.c        **** #include <string.h>
  62:main.c        **** // #include <avr/pgmspace.h>
  63:main.c        **** #include "common.h"
  64:main.c        **** //#include "uart.h"
  65:main.c        **** 
  66:main.c        **** //#define DEBUG 0
  67:main.c        **** #include "debug.h"
  68:main.c        **** #ifndef F_CPU
  69:main.c        **** //# warning "F_CPU was not defined!! defining it now in debug.h but you should take care before!"
  70:main.c        **** #define F_CPU 8000000UL //very important! define before delay.h as delay.h fucks up the serial-timi
  71:main.c        **** #endif
  72:main.c        **** //#include <util/delay.h>
  73:main.c        **** 
  74:main.c        **** 
  75:main.c        **** #if defined(__AVR_ATmega48__) || (__AVR_ATmega88__) || (__AVR_ATmega328P__)
  76:main.c        **** /* ATMega is currently untested! */
  77:main.c        **** # error "ATMega defs are very outdated/broken in this code - fix first"
  78:main.c        **** // OW_PORT Pin 4  - PD2(INT0)
  79:main.c        **** 
  80:main.c        **** //OW Pin
  81:main.c        **** #define OW_PORT PORTD //1 Wire Port
  82:main.c        **** #define OW_PIN PIND //1 Wire Pin as number
  83:main.c        **** #define OW_PORTN (1<<PIND2)  //Pin as bit in registers
  84:main.c        **** #define OW_PINN (1<<PIND2)
  85:main.c        **** #define OW_DDR DDRD  //pin direction register
  86:main.c        **** #define SET_LOW OW_DDR|=OW_PINN;OW_PORT&=~OW_PORTN;  //set 1-Wire line to low
  87:main.c        **** #define RESET_LOW {OW_DDR&=~OW_PINN;}  //set 1-Wire pin as input
  88:main.c        **** //Pin interrupt
  89:main.c        **** #define EN_OWINT {EIMSK|=(1<<INT0);EIFR=(1<<INTF0);}  //enable interrupt 0 and *clear* it
  90:main.c        **** #define DIS_OWINT  EIMSK&=~(1<<INT0);  //disable interrupt 0
  91:main.c        **** #define SET_OWINT_RISING EICRA|=(1<<ISC01)|(1<<ISC00);  //set interrupt at rising edge
  92:main.c        **** #define SET_OWINT_FALLING {EICRA|=(1<<ISC01);EICRA&=~(1<<ISC00);} //set interrupt at falling edge
  93:main.c        **** #define CHK_INT_EN (EIMSK&(1<<INT0))==(1<<INT0) //test if interrupt enabled
  94:main.c        **** #define PIN_INT ISR(INT0_vect)  // the interrupt service routine
  95:main.c        **** //Timer Interrupt
  96:main.c        **** #define EN_TIMER {TIMSK0 |= (1<<TOIE0); TIFR0|=(1<<TOV0);} //enable timer0 interrupt
  97:main.c        **** #define DIS_TIMER TIMSK0  &= ~(1<<TOIE0); // disable timer interrupt
  98:main.c        **** #define TCNT_REG TCNT0  //register of timer-counter
  99:main.c        **** #define TIMER_INT ISR(TIMER0_OVF_vect) //the timer interrupt service routine
 100:main.c        **** 
 101:main.c        **** /* TODO/FIXME: define ports for status-leds, etc
 102:main.c        ****  * AVOID:
 103:main.c        ****  * PB2-5: SPI
 104:main.c        ****  * PC4-5: TWI
 105:main.c        ****  * PC0-3: ADC0-3
 106:main.c        ****  * PD5-6: PWM0 (?TC in use!)
 107:main.c        ****  * PB1-2: PWM1
 108:main.c        ****  * PB3/PD3: PWM2
 109:main.c        ****  * PD2-3: INT0-1
 110:main.c        ****  * PD0-1: USART
 111:main.c        ****  * Good:
 112:main.c        ****  * PD4
 113:main.c        ****  * PB6-7 (XTAL)
 114:main.c        ****  * PD7
 115:main.c        ****  * PB0
 116:main.c        ****  * PB1-5 (used by counter, collides PWM0,SPI)
 117:main.c        ****  */
 118:main.c        **** 
 119:main.c        **** #define OWRXLED_PORT PORTD
 120:main.c        **** #define OWRXLED_DDR DDRD
 121:main.c        **** #define OWRXLED_PIN PIND7
 122:main.c        **** 
 123:main.c        **** /* PWRDOWN: use PORTB / same PORT as counters ! */
 124:main.c        **** #define PWRDOWN_PORT PORTB
 125:main.c        **** #define PWRDOWN_DDR DDRB
 126:main.c        **** #define PWRDOWN_PIN PINB0
 127:main.c        **** 
 128:main.c        **** #define INIT_LED_PINS RMRXLED_DDR |= (1<<RMRXLED_PIN); \
 129:main.c        ****                      OWRXLED_DDR |= (1<<OWRXLED_PIN); /* pins as output */
 130:main.c        **** /* Toogle:  PORTB ^= ( 1 << PB0 );
 131:main.c        ****  * OWRXLED_PORT ^= (1<<OWRXLED_PIN);
 132:main.c        ****  */
 133:main.c        **** 
 134:main.c        **** //FIXME / TODO: double-check & compare timings!
 135:main.c        **** #define OWT_MIN_RESET 51 // tRSTL 512uS in DS, tRSTH = 584; 51 are 408uS
 136:main.c        **** #define OWT_RESET_PRESENCE 4 //tPDT 64uS in DS
 137:main.c        **** #define OWT_PRESENCE 20 // unclear, mabe between 512 and 584 uS; 20 are 160uS? real bus 9/170uS -> 
 138:main.c        **** #define OWT_READLINE 2 //for fast master, maybe 4 for long lines; flexible is 10 to 24 uS
 139:main.c        **** #define OWT_LOWTIME 3 //3=24uS for DS9490,
 140:main.c        **** 
 141:main.c        **** //Initializations of AVR
 142:main.c        **** #define INIT_AVR CLKPR=(1<<CLKPCE); /* FIXME! this is crap, next line disables it! */ \
 143:main.c        ****                   CLKPR=0; /* 8Mhz */ \
 144:main.c        ****                   /* CLKPR=(1<<CLKPCE)|(0<<CLKPS3)|(0<<CLKPS2)|(0<<CLKPS1)|(1<<CLKPS0);  FIXME/CHEC
 145:main.c        ****                   TIMSK0=0; \
 146:main.c        ****                   EIMSK=(1<<INT0);  /*set direct GICR INT0 enable*/ \
 147:main.c        ****                   TCCR0B=(1<<CS00)|(1<<CS01); /*8mhz /64 cause 8 bit Timer interrupt every 8us */ \
 148:main.c        ****                   TIMSK1 |= (1<<TOIE1); TIFR1 |= (1<<TOV1); /* enable overflow int for timer1 */ \
 149:main.c        ****                   TCCR1A |= (1<<COM1A1)|(1<<COM1B1)|(1<<WGM10); /* 8bit Fast-PWM 0<<COM1A0 0<<COM1B
 150:main.c        ****                   TCCR1B |= (1<<WGM12)|(1<<CS11)|(1<<CS10); /* 0<<WGM13 FastPWM - Clock for TIM1 /1
 151:main.c        ****                   /* FIXME: disable ADC etc to save power here? */
 152:main.c        **** 
 153:main.c        ****                   /* TCCR0B=(1<<CS00)|(1<<CS01);  FIXME/CHECK: 4mhz /8 cause 8 bit Timer interrupt 
 154:main.c        ****                   /* MAYBE use 16bit TC1 for this @4MHz?? */
 155:main.c        **** 
 156:main.c        ****                   /* FIXME: init TC1 for PWM/internal time-clock */
 157:main.c        ****                   /* FIXED: test wether TC0 can be still used for PWM->YES 490Hz- though it "flicke
 158:main.c        ****                   /* DDRD |= ((1<<PIND5)|(1<<PIND6)); PD5& as output */
 159:main.c        ****                   /* TCCR0A |= ((2<<COM0A0) | (2<<COM0B0) | (3<<WGM00)); enable output-compare-matc
 160:main.c        ****                   /* OCR0A = 128; OCR0B = 192; set dummy-values 50/75% */
 161:main.c        ****                   /* TCNT1 - Test */
 162:main.c        ****                   /* DDRB |= ((1<<PINB1)|(1<<PINB2)); PB1&2 as output */
 163:main.c        ****                   /* OCR1A = 128; OCR1B = 192; set dummy-values 50/75% */
 164:main.c        ****                   /* NO internal 1V1 AREF - we have 1M/470k = 20.1758 * AREAD / 1000 = Volt */
 165:main.c        ****                   /* /124 gives PWM cycle of 32.8ms = 30Hz ; 4885-5190 = 305 * ++ in OVF per 10s */
 166:main.c        ****                   /* /256 gives 125Hz? 8ms = 1222 * ++ in OVF per 10s every 32us ?*/
 167:main.c        **** 
 168:main.c        ****                   /* !! FIXME: must set DDRB PB0/PB1 to output and remove counter below! for PWM to
 169:main.c        ****                   /* Atmega48: PD5/PD6; Attiny2313: PB2/PD5 */
 170:main.c        **** 
 171:main.c        **** #define PWRSAVE_AVR PRR = (1<<PRTWI)|(1<<PRTIM2)|(1<<PRSPI); /* power down TWI, TIMCNT2, leave USAR
 172:main.c        ****                     DIDR0 = (1<<ADC5D)|(1<<ADC4D)|(1<<ADC3D)|(1<<ADC2D)|(1<<ADC1D)|(1<<ADC0D); /* d
 173:main.c        ****                     /* |(1<<PRTIM1) and ADC |(1<<PRADC) enabled for now */
 174:main.c        **** 
 175:main.c        **** 
 176:main.c        **** #define PC_INT_ISR ISR(PCINT0_vect) { /* ATmega48 is PCINT0_vect - counter PCINT */ \
 177:main.c        ****           if (((PINB&(1<<PINB1))==0)&&((istat&(1<<PINB1))==(1<<PINB1))) { Counter1++; } \
 178:main.c        ****           if (((PINB&(1<<PINB2))==0)&&((istat&(1<<PINB2))==(1<<PINB2))) { Counter2++; } \
 179:main.c        ****           if (((PINB&(1<<PINB3))==0)&&((istat&(1<<PINB3))==(1<<PINB3))) { Counter3++; } \
 180:main.c        ****           if (((PINB&(1<<PINB4))==0)&&((istat&(1<<PINB4))==(1<<PINB4))) { Counter4++; } \
 181:main.c        ****           if (((PINB&(1<<PINB0))==0)&&((istat&(1<<PINB0))==(1<<PINB0))) {               \
 182:main.c        ****                 /* FIXME: ints off for eeprom-write ?? */ \
 183:main.c        ****                 eeprom_update_dword((uint32_t *) (EE_COUNTER_OFFSET+0),Counter1);\
 184:main.c        ****                 eeprom_update_dword((uint32_t *) (EE_COUNTER_OFFSET+4),Counter2);\
 185:main.c        ****                 eeprom_update_dword((uint32_t *) (EE_COUNTER_OFFSET+8),Counter3);\
 186:main.c        ****                 eeprom_update_dword((uint32_t *) (EE_COUNTER_OFFSET+12),Counter4); } \
 187:main.c        ****                 eeprom_update_byte((uint8_t *) (EE_OUTPUT_OFFSET),outstate); } \
 188:main.c        ****             istat=PINB; }
 189:main.c        ****           /* FIXME: !!! debounce !!! */
 190:main.c        **** 
 191:main.c        **** #define INIT_COUNTER_PINS /* Init counter pins */ \
 192:main.c        ****           PCICR=(1<<PCIE0); /* enable PCINT0..7 global */ \
 193:main.c        ****           PORTB |= ( (1<<PB1) | (1<<PB2) ); \
 194:main.c        ****           PORTB |= ( (1<<PB3) | (1<<PB4) ); /* activate internal Pull-Up PB1-4 */ \
 195:main.c        ****           PCMSK0|= ((1<<PCINT1)|(1<<PCINT2)); \
 196:main.c        ****           PCMSK0|= ((1<<PCINT3)|(1<<PCINT4)); /* enable PCINT1-4 PB1-4 */ \
 197:main.c        ****           PCMSK0|= (1<<PCINT0); /* enable PCINT0 PB0 */ \
 198:main.c        ****           DDRB &=~((1<<PINB1)|(1<<PINB2)); \
 199:main.c        ****           DDRB &=~((1<<PINB3)|(1<<PINB4)); /* PB1-4 as input */ \
 200:main.c        ****           DDRB &=~((1<<PINB0)); /* PB0 as input */ \
 201:main.c        ****               istat=PINB; \
 202:main.c        **** 
 203:main.c        **** /* FIXME: !! nonsense ! just to emulate DS18B20 !!
 204:main.c        **** #define INIT_TEMP   DDRC&=~(1<<PINC0); \
 205:main.c        ****                     ADMUX=(1<<REFS0); \
 206:main.c        ****                     ADCSRA= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
 207:main.c        **** 
 208:main.c        **** #define CONV_TEMP   { uint8_t tc; int16_t sum=0; \
 209:main.c        ****                         for(tc=0;tc<0x10;tc++) { \
 210:main.c        ****                             ADCSRA|=(1<<ADSC)|(1<<ADIF);\
 211:main.c        ****                             while(ADCSRA&(1<<ADSC));\
 212:main.c        ****                             sum=sum+ADC; \
 213:main.c        ****                         } \
 214:main.c        ****                         sum=(sum<<4);  \
 215:main.c        ****                         scratchpad.u16_22 = sum;\
 216:main.c        ****                         scratchpad.u8_24 = ADCL;\
 217:main.c        ****                         scratchpad.u8_25 = ADCH; } \
 218:main.c        **** */
 219:main.c        **** 
 220:main.c        **** #endif // __AVR_ATmega48__
 221:main.c        **** 
 222:main.c        **** #if defined (__AVR_ATtiny24__) || (__AVR_ATtiny44__) || (__AVR_ATtiny84__)
 223:main.c        **** // OW_PORT Pin 5 - PB2
 224:main.c        **** 
 225:main.c        **** //OW Pin
 226:main.c        **** #define OW_PORT PORTB //1 Wire Port
 227:main.c        **** #define OW_PIN PINB //1 Wire Pin as number
 228:main.c        **** #define OW_PORTN (1<<PINB2)  //Pin as bit in registers
 229:main.c        **** #define OW_PINN (1<<PINB2)
 230:main.c        **** #define OW_DDR DDRB  //pin direction register
 231:main.c        **** #define SET_LOW OW_DDR|=OW_PINN;OW_PORT&=~OW_PORTN;  //set 1-Wire line to low
 232:main.c        **** #define RESET_LOW {OW_DDR&=~OW_PINN;}  //set 1-Wire pin as input
 233:main.c        **** //Pin interrupt
 234:main.c        **** #define EN_OWINT { GIMSK|=(1<<INT0); GIFR=(1<<INTF0); }  //enable interrupt and clear it! GIFR=(1<<
 235:main.c        **** #define DIS_OWINT  GIMSK&=~(1<<INT0); sleepmode=SLEEP_MODE_IDLE; //disable interrupt
 236:main.c        **** #define SET_OWINT_RISING MCUCR=(1<<ISC01)|(1<<ISC00);  //set interrupt at rising edge
 237:main.c        **** #define SET_OWINT_FALLING MCUCR=(1<<ISC01);MCUCR&=~(1<<ISC00); //set interrupt at falling edge FIXM
 238:main.c        **** #define SET_OWINT_BOTH MCUCR=(1<<ISC00);MCUCR&=~(1<<ISC01); //set interrupt at both edges
 239:main.c        **** #define SET_OWINT_LOWLEVEL MCUCR&=~((1<<ISC01)|(1<<ISC00)); //set interrupt at low level
 240:main.c        **** 
 241:main.c        **** #define CHK_INT_EN (GIMSK&(1<<INT0))==(1<<INT0) //test if interrupt enabled
 242:main.c        **** #define PIN_INT ISR(INT0_vect)  // the interrupt service routine
 243:main.c        **** //Timer Interrupt
 244:main.c        **** #define EN_TIMER {TIMSK0 |= (1<<TOIE0); TIFR0|=(1<<TOV0); } //enable timer interrupt
 245:main.c        **** #define DIS_TIMER TIMSK0  &= ~(1<<TOIE0); // disable timer interrupt + IDLE-Sleep?
 246:main.c        **** #define TCNT_REG TCNT0  //register of timer-counter
 247:main.c        **** #define TIMER_INT ISR(TIM0_OVF_vect) //the timer interrupt service routine
 248:main.c        **** 
 249:main.c        **** #define OWRXLED_PORT PORTA
 250:main.c        **** #define OWRXLED_DDR DDRA
 251:main.c        **** #define OWRXLED_PIN PINA2
 252:main.c        **** 
 253:main.c        **** #define OUTA_PORT PORTA
 254:main.c        **** #define OUTA_DDR DDRA
 255:main.c        **** #define OUTA_PIN PINA0
 256:main.c        **** #define OUTB_PORT PORTA
 257:main.c        **** #define OUTB_DDR DDRA
 258:main.c        **** #define OUTB_PIN PINA1
 259:main.c        **** 
 260:main.c        **** /* PWRDOWN: use PORTB / same PORT as counters ! */
 261:main.c        **** #define PWRDOWN_PORT PORTB
 262:main.c        **** #define PWRDOWN_DDR DDRB
 263:main.c        **** #define PWRDOWN_PIN PINB0
 264:main.c        **** 
 265:main.c        **** #define INIT_LED_PINS OWRXLED_DDR |= (1<<OWRXLED_PIN); /* pins as output */
 266:main.c        **** 
 267:main.c        **** #define INIT_OUT_PINS OUTA_DDR |= (1<<OUTA_PIN); \
 268:main.c        ****                       OUTB_DDR |= (1<<OUTB_PIN); /* pins as output */ \
 269:main.c        ****                       OUTA_PORT &= ~((outstate&0x01) <<OUTA_PIN); \
 270:main.c        ****                       OUTB_PORT &= ~((outstate&0x02) <<OUTB_PIN);
 271:main.c        **** 
 272:main.c        **** /*                      OUTA_PIN xxx Init out-Pins AFTER EEPROM-read!
 273:main.c        **** */
 274:main.c        **** 
 275:main.c        **** //FIXME / TODO: Double-check timings and move these to EEPROM
 276:main.c        **** #define OWT_MIN_RESET 51
 277:main.c        **** #define OWT_RESET_PRESENCE 4
 278:main.c        **** #define OWT_PRESENCE 20
 279:main.c        **** #define OWT_READLINE 2 //3 for fast master, 4 for slow master and long lines
 280:main.c        **** #define OWT_LOWTIME 3 //3 for fast master, 4 for slow master and long lines
 281:main.c        **** 
 282:main.c        **** //Initializations of AVR
 283:main.c        **** #define INIT_AVR CLKPR=(1<<CLKPCE); \
 284:main.c        ****                    CLKPR=0; /*8Mhz*/  \
 285:main.c        ****                    TIMSK0=0; \
 286:main.c        ****                    GIMSK=(1<<INT0);  /*set direct GIMSK register*/ \
 287:main.c        ****                    TCCR0B=(1<<CS00)|(1<<CS01); /*8mhz /64 couse 8 bit Timer interrupt every 8us*/ \
 288:main.c        ****                    WDTCSR |= ((1<<WDP2)|(1<<WDP1)|(1<<WDP0)); /* ((1<<WDP2)|(1<<WDP1)|(1<<WDP0)) WD
 289:main.c        ****                    WDTCSR |= (1<<WDIE); /* only enable int, no real watchdog */
 290:main.c        **** 
 291:main.c        **** #define PWRSAVE_AVR ADCSRA &= ~(1<<ADEN); PRR |= (1<<PRTIM1)|(1<<PRUSI)|(1<<PRADC);
 292:main.c        **** 
 293:main.c        **** #define PC_INT_ISRA ISR(PCINT0_vect) { /*Attiny84 - PAx is PCINT0 */ \
 294:main.c        ****                     if (((PINA&(1<<PINA3))==0)&&((pinstatA&(1<<PINA3))==(1<<PINA3))) { Counter2++; 
 295:main.c        ****                     if (((PINA&(1<<PINA4))==0)&&((pinstatA&(1<<PINA4))==(1<<PINA4))) { Counter3++; 
 296:main.c        ****                     if (((PINA&(1<<PINA5))==0)&&((pinstatA&(1<<PINA5))==(1<<PINA5))) { Counter4++; 
 297:main.c        ****                     pinstatA=PINA;}    \
 298:main.c        **** 
 299:main.c        **** #define PC_INT_ISRB ISR(PCINT1_vect) { /*Attiny84 - PBx is PCINT1 */ \
 300:main.c        ****                     if (((PINB&(1<<PINB1))==0)&&((pinstatB&(1<<PINB1))==(1<<PINB1))) { Counter1++; 
 301:main.c        ****                     if (((PINB&(1<<PINB0))==0)&&((pinstatB&(1<<PINB0))==(1<<PINB0))) {             
 302:main.c        ****                           /* FIXME: ints off for eeprom-write ?? eeprom own routines to save much s
 303:main.c        ****                           eeprom_update_dword((uint32_t *) (EE_COUNTER_OFFSET+0),Counter1);\
 304:main.c        ****                           eeprom_update_dword((uint32_t *) (EE_COUNTER_OFFSET+4),Counter2);\
 305:main.c        ****                           eeprom_update_dword((uint32_t *) (EE_COUNTER_OFFSET+8),Counter3);\
 306:main.c        ****                           eeprom_update_dword((uint32_t *) (EE_COUNTER_OFFSET+12),Counter4); \
 307:main.c        ****                           eeprom_update_byte((uint8_t *) (EE_OUTPUT_OFFSET),outstate); } \
 308:main.c        ****                     pinstatB=PINB;}    \
 309:main.c        **** 
 310:main.c        **** #define INIT_COUNTER_PINS /* Counter Interrupt */\
 311:main.c        ****                         GIMSK|=(1<<PCIE0);\
 312:main.c        ****                         GIMSK|=(1<<PCIE1);\
 313:main.c        ****                         PCMSK1|=(1<<PCINT9); /* PB1 PCINT */ \
 314:main.c        ****                         PCMSK1|= (1<<PCINT8); /* enable PCINT8 PB0 */ \
 315:main.c        ****                         DDRB &=~((1<<PINB1));  /* Counter-pins as input */ \
 316:main.c        ****                         DDRB &=~((1<<PINB0)); /* PB0 as input */ \
 317:main.c        ****                         pinstatB=PINB; \
 318:main.c        ****                         PCMSK0|=((1<<PCINT3)|(1<<PCINT4)|(1<<PCINT5)); /* PA3-5 PCINT */ \
 319:main.c        ****                         DDRA &=~((1<<PINA3)|(1<<PINA4)|(1<<PINA5));  /* Counter-pins PA3-5 as input
 320:main.c        ****                         pinstatA=PINA; \
 321:main.c        ****                         if (pullupcfg) { \
 322:main.c        ****                           PORTA |= ( (1<<PA3)|(1<<PA4)|(1<<PA5) ); /* activate internal Pull-Up PA3
 323:main.c        ****                           PORTB |= ( (1<<PB1) ); /* activate internal Pull-Up PB1 */ \
 324:main.c        ****                         } \
 325:main.c        **** 
 326:main.c        **** 
 327:main.c        **** #endif // __AVR_ATtiny84__
 328:main.c        **** 
 329:main.c        **** //States / Modes (defines from original owslave.c - new are all called OWC_ !)
 330:main.c        **** #define OWM_SLEEP 0  //Waiting for next reset pulse
 331:main.c        **** #define OWM_RESET 1  //Reset pulse received
 332:main.c        **** #define OWM_PRESENCE 2  //sending presence pulse
 333:main.c        **** #define OWM_READ_COMMAND 3 //read 8 bit of command
 334:main.c        **** #define OWM_SEARCH_ROM 4  //SEARCH_ROM algorithms
 335:main.c        **** #define OWM_MATCH_ROM 5  //test number
 336:main.c        **** #define OWM_CHK_RESET 8  //waiting of rising edge from reset pulse
 337:main.c        **** #define OWM_GET_ADRESS 6
 338:main.c        **** #define OWM_READ_MEMORY_COUNTER 7
 339:main.c        **** #define OWM_WRITE_SCRATCHPAD 9
 340:main.c        **** #define OWM_READ_SCRATCHPAD 10
 341:main.c        **** 
 342:main.c        **** #define OWM_WRITE_PAGE_TO_MASTER 11
 343:main.c        **** #define OWM_WRITE_FUNC 12
 344:main.c        **** 
 345:main.c        **** #define OWC_READ_SCRATCHPAD 0xBE
 346:main.c        **** #define OWC_WRITE_SCRATCHPAD 0x4E
 347:main.c        **** #define OWC_WRITE_FUNC 0x4F
 348:main.c        **** /* READ_SCRATCHPAD 0xBE + 0xYY is adaptec from DS2438! BE + Address
 349:main.c        ****  *
 350:main.c        ****  */
 351:main.c        **** 
 352:main.c        **** //Write a bit after next falling edge from master
 353:main.c        **** //its for sending a zero as soon as possible
 354:main.c        **** #define OWW_NO_WRITE 2
 355:main.c        **** #define OWW_WRITE_1 1
 356:main.c        **** #define OWW_WRITE_0 0
 357:main.c        **** 
 358:main.c        **** 
 359:main.c        **** volatile uint32_t uptime = 0; /* holds uptime in 1/2 seconds - overflows after 6.8 years */
 360:main.c        **** 
 361:main.c        **** typedef union {
 362:main.c        ****     volatile uint8_t bytes[11];
 363:main.c        ****     struct {
 364:main.c        ****       uint8_t   page1;
 365:main.c        ****       uint8_t   u8_11;
 366:main.c        ****       uint8_t   u8_12;
 367:main.c        ****       uint16_t  u16_13;
 368:main.c        ****       uint32_t  u32_14;
 369:main.c        ****       uint8_t   crc1;
 370:main.c        ****     };
 371:main.c        ****     struct {
 372:main.c        ****       uint8_t   page2;
 373:main.c        ****       uint16_t  u16_21;
 374:main.c        ****       uint16_t  u16_22;
 375:main.c        ****       uint16_t  u16_23;
 376:main.c        ****       uint8_t   u16_24;
 377:main.c        ****       uint8_t   crc2;
 378:main.c        ****     };
 379:main.c        ****     struct {
 380:main.c        ****       uint8_t   page3;
 381:main.c        ****       uint32_t  u32_31;
 382:main.c        ****       uint32_t  u32_32;
 383:main.c        ****       uint8_t   crc3;
 384:main.c        ****     };
 385:main.c        ****     struct {
 386:main.c        ****       uint8_t   page4;
 387:main.c        ****       uint8_t   u8_41;
 388:main.c        ****       uint8_t   u8_42;
 389:main.c        ****       uint8_t   u8_43;
 390:main.c        ****       uint8_t   u8_44;
 391:main.c        ****       uint32_t   u32_4XX;
 392:main.c        ****       uint8_t   crc4;
 393:main.c        ****     };
 394:main.c        **** } scratchpad_t;
 395:main.c        **** scratchpad_t scratchpad;
 396:main.c        **** 
 397:main.c        **** /* recv-states */
 398:main.c        **** enum {
 399:main.c        ****       S_NULL = 0,
 400:main.c        ****       S_STX = 2,
 401:main.c        ****       S_ETX = 3,
 402:main.c        ****       S_ACK = 6,
 403:main.c        ****       S_NACK = 15,
 404:main.c        ****       S_DATA = 20,
 405:main.c        **** };
 406:main.c        **** uint8_t recv_state = S_NULL;
 407:main.c        **** uint8_t nackmsg=0;
 408:main.c        **** 
 409:main.c        **** volatile uint16_t scrc; //CRC calculation
 410:main.c        **** volatile uint8_t page; /* address of memory-page to read/write */
 411:main.c        **** 
 412:main.c        **** volatile uint8_t lastcps;
 413:main.c        **** volatile uint32_t Counter1;
 414:main.c        **** volatile uint32_t Counter2;
 415:main.c        **** volatile uint32_t Counter3;
 416:main.c        **** volatile uint32_t Counter4;
 417:main.c        **** volatile uint8_t pinstatA;
 418:main.c        **** volatile uint8_t pinstatB;
 419:main.c        **** volatile uint8_t sleepmode;
 420:main.c        **** 
 421:main.c        **** volatile uint8_t cbuf; //Input buffer for a command
 422:main.c        **** uint8_t owid[8] = {0xE1, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x84, 0x28 };
 423:main.c        **** 
 424:main.c        **** volatile uint8_t bitp;  //pointer to current Byte
 425:main.c        **** volatile uint8_t bytep; //pointer to current Bit
 426:main.c        **** 
 427:main.c        **** volatile uint8_t mode; //state
 428:main.c        **** volatile uint8_t wmode; //if 0 next bit that send the device is  0
 429:main.c        **** volatile uint8_t actbit; //current
 430:main.c        **** volatile uint8_t srcount; //counter for search rom
 431:main.c        **** 
 432:main.c        **** /* temp vars to avoid eeprom-reading - in case of low-mem: FIXME */
 433:main.c        **** uint16_t version = 0x0106;
 434:main.c        **** uint8_t stype = 1;
 435:main.c        **** uint8_t pullupcfg = 1;
 436:main.c        **** uint8_t outstate = 0;
 437:main.c        **** uint16_t rcnt = 1;
 438:main.c        **** uint8_t eflag; //internal error/status-flag
 439:main.c        **** volatile uint8_t crcerrcnt=0;
 440:main.c        **** volatile uint8_t ewrite_flag;//ewrite_flag is already volatile and used as semaphore..
 441:main.c        **** typedef union {
 442:main.c        ****     uint8_t bytes[8];
 443:main.c        ****     struct {
 444:main.c        ****       uint32_t u32_1;
 445:main.c        ****       uint32_t u32_2;
 446:main.c        ****     };
 447:main.c        **** } eewrite_t;
 448:main.c        **** eewrite_t eewrite_buf;
 449:main.c        **** 
 450:main.c        **** PIN_INT {
  14               		.loc 1 450 0
  15 0000 1F92      		push r1
  16               	.LCFI0:
  17 0002 0F92      		push r0
  18               	.LCFI1:
  19 0004 0FB6      		in r0,__SREG__
  20 0006 0F92      		push r0
  21 0008 1124      		clr __zero_reg__
  22 000a 2F93      		push r18
  23               	.LCFI2:
  24 000c 8F93      		push r24
  25               	.LCFI3:
  26 000e 9F93      		push r25
  27               	.LCFI4:
  28 0010 EF93      		push r30
  29               	.LCFI5:
  30 0012 FF93      		push r31
  31               	.LCFI6:
  32               	/* prologue: Signal */
  33               	/* frame size = 0 */
  34               	/* stack size = 8 */
  35               	.L__stack_usage = 8
 451:main.c        ****     uint8_t lwmode=wmode;  //let this variables in registers
  36               		.loc 1 451 0
  37 0014 8091 0000 		lds r24,wmode
  38               	.LVL0:
 452:main.c        ****     uint8_t lmode=mode;
  39               		.loc 1 452 0
  40 0018 9091 0000 		lds r25,mode
  41               	.LVL1:
 453:main.c        ****     if (lwmode==OWW_WRITE_0) { //if necessary set 0-Bit
  42               		.loc 1 453 0
  43 001c 8111      		cpse r24,__zero_reg__
  44 001e 00C0      		rjmp .L2
 454:main.c        ****         SET_LOW;
  45               		.loc 1 454 0
  46 0020 BA9A      		sbi 0x17,2
  47 0022 C298      		cbi 0x18,2
  48               	.LVL2:
 455:main.c        ****         lwmode=OWW_NO_WRITE;
  49               		.loc 1 455 0
  50 0024 82E0      		ldi r24,lo8(2)
  51               	.LVL3:
  52               	.L2:
 456:main.c        ****     }
 457:main.c        ****     DIS_OWINT; //disable interrupt, only in OWM_SLEEP mode it is active
  53               		.loc 1 457 0
  54 0026 2BB7      		in r18,0x3b
  55 0028 2F7B      		andi r18,lo8(-65)
  56 002a 2BBF      		out 0x3b,r18
  57 002c 1092 0000 		sts sleepmode,__zero_reg__
 458:main.c        ****     sleepmode=SLEEP_MODE_IDLE; //powerdown is set in TIMER_INT on OWM_SLEEP only!
  58               		.loc 1 458 0
  59 0030 1092 0000 		sts sleepmode,__zero_reg__
 459:main.c        ****     switch (lmode) {
  60               		.loc 1 459 0
  61 0034 E92F      		mov r30,r25
  62 0036 F0E0      		ldi r31,0
  63 0038 ED30      		cpi r30,13
  64 003a F105      		cpc r31,__zero_reg__
  65 003c 00F4      		brsh .L3
  66 003e E050      		subi r30,lo8(-(gs(.L9)))
  67 0040 F040      		sbci r31,hi8(-(gs(.L9)))
  68 0042 0994      		ijmp
  69               	.LVL4:
  70               		.section	.progmem.gcc_sw_table,"ax",@progbits
  71               		.p2align	1
  72               	.L9:
  73 0000 00C0      		rjmp .L4
  74 0002 00C0      		rjmp .L3
  75 0004 00C0      		rjmp .L3
  76 0006 00C0      		rjmp .L10
  77 0008 00C0      		rjmp .L6
  78 000a 00C0      		rjmp .L10
  79 000c 00C0      		rjmp .L10
  80 000e 00C0      		rjmp .L3
  81 0010 00C0      		rjmp .L7
  82 0012 00C0      		rjmp .L10
  83 0014 00C0      		rjmp .L8
  84 0016 00C0      		rjmp .L8
  85 0018 00C0      		rjmp .L10
  86               		.text
  87               	.L4:
 460:main.c        ****         case OWM_SLEEP:
 461:main.c        ****             TCNT_REG=~(OWT_MIN_RESET);
  88               		.loc 1 461 0
  89 0044 2CEC      		ldi r18,lo8(-52)
  90 0046 22BF      		out 0x32,r18
 462:main.c        ****             //RESET_LOW;  //??? Set pin as input again ???
 463:main.c        ****             EN_OWINT; SET_OWINT_RISING; //other edges ?
  91               		.loc 1 463 0
  92 0048 2BB7      		in r18,0x3b
  93 004a 2064      		ori r18,lo8(64)
  94 004c 2BBF      		out 0x3b,r18
  95 004e 20E4      		ldi r18,lo8(64)
  96 0050 2ABF      		out 0x3a,r18
  97 0052 23E0      		ldi r18,lo8(3)
  98 0054 25BF      		out 0x35,r18
 464:main.c        ****             OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
  99               		.loc 1 464 0
 100 0056 DA98      		cbi 0x1b,2
 465:main.c        ****             break;
 101               		.loc 1 465 0
 102 0058 00C0      		rjmp .L3
 103               	.L6:
 466:main.c        ****         //start of reading a byte with falling edge from master, reading closed in timer isr
 467:main.c        ****         case OWM_MATCH_ROM:  //falling edge wait for receive
 468:main.c        ****         case OWM_WRITE_SCRATCHPAD:
 469:main.c        ****         case OWM_GET_ADRESS:
 470:main.c        ****         case OWM_READ_COMMAND:
 471:main.c        ****         case OWM_WRITE_FUNC:
 472:main.c        ****             TCNT_REG=~(OWT_READLINE); //wait a time for reading
 473:main.c        ****             break;
 474:main.c        ****         case OWM_SEARCH_ROM:   //Search algorithm waiting for receive or send
 475:main.c        ****             if (srcount<2) { //this means bit or complement is writing,
 104               		.loc 1 475 0
 105 005a 2091 0000 		lds r18,srcount
 106 005e 2230      		cpi r18,lo8(2)
 107 0060 00F4      		brsh .L10
 108 0062 00C0      		rjmp .L8
 109               	.L10:
 476:main.c        ****                 TCNT_REG=~(OWT_LOWTIME);
 477:main.c        ****             } else
 478:main.c        ****                 TCNT_REG=~(OWT_READLINE);  //init for read answer of master
 110               		.loc 1 478 0
 111 0064 2DEF      		ldi r18,lo8(-3)
 112               	.L11:
 113 0066 22BF      		out 0x32,r18
 114 0068 00C0      		rjmp .L3
 115               	.L8:
 479:main.c        ****             break;
 480:main.c        ****         case OWM_READ_SCRATCHPAD:
 481:main.c        ****         case OWM_WRITE_PAGE_TO_MASTER:
 482:main.c        ****             TCNT_REG=~(OWT_LOWTIME);
 116               		.loc 1 482 0
 117 006a 2CEF      		ldi r18,lo8(-4)
 118 006c 00C0      		rjmp .L11
 119               	.L7:
 483:main.c        ****             break;
 484:main.c        ****         case OWM_CHK_RESET:  //rising edge of reset pulse
 485:main.c        ****             SET_OWINT_FALLING;
 120               		.loc 1 485 0
 121 006e 92E0      		ldi r25,lo8(2)
 122 0070 95BF      		out 0x35,r25
 123 0072 95B7      		in r25,0x35
 124 0074 9E7F      		andi r25,lo8(-2)
 125 0076 95BF      		out 0x35,r25
 486:main.c        ****             TCNT_REG=~(OWT_RESET_PRESENCE);  //waiting for sending presence pulse
 126               		.loc 1 486 0
 127 0078 9BEF      		ldi r25,lo8(-5)
 128 007a 92BF      		out 0x32,r25
 129               	.LVL5:
 487:main.c        ****             lmode=OWM_RESET;
 130               		.loc 1 487 0
 131 007c 91E0      		ldi r25,lo8(1)
 132               	.LVL6:
 133               	.L3:
 488:main.c        ****             break;
 489:main.c        ****     }
 490:main.c        ****     EN_TIMER;
 134               		.loc 1 490 0
 135 007e 29B7      		in r18,0x39
 136 0080 2160      		ori r18,lo8(1)
 137 0082 29BF      		out 0x39,r18
 138 0084 28B7      		in r18,0x38
 139 0086 2160      		ori r18,lo8(1)
 140 0088 28BF      		out 0x38,r18
 491:main.c        ****     mode=lmode;
 141               		.loc 1 491 0
 142 008a 9093 0000 		sts mode,r25
 492:main.c        ****     wmode=lwmode;
 143               		.loc 1 492 0
 144 008e 8093 0000 		sts wmode,r24
 145               	/* epilogue start */
 493:main.c        **** }
 146               		.loc 1 493 0
 147 0092 FF91      		pop r31
 148 0094 EF91      		pop r30
 149 0096 9F91      		pop r25
 150               	.LVL7:
 151 0098 8F91      		pop r24
 152               	.LVL8:
 153 009a 2F91      		pop r18
 154 009c 0F90      		pop r0
 155 009e 0FBE      		out __SREG__,r0
 156 00a0 0F90      		pop r0
 157 00a2 1F90      		pop r1
 158 00a4 1895      		reti
 159               	.LFE0:
 161               	.global	__vector_11
 163               	__vector_11:
 164               	.LFB1:
 494:main.c        **** 
 495:main.c        **** TIMER_INT {
 165               		.loc 1 495 0
 166 00a6 1F92      		push r1
 167               	.LCFI7:
 168 00a8 0F92      		push r0
 169               	.LCFI8:
 170 00aa 0FB6      		in r0,__SREG__
 171 00ac 0F92      		push r0
 172 00ae 1124      		clr __zero_reg__
 173 00b0 CF92      		push r12
 174               	.LCFI9:
 175 00b2 DF92      		push r13
 176               	.LCFI10:
 177 00b4 FF92      		push r15
 178               	.LCFI11:
 179 00b6 0F93      		push r16
 180               	.LCFI12:
 181 00b8 1F93      		push r17
 182               	.LCFI13:
 183 00ba 2F93      		push r18
 184               	.LCFI14:
 185 00bc 3F93      		push r19
 186               	.LCFI15:
 187 00be 4F93      		push r20
 188               	.LCFI16:
 189 00c0 5F93      		push r21
 190               	.LCFI17:
 191 00c2 6F93      		push r22
 192               	.LCFI18:
 193 00c4 7F93      		push r23
 194               	.LCFI19:
 195 00c6 8F93      		push r24
 196               	.LCFI20:
 197 00c8 9F93      		push r25
 198               	.LCFI21:
 199 00ca AF93      		push r26
 200               	.LCFI22:
 201 00cc BF93      		push r27
 202               	.LCFI23:
 203 00ce EF93      		push r30
 204               	.LCFI24:
 205 00d0 FF93      		push r31
 206               	.LCFI25:
 207 00d2 CF93      		push r28
 208               	.LCFI26:
 209 00d4 DF93      		push r29
 210               	.LCFI27:
 211 00d6 1F92      		push __zero_reg__
 212               	.LCFI28:
 213 00d8 CDB7      		in r28,__SP_L__
 214 00da DEB7      		in r29,__SP_H__
 215               	.LCFI29:
 216               	/* prologue: Signal */
 217               	/* frame size = 1 */
 218               	/* stack size = 23 */
 219               	.L__stack_usage = 23
 496:main.c        ****     uint8_t lwmode=wmode; //let this variables in registers
 220               		.loc 1 496 0
 221 00dc 0091 0000 		lds r16,wmode
 222               	.LVL9:
 497:main.c        ****     uint8_t lmode=mode;
 223               		.loc 1 497 0
 224 00e0 3091 0000 		lds r19,mode
 225               	.LVL10:
 498:main.c        ****     uint8_t lbytep=bytep;
 226               		.loc 1 498 0
 227 00e4 1091 0000 		lds r17,bytep
 228               	.LVL11:
 499:main.c        ****     uint8_t lbitp=bitp;
 229               		.loc 1 499 0
 230 00e8 6091 0000 		lds r22,bitp
 231               	.LVL12:
 500:main.c        ****     uint8_t lsrcount=srcount;
 232               		.loc 1 500 0
 233 00ec F090 0000 		lds r15,srcount
 234               	.LVL13:
 501:main.c        ****     uint8_t lactbit=actbit;
 235               		.loc 1 501 0
 236 00f0 2091 0000 		lds r18,actbit
 237               	.LVL14:
 502:main.c        ****     uint16_t lscrc=scrc;
 238               		.loc 1 502 0
 239 00f4 C090 0000 		lds r12,scrc
 240 00f8 D090 0000 		lds r13,scrc+1
 241               	.LVL15:
 503:main.c        ****     //Ask input line sate
 504:main.c        ****     uint8_t p=((OW_PIN&OW_PINN)==OW_PINN);
 242               		.loc 1 504 0
 243 00fc 76B3      		in r23,0x16
 244 00fe 72FB      		bst r23,2
 245 0100 7727      		clr r23
 246 0102 70F9      		bld r23,0
 247               	.LVL16:
 505:main.c        **** 
 506:main.c        ****     OWRXLED_PORT ^= (1<<OWRXLED_PIN); /* toolge RX-led */
 248               		.loc 1 506 0
 249 0104 8BB3      		in r24,0x1b
 250 0106 94E0      		ldi r25,lo8(4)
 251 0108 8927      		eor r24,r25
 252 010a 8BBB      		out 0x1b,r24
 507:main.c        **** 
 508:main.c        ****     //Interrupt still active ?
 509:main.c        ****     if (CHK_INT_EN) {
 253               		.loc 1 509 0
 254 010c 0BB6      		in __tmp_reg__,0x3b
 255 010e 06FE      		sbrs __tmp_reg__,6
 256 0110 00C0      		rjmp .L13
 510:main.c        ****         //maybe reset pulse
 511:main.c        ****         if (p==0) {
 257               		.loc 1 511 0
 258 0112 7111      		cpse r23,__zero_reg__
 259 0114 00C0      		rjmp .L14
 260               	.LVL17:
 512:main.c        ****             lmode=OWM_CHK_RESET;  //wait for rising edge
 513:main.c        ****             SET_OWINT_RISING;
 261               		.loc 1 513 0
 262 0116 83E0      		ldi r24,lo8(3)
 263 0118 85BF      		out 0x35,r24
 512:main.c        ****             lmode=OWM_CHK_RESET;  //wait for rising edge
 264               		.loc 1 512 0
 265 011a 38E0      		ldi r19,lo8(8)
 266               	.LVL18:
 267               	.L14:
 514:main.c        ****         }
 515:main.c        ****         DIS_TIMER;
 268               		.loc 1 515 0
 269 011c 89B7      		in r24,0x39
 270 011e 8E7F      		andi r24,lo8(-2)
 271 0120 89BF      		out 0x39,r24
 272 0122 00C0      		rjmp .L15
 273               	.L13:
 516:main.c        ****     } else
 517:main.c        ****     switch (lmode) {
 274               		.loc 1 517 0
 275 0124 832F      		mov r24,r19
 276 0126 90E0      		ldi r25,0
 277 0128 FC01      		movw r30,r24
 278 012a 3197      		sbiw r30,1
 279 012c EC30      		cpi r30,12
 280 012e F105      		cpc r31,__zero_reg__
 281 0130 00F0      		brlo .+2
 282 0132 00C0      		rjmp .L15
 283 0134 E050      		subi r30,lo8(-(gs(.L24)))
 284 0136 F040      		sbci r31,hi8(-(gs(.L24)))
 285 0138 0994      		ijmp
 286               		.section	.progmem.gcc_sw_table,"ax",@progbits
 287               		.p2align	1
 288               	.L24:
 289 001a 00C0      		rjmp .L16
 290 001c 00C0      		rjmp .L17
 291 001e 00C0      		rjmp .L18
 292 0020 00C0      		rjmp .L19
 293 0022 00C0      		rjmp .L20
 294 0024 00C0      		rjmp .L21
 295 0026 00C0      		rjmp .L15
 296 0028 00C0      		rjmp .L15
 297 002a 00C0      		rjmp .L15
 298 002c 00C0      		rjmp .L15
 299 002e 00C0      		rjmp .L22
 300 0030 00C0      		rjmp .L23
 301               		.text
 302               	.L16:
 303               	.LVL19:
 518:main.c        ****         case OWM_RESET:  //Reset pulse and time after is finished, now go in presence state
 519:main.c        ****             lmode=OWM_PRESENCE;
 520:main.c        ****             SET_LOW;
 304               		.loc 1 520 0
 305 013a BA9A      		sbi 0x17,2
 306 013c C298      		cbi 0x18,2
 521:main.c        ****             TCNT_REG=~(OWT_PRESENCE);
 307               		.loc 1 521 0
 308 013e 8BEE      		ldi r24,lo8(-21)
 309 0140 82BF      		out 0x32,r24
 522:main.c        ****             DIS_OWINT;  //No Pin interrupt necessary only wait for presence is done
 310               		.loc 1 522 0
 311 0142 8BB7      		in r24,0x3b
 312 0144 8F7B      		andi r24,lo8(-65)
 313 0146 8BBF      		out 0x3b,r24
 314 0148 1092 0000 		sts sleepmode,__zero_reg__
 519:main.c        ****             lmode=OWM_PRESENCE;
 315               		.loc 1 519 0
 316 014c 32E0      		ldi r19,lo8(2)
 523:main.c        ****             break;
 317               		.loc 1 523 0
 318 014e 00C0      		rjmp .L79
 319               	.LVL20:
 320               	.L17:
 524:main.c        ****         case OWM_PRESENCE:
 525:main.c        ****             RESET_LOW;  //Presence is done now wait for a command
 321               		.loc 1 525 0
 322 0150 BA98      		cbi 0x17,2
 323               	.LVL21:
 324 0152 00C0      		rjmp .L125
 325               	.LVL22:
 326               	.L18:
 526:main.c        ****             lmode=OWM_READ_COMMAND;
 527:main.c        ****             cbuf=0;lbitp=1;  //Command buffer have to set zero, only set bits will write in
 528:main.c        ****             break;
 529:main.c        ****         case OWM_READ_COMMAND:
 530:main.c        ****             if (p) {  //Set bit if line high
 327               		.loc 1 530 0
 328 0154 7723      		tst r23
 329 0156 01F0      		breq .L26
 531:main.c        ****                 cbuf|=lbitp;
 330               		.loc 1 531 0
 331 0158 8091 0000 		lds r24,cbuf
 332 015c 862B      		or r24,r22
 333 015e 8093 0000 		sts cbuf,r24
 334               	.L26:
 532:main.c        ****             }
 533:main.c        ****             lbitp=(lbitp<<1);
 335               		.loc 1 533 0
 336 0162 660F      		lsl r22
 337               	.LVL23:
 534:main.c        ****             if (!lbitp) { //8-Bits read - weird syntax?
 338               		.loc 1 534 0
 339 0164 01F0      		breq .+2
 340 0166 00C0      		rjmp .L77
 341               	.LVL24:
 535:main.c        ****                 lbitp=1;
 536:main.c        ****                 switch (cbuf) {
 342               		.loc 1 536 0
 343 0168 8091 0000 		lds r24,cbuf
 344 016c 8535      		cpi r24,lo8(85)
 345 016e 01F4      		brne .+2
 346 0170 00C0      		rjmp .L82
 347 0172 00F4      		brsh .L31
 348 0174 8F34      		cpi r24,lo8(79)
 349 0176 01F0      		breq .+2
 350 0178 00C0      		rjmp .L89
 351 017a 00C0      		rjmp .L28
 352               	.L31:
 353 017c 8E3B      		cpi r24,lo8(-66)
 354 017e 01F0      		breq .L29
 355 0180 803F      		cpi r24,lo8(-16)
 356 0182 01F0      		breq .+2
 357 0184 00C0      		rjmp .L89
 358               	.LVL25:
 537:main.c        ****                     case 0x55://Match ROM
 538:main.c        ****                         lbytep=0;
 539:main.c        ****                         lmode=OWM_MATCH_ROM;
 540:main.c        ****                         break;
 541:main.c        ****                     case 0xF0:  //initialize search rom
 542:main.c        ****                         lmode=OWM_SEARCH_ROM;
 543:main.c        ****                         lsrcount=0;
 544:main.c        ****                         lbytep=0;
 545:main.c        ****                         lactbit=(owid[lbytep]&lbitp)==lbitp; //set actual bit
 359               		.loc 1 545 0
 360 0186 0091 0000 		lds r16,owid
 361               	.LVL26:
 362 018a 0170      		andi r16,lo8(1)
 363               	.LVL27:
 364 018c 202F      		mov r18,r16
 543:main.c        ****                         lsrcount=0;
 365               		.loc 1 543 0
 366 018e F12C      		mov r15,__zero_reg__
 535:main.c        ****                 lbitp=1;
 367               		.loc 1 535 0
 368 0190 61E0      		ldi r22,lo8(1)
 544:main.c        ****                         lbytep=0;
 369               		.loc 1 544 0
 370 0192 10E0      		ldi r17,0
 542:main.c        ****                         lmode=OWM_SEARCH_ROM;
 371               		.loc 1 542 0
 372 0194 34E0      		ldi r19,lo8(4)
 546:main.c        ****                         lwmode=lactbit;  //prepare for writing when next falling edge
 547:main.c        ****                         break;
 373               		.loc 1 547 0
 374 0196 00C0      		rjmp .L78
 375               	.LVL28:
 376               	.L29:
 548:main.c        ****                     //FIXME: case 0xEC:  //alarm search rom - TODO
 549:main.c        ****                     case 0xBE: //read scratchpad
 550:main.c        ****                         lmode=OWM_GET_ADRESS; //first the master sends an address
 551:main.c        ****                         lbytep=0;
 552:main.c        ****                         page=0;
 377               		.loc 1 552 0
 378 0198 1092 0000 		sts page,__zero_reg__
 535:main.c        ****                 lbitp=1;
 379               		.loc 1 535 0
 380 019c 61E0      		ldi r22,lo8(1)
 551:main.c        ****                         lbytep=0;
 381               		.loc 1 551 0
 382 019e 10E0      		ldi r17,0
 550:main.c        ****                         lmode=OWM_GET_ADRESS; //first the master sends an address
 383               		.loc 1 550 0
 384 01a0 36E0      		ldi r19,lo8(6)
 553:main.c        ****                         //EN_OWINT; SET_OWINT_LOWLEVEL; sleepmode=SLEEP_MODE_PWR_DOWN; //Testing if
 554:main.c        ****                         break;
 385               		.loc 1 554 0
 386 01a2 00C0      		rjmp .L78
 387               	.LVL29:
 388               	.L28:
 555:main.c        ****                     case OWC_WRITE_FUNC:
 556:main.c        ****                         lmode=OWM_WRITE_FUNC; //first the master sends an address(page/func), then 
 557:main.c        ****                         lbytep=0;
 558:main.c        ****                         lscrc=0;
 559:main.c        ****                         scratchpad.page1=0;
 389               		.loc 1 559 0
 390 01a4 1092 0000 		sts scratchpad,__zero_reg__
 558:main.c        ****                         lscrc=0;
 391               		.loc 1 558 0
 392 01a8 C12C      		mov r12,__zero_reg__
 393 01aa D12C      		mov r13,__zero_reg__
 535:main.c        ****                 lbitp=1;
 394               		.loc 1 535 0
 395 01ac 61E0      		ldi r22,lo8(1)
 557:main.c        ****                         lbytep=0;
 396               		.loc 1 557 0
 397 01ae 10E0      		ldi r17,0
 556:main.c        ****                         lmode=OWM_WRITE_FUNC; //first the master sends an address(page/func), then 
 398               		.loc 1 556 0
 399 01b0 3CE0      		ldi r19,lo8(12)
 560:main.c        ****                         break;
 400               		.loc 1 560 0
 401 01b2 00C0      		rjmp .L78
 402               	.LVL30:
 403               	.L19:
 561:main.c        ****                     default:
 562:main.c        ****                         LSL("\r\nDC:")
 563:main.c        ****                         //LVH(cbuf)
 564:main.c        ****                         lmode=OWM_SLEEP;  //all other commands do nothing
 565:main.c        ****                 }
 566:main.c        ****             }
 567:main.c        ****             break;
 568:main.c        ****         case OWM_SEARCH_ROM:
 569:main.c        ****             RESET_LOW;  //Set low also if nothing send (branch takes time and memory)
 404               		.loc 1 569 0
 405 01b4 BA98      		cbi 0x17,2
 570:main.c        ****             lsrcount++;  //next search rom mode
 406               		.loc 1 570 0
 407 01b6 F394      		inc r15
 408               	.LVL31:
 571:main.c        ****             switch (lsrcount) {
 409               		.loc 1 571 0
 410 01b8 81E0      		ldi r24,lo8(1)
 411 01ba F816      		cp r15,r24
 412 01bc 01F0      		breq .L32
 413 01be A3E0      		ldi r26,lo8(3)
 414 01c0 FA12      		cpse r15,r26
 415 01c2 00C0      		rjmp .L77
 416 01c4 00C0      		rjmp .L33
 417               	.L32:
 572:main.c        ****                 case 1:lwmode=!lactbit;  //preparation sending complement
 418               		.loc 1 572 0
 419 01c6 01E0      		ldi r16,lo8(1)
 420               	.LVL32:
 421 01c8 2223      		tst r18
 422 01ca 01F4      		brne .+2
 423 01cc 00C0      		rjmp .L77
 424 01ce 00E0      		ldi r16,0
 425               	.LVL33:
 573:main.c        ****                     break;
 426               		.loc 1 573 0
 427 01d0 00C0      		rjmp .L77
 428               	.LVL34:
 429               	.L33:
 574:main.c        ****                 case 3:
 575:main.c        ****                     if (p!=(lactbit==1)) {  //check master bit
 430               		.loc 1 575 0
 431 01d2 81E0      		ldi r24,lo8(1)
 432 01d4 2130      		cpi r18,lo8(1)
 433 01d6 01F0      		breq .L35
 434 01d8 80E0      		ldi r24,0
 435               	.L35:
 436 01da 7813      		cpse r23,r24
 437 01dc 00C0      		rjmp .L80
 576:main.c        ****                         lmode=OWM_SLEEP;  //not the same go sleep
 577:main.c        ****                     } else {
 578:main.c        ****                         lbitp=(lbitp<<1);  //prepare next bit
 438               		.loc 1 578 0
 439 01de 660F      		lsl r22
 440               	.LVL35:
 579:main.c        ****                         if (lbitp==0) {
 441               		.loc 1 579 0
 442 01e0 01F4      		brne .L36
 443               	.LVL36:
 580:main.c        ****                             lbitp=1;
 581:main.c        ****                             lbytep++;
 444               		.loc 1 581 0
 445 01e2 1F5F      		subi r17,lo8(-(1))
 446               	.LVL37:
 580:main.c        ****                             lbitp=1;
 447               		.loc 1 580 0
 448 01e4 61E0      		ldi r22,lo8(1)
 582:main.c        ****                             if (lbytep>=8) {
 449               		.loc 1 582 0
 450 01e6 1830      		cpi r17,lo8(8)
 451 01e8 00F0      		brlo .+2
 452 01ea 00C0      		rjmp .L80
 453               	.LVL38:
 454               	.L36:
 583:main.c        ****                                 lmode=OWM_SLEEP;  //all bits processed
 584:main.c        ****                                 break;
 585:main.c        ****                             }
 586:main.c        ****                         }
 587:main.c        ****                         lsrcount=0;
 588:main.c        ****                         lactbit=(owid[lbytep]&lbitp)==lbitp;
 455               		.loc 1 588 0
 456 01ec E12F      		mov r30,r17
 457 01ee F0E0      		ldi r31,0
 458 01f0 E050      		subi r30,lo8(-(owid))
 459 01f2 F040      		sbci r31,hi8(-(owid))
 460 01f4 8081      		ld r24,Z
 461 01f6 8623      		and r24,r22
 462 01f8 21E0      		ldi r18,lo8(1)
 463               	.LVL39:
 464 01fa 8613      		cpse r24,r22
 465 01fc 20E0      		ldi r18,0
 466               	.L37:
 467               	.LVL40:
 589:main.c        ****                         lwmode=lactbit;
 468               		.loc 1 589 0
 469 01fe 022F      		mov r16,r18
 587:main.c        ****                         lsrcount=0;
 470               		.loc 1 587 0
 471 0200 F12C      		mov r15,__zero_reg__
 472 0202 00C0      		rjmp .L77
 473               	.LVL41:
 474               	.L20:
 590:main.c        ****                     }
 591:main.c        ****                     break;
 592:main.c        ****             }
 593:main.c        ****             break;
 594:main.c        ****         case OWM_MATCH_ROM:
 595:main.c        ****             if (p==((owid[lbytep]&lbitp)==lbitp)) {  //Compare with ID Buffer
 475               		.loc 1 595 0
 476 0204 E12F      		mov r30,r17
 477 0206 F0E0      		ldi r31,0
 478 0208 E050      		subi r30,lo8(-(owid))
 479 020a F040      		sbci r31,hi8(-(owid))
 480 020c 8081      		ld r24,Z
 481 020e 8623      		and r24,r22
 482 0210 91E0      		ldi r25,lo8(1)
 483 0212 8613      		cpse r24,r22
 484 0214 90E0      		ldi r25,0
 485               	.L38:
 486 0216 7913      		cpse r23,r25
 487 0218 00C0      		rjmp .L80
 596:main.c        ****                 lbitp=(lbitp<<1);
 488               		.loc 1 596 0
 489 021a 660F      		lsl r22
 490               	.LVL42:
 597:main.c        ****                 if (!lbitp) {
 491               		.loc 1 597 0
 492 021c 01F0      		breq .+2
 493 021e 00C0      		rjmp .L77
 598:main.c        ****                     lbytep++;
 494               		.loc 1 598 0
 495 0220 1F5F      		subi r17,lo8(-(1))
 496               	.LVL43:
 599:main.c        ****                     lbitp=1;
 600:main.c        ****                     if (lbytep>=8) {
 497               		.loc 1 600 0
 498 0222 1830      		cpi r17,lo8(8)
 499 0224 00F4      		brsh .+2
 500 0226 00C0      		rjmp .L88
 501               	.LVL44:
 502               	.L125:
 601:main.c        ****                         lmode=OWM_READ_COMMAND;  //same? get next command
 602:main.c        ****                         cbuf=0;
 503               		.loc 1 602 0
 504 0228 1092 0000 		sts cbuf,__zero_reg__
 599:main.c        ****                     lbitp=1;
 505               		.loc 1 599 0
 506 022c 61E0      		ldi r22,lo8(1)
 601:main.c        ****                         lmode=OWM_READ_COMMAND;  //same? get next command
 507               		.loc 1 601 0
 508 022e 33E0      		ldi r19,lo8(3)
 603:main.c        ****                         break;
 509               		.loc 1 603 0
 510 0230 00C0      		rjmp .L78
 511               	.LVL45:
 512               	.L21:
 604:main.c        ****                     }
 605:main.c        ****                 }
 606:main.c        ****             } else {
 607:main.c        ****                 lmode=OWM_SLEEP;
 608:main.c        ****             }
 609:main.c        ****             break;
 610:main.c        ****         case OWM_GET_ADRESS:
 611:main.c        ****             if (p) { //Get the Address for reading
 513               		.loc 1 611 0
 514 0232 7723      		tst r23
 515 0234 01F0      		breq .L39
 612:main.c        ****                 page|=lbitp;
 516               		.loc 1 612 0
 517 0236 8091 0000 		lds r24,page
 518 023a 862B      		or r24,r22
 519 023c 8093 0000 		sts page,r24
 520               	.L39:
 613:main.c        ****             }
 614:main.c        ****             lbitp=(lbitp<<1);
 521               		.loc 1 614 0
 522 0240 660F      		lsl r22
 523               	.LVL46:
 615:main.c        ****             if (!lbitp) {
 524               		.loc 1 615 0
 525 0242 01F0      		breq .+2
 526 0244 00C0      		rjmp .L77
 616:main.c        ****                 lbytep++;
 527               		.loc 1 616 0
 528 0246 1F5F      		subi r17,lo8(-(1))
 529               	.LVL47:
 617:main.c        ****                 lbitp=1;
 618:main.c        ****                 if (lbytep==1) {
 530               		.loc 1 618 0
 531 0248 1130      		cpi r17,lo8(1)
 532 024a 01F0      		breq .+2
 533 024c 00C0      		rjmp .L40
 534               	.LVL48:
 619:main.c        ****                     lmode=OWM_WRITE_PAGE_TO_MASTER;
 620:main.c        ****                     lbytep=0;lscrc=0; //from first position
 621:main.c        ****                     memset( &scratchpad.bytes, 0, 10 );
 535               		.loc 1 621 0
 536 024e 8AE0      		ldi r24,lo8(10)
 537 0250 E0E0      		ldi r30,lo8(scratchpad)
 538 0252 F0E0      		ldi r31,hi8(scratchpad)
 539 0254 DF01      		movw r26,r30
 540               		0:
 541 0256 1D92      		st X+,__zero_reg__
 542 0258 8A95      		dec r24
 543 025a 01F4      		brne 0b
 622:main.c        ****                     switch (page) {
 544               		.loc 1 622 0
 545 025c E091 0000 		lds r30,page
 546 0260 F0E0      		ldi r31,0
 623:main.c        ****                       case 0:
 624:main.c        ****                         scratchpad.page1 = page;
 625:main.c        ****                         scratchpad.u8_11 = stype;
 626:main.c        ****                         scratchpad.u8_12 = eflag;
 627:main.c        ****                         scratchpad.u16_13 = version;
 628:main.c        ****                         scratchpad.u32_14 = uptime;
 629:main.c        ****                         break;
 630:main.c        ****                       case 1:
 631:main.c        ****                         scratchpad.page1 = page;
 632:main.c        ****                         scratchpad.u16_21 = rcnt;
 633:main.c        ****                         //scratchpad.u16_22 = ADC1
 634:main.c        ****                         //scratchpad.u16_23 = ADC2
 635:main.c        ****                         scratchpad.u16_24 = crcerrcnt; //temp/debug
 636:main.c        ****                         //scratchpad.u16_24 = freeRam;
 637:main.c        ****                         break;
 638:main.c        ****                       case 2:
 639:main.c        ****                         scratchpad.page1 = page;
 640:main.c        ****                         scratchpad.u32_31 = Counter1;
 641:main.c        ****                         scratchpad.u32_32 = Counter2;
 642:main.c        ****                         break;
 643:main.c        ****                       case 3:
 644:main.c        ****                         scratchpad.page1 = page;
 645:main.c        ****                         scratchpad.u32_31 = Counter3;
 646:main.c        ****                         scratchpad.u32_32 = Counter4;
 647:main.c        ****                         break;
 648:main.c        ****                       case 4:
 649:main.c        ****                         scratchpad.page1 = page;
 650:main.c        ****                         //pin-input-state
 651:main.c        ****                         //FIXME: make 1 byte with relevant pins only
 652:main.c        ****                         scratchpad.u8_41 = pinstatA;
 653:main.c        ****                         scratchpad.u8_42 = pinstatB;
 654:main.c        ****                         scratchpad.u8_43 = pullupcfg;
 655:main.c        ****                         scratchpad.u8_44 = outstate;
 656:main.c        ****                         break;
 657:main.c        ****                       case 5:
 658:main.c        ****                         scratchpad.page1 = page;
 659:main.c        ****                         //FIXME: untested, might be broken!
 660:main.c        ****                         //FIXME: make 1 byte with relevant pins only
 661:main.c        ****                         scratchpad.u8_41 = outstate;
 662:main.c        ****                         break;
 663:main.c        ****                       case 9:
 664:main.c        ****                         scratchpad.page1 = page;
 665:main.c        ****                         scratchpad.u32_31 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+0
 666:main.c        ****                         scratchpad.u32_32 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+4
 667:main.c        ****                         break;
 668:main.c        ****                       case 10:
 669:main.c        ****                         scratchpad.page1 = page;
 670:main.c        ****                         scratchpad.u32_31 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+8
 671:main.c        ****                         scratchpad.u32_32 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+1
 672:main.c        ****                         break;
 673:main.c        ****                       default:
 674:main.c        ****                         scratchpad.page1 = page;
 547               		.loc 1 674 0
 548 0262 8091 0000 		lds r24,page
 549 0266 8093 0000 		sts scratchpad,r24
 622:main.c        ****                     switch (page) {
 550               		.loc 1 622 0
 551 026a EB30      		cpi r30,11
 552 026c F105      		cpc r31,__zero_reg__
 553 026e 00F0      		brlo .+2
 554 0270 00C0      		rjmp .L41
 555 0272 E050      		subi r30,lo8(-(gs(.L50)))
 556 0274 F040      		sbci r31,hi8(-(gs(.L50)))
 557 0276 0994      		ijmp
 558               		.section	.progmem.gcc_sw_table,"ax",@progbits
 559               		.p2align	1
 560               	.L50:
 561 0032 00C0      		rjmp .L42
 562 0034 00C0      		rjmp .L43
 563 0036 00C0      		rjmp .L44
 564 0038 00C0      		rjmp .L45
 565 003a 00C0      		rjmp .L46
 566 003c 00C0      		rjmp .L47
 567 003e 00C0      		rjmp .L41
 568 0040 00C0      		rjmp .L41
 569 0042 00C0      		rjmp .L41
 570 0044 00C0      		rjmp .L48
 571 0046 00C0      		rjmp .L49
 572               		.text
 573               	.L42:
 625:main.c        ****                         scratchpad.u8_11 = stype;
 574               		.loc 1 625 0
 575 0278 8091 0000 		lds r24,stype
 576 027c 8093 0000 		sts scratchpad+1,r24
 626:main.c        ****                         scratchpad.u8_12 = eflag;
 577               		.loc 1 626 0
 578 0280 8091 0000 		lds r24,eflag
 579 0284 8093 0000 		sts scratchpad+2,r24
 627:main.c        ****                         scratchpad.u16_13 = version;
 580               		.loc 1 627 0
 581 0288 8091 0000 		lds r24,version
 582 028c 9091 0000 		lds r25,version+1
 583 0290 9093 0000 		sts scratchpad+3+1,r25
 584 0294 8093 0000 		sts scratchpad+3,r24
 628:main.c        ****                         scratchpad.u32_14 = uptime;
 585               		.loc 1 628 0
 586 0298 8091 0000 		lds r24,uptime
 587 029c 9091 0000 		lds r25,uptime+1
 588 02a0 A091 0000 		lds r26,uptime+2
 589 02a4 B091 0000 		lds r27,uptime+3
 590 02a8 00C0      		rjmp .L122
 591               	.L43:
 632:main.c        ****                         scratchpad.u16_21 = rcnt;
 592               		.loc 1 632 0
 593 02aa 8091 0000 		lds r24,rcnt
 594 02ae 9091 0000 		lds r25,rcnt+1
 595 02b2 9093 0000 		sts scratchpad+1+1,r25
 596 02b6 8093 0000 		sts scratchpad+1,r24
 635:main.c        ****                         scratchpad.u16_24 = crcerrcnt; //temp/debug
 597               		.loc 1 635 0
 598 02ba 8091 0000 		lds r24,crcerrcnt
 599 02be 8093 0000 		sts scratchpad+7,r24
 637:main.c        ****                         break;
 600               		.loc 1 637 0
 601 02c2 00C0      		rjmp .L51
 602               	.L44:
 640:main.c        ****                         scratchpad.u32_31 = Counter1;
 603               		.loc 1 640 0
 604 02c4 8091 0000 		lds r24,Counter1
 605 02c8 9091 0000 		lds r25,Counter1+1
 606 02cc A091 0000 		lds r26,Counter1+2
 607 02d0 B091 0000 		lds r27,Counter1+3
 608 02d4 8093 0000 		sts scratchpad+1,r24
 609 02d8 9093 0000 		sts scratchpad+1+1,r25
 610 02dc A093 0000 		sts scratchpad+1+2,r26
 611 02e0 B093 0000 		sts scratchpad+1+3,r27
 641:main.c        ****                         scratchpad.u32_32 = Counter2;
 612               		.loc 1 641 0
 613 02e4 8091 0000 		lds r24,Counter2
 614 02e8 9091 0000 		lds r25,Counter2+1
 615 02ec A091 0000 		lds r26,Counter2+2
 616 02f0 B091 0000 		lds r27,Counter2+3
 617               	.L122:
 618 02f4 8093 0000 		sts scratchpad+5,r24
 619 02f8 9093 0000 		sts scratchpad+5+1,r25
 620 02fc A093 0000 		sts scratchpad+5+2,r26
 621 0300 B093 0000 		sts scratchpad+5+3,r27
 642:main.c        ****                         break;
 622               		.loc 1 642 0
 623 0304 00C0      		rjmp .L51
 624               	.L45:
 645:main.c        ****                         scratchpad.u32_31 = Counter3;
 625               		.loc 1 645 0
 626 0306 8091 0000 		lds r24,Counter3
 627 030a 9091 0000 		lds r25,Counter3+1
 628 030e A091 0000 		lds r26,Counter3+2
 629 0312 B091 0000 		lds r27,Counter3+3
 630 0316 8093 0000 		sts scratchpad+1,r24
 631 031a 9093 0000 		sts scratchpad+1+1,r25
 632 031e A093 0000 		sts scratchpad+1+2,r26
 633 0322 B093 0000 		sts scratchpad+1+3,r27
 646:main.c        ****                         scratchpad.u32_32 = Counter4;
 634               		.loc 1 646 0
 635 0326 8091 0000 		lds r24,Counter4
 636 032a 9091 0000 		lds r25,Counter4+1
 637 032e A091 0000 		lds r26,Counter4+2
 638 0332 B091 0000 		lds r27,Counter4+3
 639 0336 00C0      		rjmp .L122
 640               	.L46:
 652:main.c        ****                         scratchpad.u8_41 = pinstatA;
 641               		.loc 1 652 0
 642 0338 8091 0000 		lds r24,pinstatA
 643 033c 8093 0000 		sts scratchpad+1,r24
 653:main.c        ****                         scratchpad.u8_42 = pinstatB;
 644               		.loc 1 653 0
 645 0340 8091 0000 		lds r24,pinstatB
 646 0344 8093 0000 		sts scratchpad+2,r24
 654:main.c        ****                         scratchpad.u8_43 = pullupcfg;
 647               		.loc 1 654 0
 648 0348 8091 0000 		lds r24,pullupcfg
 649 034c 8093 0000 		sts scratchpad+3,r24
 655:main.c        ****                         scratchpad.u8_44 = outstate;
 650               		.loc 1 655 0
 651 0350 8091 0000 		lds r24,outstate
 652 0354 8093 0000 		sts scratchpad+4,r24
 656:main.c        ****                         break;
 653               		.loc 1 656 0
 654 0358 00C0      		rjmp .L51
 655               	.L47:
 661:main.c        ****                         scratchpad.u8_41 = outstate;
 656               		.loc 1 661 0
 657 035a 8091 0000 		lds r24,outstate
 658 035e 8093 0000 		sts scratchpad+1,r24
 662:main.c        ****                         break;
 659               		.loc 1 662 0
 660 0362 00C0      		rjmp .L51
 661               	.L48:
 665:main.c        ****                         scratchpad.u32_31 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+0
 662               		.loc 1 665 0
 663 0364 82E3      		ldi r24,lo8(50)
 664 0366 90E0      		ldi r25,0
 665 0368 00D0      		rcall __eerd_dword_tn84
 666               	.LVL49:
 667 036a 6093 0000 		sts scratchpad+1,r22
 668 036e 7093 0000 		sts scratchpad+1+1,r23
 669 0372 8093 0000 		sts scratchpad+1+2,r24
 670 0376 9093 0000 		sts scratchpad+1+3,r25
 666:main.c        ****                         scratchpad.u32_32 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+4
 671               		.loc 1 666 0
 672 037a 86E3      		ldi r24,lo8(54)
 673 037c 90E0      		ldi r25,0
 674 037e 00C0      		rjmp .L123
 675               	.LVL50:
 676               	.L49:
 670:main.c        ****                         scratchpad.u32_31 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+8
 677               		.loc 1 670 0
 678 0380 8AE3      		ldi r24,lo8(58)
 679 0382 90E0      		ldi r25,0
 680 0384 00D0      		rcall __eerd_dword_tn84
 681               	.LVL51:
 682 0386 6093 0000 		sts scratchpad+1,r22
 683 038a 7093 0000 		sts scratchpad+1+1,r23
 684 038e 8093 0000 		sts scratchpad+1+2,r24
 685 0392 9093 0000 		sts scratchpad+1+3,r25
 671:main.c        ****                         scratchpad.u32_32 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+1
 686               		.loc 1 671 0
 687 0396 8EE3      		ldi r24,lo8(62)
 688 0398 90E0      		ldi r25,0
 689               	.L123:
 690 039a 00D0      		rcall __eerd_dword_tn84
 691               	.LVL52:
 692 039c 6093 0000 		sts scratchpad+5,r22
 693 03a0 7093 0000 		sts scratchpad+5+1,r23
 694 03a4 8093 0000 		sts scratchpad+5+2,r24
 695 03a8 9093 0000 		sts scratchpad+5+3,r25
 672:main.c        ****                         break;
 696               		.loc 1 672 0
 697 03ac 00C0      		rjmp .L51
 698               	.LVL53:
 699               	.L41:
 675:main.c        ****                         scratchpad.u8_11 = 0xff;
 700               		.loc 1 675 0
 701 03ae 8FEF      		ldi r24,lo8(-1)
 702 03b0 8093 0000 		sts scratchpad+1,r24
 676:main.c        ****                         scratchpad.u8_12 = page; //this is actually an error! page unknown
 703               		.loc 1 676 0
 704 03b4 8091 0000 		lds r24,page
 705 03b8 8093 0000 		sts scratchpad+2,r24
 706               	.LVL54:
 707               	.L51:
 677:main.c        ****                         break;
 678:main.c        ****                     }
 679:main.c        ****                     lactbit=(lbitp&scratchpad.bytes[0])==lbitp;
 708               		.loc 1 679 0
 709 03bc 0091 0000 		lds r16,scratchpad
 710               	.LVL55:
 711 03c0 0170      		andi r16,lo8(1)
 712               	.LVL56:
 713 03c2 202F      		mov r18,r16
 620:main.c        ****                     lbytep=0;lscrc=0; //from first position
 714               		.loc 1 620 0
 715 03c4 C12C      		mov r12,__zero_reg__
 716 03c6 D12C      		mov r13,__zero_reg__
 617:main.c        ****                 lbitp=1;
 717               		.loc 1 617 0
 718 03c8 61E0      		ldi r22,lo8(1)
 620:main.c        ****                     lbytep=0;lscrc=0; //from first position
 719               		.loc 1 620 0
 720 03ca 10E0      		ldi r17,0
 619:main.c        ****                     lmode=OWM_WRITE_PAGE_TO_MASTER;
 721               		.loc 1 619 0
 722 03cc 3BE0      		ldi r19,lo8(11)
 680:main.c        ****                     lwmode=lactbit; //prepare for send firs bit
 681:main.c        ****                     break;
 723               		.loc 1 681 0
 724 03ce 00C0      		rjmp .L78
 725               	.LVL57:
 726               	.L40:
 682:main.c        ****                 } else page=0; // never happens, should be page[lbytepos]
 727               		.loc 1 682 0
 728 03d0 1092 0000 		sts page,__zero_reg__
 729 03d4 00C0      		rjmp .L88
 730               	.LVL58:
 731               	.L23:
 683:main.c        ****             }
 684:main.c        ****             break;
 685:main.c        ****         case OWM_WRITE_FUNC:
 686:main.c        ****             if (p) {
 732               		.loc 1 686 0
 733 03d6 7723      		tst r23
 734 03d8 01F0      		breq .L52
 687:main.c        ****                 scratchpad.bytes[lbytep]|=lbitp;
 735               		.loc 1 687 0
 736 03da E12F      		mov r30,r17
 737 03dc F0E0      		ldi r31,0
 738 03de E050      		subi r30,lo8(-(scratchpad))
 739 03e0 F040      		sbci r31,hi8(-(scratchpad))
 740 03e2 8081      		ld r24,Z
 741 03e4 862B      		or r24,r22
 742 03e6 8083      		st Z,r24
 743               	.L52:
 688:main.c        ****             }
 689:main.c        ****             /* Page(function) is part of CRC! */
 690:main.c        ****             if ((lscrc&1)!=p) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
 744               		.loc 1 690 0
 745 03e8 A601      		movw r20,r12
 746 03ea 4170      		andi r20,1
 747 03ec 5527      		clr r21
 748 03ee 872F      		mov r24,r23
 749 03f0 90E0      		ldi r25,0
 750 03f2 D694      		lsr r13
 751 03f4 C794      		ror r12
 752               	.LVL59:
 753 03f6 4817      		cp r20,r24
 754 03f8 5907      		cpc r21,r25
 755 03fa 01F0      		breq .L54
 756               		.loc 1 690 0 is_stmt 0 discriminator 1
 757 03fc BCE8      		ldi r27,140
 758 03fe CB26      		eor r12,r27
 759               	.LVL60:
 760               	.L54:
 691:main.c        ****             lbitp=(lbitp<<1);
 761               		.loc 1 691 0 is_stmt 1
 762 0400 660F      		lsl r22
 763               	.LVL61:
 692:main.c        ****             if (!lbitp) {
 764               		.loc 1 692 0
 765 0402 01F0      		breq .+2
 766 0404 00C0      		rjmp .L77
 693:main.c        ****                 lbytep++;
 767               		.loc 1 693 0
 768 0406 1F5F      		subi r17,lo8(-(1))
 769               	.LVL62:
 694:main.c        ****                 lbitp=1;
 695:main.c        ****                 if (lbytep==10) {
 770               		.loc 1 695 0
 771 0408 1A30      		cpi r17,lo8(10)
 772 040a 01F0      		breq .+2
 773 040c 00C0      		rjmp .L55
 696:main.c        ****                     /* now process received Write-function(s) if crc matches */
 697:main.c        ****                     if (scratchpad.bytes[9] != scratchpad.bytes[10])
 774               		.loc 1 697 0
 775 040e 9091 0000 		lds r25,scratchpad+9
 776 0412 8091 0000 		lds r24,scratchpad+10
 777 0416 9817      		cp r25,r24
 778 0418 01F0      		breq .L56
 698:main.c        ****                       crcerrcnt++;
 779               		.loc 1 698 0
 780 041a 8091 0000 		lds r24,crcerrcnt
 781 041e 8F5F      		subi r24,lo8(-(1))
 782 0420 8093 0000 		sts crcerrcnt,r24
 783 0424 00C0      		rjmp .L89
 784               	.L56:
 699:main.c        ****                     else {
 700:main.c        ****                       switch (scratchpad.bytes[0]) { /* "page" or function-id */
 785               		.loc 1 700 0
 786 0426 8091 0000 		lds r24,scratchpad
 787 042a 8232      		cpi r24,lo8(34)
 788 042c 01F4      		brne .+2
 789 042e 00C0      		rjmp .L62
 790 0430 00F4      		brsh .L65
 791 0432 8431      		cpi r24,lo8(20)
 792 0434 01F4      		brne .+2
 793 0436 00C0      		rjmp .L59
 794 0438 00F4      		brsh .L66
 795 043a 8130      		cpi r24,lo8(1)
 796 043c 01F0      		breq .L57
 797 043e 8031      		cpi r24,lo8(16)
 798 0440 01F0      		breq .+2
 799 0442 00C0      		rjmp .L89
 800 0444 00C0      		rjmp .L58
 801               	.L66:
 802 0446 8831      		cpi r24,lo8(24)
 803 0448 01F4      		brne .+2
 804 044a 00C0      		rjmp .L60
 805 044c 8C31      		cpi r24,lo8(28)
 806 044e 01F0      		breq .+2
 807 0450 00C0      		rjmp .L89
 808 0452 00C0      		rjmp .L61
 809               	.L65:
 810 0454 8C34      		cpi r24,lo8(76)
 811 0456 01F4      		brne .+2
 812 0458 00C0      		rjmp .L64
 813 045a 00F4      		brsh .L67
 814 045c 8332      		cpi r24,lo8(35)
 815 045e 01F4      		brne .+2
 816 0460 00C0      		rjmp .L63
 817 0462 8834      		cpi r24,lo8(72)
 818 0464 01F0      		breq .+2
 819 0466 00C0      		rjmp .L89
 820 0468 00C0      		rjmp .L64
 821               	.L67:
 822 046a 8035      		cpi r24,lo8(80)
 823 046c 01F4      		brne .+2
 824 046e 00C0      		rjmp .L64
 825 0470 8435      		cpi r24,lo8(84)
 826 0472 01F0      		breq .+2
 827 0474 00C0      		rjmp .L89
 828 0476 00C0      		rjmp .L64
 829               	.L57:
 701:main.c        ****                         case 1: /* reset-functions */
 702:main.c        ****                           if (scratchpad.bytes[1] == 1) /* reset counterX */ {
 830               		.loc 1 702 0
 831 0478 8091 0000 		lds r24,scratchpad+1
 832 047c 8130      		cpi r24,lo8(1)
 833 047e 01F0      		breq .+2
 834 0480 00C0      		rjmp .L89
 703:main.c        ****                             Counter1=0;Counter2=0;Counter3=0;Counter4=0;
 835               		.loc 1 703 0
 836 0482 1092 0000 		sts Counter1,__zero_reg__
 837 0486 1092 0000 		sts Counter1+1,__zero_reg__
 838 048a 1092 0000 		sts Counter1+2,__zero_reg__
 839 048e 1092 0000 		sts Counter1+3,__zero_reg__
 840 0492 1092 0000 		sts Counter2,__zero_reg__
 841 0496 1092 0000 		sts Counter2+1,__zero_reg__
 842 049a 1092 0000 		sts Counter2+2,__zero_reg__
 843 049e 1092 0000 		sts Counter2+3,__zero_reg__
 844 04a2 1092 0000 		sts Counter3,__zero_reg__
 845 04a6 1092 0000 		sts Counter3+1,__zero_reg__
 846 04aa 1092 0000 		sts Counter3+2,__zero_reg__
 847 04ae 1092 0000 		sts Counter3+3,__zero_reg__
 848 04b2 1092 0000 		sts Counter4,__zero_reg__
 849 04b6 1092 0000 		sts Counter4+1,__zero_reg__
 850 04ba 1092 0000 		sts Counter4+2,__zero_reg__
 851 04be 1092 0000 		sts Counter4+3,__zero_reg__
 852 04c2 00C0      		rjmp .L89
 853               	.L58:
 704:main.c        ****                           }
 705:main.c        ****                           break;
 706:main.c        ****                         case 16:
 707:main.c        ****                           Counter1 = scratchpad.u32_31;
 854               		.loc 1 707 0
 855 04c4 8091 0000 		lds r24,scratchpad+1
 856 04c8 9091 0000 		lds r25,scratchpad+1+1
 857 04cc A091 0000 		lds r26,scratchpad+1+2
 858 04d0 B091 0000 		lds r27,scratchpad+1+3
 859 04d4 8093 0000 		sts Counter1,r24
 860 04d8 9093 0000 		sts Counter1+1,r25
 861 04dc A093 0000 		sts Counter1+2,r26
 862 04e0 B093 0000 		sts Counter1+3,r27
 863 04e4 00C0      		rjmp .L89
 864               	.L59:
 708:main.c        ****                           break;
 709:main.c        ****                         case 20:
 710:main.c        ****                           Counter2 = scratchpad.u32_31;
 865               		.loc 1 710 0
 866 04e6 8091 0000 		lds r24,scratchpad+1
 867 04ea 9091 0000 		lds r25,scratchpad+1+1
 868 04ee A091 0000 		lds r26,scratchpad+1+2
 869 04f2 B091 0000 		lds r27,scratchpad+1+3
 870 04f6 8093 0000 		sts Counter2,r24
 871 04fa 9093 0000 		sts Counter2+1,r25
 872 04fe A093 0000 		sts Counter2+2,r26
 873 0502 B093 0000 		sts Counter2+3,r27
 874 0506 00C0      		rjmp .L89
 875               	.L60:
 711:main.c        ****                           break;
 712:main.c        ****                         case 24:
 713:main.c        ****                           Counter3 = scratchpad.u32_31;
 876               		.loc 1 713 0
 877 0508 8091 0000 		lds r24,scratchpad+1
 878 050c 9091 0000 		lds r25,scratchpad+1+1
 879 0510 A091 0000 		lds r26,scratchpad+1+2
 880 0514 B091 0000 		lds r27,scratchpad+1+3
 881 0518 8093 0000 		sts Counter3,r24
 882 051c 9093 0000 		sts Counter3+1,r25
 883 0520 A093 0000 		sts Counter3+2,r26
 884 0524 B093 0000 		sts Counter3+3,r27
 885 0528 00C0      		rjmp .L89
 886               	.L61:
 714:main.c        ****                           break;
 715:main.c        ****                         case 28:
 716:main.c        ****                           Counter4 = scratchpad.u32_31;
 887               		.loc 1 716 0
 888 052a 8091 0000 		lds r24,scratchpad+1
 889 052e 9091 0000 		lds r25,scratchpad+1+1
 890 0532 A091 0000 		lds r26,scratchpad+1+2
 891 0536 B091 0000 		lds r27,scratchpad+1+3
 892 053a 8093 0000 		sts Counter4,r24
 893 053e 9093 0000 		sts Counter4+1,r25
 894 0542 A093 0000 		sts Counter4+2,r26
 895 0546 B093 0000 		sts Counter4+3,r27
 896 054a 00C0      		rjmp .L89
 897               	.L62:
 717:main.c        ****                           break;
 718:main.c        ****                         case 34:
 719:main.c        ****                           //Pullups XXX = scratchpad.u8_11;
 720:main.c        ****                           //FIXME: Bitwise! each separate
 721:main.c        ****                           if (scratchpad.bytes[1] == 0) {
 898               		.loc 1 721 0
 899 054c 8091 0000 		lds r24,scratchpad+1
 900 0550 8111      		cpse r24,__zero_reg__
 901 0552 00C0      		rjmp .L68
 722:main.c        ****                             PORTB &= ~( (1<<PB1) ); /* disable internal Pull-Up PB1 */ \
 902               		.loc 1 722 0
 903 0554 C198      		cbi 0x18,1
 723:main.c        ****                             PORTA &= ~( (1<<PA3)|(1<<PA4)|(1<<PA5) ); /* disable internal Pull-Up P
 904               		.loc 1 723 0
 905 0556 8BB3      		in r24,0x1b
 906 0558 877C      		andi r24,lo8(-57)
 907 055a 00C0      		rjmp .L124
 908               	.L68:
 724:main.c        ****                           } else if (scratchpad.bytes[1] == 1) {
 909               		.loc 1 724 0
 910 055c 8091 0000 		lds r24,scratchpad+1
 911 0560 8130      		cpi r24,lo8(1)
 912 0562 01F4      		brne .L69
 725:main.c        ****                             PORTB |= ( (1<<PB1) ); /* activate internal Pull-Up PB1 */ \
 913               		.loc 1 725 0
 914 0564 C19A      		sbi 0x18,1
 726:main.c        ****                             PORTA |= ( (1<<PA3)|(1<<PA4)|(1<<PA5) ); /* activate internal Pull-Up P
 915               		.loc 1 726 0
 916 0566 8BB3      		in r24,0x1b
 917 0568 8863      		ori r24,lo8(56)
 918               	.L124:
 919 056a 8BBB      		out 0x1b,r24
 920               	.L69:
 727:main.c        ****                           }
 728:main.c        ****                           pullupcfg = scratchpad.bytes[1];
 921               		.loc 1 728 0
 922 056c 8091 0000 		lds r24,scratchpad+1
 923 0570 8093 0000 		sts pullupcfg,r24
 729:main.c        ****                           eeprom_write_byte((uint8_t *) (EE_PULLUP_OFFSET+0), scratchpad.bytes[1]);
 924               		.loc 1 729 0
 925 0574 6091 0000 		lds r22,scratchpad+1
 926 0578 8FE2      		ldi r24,lo8(47)
 927 057a 90E0      		ldi r25,0
 928 057c 2983      		std Y+1,r18
 929 057e 00D0      		rcall __eewr_byte_tn84
 930               	.LVL63:
 694:main.c        ****                 lbitp=1;
 931               		.loc 1 694 0
 932 0580 61E0      		ldi r22,lo8(1)
 730:main.c        ****                           break;
 933               		.loc 1 730 0
 934 0582 2981      		ldd r18,Y+1
 935 0584 00C0      		rjmp .L80
 936               	.LVL64:
 937               	.L63:
 731:main.c        ****                         case 35:
 732:main.c        ****                           /* TODO / FIXME: Set output ports/Check! */
 733:main.c        ****                           outstate = scratchpad.bytes[1]; /* EEprom-save is done on pwrdown only! *
 938               		.loc 1 733 0
 939 0586 8091 0000 		lds r24,scratchpad+1
 940 058a 8093 0000 		sts outstate,r24
 734:main.c        ****                           /* Quirky FIXME */
 735:main.c        ****                           if (outstate & 0x01)
 941               		.loc 1 735 0
 942 058e 80FF      		sbrs r24,0
 943 0590 00C0      		rjmp .L70
 736:main.c        ****                             OUTA_PORT |= (1 <<OUTA_PIN);
 944               		.loc 1 736 0
 945 0592 D89A      		sbi 0x1b,0
 946 0594 00C0      		rjmp .L71
 947               	.L70:
 737:main.c        ****                           else
 738:main.c        ****                             OUTA_PORT &= ~(1 <<OUTA_PIN);
 948               		.loc 1 738 0
 949 0596 D898      		cbi 0x1b,0
 950               	.L71:
 739:main.c        ****                           if (outstate & 0x02)
 951               		.loc 1 739 0
 952 0598 8091 0000 		lds r24,outstate
 953 059c 81FF      		sbrs r24,1
 954 059e 00C0      		rjmp .L72
 740:main.c        ****                             OUTB_PORT |= (1 <<OUTB_PIN);
 955               		.loc 1 740 0
 956 05a0 D99A      		sbi 0x1b,1
 957 05a2 00C0      		rjmp .L89
 958               	.L72:
 741:main.c        ****                           else
 742:main.c        ****                             OUTB_PORT &= ~(1 <<OUTB_PIN);
 959               		.loc 1 742 0
 960 05a4 D998      		cbi 0x1b,1
 961 05a6 00C0      		rjmp .L89
 962               	.L64:
 743:main.c        ****                           break;
 744:main.c        ****                         case 72:
 745:main.c        ****                         case 76:
 746:main.c        ****                         case 80:
 747:main.c        ****                         case 84:
 748:main.c        ****                           if (ewrite_flag > 0) //last write still pending!
 963               		.loc 1 748 0
 964 05a8 8091 0000 		lds r24,ewrite_flag
 965 05ac 8111      		cpse r24,__zero_reg__
 966 05ae 00C0      		rjmp .L89
 749:main.c        ****                             break;
 750:main.c        ****                           eewrite_buf.u32_1 = scratchpad.u32_31;
 967               		.loc 1 750 0
 968 05b0 8091 0000 		lds r24,scratchpad+1
 969 05b4 9091 0000 		lds r25,scratchpad+1+1
 970 05b8 A091 0000 		lds r26,scratchpad+1+2
 971 05bc B091 0000 		lds r27,scratchpad+1+3
 972 05c0 8093 0000 		sts eewrite_buf,r24
 973 05c4 9093 0000 		sts eewrite_buf+1,r25
 974 05c8 A093 0000 		sts eewrite_buf+2,r26
 975 05cc B093 0000 		sts eewrite_buf+3,r27
 751:main.c        ****                           ewrite_flag = (scratchpad.page1) - 72 + EE_LABEL_OFFSET;
 976               		.loc 1 751 0
 977 05d0 8091 0000 		lds r24,scratchpad
 978 05d4 8651      		subi r24,lo8(-(-22))
 979 05d6 8093 0000 		sts ewrite_flag,r24
 980 05da 00C0      		rjmp .L89
 981               	.L55:
 752:main.c        ****                           break;
 753:main.c        ****                         default:
 754:main.c        ****                           if (scratchpad.page1 > 71 && scratchpad.page1 < 72+EE_LABEL_MAXLEN)
 755:main.c        ****                             ; //alternatively: just write it?
 756:main.c        ****                           break;
 757:main.c        ****                       }
 758:main.c        ****                     }
 759:main.c        ****                     lmode=OWM_SLEEP;
 760:main.c        ****                     break;
 761:main.c        ****                 } else scratchpad.bytes[lbytep]=0;
 982               		.loc 1 761 0
 983 05dc E12F      		mov r30,r17
 984 05de F0E0      		ldi r31,0
 985 05e0 E050      		subi r30,lo8(-(scratchpad))
 986 05e2 F040      		sbci r31,hi8(-(scratchpad))
 987 05e4 1082      		st Z,__zero_reg__
 762:main.c        ****                 if (lbytep==9) {
 988               		.loc 1 762 0
 989 05e6 1930      		cpi r17,lo8(9)
 990 05e8 01F0      		breq .+2
 991 05ea 00C0      		rjmp .L88
 763:main.c        ****                     //copy calculated CRC to last scratchpad-byte as we receive it with next byte!
 764:main.c        ****                     scratchpad.bytes[10] = lscrc;
 992               		.loc 1 764 0
 993 05ec C092 0000 		sts scratchpad+10,r12
 994 05f0 00C0      		rjmp .L88
 995               	.LVL65:
 996               	.L22:
 765:main.c        ****                 }
 766:main.c        ****             }
 767:main.c        ****             break;
 768:main.c        ****         case OWM_WRITE_PAGE_TO_MASTER:
 769:main.c        ****             RESET_LOW;
 997               		.loc 1 769 0
 998 05f2 BA98      		cbi 0x17,2
 770:main.c        ****             if ((lscrc&1)!=lactbit) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
 999               		.loc 1 770 0
 1000 05f4 A601      		movw r20,r12
 1001 05f6 4170      		andi r20,1
 1002 05f8 5527      		clr r21
 1003 05fa 822F      		mov r24,r18
 1004 05fc 90E0      		ldi r25,0
 1005 05fe D694      		lsr r13
 1006 0600 C794      		ror r12
 1007               	.LVL66:
 1008 0602 4817      		cp r20,r24
 1009 0604 5907      		cpc r21,r25
 1010 0606 01F0      		breq .L74
 1011               		.loc 1 770 0 is_stmt 0 discriminator 1
 1012 0608 ECE8      		ldi r30,140
 1013 060a CE26      		eor r12,r30
 1014               	.LVL67:
 1015               	.L74:
 771:main.c        ****             lbitp=(lbitp<<1);
 1016               		.loc 1 771 0 is_stmt 1
 1017 060c 660F      		lsl r22
 1018               	.LVL68:
 772:main.c        ****             if (!lbitp) {
 1019               		.loc 1 772 0
 1020 060e 01F4      		brne .L75
 773:main.c        ****                 lbytep++;
 1021               		.loc 1 773 0
 1022 0610 1F5F      		subi r17,lo8(-(1))
 1023               	.LVL69:
 774:main.c        ****                 lbitp=1;
 775:main.c        ****                 if (lbytep>=10) {
 1024               		.loc 1 775 0
 1025 0612 1A30      		cpi r17,lo8(10)
 1026 0614 00F0      		brlo .+2
 1027 0616 00C0      		rjmp .L89
 776:main.c        ****                     lmode=OWM_SLEEP;
 777:main.c        ****                     break;
 778:main.c        ****                 } else if (lbytep==9) scratchpad.bytes[9]=lscrc;
 1028               		.loc 1 778 0
 1029 0618 1930      		cpi r17,lo8(9)
 1030 061a 01F4      		brne .L90
 1031               		.loc 1 778 0 is_stmt 0 discriminator 1
 1032 061c C092 0000 		sts scratchpad+9,r12
 1033               	.L90:
 774:main.c        ****                 lbitp=1;
 1034               		.loc 1 774 0 is_stmt 1
 1035 0620 61E0      		ldi r22,lo8(1)
 1036               	.LVL70:
 1037               	.L75:
 779:main.c        ****             }
 780:main.c        ****             lactbit=(lbitp&scratchpad.bytes[lbytep])==lbitp;
 1038               		.loc 1 780 0
 1039 0622 E12F      		mov r30,r17
 1040 0624 F0E0      		ldi r31,0
 1041 0626 E050      		subi r30,lo8(-(scratchpad))
 1042 0628 F040      		sbci r31,hi8(-(scratchpad))
 1043 062a 8081      		ld r24,Z
 1044 062c 8623      		and r24,r22
 1045 062e 21E0      		ldi r18,lo8(1)
 1046               	.LVL71:
 1047 0630 8613      		cpse r24,r22
 1048 0632 20E0      		ldi r18,0
 1049               	.L76:
 1050               	.LVL72:
 781:main.c        ****             lwmode=lactbit;
 1051               		.loc 1 781 0
 1052 0634 022F      		mov r16,r18
 782:main.c        ****             break;
 1053               		.loc 1 782 0
 1054 0636 00C0      		rjmp .L77
 1055               	.LVL73:
 1056               	.L15:
 783:main.c        ****         }
 784:main.c        ****         if (lmode==OWM_SLEEP) {
 1057               		.loc 1 784 0
 1058 0638 3111      		cpse r19,__zero_reg__
 1059 063a 00C0      		rjmp .L77
 1060               	.LVL74:
 1061               	.L80:
 785:main.c        ****           //RESET_LOW;  //??? Set pin as input again ???
 786:main.c        ****           DIS_TIMER;
 1062               		.loc 1 786 0
 1063 063c 89B7      		in r24,0x39
 1064 063e 8E7F      		andi r24,lo8(-2)
 1065 0640 89BF      		out 0x39,r24
 787:main.c        ****           EN_OWINT; SET_OWINT_LOWLEVEL;
 1066               		.loc 1 787 0
 1067 0642 8BB7      		in r24,0x3b
 1068 0644 8064      		ori r24,lo8(64)
 1069 0646 8BBF      		out 0x3b,r24
 1070 0648 80E4      		ldi r24,lo8(64)
 1071 064a 8ABF      		out 0x3a,r24
 1072 064c 85B7      		in r24,0x35
 1073 064e 8C7F      		andi r24,lo8(-4)
 1074 0650 85BF      		out 0x35,r24
 788:main.c        ****           sleepmode=SLEEP_MODE_PWR_DOWN; //sleep deep
 1075               		.loc 1 788 0
 1076 0652 80E1      		ldi r24,lo8(16)
 1077 0654 8093 0000 		sts sleepmode,r24
 789:main.c        ****           OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
 1078               		.loc 1 789 0
 1079 0658 DA98      		cbi 0x1b,2
 1080 065a 30E0      		ldi r19,0
 1081 065c 00C0      		rjmp .L78
 1082               	.LVL75:
 1083               	.L77:
 790:main.c        ****         } else {
 791:main.c        ****           //sleepmode=SLEEP_MODE_IDLE; //no sleep
 792:main.c        ****         }
 793:main.c        **** 
 794:main.c        ****         if (lmode!=OWM_PRESENCE)  {
 1084               		.loc 1 794 0
 1085 065e 3230      		cpi r19,lo8(2)
 1086 0660 01F0      		breq .L79
 1087               	.LVL76:
 1088               	.L78:
 795:main.c        ****             TCNT_REG=~(OWT_MIN_RESET-OWT_READLINE);  //OWT_READLINE around OWT_LOWTIME
 1089               		.loc 1 795 0
 1090 0662 8EEC      		ldi r24,lo8(-50)
 1091 0664 82BF      		out 0x32,r24
 796:main.c        ****             EN_OWINT;
 1092               		.loc 1 796 0
 1093 0666 8BB7      		in r24,0x3b
 1094 0668 8064      		ori r24,lo8(64)
 1095 066a 8BBF      		out 0x3b,r24
 1096 066c 80E4      		ldi r24,lo8(64)
 1097 066e 8ABF      		out 0x3a,r24
 1098               	.L79:
 797:main.c        ****         }
 798:main.c        ****         mode=lmode;
 1099               		.loc 1 798 0
 1100 0670 3093 0000 		sts mode,r19
 799:main.c        ****         wmode=lwmode;
 1101               		.loc 1 799 0
 1102 0674 0093 0000 		sts wmode,r16
 800:main.c        ****         bytep=lbytep;
 1103               		.loc 1 800 0
 1104 0678 1093 0000 		sts bytep,r17
 801:main.c        ****         bitp=lbitp;
 1105               		.loc 1 801 0
 1106 067c 6093 0000 		sts bitp,r22
 802:main.c        ****         srcount=lsrcount;
 1107               		.loc 1 802 0
 1108 0680 F092 0000 		sts srcount,r15
 803:main.c        ****         actbit=lactbit;
 1109               		.loc 1 803 0
 1110 0684 2093 0000 		sts actbit,r18
 804:main.c        ****         scrc=lscrc;
 1111               		.loc 1 804 0
 1112 0688 D092 0000 		sts scrc+1,r13
 1113 068c C092 0000 		sts scrc,r12
 1114 0690 00C0      		rjmp .L121
 1115               	.LVL77:
 1116               	.L82:
 535:main.c        ****                 lbitp=1;
 1117               		.loc 1 535 0
 1118 0692 61E0      		ldi r22,lo8(1)
 538:main.c        ****                         lbytep=0;
 1119               		.loc 1 538 0
 1120 0694 10E0      		ldi r17,0
 1121               	.LVL78:
 539:main.c        ****                         lmode=OWM_MATCH_ROM;
 1122               		.loc 1 539 0
 1123 0696 35E0      		ldi r19,lo8(5)
 1124               	.LVL79:
 1125 0698 00C0      		rjmp .L78
 1126               	.LVL80:
 1127               	.L88:
 694:main.c        ****                 lbitp=1;
 1128               		.loc 1 694 0
 1129 069a 61E0      		ldi r22,lo8(1)
 1130 069c 00C0      		rjmp .L77
 1131               	.LVL81:
 1132               	.L89:
 774:main.c        ****                 lbitp=1;
 1133               		.loc 1 774 0
 1134 069e 61E0      		ldi r22,lo8(1)
 1135               	.LVL82:
 1136 06a0 00C0      		rjmp .L80
 1137               	.LVL83:
 1138               	.L121:
 1139               	/* epilogue start */
 805:main.c        **** }
 1140               		.loc 1 805 0
 1141 06a2 0F90      		pop __tmp_reg__
 1142 06a4 DF91      		pop r29
 1143 06a6 CF91      		pop r28
 1144 06a8 FF91      		pop r31
 1145 06aa EF91      		pop r30
 1146 06ac BF91      		pop r27
 1147 06ae AF91      		pop r26
 1148 06b0 9F91      		pop r25
 1149 06b2 8F91      		pop r24
 1150 06b4 7F91      		pop r23
 1151 06b6 6F91      		pop r22
 1152 06b8 5F91      		pop r21
 1153 06ba 4F91      		pop r20
 1154 06bc 3F91      		pop r19
 1155 06be 2F91      		pop r18
 1156 06c0 1F91      		pop r17
 1157 06c2 0F91      		pop r16
 1158 06c4 FF90      		pop r15
 1159 06c6 DF90      		pop r13
 1160 06c8 CF90      		pop r12
 1161 06ca 0F90      		pop r0
 1162 06cc 0FBE      		out __SREG__,r0
 1163 06ce 0F90      		pop r0
 1164 06d0 1F90      		pop r1
 1165 06d2 1895      		reti
 1166               	.LFE1:
 1168               	.global	__vector_2
 1170               	__vector_2:
 1171               	.LFB2:
 806:main.c        **** 
 807:main.c        **** #ifdef PC_INT_ISR
 808:main.c        **** PC_INT_ISR  //for counting  defined for specific device
 809:main.c        **** #elif defined PC_INT_ISRA
 810:main.c        **** PC_INT_ISRA
 1172               		.loc 1 810 0
 1173 06d4 1F92      		push r1
 1174               	.LCFI30:
 1175 06d6 0F92      		push r0
 1176               	.LCFI31:
 1177 06d8 0FB6      		in r0,__SREG__
 1178 06da 0F92      		push r0
 1179 06dc 1124      		clr __zero_reg__
 1180 06de 8F93      		push r24
 1181               	.LCFI32:
 1182 06e0 9F93      		push r25
 1183               	.LCFI33:
 1184 06e2 AF93      		push r26
 1185               	.LCFI34:
 1186 06e4 BF93      		push r27
 1187               	.LCFI35:
 1188               	/* prologue: Signal */
 1189               	/* frame size = 0 */
 1190               	/* stack size = 7 */
 1191               	.L__stack_usage = 7
 1192               		.loc 1 810 0
 1193 06e6 CB99      		sbic 0x19,3
 1194 06e8 00C0      		rjmp .L127
 1195               		.loc 1 810 0 is_stmt 0 discriminator 1
 1196 06ea 8091 0000 		lds r24,pinstatA
 1197 06ee 83FF      		sbrs r24,3
 1198 06f0 00C0      		rjmp .L127
 1199               		.loc 1 810 0 discriminator 3
 1200 06f2 8091 0000 		lds r24,Counter2
 1201 06f6 9091 0000 		lds r25,Counter2+1
 1202 06fa A091 0000 		lds r26,Counter2+2
 1203 06fe B091 0000 		lds r27,Counter2+3
 1204 0702 0196      		adiw r24,1
 1205 0704 A11D      		adc r26,__zero_reg__
 1206 0706 B11D      		adc r27,__zero_reg__
 1207 0708 8093 0000 		sts Counter2,r24
 1208 070c 9093 0000 		sts Counter2+1,r25
 1209 0710 A093 0000 		sts Counter2+2,r26
 1210 0714 B093 0000 		sts Counter2+3,r27
 1211               	.L127:
 1212               		.loc 1 810 0 discriminator 2
 1213 0718 CC99      		sbic 0x19,4
 1214 071a 00C0      		rjmp .L128
 1215               		.loc 1 810 0 discriminator 4
 1216 071c 8091 0000 		lds r24,pinstatA
 1217 0720 84FF      		sbrs r24,4
 1218 0722 00C0      		rjmp .L128
 1219               		.loc 1 810 0 discriminator 6
 1220 0724 8091 0000 		lds r24,Counter3
 1221 0728 9091 0000 		lds r25,Counter3+1
 1222 072c A091 0000 		lds r26,Counter3+2
 1223 0730 B091 0000 		lds r27,Counter3+3
 1224 0734 0196      		adiw r24,1
 1225 0736 A11D      		adc r26,__zero_reg__
 1226 0738 B11D      		adc r27,__zero_reg__
 1227 073a 8093 0000 		sts Counter3,r24
 1228 073e 9093 0000 		sts Counter3+1,r25
 1229 0742 A093 0000 		sts Counter3+2,r26
 1230 0746 B093 0000 		sts Counter3+3,r27
 1231               	.L128:
 1232               		.loc 1 810 0 discriminator 5
 1233 074a CD99      		sbic 0x19,5
 1234 074c 00C0      		rjmp .L129
 1235               		.loc 1 810 0 discriminator 7
 1236 074e 8091 0000 		lds r24,pinstatA
 1237 0752 85FF      		sbrs r24,5
 1238 0754 00C0      		rjmp .L129
 1239               		.loc 1 810 0 discriminator 9
 1240 0756 8091 0000 		lds r24,Counter4
 1241 075a 9091 0000 		lds r25,Counter4+1
 1242 075e A091 0000 		lds r26,Counter4+2
 1243 0762 B091 0000 		lds r27,Counter4+3
 1244 0766 0196      		adiw r24,1
 1245 0768 A11D      		adc r26,__zero_reg__
 1246 076a B11D      		adc r27,__zero_reg__
 1247 076c 8093 0000 		sts Counter4,r24
 1248 0770 9093 0000 		sts Counter4+1,r25
 1249 0774 A093 0000 		sts Counter4+2,r26
 1250 0778 B093 0000 		sts Counter4+3,r27
 1251               	.L129:
 1252               		.loc 1 810 0 discriminator 8
 1253 077c 89B3      		in r24,0x19
 1254 077e 8093 0000 		sts pinstatA,r24
 1255               	/* epilogue start */
 1256 0782 BF91      		pop r27
 1257 0784 AF91      		pop r26
 1258 0786 9F91      		pop r25
 1259 0788 8F91      		pop r24
 1260 078a 0F90      		pop r0
 1261 078c 0FBE      		out __SREG__,r0
 1262 078e 0F90      		pop r0
 1263 0790 1F90      		pop r1
 1264 0792 1895      		reti
 1265               	.LFE2:
 1267               	.global	__vector_3
 1269               	__vector_3:
 1270               	.LFB3:
 811:main.c        **** PC_INT_ISRB
 1271               		.loc 1 811 0 is_stmt 1
 1272 0794 1F92      		push r1
 1273               	.LCFI36:
 1274 0796 0F92      		push r0
 1275               	.LCFI37:
 1276 0798 0FB6      		in r0,__SREG__
 1277 079a 0F92      		push r0
 1278 079c 1124      		clr __zero_reg__
 1279 079e 2F93      		push r18
 1280               	.LCFI38:
 1281 07a0 3F93      		push r19
 1282               	.LCFI39:
 1283 07a2 4F93      		push r20
 1284               	.LCFI40:
 1285 07a4 5F93      		push r21
 1286               	.LCFI41:
 1287 07a6 6F93      		push r22
 1288               	.LCFI42:
 1289 07a8 7F93      		push r23
 1290               	.LCFI43:
 1291 07aa 8F93      		push r24
 1292               	.LCFI44:
 1293 07ac 9F93      		push r25
 1294               	.LCFI45:
 1295 07ae AF93      		push r26
 1296               	.LCFI46:
 1297 07b0 BF93      		push r27
 1298               	.LCFI47:
 1299 07b2 EF93      		push r30
 1300               	.LCFI48:
 1301 07b4 FF93      		push r31
 1302               	.LCFI49:
 1303               	/* prologue: Signal */
 1304               	/* frame size = 0 */
 1305               	/* stack size = 15 */
 1306               	.L__stack_usage = 15
 1307               		.loc 1 811 0
 1308 07b6 B199      		sbic 0x16,1
 1309 07b8 00C0      		rjmp .L140
 1310               		.loc 1 811 0 is_stmt 0 discriminator 1
 1311 07ba 8091 0000 		lds r24,pinstatB
 1312 07be 81FF      		sbrs r24,1
 1313 07c0 00C0      		rjmp .L140
 1314               		.loc 1 811 0 discriminator 3
 1315 07c2 8091 0000 		lds r24,Counter1
 1316 07c6 9091 0000 		lds r25,Counter1+1
 1317 07ca A091 0000 		lds r26,Counter1+2
 1318 07ce B091 0000 		lds r27,Counter1+3
 1319 07d2 0196      		adiw r24,1
 1320 07d4 A11D      		adc r26,__zero_reg__
 1321 07d6 B11D      		adc r27,__zero_reg__
 1322 07d8 8093 0000 		sts Counter1,r24
 1323 07dc 9093 0000 		sts Counter1+1,r25
 1324 07e0 A093 0000 		sts Counter1+2,r26
 1325 07e4 B093 0000 		sts Counter1+3,r27
 1326               	.L140:
 1327               		.loc 1 811 0 discriminator 2
 1328 07e8 B099      		sbic 0x16,0
 1329 07ea 00C0      		rjmp .L141
 1330               		.loc 1 811 0 discriminator 4
 1331 07ec 8091 0000 		lds r24,pinstatB
 1332 07f0 80FF      		sbrs r24,0
 1333 07f2 00C0      		rjmp .L141
 1334               		.loc 1 811 0 discriminator 6
 1335 07f4 4091 0000 		lds r20,Counter1
 1336 07f8 5091 0000 		lds r21,Counter1+1
 1337 07fc 6091 0000 		lds r22,Counter1+2
 1338 0800 7091 0000 		lds r23,Counter1+3
 1339 0804 8CE0      		ldi r24,lo8(12)
 1340 0806 90E0      		ldi r25,0
 1341 0808 00D0      		rcall __eeupd_dword_tn84
 1342               	.LVL84:
 1343 080a 4091 0000 		lds r20,Counter2
 1344 080e 5091 0000 		lds r21,Counter2+1
 1345 0812 6091 0000 		lds r22,Counter2+2
 1346 0816 7091 0000 		lds r23,Counter2+3
 1347 081a 80E1      		ldi r24,lo8(16)
 1348 081c 90E0      		ldi r25,0
 1349 081e 00D0      		rcall __eeupd_dword_tn84
 1350               	.LVL85:
 1351 0820 4091 0000 		lds r20,Counter3
 1352 0824 5091 0000 		lds r21,Counter3+1
 1353 0828 6091 0000 		lds r22,Counter3+2
 1354 082c 7091 0000 		lds r23,Counter3+3
 1355 0830 84E1      		ldi r24,lo8(20)
 1356 0832 90E0      		ldi r25,0
 1357 0834 00D0      		rcall __eeupd_dword_tn84
 1358               	.LVL86:
 1359 0836 4091 0000 		lds r20,Counter4
 1360 083a 5091 0000 		lds r21,Counter4+1
 1361 083e 6091 0000 		lds r22,Counter4+2
 1362 0842 7091 0000 		lds r23,Counter4+3
 1363 0846 88E1      		ldi r24,lo8(24)
 1364 0848 90E0      		ldi r25,0
 1365 084a 00D0      		rcall __eeupd_dword_tn84
 1366               	.LVL87:
 1367 084c 6091 0000 		lds r22,outstate
 1368 0850 80E3      		ldi r24,lo8(48)
 1369 0852 90E0      		ldi r25,0
 1370 0854 00D0      		rcall __eeupd_byte_tn84
 1371               	.LVL88:
 1372               	.L141:
 1373               		.loc 1 811 0 discriminator 5
 1374 0856 86B3      		in r24,0x16
 1375 0858 8093 0000 		sts pinstatB,r24
 1376               	/* epilogue start */
 1377 085c FF91      		pop r31
 1378 085e EF91      		pop r30
 1379 0860 BF91      		pop r27
 1380 0862 AF91      		pop r26
 1381 0864 9F91      		pop r25
 1382 0866 8F91      		pop r24
 1383 0868 7F91      		pop r23
 1384 086a 6F91      		pop r22
 1385 086c 5F91      		pop r21
 1386 086e 4F91      		pop r20
 1387 0870 3F91      		pop r19
 1388 0872 2F91      		pop r18
 1389 0874 0F90      		pop r0
 1390 0876 0FBE      		out __SREG__,r0
 1391 0878 0F90      		pop r0
 1392 087a 1F90      		pop r1
 1393 087c 1895      		reti
 1394               	.LFE3:
 1396               	.global	init_eeprom
 1398               	init_eeprom:
 1399               	.LFB4:
 812:main.c        **** #endif
 813:main.c        **** 
 814:main.c        **** void init_eeprom(void) {
 1400               		.loc 1 814 0 is_stmt 1
 1401 087e 0F93      		push r16
 1402               	.LCFI50:
 1403 0880 1F93      		push r17
 1404               	.LCFI51:
 1405 0882 CF93      		push r28
 1406               	.LCFI52:
 1407 0884 DF93      		push r29
 1408               	.LCFI53:
 1409               	/* prologue: function */
 1410               	/* frame size = 0 */
 1411               	/* stack size = 4 */
 1412               	.L__stack_usage = 4
 815:main.c        ****     /* check magic, read slave address and counter values, resetcount, init-name, */
 816:main.c        ****     if (eeprom_read_word((const uint16_t *) (EE_MAGIC_OFFSET+0)) == EE_MAGIC_NUMBER) {
 1413               		.loc 1 816 0
 1414 0886 80E0      		ldi r24,0
 1415 0888 90E0      		ldi r25,0
 1416 088a 00D0      		rcall __eerd_word_tn84
 1417               	.LVL89:
 1418 088c 823E      		cpi r24,-30
 1419 088e 914E      		sbci r25,-31
 1420 0890 01F0      		breq .+2
 1421 0892 00C0      		rjmp .L149
 1422 0894 00E0      		ldi r16,lo8(owid)
 1423 0896 10E0      		ldi r17,hi8(owid)
 1424 0898 C2E0      		ldi r28,lo8(2)
 1425 089a D0E0      		ldi r29,0
 1426               	.L150:
 1427               	.LBB2:
 817:main.c        ****       //EEPROM valid -> read counters & settings
 818:main.c        ****       for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 819:main.c        ****         owid[i-EE_OWID_OFFSET] = eeprom_read_byte((uint8_t *) i);
 1428               		.loc 1 819 0 discriminator 2
 1429 089c CE01      		movw r24,r28
 1430 089e 00D0      		rcall __eerd_byte_tn84
 1431               	.LVL90:
 1432 08a0 F801      		movw r30,r16
 1433 08a2 8193      		st Z+,r24
 1434 08a4 8F01      		movw r16,r30
 818:main.c        ****       for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 1435               		.loc 1 818 0 discriminator 2
 1436 08a6 2196      		adiw r28,1
 1437               	.LVL91:
 1438 08a8 CA30      		cpi r28,10
 1439 08aa D105      		cpc r29,__zero_reg__
 1440 08ac 01F4      		brne .L150
 1441               	.LBE2:
 820:main.c        ****       rcnt = eeprom_read_word((const uint16_t *) (EE_RCNT_OFFSET+0)) + 1;
 1442               		.loc 1 820 0
 1443 08ae 8AE0      		ldi r24,lo8(10)
 1444 08b0 90E0      		ldi r25,0
 1445 08b2 00D0      		rcall __eerd_word_tn84
 1446               	.LVL92:
 1447 08b4 BC01      		movw r22,r24
 1448 08b6 6F5F      		subi r22,-1
 1449 08b8 7F4F      		sbci r23,-1
 1450 08ba 7093 0000 		sts rcnt+1,r23
 1451 08be 6093 0000 		sts rcnt,r22
 821:main.c        ****       eeprom_update_word((uint16_t *) (EE_RCNT_OFFSET+0), rcnt);
 1452               		.loc 1 821 0
 1453 08c2 8AE0      		ldi r24,lo8(10)
 1454 08c4 90E0      		ldi r25,0
 1455 08c6 00D0      		rcall __eeupd_word_tn84
 1456               	.LVL93:
 822:main.c        ****       //FIXME: this eats flashmem!
 823:main.c        ****       Counter1 = eeprom_read_dword((const uint32_t *) (EE_COUNTER_OFFSET+0));
 1457               		.loc 1 823 0
 1458 08c8 8CE0      		ldi r24,lo8(12)
 1459 08ca 90E0      		ldi r25,0
 1460 08cc 00D0      		rcall __eerd_dword_tn84
 1461               	.LVL94:
 1462 08ce 6093 0000 		sts Counter1,r22
 1463 08d2 7093 0000 		sts Counter1+1,r23
 1464 08d6 8093 0000 		sts Counter1+2,r24
 1465 08da 9093 0000 		sts Counter1+3,r25
 824:main.c        ****       Counter2 = eeprom_read_dword((const uint32_t *) (EE_COUNTER_OFFSET+4));
 1466               		.loc 1 824 0
 1467 08de 80E1      		ldi r24,lo8(16)
 1468 08e0 90E0      		ldi r25,0
 1469 08e2 00D0      		rcall __eerd_dword_tn84
 1470               	.LVL95:
 1471 08e4 6093 0000 		sts Counter2,r22
 1472 08e8 7093 0000 		sts Counter2+1,r23
 1473 08ec 8093 0000 		sts Counter2+2,r24
 1474 08f0 9093 0000 		sts Counter2+3,r25
 825:main.c        ****       Counter3 = eeprom_read_dword((const uint32_t *) (EE_COUNTER_OFFSET+8));
 1475               		.loc 1 825 0
 1476 08f4 84E1      		ldi r24,lo8(20)
 1477 08f6 90E0      		ldi r25,0
 1478 08f8 00D0      		rcall __eerd_dword_tn84
 1479               	.LVL96:
 1480 08fa 6093 0000 		sts Counter3,r22
 1481 08fe 7093 0000 		sts Counter3+1,r23
 1482 0902 8093 0000 		sts Counter3+2,r24
 1483 0906 9093 0000 		sts Counter3+3,r25
 826:main.c        ****       Counter4 = eeprom_read_dword((const uint32_t *) (EE_COUNTER_OFFSET+12));
 1484               		.loc 1 826 0
 1485 090a 88E1      		ldi r24,lo8(24)
 1486 090c 90E0      		ldi r25,0
 1487 090e 00D0      		rcall __eerd_dword_tn84
 1488               	.LVL97:
 1489 0910 6093 0000 		sts Counter4,r22
 1490 0914 7093 0000 		sts Counter4+1,r23
 1491 0918 8093 0000 		sts Counter4+2,r24
 1492 091c 9093 0000 		sts Counter4+3,r25
 827:main.c        ****       //FIXME: read/write if counting on falling/rising-edge ?
 828:main.c        ****       version = eeprom_read_word((const uint16_t *) (EE_VERSION_OFFSET+0));
 1493               		.loc 1 828 0
 1494 0920 8DE2      		ldi r24,lo8(45)
 1495 0922 90E0      		ldi r25,0
 1496 0924 00D0      		rcall __eerd_word_tn84
 1497               	.LVL98:
 1498 0926 9093 0000 		sts version+1,r25
 1499 092a 8093 0000 		sts version,r24
 829:main.c        ****       stype = eeprom_read_byte((uint8_t *) (EE_TYPE_OFFSET+0));
 1500               		.loc 1 829 0
 1501 092e 8CE2      		ldi r24,lo8(44)
 1502 0930 90E0      		ldi r25,0
 1503 0932 00D0      		rcall __eerd_byte_tn84
 1504               	.LVL99:
 1505 0934 8093 0000 		sts stype,r24
 830:main.c        ****       pullupcfg = eeprom_read_byte((uint8_t *) (EE_PULLUP_OFFSET+0));
 1506               		.loc 1 830 0
 1507 0938 8FE2      		ldi r24,lo8(47)
 1508 093a 90E0      		ldi r25,0
 1509 093c 00D0      		rcall __eerd_byte_tn84
 1510               	.LVL100:
 1511 093e 8093 0000 		sts pullupcfg,r24
 831:main.c        ****       outstate = eeprom_read_byte((uint8_t *) (EE_OUTPUT_OFFSET+0));
 1512               		.loc 1 831 0
 1513 0942 80E3      		ldi r24,lo8(48)
 1514 0944 90E0      		ldi r25,0
 1515 0946 00D0      		rcall __eerd_byte_tn84
 1516               	.LVL101:
 1517 0948 8093 0000 		sts outstate,r24
 1518 094c 00C0      		rjmp .L155
 1519               	.LVL102:
 1520               	.L149:
 832:main.c        ****     } else {
 833:main.c        ****       //Init values
 834:main.c        ****       /* should cli(); here no sei(); yet enabled in main.. */
 835:main.c        ****       eeprom_write_word((uint16_t *) (EE_MAGIC_OFFSET+0), EE_MAGIC_NUMBER);
 1521               		.loc 1 835 0
 1522 094e 62EE      		ldi r22,lo8(-30)
 1523 0950 71EE      		ldi r23,lo8(-31)
 1524 0952 80E0      		ldi r24,0
 1525 0954 90E0      		ldi r25,0
 1526 0956 00D0      		rcall __eewr_word_tn84
 1527               	.LVL103:
 1528 0958 00E0      		ldi r16,lo8(owid)
 1529 095a 10E0      		ldi r17,hi8(owid)
 836:main.c        ****       for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 1530               		.loc 1 836 0
 1531 095c C2E0      		ldi r28,lo8(2)
 1532 095e D0E0      		ldi r29,0
 1533               	.LVL104:
 1534               	.L152:
 1535               	.LBB3:
 837:main.c        ****         eeprom_write_byte((uint8_t *) i,owid[i-EE_OWID_OFFSET]);
 1536               		.loc 1 837 0 discriminator 2
 1537 0960 F801      		movw r30,r16
 1538 0962 6191      		ld r22,Z+
 1539 0964 8F01      		movw r16,r30
 1540 0966 CE01      		movw r24,r28
 1541 0968 00D0      		rcall __eewr_byte_tn84
 1542               	.LVL105:
 836:main.c        ****       for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 1543               		.loc 1 836 0 discriminator 2
 1544 096a 2196      		adiw r28,1
 1545               	.LVL106:
 1546 096c CA30      		cpi r28,10
 1547 096e D105      		cpc r29,__zero_reg__
 1548 0970 01F4      		brne .L152
 1549               	.LBE3:
 838:main.c        ****       eeprom_write_word((uint16_t *) (EE_RCNT_OFFSET+0), rcnt);
 1550               		.loc 1 838 0
 1551 0972 6091 0000 		lds r22,rcnt
 1552 0976 7091 0000 		lds r23,rcnt+1
 1553 097a 8AE0      		ldi r24,lo8(10)
 1554 097c 90E0      		ldi r25,0
 1555 097e 00D0      		rcall __eewr_word_tn84
 1556               	.LVL107:
 839:main.c        ****       //FIXME: this eats flashmem!
 840:main.c        ****       eeprom_write_dword((uint32_t *) (EE_COUNTER_OFFSET+0),0);
 1557               		.loc 1 840 0
 1558 0980 40E0      		ldi r20,0
 1559 0982 50E0      		ldi r21,0
 1560 0984 BA01      		movw r22,r20
 1561 0986 8CE0      		ldi r24,lo8(12)
 1562 0988 90E0      		ldi r25,0
 1563 098a 00D0      		rcall __eewr_dword_tn84
 1564               	.LVL108:
 841:main.c        ****       eeprom_write_dword((uint32_t *) (EE_COUNTER_OFFSET+4),0);
 1565               		.loc 1 841 0
 1566 098c 40E0      		ldi r20,0
 1567 098e 50E0      		ldi r21,0
 1568 0990 BA01      		movw r22,r20
 1569 0992 80E1      		ldi r24,lo8(16)
 1570 0994 90E0      		ldi r25,0
 1571 0996 00D0      		rcall __eewr_dword_tn84
 1572               	.LVL109:
 842:main.c        ****       eeprom_write_dword((uint32_t *) (EE_COUNTER_OFFSET+8),0);
 1573               		.loc 1 842 0
 1574 0998 40E0      		ldi r20,0
 1575 099a 50E0      		ldi r21,0
 1576 099c BA01      		movw r22,r20
 1577 099e 84E1      		ldi r24,lo8(20)
 1578 09a0 90E0      		ldi r25,0
 1579 09a2 00D0      		rcall __eewr_dword_tn84
 1580               	.LVL110:
 843:main.c        ****       eeprom_write_dword((uint32_t *) (EE_COUNTER_OFFSET+12),0);
 1581               		.loc 1 843 0
 1582 09a4 40E0      		ldi r20,0
 1583 09a6 50E0      		ldi r21,0
 1584 09a8 BA01      		movw r22,r20
 1585 09aa 88E1      		ldi r24,lo8(24)
 1586 09ac 90E0      		ldi r25,0
 1587 09ae 00D0      		rcall __eewr_dword_tn84
 1588               	.LVL111:
 844:main.c        ****       eeprom_write_byte((uint8_t *) (EE_TYPE_OFFSET+0), stype);
 1589               		.loc 1 844 0
 1590 09b0 6091 0000 		lds r22,stype
 1591 09b4 8CE2      		ldi r24,lo8(44)
 1592 09b6 90E0      		ldi r25,0
 1593 09b8 00D0      		rcall __eewr_byte_tn84
 1594               	.LVL112:
 845:main.c        ****       eeprom_write_word((uint16_t *) (EE_VERSION_OFFSET+0), version);
 1595               		.loc 1 845 0
 1596 09ba 6091 0000 		lds r22,version
 1597 09be 7091 0000 		lds r23,version+1
 1598 09c2 8DE2      		ldi r24,lo8(45)
 1599 09c4 90E0      		ldi r25,0
 1600 09c6 00D0      		rcall __eewr_word_tn84
 1601               	.LVL113:
 846:main.c        ****       eeprom_write_byte((uint8_t *) (EE_PULLUP_OFFSET+0), 1);
 1602               		.loc 1 846 0
 1603 09c8 61E0      		ldi r22,lo8(1)
 1604 09ca 8FE2      		ldi r24,lo8(47)
 1605 09cc 90E0      		ldi r25,0
 1606 09ce 00D0      		rcall __eewr_byte_tn84
 1607               	.LVL114:
 847:main.c        ****       eeprom_write_byte((uint8_t *) (EE_OUTPUT_OFFSET+0), 0);
 1608               		.loc 1 847 0
 1609 09d0 60E0      		ldi r22,0
 1610 09d2 80E3      		ldi r24,lo8(48)
 1611 09d4 90E0      		ldi r25,0
 1612               	/* epilogue start */
 848:main.c        ****     }
 849:main.c        **** }
 1613               		.loc 1 849 0
 1614 09d6 DF91      		pop r29
 1615 09d8 CF91      		pop r28
 1616               	.LVL115:
 1617 09da 1F91      		pop r17
 1618 09dc 0F91      		pop r16
 847:main.c        ****       eeprom_write_byte((uint8_t *) (EE_OUTPUT_OFFSET+0), 0);
 1619               		.loc 1 847 0
 1620 09de 00C0      		rjmp __eewr_byte_tn84
 1621               	.LVL116:
 1622               	.L155:
 1623               	/* epilogue start */
 1624               		.loc 1 849 0
 1625 09e0 DF91      		pop r29
 1626 09e2 CF91      		pop r28
 1627               	.LVL117:
 1628 09e4 1F91      		pop r17
 1629 09e6 0F91      		pop r16
 1630 09e8 0895      		ret
 1631               	.LFE4:
 1633               	.global	__vector_4
 1635               	__vector_4:
 1636               	.LFB5:
 850:main.c        **** 
 851:main.c        **** //FIXME: enable real watchdog?
 852:main.c        **** ISR(WDT_vect) {
 1637               		.loc 1 852 0
 1638 09ea 1F92      		push r1
 1639               	.LCFI54:
 1640 09ec 0F92      		push r0
 1641               	.LCFI55:
 1642 09ee 0FB6      		in r0,__SREG__
 1643 09f0 0F92      		push r0
 1644 09f2 1124      		clr __zero_reg__
 1645 09f4 8F93      		push r24
 1646               	.LCFI56:
 1647 09f6 9F93      		push r25
 1648               	.LCFI57:
 1649 09f8 AF93      		push r26
 1650               	.LCFI58:
 1651 09fa BF93      		push r27
 1652               	.LCFI59:
 1653               	/* prologue: Signal */
 1654               	/* frame size = 0 */
 1655               	/* stack size = 7 */
 1656               	.L__stack_usage = 7
 853:main.c        ****   uptime += 2;
 1657               		.loc 1 853 0
 1658 09fc 8091 0000 		lds r24,uptime
 1659 0a00 9091 0000 		lds r25,uptime+1
 1660 0a04 A091 0000 		lds r26,uptime+2
 1661 0a08 B091 0000 		lds r27,uptime+3
 1662 0a0c 0296      		adiw r24,2
 1663 0a0e A11D      		adc r26,__zero_reg__
 1664 0a10 B11D      		adc r27,__zero_reg__
 1665 0a12 8093 0000 		sts uptime,r24
 1666 0a16 9093 0000 		sts uptime+1,r25
 1667 0a1a A093 0000 		sts uptime+2,r26
 1668 0a1e B093 0000 		sts uptime+3,r27
 1669               	/* epilogue start */
 854:main.c        **** }
 1670               		.loc 1 854 0
 1671 0a22 BF91      		pop r27
 1672 0a24 AF91      		pop r26
 1673 0a26 9F91      		pop r25
 1674 0a28 8F91      		pop r24
 1675 0a2a 0F90      		pop r0
 1676 0a2c 0FBE      		out __SREG__,r0
 1677 0a2e 0F90      		pop r0
 1678 0a30 1F90      		pop r1
 1679 0a32 1895      		reti
 1680               	.LFE5:
 1682               		.section	.text.startup,"ax",@progbits
 1683               	.global	main
 1685               	main:
 1686               	.LFB6:
 855:main.c        **** 
 856:main.c        **** int main(void) {
 1687               		.loc 1 856 0
 1688               	/* prologue: function */
 1689               	/* frame size = 0 */
 1690               	/* stack size = 0 */
 1691               	.L__stack_usage = 0
 857:main.c        ****     mode=OWM_SLEEP;
 1692               		.loc 1 857 0
 1693 0000 1092 0000 		sts mode,__zero_reg__
 858:main.c        ****     wmode=OWW_NO_WRITE;
 1694               		.loc 1 858 0
 1695 0004 82E0      		ldi r24,lo8(2)
 1696 0006 8093 0000 		sts wmode,r24
 859:main.c        ****     OW_DDR&=~OW_PINN;
 1697               		.loc 1 859 0
 1698 000a BA98      		cbi 0x17,2
 860:main.c        **** 
 861:main.c        ****     INIT_AVR
 1699               		.loc 1 861 0
 1700 000c 80E8      		ldi r24,lo8(-128)
 1701 000e 86BD      		out 0x26,r24
 1702 0010 16BC      		out 0x26,__zero_reg__
 1703 0012 19BE      		out 0x39,__zero_reg__
 1704 0014 80E4      		ldi r24,lo8(64)
 1705 0016 8BBF      		out 0x3b,r24
 1706 0018 83E0      		ldi r24,lo8(3)
 1707 001a 83BF      		out 0x33,r24
 1708 001c 81B5      		in r24,0x21
 1709 001e 8760      		ori r24,lo8(7)
 1710 0020 81BD      		out 0x21,r24
 1711 0022 81B5      		in r24,0x21
 1712 0024 8064      		ori r24,lo8(64)
 1713 0026 81BD      		out 0x21,r24
 862:main.c        ****     PWRSAVE_AVR
 1714               		.loc 1 862 0
 1715 0028 3798      		cbi 0x6,7
 1716 002a 80B1      		in r24,0
 1717 002c 8B60      		ori r24,lo8(11)
 1718 002e 80B9      		out 0,r24
 863:main.c        **** 
 864:main.c        ****     init_eeprom();
 1719               		.loc 1 864 0
 1720 0030 00D0      		rcall init_eeprom
 1721               	.LVL118:
 865:main.c        **** 
 866:main.c        ****     INIT_COUNTER_PINS
 1722               		.loc 1 866 0
 1723 0032 8BB7      		in r24,0x3b
 1724 0034 8061      		ori r24,lo8(16)
 1725 0036 8BBF      		out 0x3b,r24
 1726 0038 8BB7      		in r24,0x3b
 1727 003a 8062      		ori r24,lo8(32)
 1728 003c 8BBF      		out 0x3b,r24
 1729 003e 80B5      		in r24,0x20
 1730 0040 8260      		ori r24,lo8(2)
 1731 0042 80BD      		out 0x20,r24
 1732 0044 80B5      		in r24,0x20
 1733 0046 8160      		ori r24,lo8(1)
 1734 0048 80BD      		out 0x20,r24
 1735 004a B998      		cbi 0x17,1
 1736 004c B898      		cbi 0x17,0
 1737 004e 86B3      		in r24,0x16
 1738 0050 8093 0000 		sts pinstatB,r24
 1739 0054 82B3      		in r24,0x12
 1740 0056 8863      		ori r24,lo8(56)
 1741 0058 82BB      		out 0x12,r24
 1742 005a 8AB3      		in r24,0x1a
 1743 005c 877C      		andi r24,lo8(-57)
 1744 005e 8ABB      		out 0x1a,r24
 1745 0060 89B3      		in r24,0x19
 1746 0062 8093 0000 		sts pinstatA,r24
 1747 0066 8091 0000 		lds r24,pullupcfg
 1748 006a 8823      		tst r24
 1749 006c 01F0      		breq .L158
 1750               		.loc 1 866 0 is_stmt 0 discriminator 1
 1751 006e 8BB3      		in r24,0x1b
 1752 0070 8863      		ori r24,lo8(56)
 1753 0072 8BBB      		out 0x1b,r24
 1754 0074 C19A      		sbi 0x18,1
 1755               	.L158:
 867:main.c        ****     INIT_LED_PINS
 1756               		.loc 1 867 0 is_stmt 1
 1757 0076 D29A      		sbi 0x1a,2
 868:main.c        ****     INIT_OUT_PINS
 1758               		.loc 1 868 0
 1759 0078 D09A      		sbi 0x1a,0
 1760 007a D19A      		sbi 0x1a,1
 1761 007c 2BB3      		in r18,0x1b
 1762 007e 8091 0000 		lds r24,outstate
 1763 0082 982F      		mov r25,r24
 1764 0084 9170      		andi r25,lo8(1)
 1765 0086 9095      		com r25
 1766 0088 9223      		and r25,r18
 1767 008a 9BBB      		out 0x1b,r25
 1768 008c 9BB3      		in r25,0x1b
 1769 008e 8270      		andi r24,lo8(2)
 1770 0090 880F      		lsl r24
 1771 0092 8095      		com r24
 1772 0094 8923      		and r24,r25
 1773 0096 8BBB      		out 0x1b,r24
 869:main.c        **** 
 870:main.c        ****     SET_OWINT_FALLING;
 1774               		.loc 1 870 0
 1775 0098 82E0      		ldi r24,lo8(2)
 1776 009a 85BF      		out 0x35,r24
 1777 009c 85B7      		in r24,0x35
 1778 009e 8E7F      		andi r24,lo8(-2)
 1779 00a0 85BF      		out 0x35,r24
 871:main.c        ****     DIS_TIMER;
 1780               		.loc 1 871 0
 1781 00a2 89B7      		in r24,0x39
 1782 00a4 8E7F      		andi r24,lo8(-2)
 1783 00a6 89BF      		out 0x39,r24
 872:main.c        ****     EN_OWINT;
 1784               		.loc 1 872 0
 1785 00a8 8BB7      		in r24,0x3b
 1786 00aa 8064      		ori r24,lo8(64)
 1787 00ac 8BBF      		out 0x3b,r24
 1788 00ae 90E4      		ldi r25,lo8(64)
 1789 00b0 9ABF      		out 0x3a,r25
 873:main.c        **** 
 874:main.c        ****     sei();
 1790               		.loc 1 874 0
 1791               	/* #APP */
 1792               	 ;  874 "main.c" 1
 1793 00b2 7894      		sei
 1794               	 ;  0 "" 2
 875:main.c        ****     //force sleep first
 876:main.c        ****     DIS_TIMER;
 1795               		.loc 1 876 0
 1796               	/* #NOAPP */
 1797 00b4 89B7      		in r24,0x39
 1798 00b6 8E7F      		andi r24,lo8(-2)
 1799 00b8 89BF      		out 0x39,r24
 877:main.c        ****     EN_OWINT; SET_OWINT_LOWLEVEL;
 1800               		.loc 1 877 0
 1801 00ba 8BB7      		in r24,0x3b
 1802 00bc 8064      		ori r24,lo8(64)
 1803 00be 8BBF      		out 0x3b,r24
 1804 00c0 9ABF      		out 0x3a,r25
 1805 00c2 85B7      		in r24,0x35
 1806 00c4 8C7F      		andi r24,lo8(-4)
 1807 00c6 85BF      		out 0x35,r24
 878:main.c        ****     sleepmode=SLEEP_MODE_PWR_DOWN;
 1808               		.loc 1 878 0
 1809 00c8 80E1      		ldi r24,lo8(16)
 1810 00ca 8093 0000 		sts sleepmode,r24
 1811               	.L160:
 879:main.c        **** 
 880:main.c        ****     while(1){
 881:main.c        ****         if (ewrite_flag) {
 1812               		.loc 1 881 0
 1813 00ce 8091 0000 		lds r24,ewrite_flag
 1814 00d2 8823      		tst r24
 1815 00d4 01F0      		breq .L159
 882:main.c        ****           eeprom_update_dword((uint32_t *) (ewrite_flag+0), eewrite_buf.u32_1);
 1816               		.loc 1 882 0
 1817 00d6 8091 0000 		lds r24,ewrite_flag
 1818 00da 4091 0000 		lds r20,eewrite_buf
 1819 00de 5091 0000 		lds r21,eewrite_buf+1
 1820 00e2 6091 0000 		lds r22,eewrite_buf+2
 1821 00e6 7091 0000 		lds r23,eewrite_buf+3
 1822 00ea 90E0      		ldi r25,0
 1823 00ec 00D0      		rcall __eeupd_dword_tn84
 1824               	.LVL119:
 883:main.c        ****           ewrite_flag = 0;
 1825               		.loc 1 883 0
 1826 00ee 1092 0000 		sts ewrite_flag,__zero_reg__
 1827               	.L159:
 884:main.c        ****         }
 885:main.c        ****         OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
 1828               		.loc 1 885 0
 1829 00f2 DA98      		cbi 0x1b,2
 886:main.c        ****         sleep_enable();
 1830               		.loc 1 886 0
 1831 00f4 85B7      		in r24,0x35
 1832 00f6 8062      		ori r24,lo8(32)
 1833 00f8 85BF      		out 0x35,r24
 887:main.c        ****         set_sleep_mode(sleepmode);
 1834               		.loc 1 887 0
 1835 00fa 85B7      		in r24,0x35
 1836 00fc 9091 0000 		lds r25,sleepmode
 1837 0100 877E      		andi r24,lo8(-25)
 1838 0102 892B      		or r24,r25
 1839 0104 85BF      		out 0x35,r24
 888:main.c        ****         sleep_cpu();
 1840               		.loc 1 888 0
 1841               	/* #APP */
 1842               	 ;  888 "main.c" 1
 1843 0106 8895      		sleep
 1844               		
 1845               	 ;  0 "" 2
 889:main.c        ****     }
 1846               		.loc 1 889 0
 1847               	/* #NOAPP */
 1848 0108 00C0      		rjmp .L160
 1849               	.LFE6:
 1851               		.comm	eewrite_buf,8,1
 1852               		.comm	ewrite_flag,1,1
 1853               	.global	crcerrcnt
 1854               		.section .bss
 1857               	crcerrcnt:
 1858 0000 00        		.zero	1
 1859               		.comm	eflag,1,1
 1860               	.global	rcnt
 1861               		.data
 1864               	rcnt:
 1865 0000 0100      		.word	1
 1866               	.global	outstate
 1867               		.section .bss
 1870               	outstate:
 1871 0001 00        		.zero	1
 1872               	.global	pullupcfg
 1873               		.data
 1876               	pullupcfg:
 1877 0002 01        		.byte	1
 1878               	.global	stype
 1881               	stype:
 1882 0003 01        		.byte	1
 1883               	.global	version
 1886               	version:
 1887 0004 0601      		.word	262
 1888               		.comm	srcount,1,1
 1889               		.comm	actbit,1,1
 1890               		.comm	wmode,1,1
 1891               		.comm	mode,1,1
 1892               		.comm	bytep,1,1
 1893               		.comm	bitp,1,1
 1894               	.global	owid
 1897               	owid:
 1898 0006 E1        		.byte	-31
 1899 0007 E2        		.byte	-30
 1900 0008 00        		.byte	0
 1901 0009 00        		.byte	0
 1902 000a 00        		.byte	0
 1903 000b 00        		.byte	0
 1904 000c 84        		.byte	-124
 1905 000d 28        		.byte	40
 1906               		.comm	cbuf,1,1
 1907               		.comm	sleepmode,1,1
 1908               		.comm	pinstatB,1,1
 1909               		.comm	pinstatA,1,1
 1910               		.comm	Counter4,4,1
 1911               		.comm	Counter3,4,1
 1912               		.comm	Counter2,4,1
 1913               		.comm	Counter1,4,1
 1914               		.comm	lastcps,1,1
 1915               		.comm	page,1,1
 1916               		.comm	scrc,2,1
 1917               	.global	nackmsg
 1918               		.section .bss
 1921               	nackmsg:
 1922 0002 00        		.zero	1
 1923               	.global	recv_state
 1926               	recv_state:
 1927 0003 00        		.zero	1
 1928               		.comm	scratchpad,11,1
 1929               	.global	uptime
 1932               	uptime:
 1933 0004 0000 0000 		.zero	4
 1934               	.global	EE_LABEL_MAXLEN
 1935               		.section	.rodata
 1938               	EE_LABEL_MAXLEN:
 1939 0000 20        		.byte	32
 1940               	.global	EE_LABEL_OFFSET
 1943               	EE_LABEL_OFFSET:
 1944 0001 32        		.byte	50
 1945               	.global	EE_OUTPUT_OFFSET
 1948               	EE_OUTPUT_OFFSET:
 1949 0002 30        		.byte	48
 1950               	.global	EE_PULLUP_OFFSET
 1953               	EE_PULLUP_OFFSET:
 1954 0003 2F        		.byte	47
 1955               	.global	EE_VERSION_OFFSET
 1958               	EE_VERSION_OFFSET:
 1959 0004 2D        		.byte	45
 1960               	.global	EE_TYPE_OFFSET
 1963               	EE_TYPE_OFFSET:
 1964 0005 2C        		.byte	44
 1965               	.global	EE_COUNTER_OFFSET
 1968               	EE_COUNTER_OFFSET:
 1969 0006 0C        		.byte	12
 1970               	.global	EE_RCNT_OFFSET
 1973               	EE_RCNT_OFFSET:
 1974 0007 0A        		.byte	10
 1975               	.global	EE_OWID_OFFSET
 1978               	EE_OWID_OFFSET:
 1979 0008 02        		.byte	2
 1980               	.global	EE_MAGIC_OFFSET
 1983               	EE_MAGIC_OFFSET:
 1984 0009 00        		.zero	1
 1985               	.global	EE_DEFTYPE
 1988               	EE_DEFTYPE:
 1989 000a 01        		.byte	1
 1990               	.global	EE_MAGIC_NUMBER
 1993               	EE_MAGIC_NUMBER:
 1994 000b E2E1      		.word	-7710
 2425               	.Letext0:
 2426               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 2427               		.file 3 "common.h"
 2428               		.file 4 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccKUOm06.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccKUOm06.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccKUOm06.s:4      *ABS*:0000003f __SREG__
     /tmp/ccKUOm06.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccKUOm06.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccKUOm06.s:11     .text:00000000 __vector_1
                            *COM*:00000001 wmode
                            *COM*:00000001 mode
                            *COM*:00000001 sleepmode
                            *COM*:00000001 srcount
     /tmp/ccKUOm06.s:163    .text:000000a6 __vector_11
                            *COM*:00000001 bytep
                            *COM*:00000001 bitp
                            *COM*:00000001 actbit
                            *COM*:00000002 scrc
                            *COM*:00000001 cbuf
     /tmp/ccKUOm06.s:1897   .data:00000006 owid
                            *COM*:00000001 page
                            *COM*:0000000b scratchpad
     /tmp/ccKUOm06.s:1881   .data:00000003 stype
                            *COM*:00000001 eflag
     /tmp/ccKUOm06.s:1886   .data:00000004 version
     /tmp/ccKUOm06.s:1932   .bss:00000004 uptime
     /tmp/ccKUOm06.s:1864   .data:00000000 rcnt
     /tmp/ccKUOm06.s:1857   .bss:00000000 crcerrcnt
                            *COM*:00000004 Counter1
                            *COM*:00000004 Counter2
                            *COM*:00000004 Counter3
                            *COM*:00000004 Counter4
                            *COM*:00000001 pinstatA
                            *COM*:00000001 pinstatB
     /tmp/ccKUOm06.s:1876   .data:00000002 pullupcfg
     /tmp/ccKUOm06.s:1870   .bss:00000001 outstate
                            *COM*:00000001 ewrite_flag
                            *COM*:00000008 eewrite_buf
     /tmp/ccKUOm06.s:1170   .text:000006d4 __vector_2
     /tmp/ccKUOm06.s:1269   .text:00000794 __vector_3
     /tmp/ccKUOm06.s:1398   .text:0000087e init_eeprom
     /tmp/ccKUOm06.s:1635   .text:000009ea __vector_4
     /tmp/ccKUOm06.s:1685   .text.startup:00000000 main
                            *COM*:00000001 lastcps
     /tmp/ccKUOm06.s:1921   .bss:00000002 nackmsg
     /tmp/ccKUOm06.s:1926   .bss:00000003 recv_state
     /tmp/ccKUOm06.s:1938   .rodata:00000000 EE_LABEL_MAXLEN
     /tmp/ccKUOm06.s:1943   .rodata:00000001 EE_LABEL_OFFSET
     /tmp/ccKUOm06.s:1948   .rodata:00000002 EE_OUTPUT_OFFSET
     /tmp/ccKUOm06.s:1953   .rodata:00000003 EE_PULLUP_OFFSET
     /tmp/ccKUOm06.s:1958   .rodata:00000004 EE_VERSION_OFFSET
     /tmp/ccKUOm06.s:1963   .rodata:00000005 EE_TYPE_OFFSET
     /tmp/ccKUOm06.s:1968   .rodata:00000006 EE_COUNTER_OFFSET
     /tmp/ccKUOm06.s:1973   .rodata:00000007 EE_RCNT_OFFSET
     /tmp/ccKUOm06.s:1978   .rodata:00000008 EE_OWID_OFFSET
     /tmp/ccKUOm06.s:1983   .rodata:00000009 EE_MAGIC_OFFSET
     /tmp/ccKUOm06.s:1988   .rodata:0000000a EE_DEFTYPE
     /tmp/ccKUOm06.s:1993   .rodata:0000000b EE_MAGIC_NUMBER

UNDEFINED SYMBOLS
__eerd_dword_tn84
__eewr_byte_tn84
__eeupd_dword_tn84
__eeupd_byte_tn84
__eerd_word_tn84
__eerd_byte_tn84
__eeupd_word_tn84
__eewr_word_tn84
__eewr_dword_tn84
__do_copy_data
__do_clear_bss
