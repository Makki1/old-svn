
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000814  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  00000814  000008a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000030  00800078  00800078  000008c0  2**0
                  ALLOC
  3 .stab         00000c90  00000000  00000000  000008c0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000201  00000000  00000000  00001550  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00001751  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000028  00000000  00000000  00001762  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000008d1  00000000  00000000  0000178a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000001d2  00000000  00000000  0000205b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000020a  00000000  00000000  0000222d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000114  00000000  00000000  00002438  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000037e  00000000  00000000  0000254c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000069f  00000000  00000000  000028ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  00002f69  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	29 c0       	rjmp	.+82     	; 0x54 <__ctors_end>
   2:	44 c0       	rjmp	.+136    	; 0x8c <__vector_1>
   4:	42 c0       	rjmp	.+132    	; 0x8a <__bad_interrupt>
   6:	41 c0       	rjmp	.+130    	; 0x8a <__bad_interrupt>
   8:	3c c3       	rjmp	.+1656   	; 0x682 <__vector_4>
   a:	3f c0       	rjmp	.+126    	; 0x8a <__bad_interrupt>
   c:	3e c0       	rjmp	.+124    	; 0x8a <__bad_interrupt>
   e:	3d c0       	rjmp	.+122    	; 0x8a <__bad_interrupt>
  10:	3c c0       	rjmp	.+120    	; 0x8a <__bad_interrupt>
  12:	3b c0       	rjmp	.+118    	; 0x8a <__bad_interrupt>
  14:	3a c0       	rjmp	.+116    	; 0x8a <__bad_interrupt>
  16:	8d c0       	rjmp	.+282    	; 0x132 <__vector_11>
  18:	38 c0       	rjmp	.+112    	; 0x8a <__bad_interrupt>
  1a:	37 c0       	rjmp	.+110    	; 0x8a <__bad_interrupt>
  1c:	36 c0       	rjmp	.+108    	; 0x8a <__bad_interrupt>
  1e:	35 c0       	rjmp	.+106    	; 0x8a <__bad_interrupt>
  20:	34 c0       	rjmp	.+104    	; 0x8a <__bad_interrupt>
  22:	56 c0       	rjmp	.+172    	; 0xd0 <__vector_1+0x44>
  24:	72 c0       	rjmp	.+228    	; 0x10a <__vector_1+0x7e>
  26:	71 c0       	rjmp	.+226    	; 0x10a <__vector_1+0x7e>
  28:	63 c0       	rjmp	.+198    	; 0xf0 <__vector_1+0x64>
  2a:	5d c0       	rjmp	.+186    	; 0xe6 <__vector_1+0x5a>
  2c:	61 c0       	rjmp	.+194    	; 0xf0 <__vector_1+0x64>
  2e:	60 c0       	rjmp	.+192    	; 0xf0 <__vector_1+0x64>
  30:	6c c0       	rjmp	.+216    	; 0x10a <__vector_1+0x7e>
  32:	63 c0       	rjmp	.+198    	; 0xfa <__vector_1+0x6e>
  34:	5d c0       	rjmp	.+186    	; 0xf0 <__vector_1+0x64>
  36:	5f c0       	rjmp	.+190    	; 0xf6 <__vector_1+0x6a>
  38:	5e c0       	rjmp	.+188    	; 0xf6 <__vector_1+0x6a>
  3a:	5a c0       	rjmp	.+180    	; 0xf0 <__vector_1+0x64>
  3c:	bd c0       	rjmp	.+378    	; 0x1b8 <__vector_11+0x86>
  3e:	c7 c0       	rjmp	.+398    	; 0x1ce <__vector_11+0x9c>
  40:	c8 c0       	rjmp	.+400    	; 0x1d2 <__vector_11+0xa0>
  42:	f7 c0       	rjmp	.+494    	; 0x232 <__vector_11+0x100>
  44:	1d c1       	rjmp	.+570    	; 0x280 <__stack+0x21>
  46:	33 c1       	rjmp	.+614    	; 0x2ae <__stack+0x4f>
  48:	74 c2       	rjmp	.+1256   	; 0x532 <__stack+0x2d3>
  4a:	73 c2       	rjmp	.+1254   	; 0x532 <__stack+0x2d3>
  4c:	72 c2       	rjmp	.+1252   	; 0x532 <__stack+0x2d3>
  4e:	71 c2       	rjmp	.+1250   	; 0x532 <__stack+0x2d3>
  50:	4e c2       	rjmp	.+1180   	; 0x4ee <__stack+0x28f>
  52:	f3 c1       	rjmp	.+998    	; 0x43a <__stack+0x1db>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d2 e0       	ldi	r29, 0x02	; 2
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 e1       	ldi	r30, 0x14	; 20
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a8 37       	cpi	r26, 0x78	; 120
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a8 e7       	ldi	r26, 0x78	; 120
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a8 3a       	cpi	r26, 0xA8	; 168
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	22 d3       	rcall	.+1604   	; 0x6cc <main>
  88:	c3 c3       	rjmp	.+1926   	; 0x810 <_exit>

0000008a <__bad_interrupt>:
  8a:	ba cf       	rjmp	.-140    	; 0x0 <__vectors>

0000008c <__vector_1>:
      uint32_t u32_2;
    };
} eewrite_t;
eewrite_t eewrite_buf;

PIN_INT {
  8c:	1f 92       	push	r1
  8e:	0f 92       	push	r0
  90:	0f b6       	in	r0, 0x3f	; 63
  92:	0f 92       	push	r0
  94:	11 24       	eor	r1, r1
  96:	2f 93       	push	r18
  98:	8f 93       	push	r24
  9a:	9f 93       	push	r25
  9c:	ef 93       	push	r30
  9e:	ff 93       	push	r31
    uint8_t lwmode=wmode;  //let this variables in registers
  a0:	80 91 8b 00 	lds	r24, 0x008B
    uint8_t lmode=mode;
  a4:	90 91 99 00 	lds	r25, 0x0099
    if (lwmode==OWW_WRITE_0) { //if necessary set 0-Bit
  a8:	81 11       	cpse	r24, r1
  aa:	03 c0       	rjmp	.+6      	; 0xb2 <__vector_1+0x26>
        SET_LOW;
  ac:	ba 9a       	sbi	0x17, 2	; 23
  ae:	c2 98       	cbi	0x18, 2	; 24
        lwmode=OWW_NO_WRITE;
  b0:	82 e0       	ldi	r24, 0x02	; 2
    }
    DIS_OWINT; //disable interrupt, only in OWM_SLEEP mode it is active
  b2:	2b b7       	in	r18, 0x3b	; 59
  b4:	2f 7b       	andi	r18, 0xBF	; 191
  b6:	2b bf       	out	0x3b, r18	; 59
  b8:	10 92 7f 00 	sts	0x007F, r1
    sleepmode=SLEEP_MODE_IDLE; //powerdown is set in TIMER_INT on OWM_SLEEP only!
  bc:	10 92 7f 00 	sts	0x007F, r1
    switch (lmode) {
  c0:	e9 2f       	mov	r30, r25
  c2:	f0 e0       	ldi	r31, 0x00	; 0
  c4:	ed 30       	cpi	r30, 0x0D	; 13
  c6:	f1 05       	cpc	r31, r1
  c8:	00 f5       	brcc	.+64     	; 0x10a <__vector_1+0x7e>
  ca:	ef 5e       	subi	r30, 0xEF	; 239
  cc:	ff 4f       	sbci	r31, 0xFF	; 255
  ce:	09 94       	ijmp
        case OWM_SLEEP:
            TCNT_REG=~(OWT_MIN_RESET);
  d0:	2c ec       	ldi	r18, 0xCC	; 204
  d2:	22 bf       	out	0x32, r18	; 50
            //RESET_LOW;  //??? Set pin as input again ???
            EN_OWINT; SET_OWINT_RISING; //other edges ?
  d4:	2b b7       	in	r18, 0x3b	; 59
  d6:	20 64       	ori	r18, 0x40	; 64
  d8:	2b bf       	out	0x3b, r18	; 59
  da:	20 e4       	ldi	r18, 0x40	; 64
  dc:	2a bf       	out	0x3a, r18	; 58
  de:	23 e0       	ldi	r18, 0x03	; 3
  e0:	25 bf       	out	0x35, r18	; 53
            OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
  e2:	da 98       	cbi	0x1b, 2	; 27
            break;
  e4:	12 c0       	rjmp	.+36     	; 0x10a <__vector_1+0x7e>
        case OWM_READ_COMMAND:
        case OWM_WRITE_FUNC:
            TCNT_REG=~(OWT_READLINE); //wait a time for reading
            break;
        case OWM_SEARCH_ROM:   //Search algorithm waiting for receive or send
            if (srcount<2) { //this means bit or complement is writing,
  e6:	20 91 97 00 	lds	r18, 0x0097
  ea:	22 30       	cpi	r18, 0x02	; 2
  ec:	08 f4       	brcc	.+2      	; 0xf0 <__vector_1+0x64>
  ee:	03 c0       	rjmp	.+6      	; 0xf6 <__vector_1+0x6a>
                TCNT_REG=~(OWT_LOWTIME);
            } else
                TCNT_REG=~(OWT_READLINE);  //init for read answer of master
  f0:	2d ef       	ldi	r18, 0xFD	; 253
  f2:	22 bf       	out	0x32, r18	; 50
  f4:	0a c0       	rjmp	.+20     	; 0x10a <__vector_1+0x7e>
            break;
        case OWM_READ_SCRATCHPAD:
        case OWM_WRITE_PAGE_TO_MASTER:
            TCNT_REG=~(OWT_LOWTIME);
  f6:	2c ef       	ldi	r18, 0xFC	; 252
  f8:	fc cf       	rjmp	.-8      	; 0xf2 <__vector_1+0x66>
            break;
        case OWM_CHK_RESET:  //rising edge of reset pulse
            SET_OWINT_FALLING;
  fa:	92 e0       	ldi	r25, 0x02	; 2
  fc:	95 bf       	out	0x35, r25	; 53
  fe:	95 b7       	in	r25, 0x35	; 53
 100:	9e 7f       	andi	r25, 0xFE	; 254
 102:	95 bf       	out	0x35, r25	; 53
            TCNT_REG=~(OWT_RESET_PRESENCE);  //waiting for sending presence pulse
 104:	9b ef       	ldi	r25, 0xFB	; 251
 106:	92 bf       	out	0x32, r25	; 50
            lmode=OWM_RESET;
 108:	91 e0       	ldi	r25, 0x01	; 1
            break;
    }
    EN_TIMER;
 10a:	29 b7       	in	r18, 0x39	; 57
 10c:	21 60       	ori	r18, 0x01	; 1
 10e:	29 bf       	out	0x39, r18	; 57
 110:	28 b7       	in	r18, 0x38	; 56
 112:	21 60       	ori	r18, 0x01	; 1
 114:	28 bf       	out	0x38, r18	; 56
    mode=lmode;
 116:	90 93 99 00 	sts	0x0099, r25
    wmode=lwmode;
 11a:	80 93 8b 00 	sts	0x008B, r24
}
 11e:	ff 91       	pop	r31
 120:	ef 91       	pop	r30
 122:	9f 91       	pop	r25
 124:	8f 91       	pop	r24
 126:	2f 91       	pop	r18
 128:	0f 90       	pop	r0
 12a:	0f be       	out	0x3f, r0	; 63
 12c:	0f 90       	pop	r0
 12e:	1f 90       	pop	r1
 130:	18 95       	reti

00000132 <__vector_11>:

TIMER_INT {
 132:	1f 92       	push	r1
 134:	0f 92       	push	r0
 136:	0f b6       	in	r0, 0x3f	; 63
 138:	0f 92       	push	r0
 13a:	11 24       	eor	r1, r1
 13c:	1f 93       	push	r17
 13e:	2f 93       	push	r18
 140:	3f 93       	push	r19
 142:	4f 93       	push	r20
 144:	5f 93       	push	r21
 146:	6f 93       	push	r22
 148:	7f 93       	push	r23
 14a:	8f 93       	push	r24
 14c:	9f 93       	push	r25
 14e:	af 93       	push	r26
 150:	bf 93       	push	r27
 152:	cf 93       	push	r28
 154:	df 93       	push	r29
 156:	ef 93       	push	r30
 158:	ff 93       	push	r31
    uint8_t lwmode=wmode; //let this variables in registers
 15a:	60 91 8b 00 	lds	r22, 0x008B
    uint8_t lmode=mode;
 15e:	50 91 99 00 	lds	r21, 0x0099
    uint8_t lbytep=bytep;
 162:	40 91 9a 00 	lds	r20, 0x009A
    uint8_t lbitp=bitp;
 166:	d0 91 96 00 	lds	r29, 0x0096
    uint8_t lsrcount=srcount;
 16a:	c0 91 97 00 	lds	r28, 0x0097
    uint8_t lactbit=actbit;
 16e:	70 91 8c 00 	lds	r23, 0x008C
    uint16_t lscrc=scrc;
 172:	20 91 9e 00 	lds	r18, 0x009E
 176:	30 91 9f 00 	lds	r19, 0x009F
    //Ask input line sate
    uint8_t p=((OW_PIN&OW_PINN)==OW_PINN);
 17a:	16 b3       	in	r17, 0x16	; 22
 17c:	12 fb       	bst	r17, 2
 17e:	11 27       	eor	r17, r17
 180:	10 f9       	bld	r17, 0

    OWRXLED_PORT ^= (1<<OWRXLED_PIN); /* toolge RX-led */
 182:	8b b3       	in	r24, 0x1b	; 27
 184:	94 e0       	ldi	r25, 0x04	; 4
 186:	89 27       	eor	r24, r25
 188:	8b bb       	out	0x1b, r24	; 27

    //Interrupt still active ?
    if (CHK_INT_EN) {
 18a:	0b b6       	in	r0, 0x3b	; 59
 18c:	06 fe       	sbrs	r0, 6
 18e:	09 c0       	rjmp	.+18     	; 0x1a2 <__vector_11+0x70>
        //maybe reset pulse
        if (p==0) {
 190:	11 11       	cpse	r17, r1
 192:	03 c0       	rjmp	.+6      	; 0x19a <__vector_11+0x68>
            lmode=OWM_CHK_RESET;  //wait for rising edge
            SET_OWINT_RISING;
 194:	83 e0       	ldi	r24, 0x03	; 3
 196:	85 bf       	out	0x35, r24	; 53

    //Interrupt still active ?
    if (CHK_INT_EN) {
        //maybe reset pulse
        if (p==0) {
            lmode=OWM_CHK_RESET;  //wait for rising edge
 198:	58 e0       	ldi	r21, 0x08	; 8
            SET_OWINT_RISING;
        }
        DIS_TIMER;
 19a:	89 b7       	in	r24, 0x39	; 57
 19c:	8e 7f       	andi	r24, 0xFE	; 254
 19e:	89 bf       	out	0x39, r24	; 57
 1a0:	c8 c1       	rjmp	.+912    	; 0x532 <__stack+0x2d3>
    } else
    switch (lmode) {
 1a2:	85 2f       	mov	r24, r21
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	fc 01       	movw	r30, r24
 1a8:	31 97       	sbiw	r30, 0x01	; 1
 1aa:	ec 30       	cpi	r30, 0x0C	; 12
 1ac:	f1 05       	cpc	r31, r1
 1ae:	08 f0       	brcs	.+2      	; 0x1b2 <__vector_11+0x80>
 1b0:	c0 c1       	rjmp	.+896    	; 0x532 <__stack+0x2d3>
 1b2:	e2 5e       	subi	r30, 0xE2	; 226
 1b4:	ff 4f       	sbci	r31, 0xFF	; 255
 1b6:	09 94       	ijmp
        case OWM_RESET:  //Reset pulse and time after is finished, now go in presence state
            lmode=OWM_PRESENCE;
            SET_LOW;
 1b8:	ba 9a       	sbi	0x17, 2	; 23
 1ba:	c2 98       	cbi	0x18, 2	; 24
            TCNT_REG=~(OWT_PRESENCE);
 1bc:	8b ee       	ldi	r24, 0xEB	; 235
 1be:	82 bf       	out	0x32, r24	; 50
            DIS_OWINT;  //No Pin interrupt necessary only wait for presence is done
 1c0:	8b b7       	in	r24, 0x3b	; 59
 1c2:	8f 7b       	andi	r24, 0xBF	; 191
 1c4:	8b bf       	out	0x3b, r24	; 59
 1c6:	10 92 7f 00 	sts	0x007F, r1
        }
        DIS_TIMER;
    } else
    switch (lmode) {
        case OWM_RESET:  //Reset pulse and time after is finished, now go in presence state
            lmode=OWM_PRESENCE;
 1ca:	52 e0       	ldi	r21, 0x02	; 2
            SET_LOW;
            TCNT_REG=~(OWT_PRESENCE);
            DIS_OWINT;  //No Pin interrupt necessary only wait for presence is done
            break;
 1cc:	ce c1       	rjmp	.+924    	; 0x56a <__stack+0x30b>
        case OWM_PRESENCE:
            RESET_LOW;  //Presence is done now wait for a command
 1ce:	ba 98       	cbi	0x17, 2	; 23
 1d0:	69 c0       	rjmp	.+210    	; 0x2a4 <__stack+0x45>
            lmode=OWM_READ_COMMAND;
            cbuf=0;lbitp=1;  //Command buffer have to set zero, only set bits will write in
            break;
        case OWM_READ_COMMAND:
            if (p) {  //Set bit if line high
 1d2:	11 23       	and	r17, r17
 1d4:	29 f0       	breq	.+10     	; 0x1e0 <__vector_11+0xae>
                cbuf|=lbitp;
 1d6:	80 91 9b 00 	lds	r24, 0x009B
 1da:	8d 2b       	or	r24, r29
 1dc:	80 93 9b 00 	sts	0x009B, r24
            }
            lbitp=(lbitp<<1);
 1e0:	dd 0f       	add	r29, r29
            if (!lbitp) { //8-Bits read - weird syntax?
 1e2:	09 f0       	breq	.+2      	; 0x1e6 <__vector_11+0xb4>
 1e4:	b9 c1       	rjmp	.+882    	; 0x558 <__stack+0x2f9>
                lbitp=1;
                switch (cbuf) {
 1e6:	80 91 9b 00 	lds	r24, 0x009B
 1ea:	85 35       	cpi	r24, 0x55	; 85
 1ec:	09 f4       	brne	.+2      	; 0x1f0 <__vector_11+0xbe>
 1ee:	d0 c1       	rjmp	.+928    	; 0x590 <__stack+0x331>
 1f0:	20 f4       	brcc	.+8      	; 0x1fa <__vector_11+0xc8>
 1f2:	8f 34       	cpi	r24, 0x4F	; 79
 1f4:	09 f0       	breq	.+2      	; 0x1f8 <__vector_11+0xc6>
 1f6:	ca c1       	rjmp	.+916    	; 0x58c <__stack+0x32d>
 1f8:	14 c0       	rjmp	.+40     	; 0x222 <__vector_11+0xf0>
 1fa:	8e 3b       	cpi	r24, 0xBE	; 190
 1fc:	61 f0       	breq	.+24     	; 0x216 <__vector_11+0xe4>
 1fe:	80 3f       	cpi	r24, 0xF0	; 240
 200:	09 f0       	breq	.+2      	; 0x204 <__vector_11+0xd2>
 202:	c4 c1       	rjmp	.+904    	; 0x58c <__stack+0x32d>
                        break;
                    case 0xF0:  //initialize search rom
                        lmode=OWM_SEARCH_ROM;
                        lsrcount=0;
                        lbytep=0;
                        lactbit=(owid[lbytep]&lbitp)==lbitp; //set actual bit
 204:	60 91 65 00 	lds	r22, 0x0065
 208:	61 70       	andi	r22, 0x01	; 1
 20a:	76 2f       	mov	r23, r22
                        lbytep=0;
                        lmode=OWM_MATCH_ROM;
                        break;
                    case 0xF0:  //initialize search rom
                        lmode=OWM_SEARCH_ROM;
                        lsrcount=0;
 20c:	c0 e0       	ldi	r28, 0x00	; 0
            if (p) {  //Set bit if line high
                cbuf|=lbitp;
            }
            lbitp=(lbitp<<1);
            if (!lbitp) { //8-Bits read - weird syntax?
                lbitp=1;
 20e:	d1 e0       	ldi	r29, 0x01	; 1
                        lmode=OWM_MATCH_ROM;
                        break;
                    case 0xF0:  //initialize search rom
                        lmode=OWM_SEARCH_ROM;
                        lsrcount=0;
                        lbytep=0;
 210:	40 e0       	ldi	r20, 0x00	; 0
                    case 0x55://Match ROM
                        lbytep=0;
                        lmode=OWM_MATCH_ROM;
                        break;
                    case 0xF0:  //initialize search rom
                        lmode=OWM_SEARCH_ROM;
 212:	54 e0       	ldi	r21, 0x04	; 4
                        lsrcount=0;
                        lbytep=0;
                        lactbit=(owid[lbytep]&lbitp)==lbitp; //set actual bit
                        lwmode=lactbit;  //prepare for writing when next falling edge
                        break;
 214:	a3 c1       	rjmp	.+838    	; 0x55c <__stack+0x2fd>
                    //FIXME: case 0xEC:  //alarm search rom - TODO
                    case 0xBE: //read scratchpad
                        lmode=OWM_GET_ADRESS; //first the master sends an address
                        lbytep=0;
                        page=0;
 216:	10 92 9c 00 	sts	0x009C, r1
            if (p) {  //Set bit if line high
                cbuf|=lbitp;
            }
            lbitp=(lbitp<<1);
            if (!lbitp) { //8-Bits read - weird syntax?
                lbitp=1;
 21a:	d1 e0       	ldi	r29, 0x01	; 1
                        lwmode=lactbit;  //prepare for writing when next falling edge
                        break;
                    //FIXME: case 0xEC:  //alarm search rom - TODO
                    case 0xBE: //read scratchpad
                        lmode=OWM_GET_ADRESS; //first the master sends an address
                        lbytep=0;
 21c:	40 e0       	ldi	r20, 0x00	; 0
                        lactbit=(owid[lbytep]&lbitp)==lbitp; //set actual bit
                        lwmode=lactbit;  //prepare for writing when next falling edge
                        break;
                    //FIXME: case 0xEC:  //alarm search rom - TODO
                    case 0xBE: //read scratchpad
                        lmode=OWM_GET_ADRESS; //first the master sends an address
 21e:	56 e0       	ldi	r21, 0x06	; 6
                        lbytep=0;
                        page=0;
                        //EN_OWINT; SET_OWINT_LOWLEVEL; sleepmode=SLEEP_MODE_PWR_DOWN; //Testing if we can charge-up?
                        break;
 220:	9d c1       	rjmp	.+826    	; 0x55c <__stack+0x2fd>
                    case OWC_WRITE_FUNC:
                        lmode=OWM_WRITE_FUNC; //first the master sends an address(page/func), then 8bytes + crc
                        lbytep=0;
                        lscrc=0;
                        scratchpad.page1=0;
 222:	10 92 80 00 	sts	0x0080, r1
                        //EN_OWINT; SET_OWINT_LOWLEVEL; sleepmode=SLEEP_MODE_PWR_DOWN; //Testing if we can charge-up?
                        break;
                    case OWC_WRITE_FUNC:
                        lmode=OWM_WRITE_FUNC; //first the master sends an address(page/func), then 8bytes + crc
                        lbytep=0;
                        lscrc=0;
 226:	20 e0       	ldi	r18, 0x00	; 0
 228:	30 e0       	ldi	r19, 0x00	; 0
            if (p) {  //Set bit if line high
                cbuf|=lbitp;
            }
            lbitp=(lbitp<<1);
            if (!lbitp) { //8-Bits read - weird syntax?
                lbitp=1;
 22a:	d1 e0       	ldi	r29, 0x01	; 1
                        page=0;
                        //EN_OWINT; SET_OWINT_LOWLEVEL; sleepmode=SLEEP_MODE_PWR_DOWN; //Testing if we can charge-up?
                        break;
                    case OWC_WRITE_FUNC:
                        lmode=OWM_WRITE_FUNC; //first the master sends an address(page/func), then 8bytes + crc
                        lbytep=0;
 22c:	40 e0       	ldi	r20, 0x00	; 0
                        lbytep=0;
                        page=0;
                        //EN_OWINT; SET_OWINT_LOWLEVEL; sleepmode=SLEEP_MODE_PWR_DOWN; //Testing if we can charge-up?
                        break;
                    case OWC_WRITE_FUNC:
                        lmode=OWM_WRITE_FUNC; //first the master sends an address(page/func), then 8bytes + crc
 22e:	5c e0       	ldi	r21, 0x0C	; 12
                        lbytep=0;
                        lscrc=0;
                        scratchpad.page1=0;
                        break;
 230:	95 c1       	rjmp	.+810    	; 0x55c <__stack+0x2fd>
                        lmode=OWM_SLEEP;  //all other commands do nothing
                }
            }
            break;
        case OWM_SEARCH_ROM:
            RESET_LOW;  //Set low also if nothing send (branch takes time and memory)
 232:	ba 98       	cbi	0x17, 2	; 23
            lsrcount++;  //next search rom mode
 234:	cf 5f       	subi	r28, 0xFF	; 255
            switch (lsrcount) {
 236:	c1 30       	cpi	r28, 0x01	; 1
 238:	21 f0       	breq	.+8      	; 0x242 <__vector_11+0x110>
 23a:	c3 30       	cpi	r28, 0x03	; 3
 23c:	09 f0       	breq	.+2      	; 0x240 <__vector_11+0x10e>
 23e:	8c c1       	rjmp	.+792    	; 0x558 <__stack+0x2f9>
 240:	06 c0       	rjmp	.+12     	; 0x24e <__vector_11+0x11c>
                case 1:lwmode=!lactbit;  //preparation sending complement
 242:	61 e0       	ldi	r22, 0x01	; 1
 244:	77 23       	and	r23, r23
 246:	09 f4       	brne	.+2      	; 0x24a <__vector_11+0x118>
 248:	87 c1       	rjmp	.+782    	; 0x558 <__stack+0x2f9>
 24a:	60 e0       	ldi	r22, 0x00	; 0
                    break;
 24c:	85 c1       	rjmp	.+778    	; 0x558 <__stack+0x2f9>
                case 3:
                    if (p!=(lactbit==1)) {  //check master bit
 24e:	81 e0       	ldi	r24, 0x01	; 1
 250:	71 30       	cpi	r23, 0x01	; 1
 252:	09 f0       	breq	.+2      	; 0x256 <__vector_11+0x124>
 254:	80 e0       	ldi	r24, 0x00	; 0
 256:	18 13       	cpse	r17, r24
 258:	6e c1       	rjmp	.+732    	; 0x536 <__stack+0x2d7>
                        lmode=OWM_SLEEP;  //not the same go sleep
                    } else {
                        lbitp=(lbitp<<1);  //prepare next bit
 25a:	dd 0f       	add	r29, r29
                        if (lbitp==0) {
 25c:	29 f4       	brne	.+10     	; 0x268 <__stack+0x9>
                            lbitp=1;
                            lbytep++;
 25e:	4f 5f       	subi	r20, 0xFF	; 255
                    if (p!=(lactbit==1)) {  //check master bit
                        lmode=OWM_SLEEP;  //not the same go sleep
                    } else {
                        lbitp=(lbitp<<1);  //prepare next bit
                        if (lbitp==0) {
                            lbitp=1;
 260:	d1 e0       	ldi	r29, 0x01	; 1
                            lbytep++;
                            if (lbytep>=8) {
 262:	48 30       	cpi	r20, 0x08	; 8
 264:	08 f0       	brcs	.+2      	; 0x268 <__stack+0x9>
 266:	67 c1       	rjmp	.+718    	; 0x536 <__stack+0x2d7>
                                lmode=OWM_SLEEP;  //all bits processed
                                break;
                            }
                        }
                        lsrcount=0;
                        lactbit=(owid[lbytep]&lbitp)==lbitp;
 268:	e4 2f       	mov	r30, r20
 26a:	f0 e0       	ldi	r31, 0x00	; 0
 26c:	eb 59       	subi	r30, 0x9B	; 155
 26e:	ff 4f       	sbci	r31, 0xFF	; 255
 270:	80 81       	ld	r24, Z
 272:	8d 23       	and	r24, r29
 274:	71 e0       	ldi	r23, 0x01	; 1
 276:	8d 13       	cpse	r24, r29
 278:	70 e0       	ldi	r23, 0x00	; 0
                        lwmode=lactbit;
 27a:	67 2f       	mov	r22, r23
                            if (lbytep>=8) {
                                lmode=OWM_SLEEP;  //all bits processed
                                break;
                            }
                        }
                        lsrcount=0;
 27c:	c0 e0       	ldi	r28, 0x00	; 0
 27e:	6c c1       	rjmp	.+728    	; 0x558 <__stack+0x2f9>
                    }
                    break;
            }
            break;
        case OWM_MATCH_ROM:
            if (p==((owid[lbytep]&lbitp)==lbitp)) {  //Compare with ID Buffer
 280:	e4 2f       	mov	r30, r20
 282:	f0 e0       	ldi	r31, 0x00	; 0
 284:	eb 59       	subi	r30, 0x9B	; 155
 286:	ff 4f       	sbci	r31, 0xFF	; 255
 288:	80 81       	ld	r24, Z
 28a:	8d 23       	and	r24, r29
 28c:	91 e0       	ldi	r25, 0x01	; 1
 28e:	8d 13       	cpse	r24, r29
 290:	90 e0       	ldi	r25, 0x00	; 0
 292:	19 13       	cpse	r17, r25
 294:	50 c1       	rjmp	.+672    	; 0x536 <__stack+0x2d7>
                lbitp=(lbitp<<1);
 296:	dd 0f       	add	r29, r29
                if (!lbitp) {
 298:	09 f0       	breq	.+2      	; 0x29c <__stack+0x3d>
 29a:	5e c1       	rjmp	.+700    	; 0x558 <__stack+0x2f9>
                    lbytep++;
 29c:	4f 5f       	subi	r20, 0xFF	; 255
                    lbitp=1;
                    if (lbytep>=8) {
 29e:	48 30       	cpi	r20, 0x08	; 8
 2a0:	08 f4       	brcc	.+2      	; 0x2a4 <__stack+0x45>
 2a2:	7a c1       	rjmp	.+756    	; 0x598 <__stack+0x339>
                        lmode=OWM_READ_COMMAND;  //same? get next command
                        cbuf=0;
 2a4:	10 92 9b 00 	sts	0x009B, r1
        case OWM_MATCH_ROM:
            if (p==((owid[lbytep]&lbitp)==lbitp)) {  //Compare with ID Buffer
                lbitp=(lbitp<<1);
                if (!lbitp) {
                    lbytep++;
                    lbitp=1;
 2a8:	d1 e0       	ldi	r29, 0x01	; 1
                    if (lbytep>=8) {
                        lmode=OWM_READ_COMMAND;  //same? get next command
 2aa:	53 e0       	ldi	r21, 0x03	; 3
                        cbuf=0;
                        break;
 2ac:	57 c1       	rjmp	.+686    	; 0x55c <__stack+0x2fd>
            } else {
                lmode=OWM_SLEEP;
            }
            break;
        case OWM_GET_ADRESS:
            if (p) { //Get the Address for reading
 2ae:	11 23       	and	r17, r17
 2b0:	29 f0       	breq	.+10     	; 0x2bc <__stack+0x5d>
                page|=lbitp;
 2b2:	80 91 9c 00 	lds	r24, 0x009C
 2b6:	8d 2b       	or	r24, r29
 2b8:	80 93 9c 00 	sts	0x009C, r24
            }
            lbitp=(lbitp<<1);
 2bc:	dd 0f       	add	r29, r29
            if (!lbitp) {
 2be:	09 f0       	breq	.+2      	; 0x2c2 <__stack+0x63>
 2c0:	4b c1       	rjmp	.+662    	; 0x558 <__stack+0x2f9>
                lbytep++;
 2c2:	4f 5f       	subi	r20, 0xFF	; 255
                lbitp=1;
                if (lbytep==1) {
 2c4:	41 30       	cpi	r20, 0x01	; 1
 2c6:	09 f0       	breq	.+2      	; 0x2ca <__stack+0x6b>
 2c8:	b5 c0       	rjmp	.+362    	; 0x434 <__stack+0x1d5>
                    lmode=OWM_WRITE_PAGE_TO_MASTER;
                    lbytep=0;lscrc=0; //from first position
                    memset( &scratchpad.bytes, 0, 10 );
 2ca:	8a e0       	ldi	r24, 0x0A	; 10
 2cc:	e0 e8       	ldi	r30, 0x80	; 128
 2ce:	f0 e0       	ldi	r31, 0x00	; 0
 2d0:	df 01       	movw	r26, r30
 2d2:	1d 92       	st	X+, r1
 2d4:	8a 95       	dec	r24
 2d6:	e9 f7       	brne	.-6      	; 0x2d2 <__stack+0x73>
                    switch (page) {
 2d8:	80 91 9c 00 	lds	r24, 0x009C
 2dc:	83 30       	cpi	r24, 0x03	; 3
 2de:	09 f4       	brne	.+2      	; 0x2e2 <__stack+0x83>
 2e0:	62 c0       	rjmp	.+196    	; 0x3a6 <__stack+0x147>
 2e2:	20 f4       	brcc	.+8      	; 0x2ec <__stack+0x8d>
 2e4:	81 30       	cpi	r24, 0x01	; 1
 2e6:	49 f1       	breq	.+82     	; 0x33a <__stack+0xdb>
 2e8:	c8 f5       	brcc	.+114    	; 0x35c <__stack+0xfd>
 2ea:	0a c0       	rjmp	.+20     	; 0x300 <__stack+0xa1>
 2ec:	89 30       	cpi	r24, 0x09	; 9
 2ee:	09 f4       	brne	.+2      	; 0x2f2 <__stack+0x93>
 2f0:	5f c0       	rjmp	.+190    	; 0x3b0 <__stack+0x151>
 2f2:	8a 30       	cpi	r24, 0x0A	; 10
 2f4:	09 f4       	brne	.+2      	; 0x2f8 <__stack+0x99>
 2f6:	6e c0       	rjmp	.+220    	; 0x3d4 <__stack+0x175>
 2f8:	84 30       	cpi	r24, 0x04	; 4
 2fa:	09 f0       	breq	.+2      	; 0x2fe <__stack+0x9f>
 2fc:	86 c0       	rjmp	.+268    	; 0x40a <__stack+0x1ab>
 2fe:	53 c0       	rjmp	.+166    	; 0x3a6 <__stack+0x147>
                      case 0:
                        scratchpad.page1 = page;
 300:	80 91 9c 00 	lds	r24, 0x009C
 304:	80 93 80 00 	sts	0x0080, r24
                        scratchpad.u8_11 = stype;
 308:	80 91 62 00 	lds	r24, 0x0062
 30c:	80 93 81 00 	sts	0x0081, r24
                        scratchpad.u8_12 = eflag;
 310:	80 91 98 00 	lds	r24, 0x0098
 314:	80 93 82 00 	sts	0x0082, r24
                        scratchpad.u16_13 = version;
 318:	80 91 63 00 	lds	r24, 0x0063
 31c:	90 91 64 00 	lds	r25, 0x0064
 320:	90 93 84 00 	sts	0x0084, r25
 324:	80 93 83 00 	sts	0x0083, r24
                        scratchpad.u32_14 = uptime;
 328:	80 91 7b 00 	lds	r24, 0x007B
 32c:	90 91 7c 00 	lds	r25, 0x007C
 330:	a0 91 7d 00 	lds	r26, 0x007D
 334:	b0 91 7e 00 	lds	r27, 0x007E
 338:	2d c0       	rjmp	.+90     	; 0x394 <__stack+0x135>
                        break;
                      case 1:
                        scratchpad.page1 = page;
 33a:	80 91 9c 00 	lds	r24, 0x009C
 33e:	80 93 80 00 	sts	0x0080, r24
                        scratchpad.u16_21 = rcnt;
 342:	80 91 60 00 	lds	r24, 0x0060
 346:	90 91 61 00 	lds	r25, 0x0061
 34a:	90 93 82 00 	sts	0x0082, r25
 34e:	80 93 81 00 	sts	0x0081, r24
                        //scratchpad.u16_22 = ADC1
                        //scratchpad.u16_23 = ADC2
                        scratchpad.u16_24 = crcerrcnt; //temp/debug
 352:	80 91 78 00 	lds	r24, 0x0078
 356:	80 93 87 00 	sts	0x0087, r24
                        //scratchpad.u16_24 = freeRam;
                        break;
 35a:	62 c0       	rjmp	.+196    	; 0x420 <__stack+0x1c1>
                      case 2:
                        scratchpad.page1 = page;
 35c:	80 91 9c 00 	lds	r24, 0x009C
 360:	80 93 80 00 	sts	0x0080, r24
                        scratchpad.u32_31 = temperature;
 364:	80 91 8d 00 	lds	r24, 0x008D
 368:	90 91 8e 00 	lds	r25, 0x008E
 36c:	a0 91 8f 00 	lds	r26, 0x008F
 370:	b0 91 90 00 	lds	r27, 0x0090
 374:	80 93 81 00 	sts	0x0081, r24
 378:	90 93 82 00 	sts	0x0082, r25
 37c:	a0 93 83 00 	sts	0x0083, r26
 380:	b0 93 84 00 	sts	0x0084, r27
                        scratchpad.u32_32 = pressure;
 384:	80 91 92 00 	lds	r24, 0x0092
 388:	90 91 93 00 	lds	r25, 0x0093
 38c:	a0 91 94 00 	lds	r26, 0x0094
 390:	b0 91 95 00 	lds	r27, 0x0095
 394:	80 93 85 00 	sts	0x0085, r24
 398:	90 93 86 00 	sts	0x0086, r25
 39c:	a0 93 87 00 	sts	0x0087, r26
 3a0:	b0 93 88 00 	sts	0x0088, r27
                        break;
 3a4:	3d c0       	rjmp	.+122    	; 0x420 <__stack+0x1c1>
                      case 3:
                        scratchpad.page1 = page;
                        //?
                        break;
                      case 4:
                        scratchpad.page1 = page;
 3a6:	80 91 9c 00 	lds	r24, 0x009C
 3aa:	80 93 80 00 	sts	0x0080, r24
                          int16_t  b2;
                          int16_t  mb;
                          int16_t  mc;
                          int16_t  md;
                        */
                        break;
 3ae:	38 c0       	rjmp	.+112    	; 0x420 <__stack+0x1c1>
                      case 9:
                        scratchpad.page1 = page;
 3b0:	80 91 9c 00 	lds	r24, 0x009C
 3b4:	80 93 80 00 	sts	0x0080, r24
                        scratchpad.u32_31 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+0));
 3b8:	82 e3       	ldi	r24, 0x32	; 50
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	e0 d1       	rcall	.+960    	; 0x77e <__eerd_dword_tn84>
 3be:	60 93 81 00 	sts	0x0081, r22
 3c2:	70 93 82 00 	sts	0x0082, r23
 3c6:	80 93 83 00 	sts	0x0083, r24
 3ca:	90 93 84 00 	sts	0x0084, r25
                        scratchpad.u32_32 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+4));
 3ce:	86 e3       	ldi	r24, 0x36	; 54
 3d0:	90 e0       	ldi	r25, 0x00	; 0
 3d2:	11 c0       	rjmp	.+34     	; 0x3f6 <__stack+0x197>
                        break;
                      case 10:
                        scratchpad.page1 = page;
 3d4:	80 91 9c 00 	lds	r24, 0x009C
 3d8:	80 93 80 00 	sts	0x0080, r24
                        scratchpad.u32_31 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+8));
 3dc:	8a e3       	ldi	r24, 0x3A	; 58
 3de:	90 e0       	ldi	r25, 0x00	; 0
 3e0:	ce d1       	rcall	.+924    	; 0x77e <__eerd_dword_tn84>
 3e2:	60 93 81 00 	sts	0x0081, r22
 3e6:	70 93 82 00 	sts	0x0082, r23
 3ea:	80 93 83 00 	sts	0x0083, r24
 3ee:	90 93 84 00 	sts	0x0084, r25
                        scratchpad.u32_32 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+12));
 3f2:	8e e3       	ldi	r24, 0x3E	; 62
 3f4:	90 e0       	ldi	r25, 0x00	; 0
 3f6:	c3 d1       	rcall	.+902    	; 0x77e <__eerd_dword_tn84>
 3f8:	60 93 85 00 	sts	0x0085, r22
 3fc:	70 93 86 00 	sts	0x0086, r23
 400:	80 93 87 00 	sts	0x0087, r24
 404:	90 93 88 00 	sts	0x0088, r25
                        break;
 408:	0b c0       	rjmp	.+22     	; 0x420 <__stack+0x1c1>
                      default:
                        scratchpad.page1 = page;
 40a:	80 91 9c 00 	lds	r24, 0x009C
 40e:	80 93 80 00 	sts	0x0080, r24
                        scratchpad.u8_11 = 0xff;
 412:	8f ef       	ldi	r24, 0xFF	; 255
 414:	80 93 81 00 	sts	0x0081, r24
                        scratchpad.u8_12 = page; //this is actually an error! page unknown
 418:	80 91 9c 00 	lds	r24, 0x009C
 41c:	80 93 82 00 	sts	0x0082, r24
                        break;
                    }
                    lactbit=(lbitp&scratchpad.bytes[0])==lbitp;
 420:	60 91 80 00 	lds	r22, 0x0080
 424:	61 70       	andi	r22, 0x01	; 1
 426:	76 2f       	mov	r23, r22
            if (!lbitp) {
                lbytep++;
                lbitp=1;
                if (lbytep==1) {
                    lmode=OWM_WRITE_PAGE_TO_MASTER;
                    lbytep=0;lscrc=0; //from first position
 428:	20 e0       	ldi	r18, 0x00	; 0
 42a:	30 e0       	ldi	r19, 0x00	; 0
                page|=lbitp;
            }
            lbitp=(lbitp<<1);
            if (!lbitp) {
                lbytep++;
                lbitp=1;
 42c:	d1 e0       	ldi	r29, 0x01	; 1
                if (lbytep==1) {
                    lmode=OWM_WRITE_PAGE_TO_MASTER;
                    lbytep=0;lscrc=0; //from first position
 42e:	40 e0       	ldi	r20, 0x00	; 0
            lbitp=(lbitp<<1);
            if (!lbitp) {
                lbytep++;
                lbitp=1;
                if (lbytep==1) {
                    lmode=OWM_WRITE_PAGE_TO_MASTER;
 430:	5b e0       	ldi	r21, 0x0B	; 11
                        scratchpad.u8_12 = page; //this is actually an error! page unknown
                        break;
                    }
                    lactbit=(lbitp&scratchpad.bytes[0])==lbitp;
                    lwmode=lactbit; //prepare for send firs bit
                    break;
 432:	94 c0       	rjmp	.+296    	; 0x55c <__stack+0x2fd>
                } else page=0; // never happens, should be page[lbytepos]
 434:	10 92 9c 00 	sts	0x009C, r1
 438:	af c0       	rjmp	.+350    	; 0x598 <__stack+0x339>
            }
            break;
        case OWM_WRITE_FUNC:
            if (p) {
 43a:	11 23       	and	r17, r17
 43c:	39 f0       	breq	.+14     	; 0x44c <__stack+0x1ed>
                scratchpad.bytes[lbytep]|=lbitp;
 43e:	e4 2f       	mov	r30, r20
 440:	f0 e0       	ldi	r31, 0x00	; 0
 442:	e0 58       	subi	r30, 0x80	; 128
 444:	ff 4f       	sbci	r31, 0xFF	; 255
 446:	80 81       	ld	r24, Z
 448:	8d 2b       	or	r24, r29
 44a:	80 83       	st	Z, r24
            }
            /* Page(function) is part of CRC! */
            if ((lscrc&1)!=p) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
 44c:	f9 01       	movw	r30, r18
 44e:	e1 70       	andi	r30, 0x01	; 1
 450:	ff 27       	eor	r31, r31
 452:	81 2f       	mov	r24, r17
 454:	90 e0       	ldi	r25, 0x00	; 0
 456:	36 95       	lsr	r19
 458:	27 95       	ror	r18
 45a:	e8 17       	cp	r30, r24
 45c:	f9 07       	cpc	r31, r25
 45e:	11 f0       	breq	.+4      	; 0x464 <__stack+0x205>
 460:	bc e8       	ldi	r27, 0x8C	; 140
 462:	2b 27       	eor	r18, r27
            lbitp=(lbitp<<1);
 464:	dd 0f       	add	r29, r29
            if (!lbitp) {
 466:	09 f0       	breq	.+2      	; 0x46a <__stack+0x20b>
 468:	77 c0       	rjmp	.+238    	; 0x558 <__stack+0x2f9>
                lbytep++;
 46a:	4f 5f       	subi	r20, 0xFF	; 255
                lbitp=1;
                if (lbytep==10) {
 46c:	4a 30       	cpi	r20, 0x0A	; 10
 46e:	a1 f5       	brne	.+104    	; 0x4d8 <__stack+0x279>
                    /* now process received Write-function(s) if crc matches */
                    if (scratchpad.bytes[9] != scratchpad.bytes[10])
 470:	90 91 89 00 	lds	r25, 0x0089
 474:	80 91 8a 00 	lds	r24, 0x008A
 478:	98 17       	cp	r25, r24
 47a:	31 f0       	breq	.+12     	; 0x488 <__stack+0x229>
                      crcerrcnt++;
 47c:	80 91 78 00 	lds	r24, 0x0078
 480:	8f 5f       	subi	r24, 0xFF	; 255
 482:	80 93 78 00 	sts	0x0078, r24
 486:	82 c0       	rjmp	.+260    	; 0x58c <__stack+0x32d>
                    else {
                      switch (scratchpad.bytes[0]) { /* "page" or function-id */
 488:	80 91 80 00 	lds	r24, 0x0080
 48c:	8c 34       	cpi	r24, 0x4C	; 76
 48e:	51 f0       	breq	.+20     	; 0x4a4 <__stack+0x245>
 490:	20 f4       	brcc	.+8      	; 0x49a <__stack+0x23b>
 492:	88 34       	cpi	r24, 0x48	; 72
 494:	09 f0       	breq	.+2      	; 0x498 <__stack+0x239>
 496:	7a c0       	rjmp	.+244    	; 0x58c <__stack+0x32d>
 498:	05 c0       	rjmp	.+10     	; 0x4a4 <__stack+0x245>
 49a:	80 35       	cpi	r24, 0x50	; 80
 49c:	19 f0       	breq	.+6      	; 0x4a4 <__stack+0x245>
 49e:	84 35       	cpi	r24, 0x54	; 84
 4a0:	09 f0       	breq	.+2      	; 0x4a4 <__stack+0x245>
 4a2:	74 c0       	rjmp	.+232    	; 0x58c <__stack+0x32d>
                        case 72:
                        case 76:
                        case 80:
                        case 84:
                          if (ewrite_flag > 0) //last write still pending!
 4a4:	80 91 9d 00 	lds	r24, 0x009D
 4a8:	81 11       	cpse	r24, r1
 4aa:	70 c0       	rjmp	.+224    	; 0x58c <__stack+0x32d>
                            break;
                          eewrite_buf.u32_1 = scratchpad.u32_31;
 4ac:	80 91 81 00 	lds	r24, 0x0081
 4b0:	90 91 82 00 	lds	r25, 0x0082
 4b4:	a0 91 83 00 	lds	r26, 0x0083
 4b8:	b0 91 84 00 	lds	r27, 0x0084
 4bc:	80 93 a0 00 	sts	0x00A0, r24
 4c0:	90 93 a1 00 	sts	0x00A1, r25
 4c4:	a0 93 a2 00 	sts	0x00A2, r26
 4c8:	b0 93 a3 00 	sts	0x00A3, r27
                          ewrite_flag = (scratchpad.page1) - 72 + EE_LABEL_OFFSET;
 4cc:	80 91 80 00 	lds	r24, 0x0080
 4d0:	86 51       	subi	r24, 0x16	; 22
 4d2:	80 93 9d 00 	sts	0x009D, r24
 4d6:	5a c0       	rjmp	.+180    	; 0x58c <__stack+0x32d>
                          break;
                      }
                    }
                    lmode=OWM_SLEEP;
                    break;
                } else scratchpad.bytes[lbytep]=0;
 4d8:	e4 2f       	mov	r30, r20
 4da:	f0 e0       	ldi	r31, 0x00	; 0
 4dc:	e0 58       	subi	r30, 0x80	; 128
 4de:	ff 4f       	sbci	r31, 0xFF	; 255
 4e0:	10 82       	st	Z, r1
                if (lbytep==9) {
 4e2:	49 30       	cpi	r20, 0x09	; 9
 4e4:	09 f0       	breq	.+2      	; 0x4e8 <__stack+0x289>
 4e6:	58 c0       	rjmp	.+176    	; 0x598 <__stack+0x339>
                    //copy calculated CRC to last scratchpad-byte as we receive it with next byte!
                    scratchpad.bytes[10] = lscrc;
 4e8:	20 93 8a 00 	sts	0x008A, r18
 4ec:	55 c0       	rjmp	.+170    	; 0x598 <__stack+0x339>
                }
            }
            break;
        case OWM_WRITE_PAGE_TO_MASTER:
            RESET_LOW;
 4ee:	ba 98       	cbi	0x17, 2	; 23
            if ((lscrc&1)!=lactbit) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
 4f0:	f9 01       	movw	r30, r18
 4f2:	e1 70       	andi	r30, 0x01	; 1
 4f4:	ff 27       	eor	r31, r31
 4f6:	87 2f       	mov	r24, r23
 4f8:	90 e0       	ldi	r25, 0x00	; 0
 4fa:	36 95       	lsr	r19
 4fc:	27 95       	ror	r18
 4fe:	e8 17       	cp	r30, r24
 500:	f9 07       	cpc	r31, r25
 502:	11 f0       	breq	.+4      	; 0x508 <__stack+0x2a9>
 504:	8c e8       	ldi	r24, 0x8C	; 140
 506:	28 27       	eor	r18, r24
            lbitp=(lbitp<<1);
 508:	dd 0f       	add	r29, r29
            if (!lbitp) {
 50a:	41 f4       	brne	.+16     	; 0x51c <__stack+0x2bd>
                lbytep++;
 50c:	4f 5f       	subi	r20, 0xFF	; 255
                lbitp=1;
                if (lbytep>=10) {
 50e:	4a 30       	cpi	r20, 0x0A	; 10
 510:	e8 f5       	brcc	.+122    	; 0x58c <__stack+0x32d>
                    lmode=OWM_SLEEP;
                    break;
                } else if (lbytep==9) scratchpad.bytes[9]=lscrc;
 512:	49 30       	cpi	r20, 0x09	; 9
 514:	11 f4       	brne	.+4      	; 0x51a <__stack+0x2bb>
 516:	20 93 89 00 	sts	0x0089, r18
            RESET_LOW;
            if ((lscrc&1)!=lactbit) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
            lbitp=(lbitp<<1);
            if (!lbitp) {
                lbytep++;
                lbitp=1;
 51a:	d1 e0       	ldi	r29, 0x01	; 1
                if (lbytep>=10) {
                    lmode=OWM_SLEEP;
                    break;
                } else if (lbytep==9) scratchpad.bytes[9]=lscrc;
            }
            lactbit=(lbitp&scratchpad.bytes[lbytep])==lbitp;
 51c:	e4 2f       	mov	r30, r20
 51e:	f0 e0       	ldi	r31, 0x00	; 0
 520:	e0 58       	subi	r30, 0x80	; 128
 522:	ff 4f       	sbci	r31, 0xFF	; 255
 524:	80 81       	ld	r24, Z
 526:	8d 23       	and	r24, r29
 528:	71 e0       	ldi	r23, 0x01	; 1
 52a:	8d 13       	cpse	r24, r29
 52c:	70 e0       	ldi	r23, 0x00	; 0
            lwmode=lactbit;
 52e:	67 2f       	mov	r22, r23
            break;
 530:	13 c0       	rjmp	.+38     	; 0x558 <__stack+0x2f9>
        }
        if (lmode==OWM_SLEEP) {
 532:	51 11       	cpse	r21, r1
 534:	11 c0       	rjmp	.+34     	; 0x558 <__stack+0x2f9>
          //RESET_LOW;  //??? Set pin as input again ???
          DIS_TIMER;
 536:	89 b7       	in	r24, 0x39	; 57
 538:	8e 7f       	andi	r24, 0xFE	; 254
 53a:	89 bf       	out	0x39, r24	; 57
          EN_OWINT; SET_OWINT_LOWLEVEL;
 53c:	8b b7       	in	r24, 0x3b	; 59
 53e:	80 64       	ori	r24, 0x40	; 64
 540:	8b bf       	out	0x3b, r24	; 59
 542:	80 e4       	ldi	r24, 0x40	; 64
 544:	8a bf       	out	0x3a, r24	; 58
 546:	85 b7       	in	r24, 0x35	; 53
 548:	8c 7f       	andi	r24, 0xFC	; 252
 54a:	85 bf       	out	0x35, r24	; 53
          sleepmode=SLEEP_MODE_PWR_DOWN; //sleep deep
 54c:	80 e1       	ldi	r24, 0x10	; 16
 54e:	80 93 7f 00 	sts	0x007F, r24
          OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
 552:	da 98       	cbi	0x1b, 2	; 27
 554:	50 e0       	ldi	r21, 0x00	; 0
 556:	02 c0       	rjmp	.+4      	; 0x55c <__stack+0x2fd>
        } else {
          //sleepmode=SLEEP_MODE_IDLE; //no sleep
        }

        if (lmode!=OWM_PRESENCE)  {
 558:	52 30       	cpi	r21, 0x02	; 2
 55a:	39 f0       	breq	.+14     	; 0x56a <__stack+0x30b>
            TCNT_REG=~(OWT_MIN_RESET-OWT_READLINE);  //OWT_READLINE around OWT_LOWTIME
 55c:	8e ec       	ldi	r24, 0xCE	; 206
 55e:	82 bf       	out	0x32, r24	; 50
            EN_OWINT;
 560:	8b b7       	in	r24, 0x3b	; 59
 562:	80 64       	ori	r24, 0x40	; 64
 564:	8b bf       	out	0x3b, r24	; 59
 566:	80 e4       	ldi	r24, 0x40	; 64
 568:	8a bf       	out	0x3a, r24	; 58
        }
        mode=lmode;
 56a:	50 93 99 00 	sts	0x0099, r21
        wmode=lwmode;
 56e:	60 93 8b 00 	sts	0x008B, r22
        bytep=lbytep;
 572:	40 93 9a 00 	sts	0x009A, r20
        bitp=lbitp;
 576:	d0 93 96 00 	sts	0x0096, r29
        srcount=lsrcount;
 57a:	c0 93 97 00 	sts	0x0097, r28
        actbit=lactbit;
 57e:	70 93 8c 00 	sts	0x008C, r23
        scrc=lscrc;
 582:	30 93 9f 00 	sts	0x009F, r19
 586:	20 93 9e 00 	sts	0x009E, r18
 58a:	08 c0       	rjmp	.+16     	; 0x59c <__stack+0x33d>
            RESET_LOW;
            if ((lscrc&1)!=lactbit) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
            lbitp=(lbitp<<1);
            if (!lbitp) {
                lbytep++;
                lbitp=1;
 58c:	d1 e0       	ldi	r29, 0x01	; 1
 58e:	d3 cf       	rjmp	.-90     	; 0x536 <__stack+0x2d7>
            if (p) {  //Set bit if line high
                cbuf|=lbitp;
            }
            lbitp=(lbitp<<1);
            if (!lbitp) { //8-Bits read - weird syntax?
                lbitp=1;
 590:	d1 e0       	ldi	r29, 0x01	; 1
                switch (cbuf) {
                    case 0x55://Match ROM
                        lbytep=0;
 592:	40 e0       	ldi	r20, 0x00	; 0
                        lmode=OWM_MATCH_ROM;
 594:	55 e0       	ldi	r21, 0x05	; 5
 596:	e2 cf       	rjmp	.-60     	; 0x55c <__stack+0x2fd>
            /* Page(function) is part of CRC! */
            if ((lscrc&1)!=p) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
            lbitp=(lbitp<<1);
            if (!lbitp) {
                lbytep++;
                lbitp=1;
 598:	d1 e0       	ldi	r29, 0x01	; 1
 59a:	de cf       	rjmp	.-68     	; 0x558 <__stack+0x2f9>
        bytep=lbytep;
        bitp=lbitp;
        srcount=lsrcount;
        actbit=lactbit;
        scrc=lscrc;
}
 59c:	ff 91       	pop	r31
 59e:	ef 91       	pop	r30
 5a0:	df 91       	pop	r29
 5a2:	cf 91       	pop	r28
 5a4:	bf 91       	pop	r27
 5a6:	af 91       	pop	r26
 5a8:	9f 91       	pop	r25
 5aa:	8f 91       	pop	r24
 5ac:	7f 91       	pop	r23
 5ae:	6f 91       	pop	r22
 5b0:	5f 91       	pop	r21
 5b2:	4f 91       	pop	r20
 5b4:	3f 91       	pop	r19
 5b6:	2f 91       	pop	r18
 5b8:	1f 91       	pop	r17
 5ba:	0f 90       	pop	r0
 5bc:	0f be       	out	0x3f, r0	; 63
 5be:	0f 90       	pop	r0
 5c0:	1f 90       	pop	r1
 5c2:	18 95       	reti

000005c4 <init_eeprom>:
#elif defined PC_INT_ISRA
PC_INT_ISRA
PC_INT_ISRB
#endif

void init_eeprom(void) {
 5c4:	0f 93       	push	r16
 5c6:	1f 93       	push	r17
 5c8:	cf 93       	push	r28
 5ca:	df 93       	push	r29
    /* check magic, read slave address and counter values, resetcount, init-name, */
    if (eeprom_read_word((const uint16_t *) (EE_MAGIC_OFFSET+0)) == EE_MAGIC_NUMBER) {
 5cc:	80 e0       	ldi	r24, 0x00	; 0
 5ce:	90 e0       	ldi	r25, 0x00	; 0
 5d0:	db d0       	rcall	.+438    	; 0x788 <__eerd_word_tn84>
 5d2:	82 3e       	cpi	r24, 0xE2	; 226
 5d4:	91 4e       	sbci	r25, 0xE1	; 225
 5d6:	39 f5       	brne	.+78     	; 0x626 <init_eeprom+0x62>
 5d8:	05 e6       	ldi	r16, 0x65	; 101
 5da:	10 e0       	ldi	r17, 0x00	; 0
 5dc:	c2 e0       	ldi	r28, 0x02	; 2
 5de:	d0 e0       	ldi	r29, 0x00	; 0
      //EEPROM valid -> read counters & settings
      for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
        owid[i-EE_OWID_OFFSET] = eeprom_read_byte((uint8_t *) i);
 5e0:	ce 01       	movw	r24, r28
 5e2:	c5 d0       	rcall	.+394    	; 0x76e <__eerd_byte_tn84>
 5e4:	f8 01       	movw	r30, r16
 5e6:	81 93       	st	Z+, r24
 5e8:	8f 01       	movw	r16, r30

void init_eeprom(void) {
    /* check magic, read slave address and counter values, resetcount, init-name, */
    if (eeprom_read_word((const uint16_t *) (EE_MAGIC_OFFSET+0)) == EE_MAGIC_NUMBER) {
      //EEPROM valid -> read counters & settings
      for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 5ea:	21 96       	adiw	r28, 0x01	; 1
 5ec:	ca 30       	cpi	r28, 0x0A	; 10
 5ee:	d1 05       	cpc	r29, r1
 5f0:	b9 f7       	brne	.-18     	; 0x5e0 <init_eeprom+0x1c>
        owid[i-EE_OWID_OFFSET] = eeprom_read_byte((uint8_t *) i);
      rcnt = eeprom_read_word((const uint16_t *) (EE_RCNT_OFFSET+0)) + 1;
 5f2:	8a e0       	ldi	r24, 0x0A	; 10
 5f4:	90 e0       	ldi	r25, 0x00	; 0
 5f6:	c8 d0       	rcall	.+400    	; 0x788 <__eerd_word_tn84>
 5f8:	bc 01       	movw	r22, r24
 5fa:	6f 5f       	subi	r22, 0xFF	; 255
 5fc:	7f 4f       	sbci	r23, 0xFF	; 255
 5fe:	70 93 61 00 	sts	0x0061, r23
 602:	60 93 60 00 	sts	0x0060, r22
      eeprom_update_word((uint16_t *) (EE_RCNT_OFFSET+0), rcnt);
 606:	8a e0       	ldi	r24, 0x0A	; 10
 608:	90 e0       	ldi	r25, 0x00	; 0
 60a:	cb d0       	rcall	.+406    	; 0x7a2 <__eeupd_word_tn84>
      version = eeprom_read_word((const uint16_t *) (EE_VERSION_OFFSET+0));
 60c:	8d e2       	ldi	r24, 0x2D	; 45
 60e:	90 e0       	ldi	r25, 0x00	; 0
 610:	bb d0       	rcall	.+374    	; 0x788 <__eerd_word_tn84>
 612:	90 93 64 00 	sts	0x0064, r25
 616:	80 93 63 00 	sts	0x0063, r24
      stype = eeprom_read_byte((uint8_t *) (EE_TYPE_OFFSET+0));
 61a:	8c e2       	ldi	r24, 0x2C	; 44
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	a7 d0       	rcall	.+334    	; 0x76e <__eerd_byte_tn84>
 620:	80 93 62 00 	sts	0x0062, r24
 624:	29 c0       	rjmp	.+82     	; 0x678 <init_eeprom+0xb4>
    } else {
      //Init values
      /* should cli(); here no sei(); yet enabled in main.. */
      eeprom_write_word((uint16_t *) (EE_MAGIC_OFFSET+0), EE_MAGIC_NUMBER);
 626:	62 ee       	ldi	r22, 0xE2	; 226
 628:	71 ee       	ldi	r23, 0xE1	; 225
 62a:	80 e0       	ldi	r24, 0x00	; 0
 62c:	90 e0       	ldi	r25, 0x00	; 0
 62e:	cb d0       	rcall	.+406    	; 0x7c6 <__eewr_word_tn84>
 630:	05 e6       	ldi	r16, 0x65	; 101
 632:	10 e0       	ldi	r17, 0x00	; 0
      for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 634:	c2 e0       	ldi	r28, 0x02	; 2
 636:	d0 e0       	ldi	r29, 0x00	; 0
        eeprom_write_byte((uint8_t *) i,owid[i-EE_OWID_OFFSET]);
 638:	f8 01       	movw	r30, r16
 63a:	61 91       	ld	r22, Z+
 63c:	8f 01       	movw	r16, r30
 63e:	ce 01       	movw	r24, r28
 640:	b4 d0       	rcall	.+360    	; 0x7aa <__eewr_byte_tn84>
      stype = eeprom_read_byte((uint8_t *) (EE_TYPE_OFFSET+0));
    } else {
      //Init values
      /* should cli(); here no sei(); yet enabled in main.. */
      eeprom_write_word((uint16_t *) (EE_MAGIC_OFFSET+0), EE_MAGIC_NUMBER);
      for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 642:	21 96       	adiw	r28, 0x01	; 1
 644:	ca 30       	cpi	r28, 0x0A	; 10
 646:	d1 05       	cpc	r29, r1
 648:	b9 f7       	brne	.-18     	; 0x638 <init_eeprom+0x74>
        eeprom_write_byte((uint8_t *) i,owid[i-EE_OWID_OFFSET]);
      eeprom_write_word((uint16_t *) (EE_RCNT_OFFSET+0), rcnt);
 64a:	60 91 60 00 	lds	r22, 0x0060
 64e:	70 91 61 00 	lds	r23, 0x0061
 652:	8a e0       	ldi	r24, 0x0A	; 10
 654:	90 e0       	ldi	r25, 0x00	; 0
 656:	b7 d0       	rcall	.+366    	; 0x7c6 <__eewr_word_tn84>
      eeprom_write_byte((uint8_t *) (EE_TYPE_OFFSET+0), stype);
 658:	60 91 62 00 	lds	r22, 0x0062
 65c:	8c e2       	ldi	r24, 0x2C	; 44
 65e:	90 e0       	ldi	r25, 0x00	; 0
 660:	a4 d0       	rcall	.+328    	; 0x7aa <__eewr_byte_tn84>
      eeprom_write_word((uint16_t *) (EE_VERSION_OFFSET+0), version);
 662:	60 91 63 00 	lds	r22, 0x0063
 666:	70 91 64 00 	lds	r23, 0x0064
 66a:	8d e2       	ldi	r24, 0x2D	; 45
 66c:	90 e0       	ldi	r25, 0x00	; 0
    }
}
 66e:	df 91       	pop	r29
 670:	cf 91       	pop	r28
 672:	1f 91       	pop	r17
 674:	0f 91       	pop	r16
      eeprom_write_word((uint16_t *) (EE_MAGIC_OFFSET+0), EE_MAGIC_NUMBER);
      for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
        eeprom_write_byte((uint8_t *) i,owid[i-EE_OWID_OFFSET]);
      eeprom_write_word((uint16_t *) (EE_RCNT_OFFSET+0), rcnt);
      eeprom_write_byte((uint8_t *) (EE_TYPE_OFFSET+0), stype);
      eeprom_write_word((uint16_t *) (EE_VERSION_OFFSET+0), version);
 676:	a7 c0       	rjmp	.+334    	; 0x7c6 <__eewr_word_tn84>
    }
}
 678:	df 91       	pop	r29
 67a:	cf 91       	pop	r28
 67c:	1f 91       	pop	r17
 67e:	0f 91       	pop	r16
 680:	08 95       	ret

00000682 <__vector_4>:

//FIXME: enable real watchdog?
ISR(WDT_vect) {
 682:	1f 92       	push	r1
 684:	0f 92       	push	r0
 686:	0f b6       	in	r0, 0x3f	; 63
 688:	0f 92       	push	r0
 68a:	11 24       	eor	r1, r1
 68c:	8f 93       	push	r24
 68e:	9f 93       	push	r25
 690:	af 93       	push	r26
 692:	bf 93       	push	r27
  uptime += 2;
 694:	80 91 7b 00 	lds	r24, 0x007B
 698:	90 91 7c 00 	lds	r25, 0x007C
 69c:	a0 91 7d 00 	lds	r26, 0x007D
 6a0:	b0 91 7e 00 	lds	r27, 0x007E
 6a4:	02 96       	adiw	r24, 0x02	; 2
 6a6:	a1 1d       	adc	r26, r1
 6a8:	b1 1d       	adc	r27, r1
 6aa:	80 93 7b 00 	sts	0x007B, r24
 6ae:	90 93 7c 00 	sts	0x007C, r25
 6b2:	a0 93 7d 00 	sts	0x007D, r26
 6b6:	b0 93 7e 00 	sts	0x007E, r27
}
 6ba:	bf 91       	pop	r27
 6bc:	af 91       	pop	r26
 6be:	9f 91       	pop	r25
 6c0:	8f 91       	pop	r24
 6c2:	0f 90       	pop	r0
 6c4:	0f be       	out	0x3f, r0	; 63
 6c6:	0f 90       	pop	r0
 6c8:	1f 90       	pop	r1
 6ca:	18 95       	reti

000006cc <main>:

int main(void) {
    mode=OWM_SLEEP;
 6cc:	10 92 99 00 	sts	0x0099, r1
    wmode=OWW_NO_WRITE;
 6d0:	d2 e0       	ldi	r29, 0x02	; 2
 6d2:	d0 93 8b 00 	sts	0x008B, r29
    OW_DDR&=~OW_PINN;
 6d6:	ba 98       	cbi	0x17, 2	; 23

    INIT_AVR
 6d8:	80 e8       	ldi	r24, 0x80	; 128
 6da:	86 bd       	out	0x26, r24	; 38
 6dc:	16 bc       	out	0x26, r1	; 38
 6de:	19 be       	out	0x39, r1	; 57
 6e0:	c0 e4       	ldi	r28, 0x40	; 64
 6e2:	cb bf       	out	0x3b, r28	; 59
 6e4:	83 e0       	ldi	r24, 0x03	; 3
 6e6:	83 bf       	out	0x33, r24	; 51
 6e8:	81 b5       	in	r24, 0x21	; 33
 6ea:	87 60       	ori	r24, 0x07	; 7
 6ec:	81 bd       	out	0x21, r24	; 33
 6ee:	81 b5       	in	r24, 0x21	; 33
 6f0:	80 64       	ori	r24, 0x40	; 64
 6f2:	81 bd       	out	0x21, r24	; 33
    PWRSAVE_AVR
 6f4:	37 98       	cbi	0x06, 7	; 6
 6f6:	80 b1       	in	r24, 0x00	; 0
 6f8:	8b 60       	ori	r24, 0x0B	; 11
 6fa:	80 b9       	out	0x00, r24	; 0

    init_eeprom();
 6fc:	63 df       	rcall	.-314    	; 0x5c4 <init_eeprom>

    INIT_LED_PINS
 6fe:	d2 9a       	sbi	0x1a, 2	; 26

    SET_OWINT_FALLING;
 700:	d5 bf       	out	0x35, r29	; 53
 702:	85 b7       	in	r24, 0x35	; 53
 704:	8e 7f       	andi	r24, 0xFE	; 254
 706:	85 bf       	out	0x35, r24	; 53
    DIS_TIMER;
 708:	89 b7       	in	r24, 0x39	; 57
 70a:	8e 7f       	andi	r24, 0xFE	; 254
 70c:	89 bf       	out	0x39, r24	; 57
    EN_OWINT;
 70e:	8b b7       	in	r24, 0x3b	; 59
 710:	80 64       	ori	r24, 0x40	; 64
 712:	8b bf       	out	0x3b, r24	; 59
 714:	ca bf       	out	0x3a, r28	; 58

    sei();
 716:	78 94       	sei
    //force sleep first
    DIS_TIMER;
 718:	89 b7       	in	r24, 0x39	; 57
 71a:	8e 7f       	andi	r24, 0xFE	; 254
 71c:	89 bf       	out	0x39, r24	; 57
    EN_OWINT; SET_OWINT_LOWLEVEL;
 71e:	8b b7       	in	r24, 0x3b	; 59
 720:	80 64       	ori	r24, 0x40	; 64
 722:	8b bf       	out	0x3b, r24	; 59
 724:	ca bf       	out	0x3a, r28	; 58
 726:	85 b7       	in	r24, 0x35	; 53
 728:	8c 7f       	andi	r24, 0xFC	; 252
 72a:	85 bf       	out	0x35, r24	; 53
    sleepmode=SLEEP_MODE_PWR_DOWN;
 72c:	80 e1       	ldi	r24, 0x10	; 16
 72e:	80 93 7f 00 	sts	0x007F, r24

    while(1){
        if (ewrite_flag) {
 732:	80 91 9d 00 	lds	r24, 0x009D
 736:	88 23       	and	r24, r24
 738:	71 f0       	breq	.+28     	; 0x756 <main+0x8a>
          eeprom_update_dword((uint32_t *) (ewrite_flag+0), eewrite_buf.u32_1);
 73a:	80 91 9d 00 	lds	r24, 0x009D
 73e:	40 91 a0 00 	lds	r20, 0x00A0
 742:	50 91 a1 00 	lds	r21, 0x00A1
 746:	60 91 a2 00 	lds	r22, 0x00A2
 74a:	70 91 a3 00 	lds	r23, 0x00A3
 74e:	90 e0       	ldi	r25, 0x00	; 0
 750:	20 d0       	rcall	.+64     	; 0x792 <__eeupd_dword_tn84>
          ewrite_flag = 0;
 752:	10 92 9d 00 	sts	0x009D, r1
        }
        OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
 756:	da 98       	cbi	0x1b, 2	; 27
        sleep_enable();
 758:	85 b7       	in	r24, 0x35	; 53
 75a:	80 62       	ori	r24, 0x20	; 32
 75c:	85 bf       	out	0x35, r24	; 53
        set_sleep_mode(sleepmode);
 75e:	85 b7       	in	r24, 0x35	; 53
 760:	90 91 7f 00 	lds	r25, 0x007F
 764:	87 7e       	andi	r24, 0xE7	; 231
 766:	89 2b       	or	r24, r25
 768:	85 bf       	out	0x35, r24	; 53
        sleep_cpu();
 76a:	88 95       	sleep
    }
 76c:	e2 cf       	rjmp	.-60     	; 0x732 <main+0x66>

0000076e <__eerd_byte_tn84>:
 76e:	e1 99       	sbic	0x1c, 1	; 28
 770:	fe cf       	rjmp	.-4      	; 0x76e <__eerd_byte_tn84>
 772:	9f bb       	out	0x1f, r25	; 31
 774:	8e bb       	out	0x1e, r24	; 30
 776:	e0 9a       	sbi	0x1c, 0	; 28
 778:	99 27       	eor	r25, r25
 77a:	8d b3       	in	r24, 0x1d	; 29
 77c:	08 95       	ret

0000077e <__eerd_dword_tn84>:
 77e:	a6 e1       	ldi	r26, 0x16	; 22
 780:	b0 e0       	ldi	r27, 0x00	; 0
 782:	44 e0       	ldi	r20, 0x04	; 4
 784:	50 e0       	ldi	r21, 0x00	; 0
 786:	24 c0       	rjmp	.+72     	; 0x7d0 <__eerd_blraw_tn84>

00000788 <__eerd_word_tn84>:
 788:	a8 e1       	ldi	r26, 0x18	; 24
 78a:	b0 e0       	ldi	r27, 0x00	; 0
 78c:	42 e0       	ldi	r20, 0x02	; 2
 78e:	50 e0       	ldi	r21, 0x00	; 0
 790:	1f c0       	rjmp	.+62     	; 0x7d0 <__eerd_blraw_tn84>

00000792 <__eeupd_dword_tn84>:
 792:	03 96       	adiw	r24, 0x03	; 3
 794:	27 2f       	mov	r18, r23
 796:	2b d0       	rcall	.+86     	; 0x7ee <__eeupd_r18_tn84>
 798:	29 d0       	rcall	.+82     	; 0x7ec <__eeupd_byte_tn84>
 79a:	25 2f       	mov	r18, r21
 79c:	28 d0       	rcall	.+80     	; 0x7ee <__eeupd_r18_tn84>
 79e:	24 2f       	mov	r18, r20
 7a0:	26 c0       	rjmp	.+76     	; 0x7ee <__eeupd_r18_tn84>

000007a2 <__eeupd_word_tn84>:
 7a2:	01 96       	adiw	r24, 0x01	; 1
 7a4:	27 2f       	mov	r18, r23
 7a6:	23 d0       	rcall	.+70     	; 0x7ee <__eeupd_r18_tn84>
 7a8:	21 c0       	rjmp	.+66     	; 0x7ec <__eeupd_byte_tn84>

000007aa <__eewr_byte_tn84>:
 7aa:	26 2f       	mov	r18, r22

000007ac <__eewr_r18_tn84>:
 7ac:	e1 99       	sbic	0x1c, 1	; 28
 7ae:	fe cf       	rjmp	.-4      	; 0x7ac <__eewr_r18_tn84>
 7b0:	1c ba       	out	0x1c, r1	; 28
 7b2:	9f bb       	out	0x1f, r25	; 31
 7b4:	8e bb       	out	0x1e, r24	; 30
 7b6:	2d bb       	out	0x1d, r18	; 29
 7b8:	0f b6       	in	r0, 0x3f	; 63
 7ba:	f8 94       	cli
 7bc:	e2 9a       	sbi	0x1c, 2	; 28
 7be:	e1 9a       	sbi	0x1c, 1	; 28
 7c0:	0f be       	out	0x3f, r0	; 63
 7c2:	01 96       	adiw	r24, 0x01	; 1
 7c4:	08 95       	ret

000007c6 <__eewr_word_tn84>:
 7c6:	f1 df       	rcall	.-30     	; 0x7aa <__eewr_byte_tn84>
 7c8:	27 2f       	mov	r18, r23
 7ca:	f0 cf       	rjmp	.-32     	; 0x7ac <__eewr_r18_tn84>

000007cc <__eerd_block_tn84>:
 7cc:	dc 01       	movw	r26, r24
 7ce:	cb 01       	movw	r24, r22

000007d0 <__eerd_blraw_tn84>:
 7d0:	fc 01       	movw	r30, r24
 7d2:	e1 99       	sbic	0x1c, 1	; 28
 7d4:	fe cf       	rjmp	.-4      	; 0x7d2 <__eerd_blraw_tn84+0x2>
 7d6:	06 c0       	rjmp	.+12     	; 0x7e4 <__eerd_blraw_tn84+0x14>
 7d8:	ff bb       	out	0x1f, r31	; 31
 7da:	ee bb       	out	0x1e, r30	; 30
 7dc:	e0 9a       	sbi	0x1c, 0	; 28
 7de:	31 96       	adiw	r30, 0x01	; 1
 7e0:	0d b2       	in	r0, 0x1d	; 29
 7e2:	0d 92       	st	X+, r0
 7e4:	41 50       	subi	r20, 0x01	; 1
 7e6:	50 40       	sbci	r21, 0x00	; 0
 7e8:	b8 f7       	brcc	.-18     	; 0x7d8 <__eerd_blraw_tn84+0x8>
 7ea:	08 95       	ret

000007ec <__eeupd_byte_tn84>:
 7ec:	26 2f       	mov	r18, r22

000007ee <__eeupd_r18_tn84>:
 7ee:	e1 99       	sbic	0x1c, 1	; 28
 7f0:	fe cf       	rjmp	.-4      	; 0x7ee <__eeupd_r18_tn84>
 7f2:	9f bb       	out	0x1f, r25	; 31
 7f4:	8e bb       	out	0x1e, r24	; 30
 7f6:	e0 9a       	sbi	0x1c, 0	; 28
 7f8:	01 97       	sbiw	r24, 0x01	; 1
 7fa:	0d b2       	in	r0, 0x1d	; 29
 7fc:	02 16       	cp	r0, r18
 7fe:	39 f0       	breq	.+14     	; 0x80e <__eeupd_r18_tn84+0x20>
 800:	1c ba       	out	0x1c, r1	; 28
 802:	2d bb       	out	0x1d, r18	; 29
 804:	0f b6       	in	r0, 0x3f	; 63
 806:	f8 94       	cli
 808:	e2 9a       	sbi	0x1c, 2	; 28
 80a:	e1 9a       	sbi	0x1c, 1	; 28
 80c:	0f be       	out	0x3f, r0	; 63
 80e:	08 95       	ret

00000810 <_exit>:
 810:	f8 94       	cli

00000812 <__stop_program>:
 812:	ff cf       	rjmp	.-2      	; 0x812 <__stop_program>
