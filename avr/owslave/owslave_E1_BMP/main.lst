   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	__vector_1
  11               	__vector_1:
  12               	.LFB0:
  13               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * based on owdevice - A small 1-Wire emulator for AVR Microcontroller
   3:main.c        ****  * Copyright (C) 2012  Tobias Mueller mail (at) tobynet.de
   4:main.c        **** 
   5:main.c        ****  * OWSlave fÃ¼r i2c/TWI with BMP085/BMP180 pressure sensor
   6:main.c        ****  * - based on owslave 1.52/1.06 4count (C) 2013 mm@elabnet.de
   7:main.c        ****  *
   8:main.c        ****  * Created: 2013-12-11, Author: Michael Markstaller
   9:main.c        ****  *
  10:main.c        ****  * use included Makefile: just change target MCU and avrdude params
  11:main.c        ****  *
  12:main.c        ****  * Notes:
  13:main.c        ****  * - OWRXLED is connected with the ANODE to PAx
  14:main.c        ****  *
  15:main.c        ****  * Changelog:
  16:main.c        ****  * v1.52(->1.06) 2013-12-11 first port from owslave_4count
  17:main.c        ****  * - Added i2c-master
  18:main.c        ****  * - purged ATMega for now
  19:main.c        ****  *
  20:main.c        ****  * Pending:
  21:main.c        ****  * - maybe extend things to supply a complete waether-station with Temp, Hum, Wind, ..?
  22:main.c        ****  * - maybe some NMEA-output directly? GPS?
  23:main.c        ****  *
  24:main.c        ****  */
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** #include <stdlib.h>
  28:main.c        **** #include <avr/io.h>
  29:main.c        **** #include <avr/interrupt.h>
  30:main.c        **** #include <avr/eeprom.h>
  31:main.c        **** #include <avr/sleep.h>
  32:main.c        **** #include <string.h>
  33:main.c        **** // #include <avr/pgmspace.h>
  34:main.c        **** #include "common.h"
  35:main.c        **** //#include "uart.h"
  36:main.c        **** 
  37:main.c        **** //#define DEBUG 0
  38:main.c        **** #include "debug.h"
  39:main.c        **** #ifndef F_CPU
  40:main.c        **** //# warning "F_CPU was not defined!! defining it now in debug.h but you should take care before!"
  41:main.c        **** #define F_CPU 8000000UL //very important! define before delay.h as delay.h fucks up the serial-timi
  42:main.c        **** #endif
  43:main.c        **** //#include <util/delay.h>
  44:main.c        **** 
  45:main.c        **** #if defined (__AVR_ATtiny24__) || (__AVR_ATtiny44__) || (__AVR_ATtiny84__)
  46:main.c        **** // OW_PORT Pin 5 - PB2
  47:main.c        **** 
  48:main.c        **** //OW Pin
  49:main.c        **** #define OW_PORT PORTB //1 Wire Port
  50:main.c        **** #define OW_PIN PINB //1 Wire Pin as number
  51:main.c        **** #define OW_PORTN (1<<PINB2)  //Pin as bit in registers
  52:main.c        **** #define OW_PINN (1<<PINB2)
  53:main.c        **** #define OW_DDR DDRB  //pin direction register
  54:main.c        **** #define SET_LOW OW_DDR|=OW_PINN;OW_PORT&=~OW_PORTN;  //set 1-Wire line to low
  55:main.c        **** #define RESET_LOW {OW_DDR&=~OW_PINN;}  //set 1-Wire pin as input
  56:main.c        **** //Pin interrupt
  57:main.c        **** #define EN_OWINT { GIMSK|=(1<<INT0); GIFR=(1<<INTF0); }  //enable interrupt and clear it! GIFR=(1<<
  58:main.c        **** #define DIS_OWINT  GIMSK&=~(1<<INT0); sleepmode=SLEEP_MODE_IDLE; //disable interrupt
  59:main.c        **** #define SET_OWINT_RISING MCUCR=(1<<ISC01)|(1<<ISC00);  //set interrupt at rising edge
  60:main.c        **** #define SET_OWINT_FALLING MCUCR=(1<<ISC01);MCUCR&=~(1<<ISC00); //set interrupt at falling edge FIXM
  61:main.c        **** #define SET_OWINT_BOTH MCUCR=(1<<ISC00);MCUCR&=~(1<<ISC01); //set interrupt at both edges
  62:main.c        **** #define SET_OWINT_LOWLEVEL MCUCR&=~((1<<ISC01)|(1<<ISC00)); //set interrupt at low level
  63:main.c        **** 
  64:main.c        **** #define CHK_INT_EN (GIMSK&(1<<INT0))==(1<<INT0) //test if interrupt enabled
  65:main.c        **** #define PIN_INT ISR(INT0_vect)  // the interrupt service routine
  66:main.c        **** //Timer Interrupt
  67:main.c        **** #define EN_TIMER {TIMSK0 |= (1<<TOIE0); TIFR0|=(1<<TOV0); } //enable timer interrupt
  68:main.c        **** #define DIS_TIMER TIMSK0  &= ~(1<<TOIE0); // disable timer interrupt + IDLE-Sleep?
  69:main.c        **** #define TCNT_REG TCNT0  //register of timer-counter
  70:main.c        **** #define TIMER_INT ISR(TIM0_OVF_vect) //the timer interrupt service routine
  71:main.c        **** 
  72:main.c        **** #define OWRXLED_PORT PORTA
  73:main.c        **** #define OWRXLED_DDR DDRA
  74:main.c        **** #define OWRXLED_PIN PINA2
  75:main.c        **** 
  76:main.c        **** #define INIT_LED_PINS OWRXLED_DDR |= (1<<OWRXLED_PIN); /* pins as output */
  77:main.c        **** 
  78:main.c        **** //FIXME / TODO: Double-check timings and move these to EEPROM
  79:main.c        **** #define OWT_MIN_RESET 51
  80:main.c        **** #define OWT_RESET_PRESENCE 4
  81:main.c        **** #define OWT_PRESENCE 20
  82:main.c        **** #define OWT_READLINE 2 //3 for fast master, 4 for slow master and long lines
  83:main.c        **** #define OWT_LOWTIME 3 //3 for fast master, 4 for slow master and long lines
  84:main.c        **** 
  85:main.c        **** //Initializations of AVR
  86:main.c        **** #define INIT_AVR CLKPR=(1<<CLKPCE); \
  87:main.c        ****                    CLKPR=0; /*8Mhz*/  \
  88:main.c        ****                    TIMSK0=0; \
  89:main.c        ****                    GIMSK=(1<<INT0);  /*set direct GIMSK register*/ \
  90:main.c        ****                    TCCR0B=(1<<CS00)|(1<<CS01); /*8mhz /64 couse 8 bit Timer interrupt every 8us*/ \
  91:main.c        ****                    WDTCSR |= ((1<<WDP2)|(1<<WDP1)|(1<<WDP0)); /* ((1<<WDP2)|(1<<WDP1)|(1<<WDP0)) WD
  92:main.c        ****                    WDTCSR |= (1<<WDIE); /* only enable int, no real watchdog */
  93:main.c        **** 
  94:main.c        **** #define PWRSAVE_AVR ADCSRA &= ~(1<<ADEN); PRR |= (1<<PRTIM1)|(1<<PRUSI)|(1<<PRADC); //FIXME: we nee
  95:main.c        **** 
  96:main.c        **** #endif // __AVR_ATtiny84__
  97:main.c        **** 
  98:main.c        **** //States / Modes (defines from original owslave.c - new are all called OWC_ !)
  99:main.c        **** #define OWM_SLEEP 0  //Waiting for next reset pulse
 100:main.c        **** #define OWM_RESET 1  //Reset pulse received
 101:main.c        **** #define OWM_PRESENCE 2  //sending presence pulse
 102:main.c        **** #define OWM_READ_COMMAND 3 //read 8 bit of command
 103:main.c        **** #define OWM_SEARCH_ROM 4  //SEARCH_ROM algorithms
 104:main.c        **** #define OWM_MATCH_ROM 5  //test number
 105:main.c        **** #define OWM_CHK_RESET 8  //waiting of rising edge from reset pulse
 106:main.c        **** #define OWM_GET_ADRESS 6
 107:main.c        **** #define OWM_READ_MEMORY_COUNTER 7
 108:main.c        **** #define OWM_WRITE_SCRATCHPAD 9
 109:main.c        **** #define OWM_READ_SCRATCHPAD 10
 110:main.c        **** 
 111:main.c        **** #define OWM_WRITE_PAGE_TO_MASTER 11
 112:main.c        **** #define OWM_WRITE_FUNC 12
 113:main.c        **** 
 114:main.c        **** #define OWC_READ_SCRATCHPAD 0xBE
 115:main.c        **** #define OWC_WRITE_SCRATCHPAD 0x4E
 116:main.c        **** #define OWC_WRITE_FUNC 0x4F
 117:main.c        **** /* READ_SCRATCHPAD 0xBE + 0xYY is adaptec from DS2438! BE + Address
 118:main.c        ****  *
 119:main.c        ****  */
 120:main.c        **** 
 121:main.c        **** //Write a bit after next falling edge from master
 122:main.c        **** //its for sending a zero as soon as possible
 123:main.c        **** #define OWW_NO_WRITE 2
 124:main.c        **** #define OWW_WRITE_1 1
 125:main.c        **** #define OWW_WRITE_0 0
 126:main.c        **** 
 127:main.c        **** volatile uint32_t uptime = 0; /* holds uptime in 1/2 seconds - overflows after 6.8 years */
 128:main.c        **** 
 129:main.c        **** typedef union {
 130:main.c        ****     volatile uint8_t bytes[11];
 131:main.c        ****     struct {
 132:main.c        ****       uint8_t   page1;
 133:main.c        ****       uint8_t   u8_11;
 134:main.c        ****       uint8_t   u8_12;
 135:main.c        ****       uint16_t  u16_13;
 136:main.c        ****       uint32_t  u32_14;
 137:main.c        ****       uint8_t   crc1;
 138:main.c        ****     };
 139:main.c        ****     struct {
 140:main.c        ****       uint8_t   page2;
 141:main.c        ****       uint16_t  u16_21;
 142:main.c        ****       uint16_t  u16_22;
 143:main.c        ****       uint16_t  u16_23;
 144:main.c        ****       uint8_t   u16_24;
 145:main.c        ****       uint8_t   crc2;
 146:main.c        ****     };
 147:main.c        ****     struct {
 148:main.c        ****       uint8_t   page3;
 149:main.c        ****       uint32_t  u32_31;
 150:main.c        ****       uint32_t  u32_32;
 151:main.c        ****       uint8_t   crc3;
 152:main.c        ****     };
 153:main.c        ****     struct {
 154:main.c        ****       uint8_t   page4;
 155:main.c        ****       uint8_t   u8_41;
 156:main.c        ****       uint8_t   u8_42;
 157:main.c        ****       uint8_t   u8_43;
 158:main.c        ****       uint8_t   u8_44;
 159:main.c        ****       uint32_t   u32_4XX;
 160:main.c        ****       uint8_t   crc4;
 161:main.c        ****     };
 162:main.c        **** } scratchpad_t;
 163:main.c        **** scratchpad_t scratchpad;
 164:main.c        **** 
 165:main.c        **** /* recv-states */
 166:main.c        **** enum {
 167:main.c        ****       S_NULL = 0,
 168:main.c        ****       S_STX = 2,
 169:main.c        ****       S_ETX = 3,
 170:main.c        ****       S_ACK = 6,
 171:main.c        ****       S_NACK = 15,
 172:main.c        ****       S_DATA = 20,
 173:main.c        **** };
 174:main.c        **** uint8_t recv_state = S_NULL;
 175:main.c        **** uint8_t nackmsg=0;
 176:main.c        **** 
 177:main.c        **** volatile uint16_t scrc; //CRC calculation
 178:main.c        **** volatile uint8_t page; /* address of memory-page to read/write */
 179:main.c        **** 
 180:main.c        **** volatile uint8_t lastcps;
 181:main.c        **** volatile uint32_t pressure;
 182:main.c        **** volatile uint32_t temperature;
 183:main.c        **** 
 184:main.c        **** volatile uint8_t sleepmode;
 185:main.c        **** 
 186:main.c        **** volatile uint8_t cbuf; //Input buffer for a command
 187:main.c        **** uint8_t owid[8] = {0xE1, 0xE2, 0x00, 0x00, 0x00, 0x06, 0x84, 0x82 };
 188:main.c        **** 
 189:main.c        **** volatile uint8_t bitp;  //pointer to current Byte
 190:main.c        **** volatile uint8_t bytep; //pointer to current Bit
 191:main.c        **** 
 192:main.c        **** volatile uint8_t mode; //state
 193:main.c        **** volatile uint8_t wmode; //if 0 next bit that send the device is  0
 194:main.c        **** volatile uint8_t actbit; //current
 195:main.c        **** volatile uint8_t srcount; //counter for search rom
 196:main.c        **** 
 197:main.c        **** /* temp vars to avoid eeprom-reading - in case of low-mem: FIXME */
 198:main.c        **** uint16_t version = 0x0106;
 199:main.c        **** uint8_t stype = 6;
 200:main.c        **** uint16_t rcnt = 1;
 201:main.c        **** uint8_t eflag; //internal error/status-flag
 202:main.c        **** volatile uint8_t crcerrcnt=0;
 203:main.c        **** volatile uint8_t ewrite_flag;//ewrite_flag is already volatile and used as semaphore..
 204:main.c        **** typedef union {
 205:main.c        ****     uint8_t bytes[8];
 206:main.c        ****     struct {
 207:main.c        ****       uint32_t u32_1;
 208:main.c        ****       uint32_t u32_2;
 209:main.c        ****     };
 210:main.c        **** } eewrite_t;
 211:main.c        **** eewrite_t eewrite_buf;
 212:main.c        **** 
 213:main.c        **** PIN_INT {
  14               		.loc 1 213 0
  15 0000 1F92      		push r1
  16               	.LCFI0:
  17 0002 0F92      		push r0
  18               	.LCFI1:
  19 0004 0FB6      		in r0,__SREG__
  20 0006 0F92      		push r0
  21 0008 1124      		clr __zero_reg__
  22 000a 2F93      		push r18
  23               	.LCFI2:
  24 000c 8F93      		push r24
  25               	.LCFI3:
  26 000e 9F93      		push r25
  27               	.LCFI4:
  28 0010 EF93      		push r30
  29               	.LCFI5:
  30 0012 FF93      		push r31
  31               	.LCFI6:
  32               	/* prologue: Signal */
  33               	/* frame size = 0 */
  34               	/* stack size = 8 */
  35               	.L__stack_usage = 8
 214:main.c        ****     uint8_t lwmode=wmode;  //let this variables in registers
  36               		.loc 1 214 0
  37 0014 8091 0000 		lds r24,wmode
  38               	.LVL0:
 215:main.c        ****     uint8_t lmode=mode;
  39               		.loc 1 215 0
  40 0018 9091 0000 		lds r25,mode
  41               	.LVL1:
 216:main.c        ****     if (lwmode==OWW_WRITE_0) { //if necessary set 0-Bit
  42               		.loc 1 216 0
  43 001c 8111      		cpse r24,__zero_reg__
  44 001e 00C0      		rjmp .L2
 217:main.c        ****         SET_LOW;
  45               		.loc 1 217 0
  46 0020 BA9A      		sbi 0x17,2
  47 0022 C298      		cbi 0x18,2
  48               	.LVL2:
 218:main.c        ****         lwmode=OWW_NO_WRITE;
  49               		.loc 1 218 0
  50 0024 82E0      		ldi r24,lo8(2)
  51               	.LVL3:
  52               	.L2:
 219:main.c        ****     }
 220:main.c        ****     DIS_OWINT; //disable interrupt, only in OWM_SLEEP mode it is active
  53               		.loc 1 220 0
  54 0026 2BB7      		in r18,0x3b
  55 0028 2F7B      		andi r18,lo8(-65)
  56 002a 2BBF      		out 0x3b,r18
  57 002c 1092 0000 		sts sleepmode,__zero_reg__
 221:main.c        ****     sleepmode=SLEEP_MODE_IDLE; //powerdown is set in TIMER_INT on OWM_SLEEP only!
  58               		.loc 1 221 0
  59 0030 1092 0000 		sts sleepmode,__zero_reg__
 222:main.c        ****     switch (lmode) {
  60               		.loc 1 222 0
  61 0034 E92F      		mov r30,r25
  62 0036 F0E0      		ldi r31,0
  63 0038 ED30      		cpi r30,13
  64 003a F105      		cpc r31,__zero_reg__
  65 003c 00F4      		brsh .L3
  66 003e E050      		subi r30,lo8(-(gs(.L9)))
  67 0040 F040      		sbci r31,hi8(-(gs(.L9)))
  68 0042 0994      		ijmp
  69               	.LVL4:
  70               		.section	.progmem.gcc_sw_table,"ax",@progbits
  71               		.p2align	1
  72               	.L9:
  73 0000 00C0      		rjmp .L4
  74 0002 00C0      		rjmp .L3
  75 0004 00C0      		rjmp .L3
  76 0006 00C0      		rjmp .L10
  77 0008 00C0      		rjmp .L6
  78 000a 00C0      		rjmp .L10
  79 000c 00C0      		rjmp .L10
  80 000e 00C0      		rjmp .L3
  81 0010 00C0      		rjmp .L7
  82 0012 00C0      		rjmp .L10
  83 0014 00C0      		rjmp .L8
  84 0016 00C0      		rjmp .L8
  85 0018 00C0      		rjmp .L10
  86               		.text
  87               	.L4:
 223:main.c        ****         case OWM_SLEEP:
 224:main.c        ****             TCNT_REG=~(OWT_MIN_RESET);
  88               		.loc 1 224 0
  89 0044 2CEC      		ldi r18,lo8(-52)
  90 0046 22BF      		out 0x32,r18
 225:main.c        ****             //RESET_LOW;  //??? Set pin as input again ???
 226:main.c        ****             EN_OWINT; SET_OWINT_RISING; //other edges ?
  91               		.loc 1 226 0
  92 0048 2BB7      		in r18,0x3b
  93 004a 2064      		ori r18,lo8(64)
  94 004c 2BBF      		out 0x3b,r18
  95 004e 20E4      		ldi r18,lo8(64)
  96 0050 2ABF      		out 0x3a,r18
  97 0052 23E0      		ldi r18,lo8(3)
  98 0054 25BF      		out 0x35,r18
 227:main.c        ****             OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
  99               		.loc 1 227 0
 100 0056 DA98      		cbi 0x1b,2
 228:main.c        ****             break;
 101               		.loc 1 228 0
 102 0058 00C0      		rjmp .L3
 103               	.L6:
 229:main.c        ****         //start of reading a byte with falling edge from master, reading closed in timer isr
 230:main.c        ****         case OWM_MATCH_ROM:  //falling edge wait for receive
 231:main.c        ****         case OWM_WRITE_SCRATCHPAD:
 232:main.c        ****         case OWM_GET_ADRESS:
 233:main.c        ****         case OWM_READ_COMMAND:
 234:main.c        ****         case OWM_WRITE_FUNC:
 235:main.c        ****             TCNT_REG=~(OWT_READLINE); //wait a time for reading
 236:main.c        ****             break;
 237:main.c        ****         case OWM_SEARCH_ROM:   //Search algorithm waiting for receive or send
 238:main.c        ****             if (srcount<2) { //this means bit or complement is writing,
 104               		.loc 1 238 0
 105 005a 2091 0000 		lds r18,srcount
 106 005e 2230      		cpi r18,lo8(2)
 107 0060 00F4      		brsh .L10
 108 0062 00C0      		rjmp .L8
 109               	.L10:
 239:main.c        ****                 TCNT_REG=~(OWT_LOWTIME);
 240:main.c        ****             } else
 241:main.c        ****                 TCNT_REG=~(OWT_READLINE);  //init for read answer of master
 110               		.loc 1 241 0
 111 0064 2DEF      		ldi r18,lo8(-3)
 112               	.L11:
 113 0066 22BF      		out 0x32,r18
 114 0068 00C0      		rjmp .L3
 115               	.L8:
 242:main.c        ****             break;
 243:main.c        ****         case OWM_READ_SCRATCHPAD:
 244:main.c        ****         case OWM_WRITE_PAGE_TO_MASTER:
 245:main.c        ****             TCNT_REG=~(OWT_LOWTIME);
 116               		.loc 1 245 0
 117 006a 2CEF      		ldi r18,lo8(-4)
 118 006c 00C0      		rjmp .L11
 119               	.L7:
 246:main.c        ****             break;
 247:main.c        ****         case OWM_CHK_RESET:  //rising edge of reset pulse
 248:main.c        ****             SET_OWINT_FALLING;
 120               		.loc 1 248 0
 121 006e 92E0      		ldi r25,lo8(2)
 122 0070 95BF      		out 0x35,r25
 123 0072 95B7      		in r25,0x35
 124 0074 9E7F      		andi r25,lo8(-2)
 125 0076 95BF      		out 0x35,r25
 249:main.c        ****             TCNT_REG=~(OWT_RESET_PRESENCE);  //waiting for sending presence pulse
 126               		.loc 1 249 0
 127 0078 9BEF      		ldi r25,lo8(-5)
 128 007a 92BF      		out 0x32,r25
 129               	.LVL5:
 250:main.c        ****             lmode=OWM_RESET;
 130               		.loc 1 250 0
 131 007c 91E0      		ldi r25,lo8(1)
 132               	.LVL6:
 133               	.L3:
 251:main.c        ****             break;
 252:main.c        ****     }
 253:main.c        ****     EN_TIMER;
 134               		.loc 1 253 0
 135 007e 29B7      		in r18,0x39
 136 0080 2160      		ori r18,lo8(1)
 137 0082 29BF      		out 0x39,r18
 138 0084 28B7      		in r18,0x38
 139 0086 2160      		ori r18,lo8(1)
 140 0088 28BF      		out 0x38,r18
 254:main.c        ****     mode=lmode;
 141               		.loc 1 254 0
 142 008a 9093 0000 		sts mode,r25
 255:main.c        ****     wmode=lwmode;
 143               		.loc 1 255 0
 144 008e 8093 0000 		sts wmode,r24
 145               	/* epilogue start */
 256:main.c        **** }
 146               		.loc 1 256 0
 147 0092 FF91      		pop r31
 148 0094 EF91      		pop r30
 149 0096 9F91      		pop r25
 150               	.LVL7:
 151 0098 8F91      		pop r24
 152               	.LVL8:
 153 009a 2F91      		pop r18
 154 009c 0F90      		pop r0
 155 009e 0FBE      		out __SREG__,r0
 156 00a0 0F90      		pop r0
 157 00a2 1F90      		pop r1
 158 00a4 1895      		reti
 159               	.LFE0:
 161               	.global	__vector_11
 163               	__vector_11:
 164               	.LFB1:
 257:main.c        **** 
 258:main.c        **** TIMER_INT {
 165               		.loc 1 258 0
 166 00a6 1F92      		push r1
 167               	.LCFI7:
 168 00a8 0F92      		push r0
 169               	.LCFI8:
 170 00aa 0FB6      		in r0,__SREG__
 171 00ac 0F92      		push r0
 172 00ae 1124      		clr __zero_reg__
 173 00b0 1F93      		push r17
 174               	.LCFI9:
 175 00b2 2F93      		push r18
 176               	.LCFI10:
 177 00b4 3F93      		push r19
 178               	.LCFI11:
 179 00b6 4F93      		push r20
 180               	.LCFI12:
 181 00b8 5F93      		push r21
 182               	.LCFI13:
 183 00ba 6F93      		push r22
 184               	.LCFI14:
 185 00bc 7F93      		push r23
 186               	.LCFI15:
 187 00be 8F93      		push r24
 188               	.LCFI16:
 189 00c0 9F93      		push r25
 190               	.LCFI17:
 191 00c2 AF93      		push r26
 192               	.LCFI18:
 193 00c4 BF93      		push r27
 194               	.LCFI19:
 195 00c6 CF93      		push r28
 196               	.LCFI20:
 197 00c8 DF93      		push r29
 198               	.LCFI21:
 199 00ca EF93      		push r30
 200               	.LCFI22:
 201 00cc FF93      		push r31
 202               	.LCFI23:
 203               	/* prologue: Signal */
 204               	/* frame size = 0 */
 205               	/* stack size = 18 */
 206               	.L__stack_usage = 18
 259:main.c        ****     uint8_t lwmode=wmode; //let this variables in registers
 207               		.loc 1 259 0
 208 00ce 6091 0000 		lds r22,wmode
 209               	.LVL9:
 260:main.c        ****     uint8_t lmode=mode;
 210               		.loc 1 260 0
 211 00d2 5091 0000 		lds r21,mode
 212               	.LVL10:
 261:main.c        ****     uint8_t lbytep=bytep;
 213               		.loc 1 261 0
 214 00d6 4091 0000 		lds r20,bytep
 215               	.LVL11:
 262:main.c        ****     uint8_t lbitp=bitp;
 216               		.loc 1 262 0
 217 00da D091 0000 		lds r29,bitp
 218               	.LVL12:
 263:main.c        ****     uint8_t lsrcount=srcount;
 219               		.loc 1 263 0
 220 00de C091 0000 		lds r28,srcount
 221               	.LVL13:
 264:main.c        ****     uint8_t lactbit=actbit;
 222               		.loc 1 264 0
 223 00e2 7091 0000 		lds r23,actbit
 224               	.LVL14:
 265:main.c        ****     uint16_t lscrc=scrc;
 225               		.loc 1 265 0
 226 00e6 2091 0000 		lds r18,scrc
 227 00ea 3091 0000 		lds r19,scrc+1
 228               	.LVL15:
 266:main.c        ****     //Ask input line sate
 267:main.c        ****     uint8_t p=((OW_PIN&OW_PINN)==OW_PINN);
 229               		.loc 1 267 0
 230 00ee 16B3      		in r17,0x16
 231 00f0 12FB      		bst r17,2
 232 00f2 1127      		clr r17
 233 00f4 10F9      		bld r17,0
 234               	.LVL16:
 268:main.c        **** 
 269:main.c        ****     OWRXLED_PORT ^= (1<<OWRXLED_PIN); /* toolge RX-led */
 235               		.loc 1 269 0
 236 00f6 8BB3      		in r24,0x1b
 237 00f8 94E0      		ldi r25,lo8(4)
 238 00fa 8927      		eor r24,r25
 239 00fc 8BBB      		out 0x1b,r24
 270:main.c        **** 
 271:main.c        ****     //Interrupt still active ?
 272:main.c        ****     if (CHK_INT_EN) {
 240               		.loc 1 272 0
 241 00fe 0BB6      		in __tmp_reg__,0x3b
 242 0100 06FE      		sbrs __tmp_reg__,6
 243 0102 00C0      		rjmp .L13
 273:main.c        ****         //maybe reset pulse
 274:main.c        ****         if (p==0) {
 244               		.loc 1 274 0
 245 0104 1111      		cpse r17,__zero_reg__
 246 0106 00C0      		rjmp .L14
 247               	.LVL17:
 275:main.c        ****             lmode=OWM_CHK_RESET;  //wait for rising edge
 276:main.c        ****             SET_OWINT_RISING;
 248               		.loc 1 276 0
 249 0108 83E0      		ldi r24,lo8(3)
 250 010a 85BF      		out 0x35,r24
 275:main.c        ****             lmode=OWM_CHK_RESET;  //wait for rising edge
 251               		.loc 1 275 0
 252 010c 58E0      		ldi r21,lo8(8)
 253               	.LVL18:
 254               	.L14:
 277:main.c        ****         }
 278:main.c        ****         DIS_TIMER;
 255               		.loc 1 278 0
 256 010e 89B7      		in r24,0x39
 257 0110 8E7F      		andi r24,lo8(-2)
 258 0112 89BF      		out 0x39,r24
 259 0114 00C0      		rjmp .L15
 260               	.L13:
 279:main.c        ****     } else
 280:main.c        ****     switch (lmode) {
 261               		.loc 1 280 0
 262 0116 852F      		mov r24,r21
 263 0118 90E0      		ldi r25,0
 264 011a FC01      		movw r30,r24
 265 011c 3197      		sbiw r30,1
 266 011e EC30      		cpi r30,12
 267 0120 F105      		cpc r31,__zero_reg__
 268 0122 00F0      		brlo .+2
 269 0124 00C0      		rjmp .L15
 270 0126 E050      		subi r30,lo8(-(gs(.L24)))
 271 0128 F040      		sbci r31,hi8(-(gs(.L24)))
 272 012a 0994      		ijmp
 273               		.section	.progmem.gcc_sw_table,"ax",@progbits
 274               		.p2align	1
 275               	.L24:
 276 001a 00C0      		rjmp .L16
 277 001c 00C0      		rjmp .L17
 278 001e 00C0      		rjmp .L18
 279 0020 00C0      		rjmp .L19
 280 0022 00C0      		rjmp .L20
 281 0024 00C0      		rjmp .L21
 282 0026 00C0      		rjmp .L15
 283 0028 00C0      		rjmp .L15
 284 002a 00C0      		rjmp .L15
 285 002c 00C0      		rjmp .L15
 286 002e 00C0      		rjmp .L22
 287 0030 00C0      		rjmp .L23
 288               		.text
 289               	.L16:
 290               	.LVL19:
 281:main.c        ****         case OWM_RESET:  //Reset pulse and time after is finished, now go in presence state
 282:main.c        ****             lmode=OWM_PRESENCE;
 283:main.c        ****             SET_LOW;
 291               		.loc 1 283 0
 292 012c BA9A      		sbi 0x17,2
 293 012e C298      		cbi 0x18,2
 284:main.c        ****             TCNT_REG=~(OWT_PRESENCE);
 294               		.loc 1 284 0
 295 0130 8BEE      		ldi r24,lo8(-21)
 296 0132 82BF      		out 0x32,r24
 285:main.c        ****             DIS_OWINT;  //No Pin interrupt necessary only wait for presence is done
 297               		.loc 1 285 0
 298 0134 8BB7      		in r24,0x3b
 299 0136 8F7B      		andi r24,lo8(-65)
 300 0138 8BBF      		out 0x3b,r24
 301 013a 1092 0000 		sts sleepmode,__zero_reg__
 282:main.c        ****             lmode=OWM_PRESENCE;
 302               		.loc 1 282 0
 303 013e 52E0      		ldi r21,lo8(2)
 286:main.c        ****             break;
 304               		.loc 1 286 0
 305 0140 00C0      		rjmp .L64
 306               	.LVL20:
 307               	.L17:
 287:main.c        ****         case OWM_PRESENCE:
 288:main.c        ****             RESET_LOW;  //Presence is done now wait for a command
 308               		.loc 1 288 0
 309 0142 BA98      		cbi 0x17,2
 310               	.LVL21:
 311 0144 00C0      		rjmp .L110
 312               	.LVL22:
 313               	.L18:
 289:main.c        ****             lmode=OWM_READ_COMMAND;
 290:main.c        ****             cbuf=0;lbitp=1;  //Command buffer have to set zero, only set bits will write in
 291:main.c        ****             break;
 292:main.c        ****         case OWM_READ_COMMAND:
 293:main.c        ****             if (p) {  //Set bit if line high
 314               		.loc 1 293 0
 315 0146 1123      		tst r17
 316 0148 01F0      		breq .L26
 294:main.c        ****                 cbuf|=lbitp;
 317               		.loc 1 294 0
 318 014a 8091 0000 		lds r24,cbuf
 319 014e 8D2B      		or r24,r29
 320 0150 8093 0000 		sts cbuf,r24
 321               	.L26:
 295:main.c        ****             }
 296:main.c        ****             lbitp=(lbitp<<1);
 322               		.loc 1 296 0
 323 0154 DD0F      		lsl r29
 324               	.LVL23:
 297:main.c        ****             if (!lbitp) { //8-Bits read - weird syntax?
 325               		.loc 1 297 0
 326 0156 01F0      		breq .+2
 327 0158 00C0      		rjmp .L62
 328               	.LVL24:
 298:main.c        ****                 lbitp=1;
 299:main.c        ****                 switch (cbuf) {
 329               		.loc 1 299 0
 330 015a 8091 0000 		lds r24,cbuf
 331 015e 8535      		cpi r24,lo8(85)
 332 0160 01F4      		brne .+2
 333 0162 00C0      		rjmp .L67
 334 0164 00F4      		brsh .L31
 335 0166 8F34      		cpi r24,lo8(79)
 336 0168 01F0      		breq .+2
 337 016a 00C0      		rjmp .L73
 338 016c 00C0      		rjmp .L28
 339               	.L31:
 340 016e 8E3B      		cpi r24,lo8(-66)
 341 0170 01F0      		breq .L29
 342 0172 803F      		cpi r24,lo8(-16)
 343 0174 01F0      		breq .+2
 344 0176 00C0      		rjmp .L73
 345               	.LVL25:
 300:main.c        ****                     case 0x55://Match ROM
 301:main.c        ****                         lbytep=0;
 302:main.c        ****                         lmode=OWM_MATCH_ROM;
 303:main.c        ****                         break;
 304:main.c        ****                     case 0xF0:  //initialize search rom
 305:main.c        ****                         lmode=OWM_SEARCH_ROM;
 306:main.c        ****                         lsrcount=0;
 307:main.c        ****                         lbytep=0;
 308:main.c        ****                         lactbit=(owid[lbytep]&lbitp)==lbitp; //set actual bit
 346               		.loc 1 308 0
 347 0178 6091 0000 		lds r22,owid
 348               	.LVL26:
 349 017c 6170      		andi r22,lo8(1)
 350               	.LVL27:
 351 017e 762F      		mov r23,r22
 306:main.c        ****                         lsrcount=0;
 352               		.loc 1 306 0
 353 0180 C0E0      		ldi r28,0
 298:main.c        ****                 lbitp=1;
 354               		.loc 1 298 0
 355 0182 D1E0      		ldi r29,lo8(1)
 307:main.c        ****                         lbytep=0;
 356               		.loc 1 307 0
 357 0184 40E0      		ldi r20,0
 305:main.c        ****                         lmode=OWM_SEARCH_ROM;
 358               		.loc 1 305 0
 359 0186 54E0      		ldi r21,lo8(4)
 309:main.c        ****                         lwmode=lactbit;  //prepare for writing when next falling edge
 310:main.c        ****                         break;
 360               		.loc 1 310 0
 361 0188 00C0      		rjmp .L63
 362               	.LVL28:
 363               	.L29:
 311:main.c        ****                     //FIXME: case 0xEC:  //alarm search rom - TODO
 312:main.c        ****                     case 0xBE: //read scratchpad
 313:main.c        ****                         lmode=OWM_GET_ADRESS; //first the master sends an address
 314:main.c        ****                         lbytep=0;
 315:main.c        ****                         page=0;
 364               		.loc 1 315 0
 365 018a 1092 0000 		sts page,__zero_reg__
 298:main.c        ****                 lbitp=1;
 366               		.loc 1 298 0
 367 018e D1E0      		ldi r29,lo8(1)
 314:main.c        ****                         lbytep=0;
 368               		.loc 1 314 0
 369 0190 40E0      		ldi r20,0
 313:main.c        ****                         lmode=OWM_GET_ADRESS; //first the master sends an address
 370               		.loc 1 313 0
 371 0192 56E0      		ldi r21,lo8(6)
 316:main.c        ****                         //EN_OWINT; SET_OWINT_LOWLEVEL; sleepmode=SLEEP_MODE_PWR_DOWN; //Testing if
 317:main.c        ****                         break;
 372               		.loc 1 317 0
 373 0194 00C0      		rjmp .L63
 374               	.LVL29:
 375               	.L28:
 318:main.c        ****                     case OWC_WRITE_FUNC:
 319:main.c        ****                         lmode=OWM_WRITE_FUNC; //first the master sends an address(page/func), then 
 320:main.c        ****                         lbytep=0;
 321:main.c        ****                         lscrc=0;
 322:main.c        ****                         scratchpad.page1=0;
 376               		.loc 1 322 0
 377 0196 1092 0000 		sts scratchpad,__zero_reg__
 321:main.c        ****                         lscrc=0;
 378               		.loc 1 321 0
 379 019a 20E0      		ldi r18,0
 380 019c 30E0      		ldi r19,0
 298:main.c        ****                 lbitp=1;
 381               		.loc 1 298 0
 382 019e D1E0      		ldi r29,lo8(1)
 320:main.c        ****                         lbytep=0;
 383               		.loc 1 320 0
 384 01a0 40E0      		ldi r20,0
 319:main.c        ****                         lmode=OWM_WRITE_FUNC; //first the master sends an address(page/func), then 
 385               		.loc 1 319 0
 386 01a2 5CE0      		ldi r21,lo8(12)
 323:main.c        ****                         break;
 387               		.loc 1 323 0
 388 01a4 00C0      		rjmp .L63
 389               	.LVL30:
 390               	.L19:
 324:main.c        ****                     default:
 325:main.c        ****                         LSL("\r\nDC:")
 326:main.c        ****                         //LVH(cbuf)
 327:main.c        ****                         lmode=OWM_SLEEP;  //all other commands do nothing
 328:main.c        ****                 }
 329:main.c        ****             }
 330:main.c        ****             break;
 331:main.c        ****         case OWM_SEARCH_ROM:
 332:main.c        ****             RESET_LOW;  //Set low also if nothing send (branch takes time and memory)
 391               		.loc 1 332 0
 392 01a6 BA98      		cbi 0x17,2
 333:main.c        ****             lsrcount++;  //next search rom mode
 393               		.loc 1 333 0
 394 01a8 CF5F      		subi r28,lo8(-(1))
 395               	.LVL31:
 334:main.c        ****             switch (lsrcount) {
 396               		.loc 1 334 0
 397 01aa C130      		cpi r28,lo8(1)
 398 01ac 01F0      		breq .L32
 399 01ae C330      		cpi r28,lo8(3)
 400 01b0 01F0      		breq .+2
 401 01b2 00C0      		rjmp .L62
 402 01b4 00C0      		rjmp .L33
 403               	.L32:
 335:main.c        ****                 case 1:lwmode=!lactbit;  //preparation sending complement
 404               		.loc 1 335 0
 405 01b6 61E0      		ldi r22,lo8(1)
 406               	.LVL32:
 407 01b8 7723      		tst r23
 408 01ba 01F4      		brne .+2
 409 01bc 00C0      		rjmp .L62
 410 01be 60E0      		ldi r22,0
 411               	.LVL33:
 336:main.c        ****                     break;
 412               		.loc 1 336 0
 413 01c0 00C0      		rjmp .L62
 414               	.LVL34:
 415               	.L33:
 337:main.c        ****                 case 3:
 338:main.c        ****                     if (p!=(lactbit==1)) {  //check master bit
 416               		.loc 1 338 0
 417 01c2 81E0      		ldi r24,lo8(1)
 418 01c4 7130      		cpi r23,lo8(1)
 419 01c6 01F0      		breq .L35
 420 01c8 80E0      		ldi r24,0
 421               	.L35:
 422 01ca 1813      		cpse r17,r24
 423 01cc 00C0      		rjmp .L65
 339:main.c        ****                         lmode=OWM_SLEEP;  //not the same go sleep
 340:main.c        ****                     } else {
 341:main.c        ****                         lbitp=(lbitp<<1);  //prepare next bit
 424               		.loc 1 341 0
 425 01ce DD0F      		lsl r29
 426               	.LVL35:
 342:main.c        ****                         if (lbitp==0) {
 427               		.loc 1 342 0
 428 01d0 01F4      		brne .L36
 429               	.LVL36:
 343:main.c        ****                             lbitp=1;
 344:main.c        ****                             lbytep++;
 430               		.loc 1 344 0
 431 01d2 4F5F      		subi r20,lo8(-(1))
 432               	.LVL37:
 343:main.c        ****                             lbitp=1;
 433               		.loc 1 343 0
 434 01d4 D1E0      		ldi r29,lo8(1)
 345:main.c        ****                             if (lbytep>=8) {
 435               		.loc 1 345 0
 436 01d6 4830      		cpi r20,lo8(8)
 437 01d8 00F0      		brlo .+2
 438 01da 00C0      		rjmp .L65
 439               	.LVL38:
 440               	.L36:
 346:main.c        ****                                 lmode=OWM_SLEEP;  //all bits processed
 347:main.c        ****                                 break;
 348:main.c        ****                             }
 349:main.c        ****                         }
 350:main.c        ****                         lsrcount=0;
 351:main.c        ****                         lactbit=(owid[lbytep]&lbitp)==lbitp;
 441               		.loc 1 351 0
 442 01dc E42F      		mov r30,r20
 443 01de F0E0      		ldi r31,0
 444 01e0 E050      		subi r30,lo8(-(owid))
 445 01e2 F040      		sbci r31,hi8(-(owid))
 446 01e4 8081      		ld r24,Z
 447 01e6 8D23      		and r24,r29
 448 01e8 71E0      		ldi r23,lo8(1)
 449               	.LVL39:
 450 01ea 8D13      		cpse r24,r29
 451 01ec 70E0      		ldi r23,0
 452               	.L37:
 453               	.LVL40:
 352:main.c        ****                         lwmode=lactbit;
 454               		.loc 1 352 0
 455 01ee 672F      		mov r22,r23
 350:main.c        ****                         lsrcount=0;
 456               		.loc 1 350 0
 457 01f0 C0E0      		ldi r28,0
 458 01f2 00C0      		rjmp .L62
 459               	.LVL41:
 460               	.L20:
 353:main.c        ****                     }
 354:main.c        ****                     break;
 355:main.c        ****             }
 356:main.c        ****             break;
 357:main.c        ****         case OWM_MATCH_ROM:
 358:main.c        ****             if (p==((owid[lbytep]&lbitp)==lbitp)) {  //Compare with ID Buffer
 461               		.loc 1 358 0
 462 01f4 E42F      		mov r30,r20
 463 01f6 F0E0      		ldi r31,0
 464 01f8 E050      		subi r30,lo8(-(owid))
 465 01fa F040      		sbci r31,hi8(-(owid))
 466 01fc 8081      		ld r24,Z
 467 01fe 8D23      		and r24,r29
 468 0200 91E0      		ldi r25,lo8(1)
 469 0202 8D13      		cpse r24,r29
 470 0204 90E0      		ldi r25,0
 471               	.L38:
 472 0206 1913      		cpse r17,r25
 473 0208 00C0      		rjmp .L65
 359:main.c        ****                 lbitp=(lbitp<<1);
 474               		.loc 1 359 0
 475 020a DD0F      		lsl r29
 476               	.LVL42:
 360:main.c        ****                 if (!lbitp) {
 477               		.loc 1 360 0
 478 020c 01F0      		breq .+2
 479 020e 00C0      		rjmp .L62
 361:main.c        ****                     lbytep++;
 480               		.loc 1 361 0
 481 0210 4F5F      		subi r20,lo8(-(1))
 482               	.LVL43:
 362:main.c        ****                     lbitp=1;
 363:main.c        ****                     if (lbytep>=8) {
 483               		.loc 1 363 0
 484 0212 4830      		cpi r20,lo8(8)
 485 0214 00F4      		brsh .+2
 486 0216 00C0      		rjmp .L72
 487               	.LVL44:
 488               	.L110:
 364:main.c        ****                         lmode=OWM_READ_COMMAND;  //same? get next command
 365:main.c        ****                         cbuf=0;
 489               		.loc 1 365 0
 490 0218 1092 0000 		sts cbuf,__zero_reg__
 362:main.c        ****                     lbitp=1;
 491               		.loc 1 362 0
 492 021c D1E0      		ldi r29,lo8(1)
 364:main.c        ****                         lmode=OWM_READ_COMMAND;  //same? get next command
 493               		.loc 1 364 0
 494 021e 53E0      		ldi r21,lo8(3)
 366:main.c        ****                         break;
 495               		.loc 1 366 0
 496 0220 00C0      		rjmp .L63
 497               	.LVL45:
 498               	.L21:
 367:main.c        ****                     }
 368:main.c        ****                 }
 369:main.c        ****             } else {
 370:main.c        ****                 lmode=OWM_SLEEP;
 371:main.c        ****             }
 372:main.c        ****             break;
 373:main.c        ****         case OWM_GET_ADRESS:
 374:main.c        ****             if (p) { //Get the Address for reading
 499               		.loc 1 374 0
 500 0222 1123      		tst r17
 501 0224 01F0      		breq .L39
 375:main.c        ****                 page|=lbitp;
 502               		.loc 1 375 0
 503 0226 8091 0000 		lds r24,page
 504 022a 8D2B      		or r24,r29
 505 022c 8093 0000 		sts page,r24
 506               	.L39:
 376:main.c        ****             }
 377:main.c        ****             lbitp=(lbitp<<1);
 507               		.loc 1 377 0
 508 0230 DD0F      		lsl r29
 509               	.LVL46:
 378:main.c        ****             if (!lbitp) {
 510               		.loc 1 378 0
 511 0232 01F0      		breq .+2
 512 0234 00C0      		rjmp .L62
 379:main.c        ****                 lbytep++;
 513               		.loc 1 379 0
 514 0236 4F5F      		subi r20,lo8(-(1))
 515               	.LVL47:
 380:main.c        ****                 lbitp=1;
 381:main.c        ****                 if (lbytep==1) {
 516               		.loc 1 381 0
 517 0238 4130      		cpi r20,lo8(1)
 518 023a 01F0      		breq .+2
 519 023c 00C0      		rjmp .L40
 520               	.LVL48:
 382:main.c        ****                     lmode=OWM_WRITE_PAGE_TO_MASTER;
 383:main.c        ****                     lbytep=0;lscrc=0; //from first position
 384:main.c        ****                     memset( &scratchpad.bytes, 0, 10 );
 521               		.loc 1 384 0
 522 023e 8AE0      		ldi r24,lo8(10)
 523 0240 E0E0      		ldi r30,lo8(scratchpad)
 524 0242 F0E0      		ldi r31,hi8(scratchpad)
 525 0244 DF01      		movw r26,r30
 526               		0:
 527 0246 1D92      		st X+,__zero_reg__
 528 0248 8A95      		dec r24
 529 024a 01F4      		brne 0b
 385:main.c        ****                     switch (page) {
 530               		.loc 1 385 0
 531 024c 8091 0000 		lds r24,page
 532 0250 8330      		cpi r24,lo8(3)
 533 0252 01F4      		brne .+2
 534 0254 00C0      		rjmp .L46
 535 0256 00F4      		brsh .L49
 536 0258 8130      		cpi r24,lo8(1)
 537 025a 01F0      		breq .L43
 538 025c 00F4      		brsh .L44
 539 025e 00C0      		rjmp .L105
 540               	.L49:
 541 0260 8930      		cpi r24,lo8(9)
 542 0262 01F4      		brne .+2
 543 0264 00C0      		rjmp .L47
 544 0266 8A30      		cpi r24,lo8(10)
 545 0268 01F4      		brne .+2
 546 026a 00C0      		rjmp .L48
 547 026c 8430      		cpi r24,lo8(4)
 548 026e 01F0      		breq .+2
 549 0270 00C0      		rjmp .L106
 550 0272 00C0      		rjmp .L46
 551               	.L105:
 386:main.c        ****                       case 0:
 387:main.c        ****                         scratchpad.page1 = page;
 552               		.loc 1 387 0
 553 0274 8091 0000 		lds r24,page
 554 0278 8093 0000 		sts scratchpad,r24
 388:main.c        ****                         scratchpad.u8_11 = stype;
 555               		.loc 1 388 0
 556 027c 8091 0000 		lds r24,stype
 557 0280 8093 0000 		sts scratchpad+1,r24
 389:main.c        ****                         scratchpad.u8_12 = eflag;
 558               		.loc 1 389 0
 559 0284 8091 0000 		lds r24,eflag
 560 0288 8093 0000 		sts scratchpad+2,r24
 390:main.c        ****                         scratchpad.u16_13 = version;
 561               		.loc 1 390 0
 562 028c 8091 0000 		lds r24,version
 563 0290 9091 0000 		lds r25,version+1
 564 0294 9093 0000 		sts scratchpad+3+1,r25
 565 0298 8093 0000 		sts scratchpad+3,r24
 391:main.c        ****                         scratchpad.u32_14 = uptime;
 566               		.loc 1 391 0
 567 029c 8091 0000 		lds r24,uptime
 568 02a0 9091 0000 		lds r25,uptime+1
 569 02a4 A091 0000 		lds r26,uptime+2
 570 02a8 B091 0000 		lds r27,uptime+3
 571 02ac 00C0      		rjmp .L108
 572               	.L43:
 392:main.c        ****                         break;
 393:main.c        ****                       case 1:
 394:main.c        ****                         scratchpad.page1 = page;
 573               		.loc 1 394 0
 574 02ae 8091 0000 		lds r24,page
 575 02b2 8093 0000 		sts scratchpad,r24
 395:main.c        ****                         scratchpad.u16_21 = rcnt;
 576               		.loc 1 395 0
 577 02b6 8091 0000 		lds r24,rcnt
 578 02ba 9091 0000 		lds r25,rcnt+1
 579 02be 9093 0000 		sts scratchpad+1+1,r25
 580 02c2 8093 0000 		sts scratchpad+1,r24
 396:main.c        ****                         //scratchpad.u16_22 = ADC1
 397:main.c        ****                         //scratchpad.u16_23 = ADC2
 398:main.c        ****                         scratchpad.u16_24 = crcerrcnt; //temp/debug
 581               		.loc 1 398 0
 582 02c6 8091 0000 		lds r24,crcerrcnt
 583 02ca 8093 0000 		sts scratchpad+7,r24
 399:main.c        ****                         //scratchpad.u16_24 = freeRam;
 400:main.c        ****                         break;
 584               		.loc 1 400 0
 585 02ce 00C0      		rjmp .L50
 586               	.L44:
 401:main.c        ****                       case 2:
 402:main.c        ****                         scratchpad.page1 = page;
 587               		.loc 1 402 0
 588 02d0 8091 0000 		lds r24,page
 589 02d4 8093 0000 		sts scratchpad,r24
 403:main.c        ****                         scratchpad.u32_31 = temperature;
 590               		.loc 1 403 0
 591 02d8 8091 0000 		lds r24,temperature
 592 02dc 9091 0000 		lds r25,temperature+1
 593 02e0 A091 0000 		lds r26,temperature+2
 594 02e4 B091 0000 		lds r27,temperature+3
 595 02e8 8093 0000 		sts scratchpad+1,r24
 596 02ec 9093 0000 		sts scratchpad+1+1,r25
 597 02f0 A093 0000 		sts scratchpad+1+2,r26
 598 02f4 B093 0000 		sts scratchpad+1+3,r27
 404:main.c        ****                         scratchpad.u32_32 = pressure;
 599               		.loc 1 404 0
 600 02f8 8091 0000 		lds r24,pressure
 601 02fc 9091 0000 		lds r25,pressure+1
 602 0300 A091 0000 		lds r26,pressure+2
 603 0304 B091 0000 		lds r27,pressure+3
 604               	.L108:
 605 0308 8093 0000 		sts scratchpad+5,r24
 606 030c 9093 0000 		sts scratchpad+5+1,r25
 607 0310 A093 0000 		sts scratchpad+5+2,r26
 608 0314 B093 0000 		sts scratchpad+5+3,r27
 405:main.c        ****                         break;
 609               		.loc 1 405 0
 610 0318 00C0      		rjmp .L50
 611               	.L46:
 406:main.c        ****                       case 3:
 407:main.c        ****                         scratchpad.page1 = page;
 408:main.c        ****                         //?
 409:main.c        ****                         break;
 410:main.c        ****                       case 4:
 411:main.c        ****                         scratchpad.page1 = page;
 612               		.loc 1 411 0
 613 031a 8091 0000 		lds r24,page
 614 031e 8093 0000 		sts scratchpad,r24
 412:main.c        ****                         /* Calibration data:
 413:main.c        ****                           int16_t  ac1;
 414:main.c        ****                           int16_t  ac2;
 415:main.c        ****                           int16_t  ac3;
 416:main.c        ****                           uint16_t ac4;
 417:main.c        ****                           uint16_t ac5;
 418:main.c        ****                           uint16_t ac6;
 419:main.c        ****                           int16_t  b1;
 420:main.c        ****                           int16_t  b2;
 421:main.c        ****                           int16_t  mb;
 422:main.c        ****                           int16_t  mc;
 423:main.c        ****                           int16_t  md;
 424:main.c        ****                         */
 425:main.c        ****                         break;
 615               		.loc 1 425 0
 616 0322 00C0      		rjmp .L50
 617               	.L47:
 426:main.c        ****                       case 9:
 427:main.c        ****                         scratchpad.page1 = page;
 618               		.loc 1 427 0
 619 0324 8091 0000 		lds r24,page
 620 0328 8093 0000 		sts scratchpad,r24
 428:main.c        ****                         scratchpad.u32_31 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+0
 621               		.loc 1 428 0
 622 032c 82E3      		ldi r24,lo8(50)
 623 032e 90E0      		ldi r25,0
 624 0330 00D0      		rcall __eerd_dword_tn84
 625               	.LVL49:
 626 0332 6093 0000 		sts scratchpad+1,r22
 627 0336 7093 0000 		sts scratchpad+1+1,r23
 628 033a 8093 0000 		sts scratchpad+1+2,r24
 629 033e 9093 0000 		sts scratchpad+1+3,r25
 429:main.c        ****                         scratchpad.u32_32 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+4
 630               		.loc 1 429 0
 631 0342 86E3      		ldi r24,lo8(54)
 632 0344 90E0      		ldi r25,0
 633 0346 00C0      		rjmp .L109
 634               	.LVL50:
 635               	.L48:
 430:main.c        ****                         break;
 431:main.c        ****                       case 10:
 432:main.c        ****                         scratchpad.page1 = page;
 636               		.loc 1 432 0
 637 0348 8091 0000 		lds r24,page
 638 034c 8093 0000 		sts scratchpad,r24
 433:main.c        ****                         scratchpad.u32_31 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+8
 639               		.loc 1 433 0
 640 0350 8AE3      		ldi r24,lo8(58)
 641 0352 90E0      		ldi r25,0
 642 0354 00D0      		rcall __eerd_dword_tn84
 643               	.LVL51:
 644 0356 6093 0000 		sts scratchpad+1,r22
 645 035a 7093 0000 		sts scratchpad+1+1,r23
 646 035e 8093 0000 		sts scratchpad+1+2,r24
 647 0362 9093 0000 		sts scratchpad+1+3,r25
 434:main.c        ****                         scratchpad.u32_32 = eeprom_read_dword((const uint32_t *) (EE_LABEL_OFFSET+1
 648               		.loc 1 434 0
 649 0366 8EE3      		ldi r24,lo8(62)
 650 0368 90E0      		ldi r25,0
 651               	.L109:
 652 036a 00D0      		rcall __eerd_dword_tn84
 653               	.LVL52:
 654 036c 6093 0000 		sts scratchpad+5,r22
 655 0370 7093 0000 		sts scratchpad+5+1,r23
 656 0374 8093 0000 		sts scratchpad+5+2,r24
 657 0378 9093 0000 		sts scratchpad+5+3,r25
 435:main.c        ****                         break;
 658               		.loc 1 435 0
 659 037c 00C0      		rjmp .L50
 660               	.LVL53:
 661               	.L106:
 436:main.c        ****                       default:
 437:main.c        ****                         scratchpad.page1 = page;
 662               		.loc 1 437 0
 663 037e 8091 0000 		lds r24,page
 664 0382 8093 0000 		sts scratchpad,r24
 438:main.c        ****                         scratchpad.u8_11 = 0xff;
 665               		.loc 1 438 0
 666 0386 8FEF      		ldi r24,lo8(-1)
 667 0388 8093 0000 		sts scratchpad+1,r24
 439:main.c        ****                         scratchpad.u8_12 = page; //this is actually an error! page unknown
 668               		.loc 1 439 0
 669 038c 8091 0000 		lds r24,page
 670 0390 8093 0000 		sts scratchpad+2,r24
 671               	.LVL54:
 672               	.L50:
 440:main.c        ****                         break;
 441:main.c        ****                     }
 442:main.c        ****                     lactbit=(lbitp&scratchpad.bytes[0])==lbitp;
 673               		.loc 1 442 0
 674 0394 6091 0000 		lds r22,scratchpad
 675 0398 6170      		andi r22,lo8(1)
 676               	.LVL55:
 677 039a 762F      		mov r23,r22
 383:main.c        ****                     lbytep=0;lscrc=0; //from first position
 678               		.loc 1 383 0
 679 039c 20E0      		ldi r18,0
 680 039e 30E0      		ldi r19,0
 380:main.c        ****                 lbitp=1;
 681               		.loc 1 380 0
 682 03a0 D1E0      		ldi r29,lo8(1)
 383:main.c        ****                     lbytep=0;lscrc=0; //from first position
 683               		.loc 1 383 0
 684 03a2 40E0      		ldi r20,0
 382:main.c        ****                     lmode=OWM_WRITE_PAGE_TO_MASTER;
 685               		.loc 1 382 0
 686 03a4 5BE0      		ldi r21,lo8(11)
 443:main.c        ****                     lwmode=lactbit; //prepare for send firs bit
 444:main.c        ****                     break;
 687               		.loc 1 444 0
 688 03a6 00C0      		rjmp .L63
 689               	.LVL56:
 690               	.L40:
 445:main.c        ****                 } else page=0; // never happens, should be page[lbytepos]
 691               		.loc 1 445 0
 692 03a8 1092 0000 		sts page,__zero_reg__
 693 03ac 00C0      		rjmp .L72
 694               	.LVL57:
 695               	.L23:
 446:main.c        ****             }
 447:main.c        ****             break;
 448:main.c        ****         case OWM_WRITE_FUNC:
 449:main.c        ****             if (p) {
 696               		.loc 1 449 0
 697 03ae 1123      		tst r17
 698 03b0 01F0      		breq .L51
 450:main.c        ****                 scratchpad.bytes[lbytep]|=lbitp;
 699               		.loc 1 450 0
 700 03b2 E42F      		mov r30,r20
 701 03b4 F0E0      		ldi r31,0
 702 03b6 E050      		subi r30,lo8(-(scratchpad))
 703 03b8 F040      		sbci r31,hi8(-(scratchpad))
 704 03ba 8081      		ld r24,Z
 705 03bc 8D2B      		or r24,r29
 706 03be 8083      		st Z,r24
 707               	.L51:
 451:main.c        ****             }
 452:main.c        ****             /* Page(function) is part of CRC! */
 453:main.c        ****             if ((lscrc&1)!=p) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
 708               		.loc 1 453 0
 709 03c0 F901      		movw r30,r18
 710 03c2 E170      		andi r30,1
 711 03c4 FF27      		clr r31
 712 03c6 812F      		mov r24,r17
 713 03c8 90E0      		ldi r25,0
 714 03ca 3695      		lsr r19
 715 03cc 2795      		ror r18
 716               	.LVL58:
 717 03ce E817      		cp r30,r24
 718 03d0 F907      		cpc r31,r25
 719 03d2 01F0      		breq .L53
 720               		.loc 1 453 0 is_stmt 0 discriminator 1
 721 03d4 BCE8      		ldi r27,140
 722 03d6 2B27      		eor r18,r27
 723               	.LVL59:
 724               	.L53:
 454:main.c        ****             lbitp=(lbitp<<1);
 725               		.loc 1 454 0 is_stmt 1
 726 03d8 DD0F      		lsl r29
 727               	.LVL60:
 455:main.c        ****             if (!lbitp) {
 728               		.loc 1 455 0
 729 03da 01F0      		breq .+2
 730 03dc 00C0      		rjmp .L62
 456:main.c        ****                 lbytep++;
 731               		.loc 1 456 0
 732 03de 4F5F      		subi r20,lo8(-(1))
 733               	.LVL61:
 457:main.c        ****                 lbitp=1;
 458:main.c        ****                 if (lbytep==10) {
 734               		.loc 1 458 0
 735 03e0 4A30      		cpi r20,lo8(10)
 736 03e2 01F4      		brne .L54
 459:main.c        ****                     /* now process received Write-function(s) if crc matches */
 460:main.c        ****                     if (scratchpad.bytes[9] != scratchpad.bytes[10])
 737               		.loc 1 460 0
 738 03e4 9091 0000 		lds r25,scratchpad+9
 739 03e8 8091 0000 		lds r24,scratchpad+10
 740 03ec 9817      		cp r25,r24
 741 03ee 01F0      		breq .L55
 461:main.c        ****                       crcerrcnt++;
 742               		.loc 1 461 0
 743 03f0 8091 0000 		lds r24,crcerrcnt
 744 03f4 8F5F      		subi r24,lo8(-(1))
 745 03f6 8093 0000 		sts crcerrcnt,r24
 746 03fa 00C0      		rjmp .L73
 747               	.L55:
 462:main.c        ****                     else {
 463:main.c        ****                       switch (scratchpad.bytes[0]) { /* "page" or function-id */
 748               		.loc 1 463 0
 749 03fc 8091 0000 		lds r24,scratchpad
 750 0400 8C34      		cpi r24,lo8(76)
 751 0402 01F0      		breq .L56
 752 0404 00F4      		brsh .L57
 753 0406 8834      		cpi r24,lo8(72)
 754 0408 01F0      		breq .+2
 755 040a 00C0      		rjmp .L73
 756 040c 00C0      		rjmp .L56
 757               	.L57:
 758 040e 8035      		cpi r24,lo8(80)
 759 0410 01F0      		breq .L56
 760 0412 8435      		cpi r24,lo8(84)
 761 0414 01F0      		breq .+2
 762 0416 00C0      		rjmp .L73
 763               	.L56:
 464:main.c        ****                         case 72:
 465:main.c        ****                         case 76:
 466:main.c        ****                         case 80:
 467:main.c        ****                         case 84:
 468:main.c        ****                           if (ewrite_flag > 0) //last write still pending!
 764               		.loc 1 468 0
 765 0418 8091 0000 		lds r24,ewrite_flag
 766 041c 8111      		cpse r24,__zero_reg__
 767 041e 00C0      		rjmp .L73
 469:main.c        ****                             break;
 470:main.c        ****                           eewrite_buf.u32_1 = scratchpad.u32_31;
 768               		.loc 1 470 0
 769 0420 8091 0000 		lds r24,scratchpad+1
 770 0424 9091 0000 		lds r25,scratchpad+1+1
 771 0428 A091 0000 		lds r26,scratchpad+1+2
 772 042c B091 0000 		lds r27,scratchpad+1+3
 773 0430 8093 0000 		sts eewrite_buf,r24
 774 0434 9093 0000 		sts eewrite_buf+1,r25
 775 0438 A093 0000 		sts eewrite_buf+2,r26
 776 043c B093 0000 		sts eewrite_buf+3,r27
 471:main.c        ****                           ewrite_flag = (scratchpad.page1) - 72 + EE_LABEL_OFFSET;
 777               		.loc 1 471 0
 778 0440 8091 0000 		lds r24,scratchpad
 779 0444 8651      		subi r24,lo8(-(-22))
 780 0446 8093 0000 		sts ewrite_flag,r24
 781 044a 00C0      		rjmp .L73
 782               	.L54:
 472:main.c        ****                           break;
 473:main.c        ****                         default:
 474:main.c        ****                           if (scratchpad.page1 > 71 && scratchpad.page1 < 72+EE_LABEL_MAXLEN)
 475:main.c        ****                             ; //alternatively: just write it?
 476:main.c        ****                           break;
 477:main.c        ****                       }
 478:main.c        ****                     }
 479:main.c        ****                     lmode=OWM_SLEEP;
 480:main.c        ****                     break;
 481:main.c        ****                 } else scratchpad.bytes[lbytep]=0;
 783               		.loc 1 481 0
 784 044c E42F      		mov r30,r20
 785 044e F0E0      		ldi r31,0
 786 0450 E050      		subi r30,lo8(-(scratchpad))
 787 0452 F040      		sbci r31,hi8(-(scratchpad))
 788 0454 1082      		st Z,__zero_reg__
 482:main.c        ****                 if (lbytep==9) {
 789               		.loc 1 482 0
 790 0456 4930      		cpi r20,lo8(9)
 791 0458 01F0      		breq .+2
 792 045a 00C0      		rjmp .L72
 483:main.c        ****                     //copy calculated CRC to last scratchpad-byte as we receive it with next byte!
 484:main.c        ****                     scratchpad.bytes[10] = lscrc;
 793               		.loc 1 484 0
 794 045c 2093 0000 		sts scratchpad+10,r18
 795 0460 00C0      		rjmp .L72
 796               	.LVL62:
 797               	.L22:
 485:main.c        ****                 }
 486:main.c        ****             }
 487:main.c        ****             break;
 488:main.c        ****         case OWM_WRITE_PAGE_TO_MASTER:
 489:main.c        ****             RESET_LOW;
 798               		.loc 1 489 0
 799 0462 BA98      		cbi 0x17,2
 490:main.c        ****             if ((lscrc&1)!=lactbit) lscrc=(lscrc>>1)^0x8c; else lscrc >>=1;
 800               		.loc 1 490 0
 801 0464 F901      		movw r30,r18
 802 0466 E170      		andi r30,1
 803 0468 FF27      		clr r31
 804 046a 872F      		mov r24,r23
 805 046c 90E0      		ldi r25,0
 806 046e 3695      		lsr r19
 807 0470 2795      		ror r18
 808               	.LVL63:
 809 0472 E817      		cp r30,r24
 810 0474 F907      		cpc r31,r25
 811 0476 01F0      		breq .L59
 812               		.loc 1 490 0 is_stmt 0 discriminator 1
 813 0478 8CE8      		ldi r24,140
 814 047a 2827      		eor r18,r24
 815               	.LVL64:
 816               	.L59:
 491:main.c        ****             lbitp=(lbitp<<1);
 817               		.loc 1 491 0 is_stmt 1
 818 047c DD0F      		lsl r29
 819               	.LVL65:
 492:main.c        ****             if (!lbitp) {
 820               		.loc 1 492 0
 821 047e 01F4      		brne .L60
 493:main.c        ****                 lbytep++;
 822               		.loc 1 493 0
 823 0480 4F5F      		subi r20,lo8(-(1))
 824               	.LVL66:
 494:main.c        ****                 lbitp=1;
 495:main.c        ****                 if (lbytep>=10) {
 825               		.loc 1 495 0
 826 0482 4A30      		cpi r20,lo8(10)
 827 0484 00F4      		brsh .L73
 496:main.c        ****                     lmode=OWM_SLEEP;
 497:main.c        ****                     break;
 498:main.c        ****                 } else if (lbytep==9) scratchpad.bytes[9]=lscrc;
 828               		.loc 1 498 0
 829 0486 4930      		cpi r20,lo8(9)
 830 0488 01F4      		brne .L74
 831               		.loc 1 498 0 is_stmt 0 discriminator 1
 832 048a 2093 0000 		sts scratchpad+9,r18
 833               	.L74:
 494:main.c        ****                 lbitp=1;
 834               		.loc 1 494 0 is_stmt 1
 835 048e D1E0      		ldi r29,lo8(1)
 836               	.LVL67:
 837               	.L60:
 499:main.c        ****             }
 500:main.c        ****             lactbit=(lbitp&scratchpad.bytes[lbytep])==lbitp;
 838               		.loc 1 500 0
 839 0490 E42F      		mov r30,r20
 840 0492 F0E0      		ldi r31,0
 841 0494 E050      		subi r30,lo8(-(scratchpad))
 842 0496 F040      		sbci r31,hi8(-(scratchpad))
 843 0498 8081      		ld r24,Z
 844 049a 8D23      		and r24,r29
 845 049c 71E0      		ldi r23,lo8(1)
 846               	.LVL68:
 847 049e 8D13      		cpse r24,r29
 848 04a0 70E0      		ldi r23,0
 849               	.L61:
 850               	.LVL69:
 501:main.c        ****             lwmode=lactbit;
 851               		.loc 1 501 0
 852 04a2 672F      		mov r22,r23
 502:main.c        ****             break;
 853               		.loc 1 502 0
 854 04a4 00C0      		rjmp .L62
 855               	.LVL70:
 856               	.L15:
 503:main.c        ****         }
 504:main.c        ****         if (lmode==OWM_SLEEP) {
 857               		.loc 1 504 0
 858 04a6 5111      		cpse r21,__zero_reg__
 859 04a8 00C0      		rjmp .L62
 860               	.LVL71:
 861               	.L65:
 505:main.c        ****           //RESET_LOW;  //??? Set pin as input again ???
 506:main.c        ****           DIS_TIMER;
 862               		.loc 1 506 0
 863 04aa 89B7      		in r24,0x39
 864 04ac 8E7F      		andi r24,lo8(-2)
 865 04ae 89BF      		out 0x39,r24
 507:main.c        ****           EN_OWINT; SET_OWINT_LOWLEVEL;
 866               		.loc 1 507 0
 867 04b0 8BB7      		in r24,0x3b
 868 04b2 8064      		ori r24,lo8(64)
 869 04b4 8BBF      		out 0x3b,r24
 870 04b6 80E4      		ldi r24,lo8(64)
 871 04b8 8ABF      		out 0x3a,r24
 872 04ba 85B7      		in r24,0x35
 873 04bc 8C7F      		andi r24,lo8(-4)
 874 04be 85BF      		out 0x35,r24
 508:main.c        ****           sleepmode=SLEEP_MODE_PWR_DOWN; //sleep deep
 875               		.loc 1 508 0
 876 04c0 80E1      		ldi r24,lo8(16)
 877 04c2 8093 0000 		sts sleepmode,r24
 509:main.c        ****           OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
 878               		.loc 1 509 0
 879 04c6 DA98      		cbi 0x1b,2
 880 04c8 50E0      		ldi r21,0
 881 04ca 00C0      		rjmp .L63
 882               	.LVL72:
 883               	.L62:
 510:main.c        ****         } else {
 511:main.c        ****           //sleepmode=SLEEP_MODE_IDLE; //no sleep
 512:main.c        ****         }
 513:main.c        **** 
 514:main.c        ****         if (lmode!=OWM_PRESENCE)  {
 884               		.loc 1 514 0
 885 04cc 5230      		cpi r21,lo8(2)
 886 04ce 01F0      		breq .L64
 887               	.LVL73:
 888               	.L63:
 515:main.c        ****             TCNT_REG=~(OWT_MIN_RESET-OWT_READLINE);  //OWT_READLINE around OWT_LOWTIME
 889               		.loc 1 515 0
 890 04d0 8EEC      		ldi r24,lo8(-50)
 891 04d2 82BF      		out 0x32,r24
 516:main.c        ****             EN_OWINT;
 892               		.loc 1 516 0
 893 04d4 8BB7      		in r24,0x3b
 894 04d6 8064      		ori r24,lo8(64)
 895 04d8 8BBF      		out 0x3b,r24
 896 04da 80E4      		ldi r24,lo8(64)
 897 04dc 8ABF      		out 0x3a,r24
 898               	.L64:
 517:main.c        ****         }
 518:main.c        ****         mode=lmode;
 899               		.loc 1 518 0
 900 04de 5093 0000 		sts mode,r21
 519:main.c        ****         wmode=lwmode;
 901               		.loc 1 519 0
 902 04e2 6093 0000 		sts wmode,r22
 520:main.c        ****         bytep=lbytep;
 903               		.loc 1 520 0
 904 04e6 4093 0000 		sts bytep,r20
 521:main.c        ****         bitp=lbitp;
 905               		.loc 1 521 0
 906 04ea D093 0000 		sts bitp,r29
 522:main.c        ****         srcount=lsrcount;
 907               		.loc 1 522 0
 908 04ee C093 0000 		sts srcount,r28
 523:main.c        ****         actbit=lactbit;
 909               		.loc 1 523 0
 910 04f2 7093 0000 		sts actbit,r23
 524:main.c        ****         scrc=lscrc;
 911               		.loc 1 524 0
 912 04f6 3093 0000 		sts scrc+1,r19
 913 04fa 2093 0000 		sts scrc,r18
 914 04fe 00C0      		rjmp .L107
 915               	.LVL74:
 916               	.L73:
 494:main.c        ****                 lbitp=1;
 917               		.loc 1 494 0
 918 0500 D1E0      		ldi r29,lo8(1)
 919               	.LVL75:
 920 0502 00C0      		rjmp .L65
 921               	.LVL76:
 922               	.L67:
 298:main.c        ****                 lbitp=1;
 923               		.loc 1 298 0
 924 0504 D1E0      		ldi r29,lo8(1)
 301:main.c        ****                         lbytep=0;
 925               		.loc 1 301 0
 926 0506 40E0      		ldi r20,0
 927               	.LVL77:
 302:main.c        ****                         lmode=OWM_MATCH_ROM;
 928               		.loc 1 302 0
 929 0508 55E0      		ldi r21,lo8(5)
 930               	.LVL78:
 931 050a 00C0      		rjmp .L63
 932               	.LVL79:
 933               	.L72:
 457:main.c        ****                 lbitp=1;
 934               		.loc 1 457 0
 935 050c D1E0      		ldi r29,lo8(1)
 936 050e 00C0      		rjmp .L62
 937               	.LVL80:
 938               	.L107:
 939               	/* epilogue start */
 525:main.c        **** }
 940               		.loc 1 525 0
 941 0510 FF91      		pop r31
 942 0512 EF91      		pop r30
 943 0514 DF91      		pop r29
 944 0516 CF91      		pop r28
 945 0518 BF91      		pop r27
 946 051a AF91      		pop r26
 947 051c 9F91      		pop r25
 948 051e 8F91      		pop r24
 949 0520 7F91      		pop r23
 950               	.LVL81:
 951 0522 6F91      		pop r22
 952 0524 5F91      		pop r21
 953 0526 4F91      		pop r20
 954 0528 3F91      		pop r19
 955 052a 2F91      		pop r18
 956 052c 1F91      		pop r17
 957               	.LVL82:
 958 052e 0F90      		pop r0
 959 0530 0FBE      		out __SREG__,r0
 960 0532 0F90      		pop r0
 961 0534 1F90      		pop r1
 962 0536 1895      		reti
 963               	.LFE1:
 965               	.global	init_eeprom
 967               	init_eeprom:
 968               	.LFB2:
 526:main.c        **** 
 527:main.c        **** #ifdef PC_INT_ISR
 528:main.c        **** PC_INT_ISR  //for counting  defined for specific device
 529:main.c        **** #elif defined PC_INT_ISRA
 530:main.c        **** PC_INT_ISRA
 531:main.c        **** PC_INT_ISRB
 532:main.c        **** #endif
 533:main.c        **** 
 534:main.c        **** void init_eeprom(void) {
 969               		.loc 1 534 0
 970 0538 0F93      		push r16
 971               	.LCFI24:
 972 053a 1F93      		push r17
 973               	.LCFI25:
 974 053c CF93      		push r28
 975               	.LCFI26:
 976 053e DF93      		push r29
 977               	.LCFI27:
 978               	/* prologue: function */
 979               	/* frame size = 0 */
 980               	/* stack size = 4 */
 981               	.L__stack_usage = 4
 535:main.c        ****     /* check magic, read slave address and counter values, resetcount, init-name, */
 536:main.c        ****     if (eeprom_read_word((const uint16_t *) (EE_MAGIC_OFFSET+0)) == EE_MAGIC_NUMBER) {
 982               		.loc 1 536 0
 983 0540 80E0      		ldi r24,0
 984 0542 90E0      		ldi r25,0
 985 0544 00D0      		rcall __eerd_word_tn84
 986               	.LVL83:
 987 0546 823E      		cpi r24,-30
 988 0548 914E      		sbci r25,-31
 989 054a 01F4      		brne .L112
 990 054c 00E0      		ldi r16,lo8(owid)
 991 054e 10E0      		ldi r17,hi8(owid)
 992 0550 C2E0      		ldi r28,lo8(2)
 993 0552 D0E0      		ldi r29,0
 994               	.L113:
 995               	.LBB2:
 537:main.c        ****       //EEPROM valid -> read counters & settings
 538:main.c        ****       for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 539:main.c        ****         owid[i-EE_OWID_OFFSET] = eeprom_read_byte((uint8_t *) i);
 996               		.loc 1 539 0 discriminator 2
 997 0554 CE01      		movw r24,r28
 998 0556 00D0      		rcall __eerd_byte_tn84
 999               	.LVL84:
 1000 0558 F801      		movw r30,r16
 1001 055a 8193      		st Z+,r24
 1002 055c 8F01      		movw r16,r30
 538:main.c        ****       for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 1003               		.loc 1 538 0 discriminator 2
 1004 055e 2196      		adiw r28,1
 1005               	.LVL85:
 1006 0560 CA30      		cpi r28,10
 1007 0562 D105      		cpc r29,__zero_reg__
 1008 0564 01F4      		brne .L113
 1009               	.LBE2:
 540:main.c        ****       rcnt = eeprom_read_word((const uint16_t *) (EE_RCNT_OFFSET+0)) + 1;
 1010               		.loc 1 540 0
 1011 0566 8AE0      		ldi r24,lo8(10)
 1012 0568 90E0      		ldi r25,0
 1013 056a 00D0      		rcall __eerd_word_tn84
 1014               	.LVL86:
 1015 056c BC01      		movw r22,r24
 1016 056e 6F5F      		subi r22,-1
 1017 0570 7F4F      		sbci r23,-1
 1018 0572 7093 0000 		sts rcnt+1,r23
 1019 0576 6093 0000 		sts rcnt,r22
 541:main.c        ****       eeprom_update_word((uint16_t *) (EE_RCNT_OFFSET+0), rcnt);
 1020               		.loc 1 541 0
 1021 057a 8AE0      		ldi r24,lo8(10)
 1022 057c 90E0      		ldi r25,0
 1023 057e 00D0      		rcall __eeupd_word_tn84
 1024               	.LVL87:
 542:main.c        ****       version = eeprom_read_word((const uint16_t *) (EE_VERSION_OFFSET+0));
 1025               		.loc 1 542 0
 1026 0580 8DE2      		ldi r24,lo8(45)
 1027 0582 90E0      		ldi r25,0
 1028 0584 00D0      		rcall __eerd_word_tn84
 1029               	.LVL88:
 1030 0586 9093 0000 		sts version+1,r25
 1031 058a 8093 0000 		sts version,r24
 543:main.c        ****       stype = eeprom_read_byte((uint8_t *) (EE_TYPE_OFFSET+0));
 1032               		.loc 1 543 0
 1033 058e 8CE2      		ldi r24,lo8(44)
 1034 0590 90E0      		ldi r25,0
 1035 0592 00D0      		rcall __eerd_byte_tn84
 1036               	.LVL89:
 1037 0594 8093 0000 		sts stype,r24
 1038 0598 00C0      		rjmp .L118
 1039               	.LVL90:
 1040               	.L112:
 544:main.c        ****     } else {
 545:main.c        ****       //Init values
 546:main.c        ****       /* should cli(); here no sei(); yet enabled in main.. */
 547:main.c        ****       eeprom_write_word((uint16_t *) (EE_MAGIC_OFFSET+0), EE_MAGIC_NUMBER);
 1041               		.loc 1 547 0
 1042 059a 62EE      		ldi r22,lo8(-30)
 1043 059c 71EE      		ldi r23,lo8(-31)
 1044 059e 80E0      		ldi r24,0
 1045 05a0 90E0      		ldi r25,0
 1046 05a2 00D0      		rcall __eewr_word_tn84
 1047               	.LVL91:
 1048 05a4 00E0      		ldi r16,lo8(owid)
 1049 05a6 10E0      		ldi r17,hi8(owid)
 548:main.c        ****       for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 1050               		.loc 1 548 0
 1051 05a8 C2E0      		ldi r28,lo8(2)
 1052 05aa D0E0      		ldi r29,0
 1053               	.LVL92:
 1054               	.L115:
 1055               	.LBB3:
 549:main.c        ****         eeprom_write_byte((uint8_t *) i,owid[i-EE_OWID_OFFSET]);
 1056               		.loc 1 549 0 discriminator 2
 1057 05ac F801      		movw r30,r16
 1058 05ae 6191      		ld r22,Z+
 1059 05b0 8F01      		movw r16,r30
 1060 05b2 CE01      		movw r24,r28
 1061 05b4 00D0      		rcall __eewr_byte_tn84
 1062               	.LVL93:
 548:main.c        ****       for (uint16_t i=EE_OWID_OFFSET;i<EE_OWID_OFFSET+8;i++)
 1063               		.loc 1 548 0 discriminator 2
 1064 05b6 2196      		adiw r28,1
 1065               	.LVL94:
 1066 05b8 CA30      		cpi r28,10
 1067 05ba D105      		cpc r29,__zero_reg__
 1068 05bc 01F4      		brne .L115
 1069               	.LBE3:
 550:main.c        ****       eeprom_write_word((uint16_t *) (EE_RCNT_OFFSET+0), rcnt);
 1070               		.loc 1 550 0
 1071 05be 6091 0000 		lds r22,rcnt
 1072 05c2 7091 0000 		lds r23,rcnt+1
 1073 05c6 8AE0      		ldi r24,lo8(10)
 1074 05c8 90E0      		ldi r25,0
 1075 05ca 00D0      		rcall __eewr_word_tn84
 1076               	.LVL95:
 551:main.c        ****       eeprom_write_byte((uint8_t *) (EE_TYPE_OFFSET+0), stype);
 1077               		.loc 1 551 0
 1078 05cc 6091 0000 		lds r22,stype
 1079 05d0 8CE2      		ldi r24,lo8(44)
 1080 05d2 90E0      		ldi r25,0
 1081 05d4 00D0      		rcall __eewr_byte_tn84
 1082               	.LVL96:
 552:main.c        ****       eeprom_write_word((uint16_t *) (EE_VERSION_OFFSET+0), version);
 1083               		.loc 1 552 0
 1084 05d6 6091 0000 		lds r22,version
 1085 05da 7091 0000 		lds r23,version+1
 1086 05de 8DE2      		ldi r24,lo8(45)
 1087 05e0 90E0      		ldi r25,0
 1088               	/* epilogue start */
 553:main.c        ****     }
 554:main.c        **** }
 1089               		.loc 1 554 0
 1090 05e2 DF91      		pop r29
 1091 05e4 CF91      		pop r28
 1092               	.LVL97:
 1093 05e6 1F91      		pop r17
 1094 05e8 0F91      		pop r16
 552:main.c        ****       eeprom_write_word((uint16_t *) (EE_VERSION_OFFSET+0), version);
 1095               		.loc 1 552 0
 1096 05ea 00C0      		rjmp __eewr_word_tn84
 1097               	.LVL98:
 1098               	.L118:
 1099               	/* epilogue start */
 1100               		.loc 1 554 0
 1101 05ec DF91      		pop r29
 1102 05ee CF91      		pop r28
 1103               	.LVL99:
 1104 05f0 1F91      		pop r17
 1105 05f2 0F91      		pop r16
 1106 05f4 0895      		ret
 1107               	.LFE2:
 1109               	.global	__vector_4
 1111               	__vector_4:
 1112               	.LFB3:
 555:main.c        **** 
 556:main.c        **** //FIXME: enable real watchdog?
 557:main.c        **** ISR(WDT_vect) {
 1113               		.loc 1 557 0
 1114 05f6 1F92      		push r1
 1115               	.LCFI28:
 1116 05f8 0F92      		push r0
 1117               	.LCFI29:
 1118 05fa 0FB6      		in r0,__SREG__
 1119 05fc 0F92      		push r0
 1120 05fe 1124      		clr __zero_reg__
 1121 0600 8F93      		push r24
 1122               	.LCFI30:
 1123 0602 9F93      		push r25
 1124               	.LCFI31:
 1125 0604 AF93      		push r26
 1126               	.LCFI32:
 1127 0606 BF93      		push r27
 1128               	.LCFI33:
 1129               	/* prologue: Signal */
 1130               	/* frame size = 0 */
 1131               	/* stack size = 7 */
 1132               	.L__stack_usage = 7
 558:main.c        ****   uptime += 2;
 1133               		.loc 1 558 0
 1134 0608 8091 0000 		lds r24,uptime
 1135 060c 9091 0000 		lds r25,uptime+1
 1136 0610 A091 0000 		lds r26,uptime+2
 1137 0614 B091 0000 		lds r27,uptime+3
 1138 0618 0296      		adiw r24,2
 1139 061a A11D      		adc r26,__zero_reg__
 1140 061c B11D      		adc r27,__zero_reg__
 1141 061e 8093 0000 		sts uptime,r24
 1142 0622 9093 0000 		sts uptime+1,r25
 1143 0626 A093 0000 		sts uptime+2,r26
 1144 062a B093 0000 		sts uptime+3,r27
 1145               	/* epilogue start */
 559:main.c        **** }
 1146               		.loc 1 559 0
 1147 062e BF91      		pop r27
 1148 0630 AF91      		pop r26
 1149 0632 9F91      		pop r25
 1150 0634 8F91      		pop r24
 1151 0636 0F90      		pop r0
 1152 0638 0FBE      		out __SREG__,r0
 1153 063a 0F90      		pop r0
 1154 063c 1F90      		pop r1
 1155 063e 1895      		reti
 1156               	.LFE3:
 1158               		.section	.text.startup,"ax",@progbits
 1159               	.global	main
 1161               	main:
 1162               	.LFB4:
 560:main.c        **** 
 561:main.c        **** int main(void) {
 1163               		.loc 1 561 0
 1164               	/* prologue: function */
 1165               	/* frame size = 0 */
 1166               	/* stack size = 0 */
 1167               	.L__stack_usage = 0
 562:main.c        ****     mode=OWM_SLEEP;
 1168               		.loc 1 562 0
 1169 0000 1092 0000 		sts mode,__zero_reg__
 563:main.c        ****     wmode=OWW_NO_WRITE;
 1170               		.loc 1 563 0
 1171 0004 D2E0      		ldi r29,lo8(2)
 1172 0006 D093 0000 		sts wmode,r29
 564:main.c        ****     OW_DDR&=~OW_PINN;
 1173               		.loc 1 564 0
 1174 000a BA98      		cbi 0x17,2
 565:main.c        **** 
 566:main.c        ****     INIT_AVR
 1175               		.loc 1 566 0
 1176 000c 80E8      		ldi r24,lo8(-128)
 1177 000e 86BD      		out 0x26,r24
 1178 0010 16BC      		out 0x26,__zero_reg__
 1179 0012 19BE      		out 0x39,__zero_reg__
 1180 0014 C0E4      		ldi r28,lo8(64)
 1181 0016 CBBF      		out 0x3b,r28
 1182 0018 83E0      		ldi r24,lo8(3)
 1183 001a 83BF      		out 0x33,r24
 1184 001c 81B5      		in r24,0x21
 1185 001e 8760      		ori r24,lo8(7)
 1186 0020 81BD      		out 0x21,r24
 1187 0022 81B5      		in r24,0x21
 1188 0024 8064      		ori r24,lo8(64)
 1189 0026 81BD      		out 0x21,r24
 567:main.c        ****     PWRSAVE_AVR
 1190               		.loc 1 567 0
 1191 0028 3798      		cbi 0x6,7
 1192 002a 80B1      		in r24,0
 1193 002c 8B60      		ori r24,lo8(11)
 1194 002e 80B9      		out 0,r24
 568:main.c        **** 
 569:main.c        ****     init_eeprom();
 1195               		.loc 1 569 0
 1196 0030 00D0      		rcall init_eeprom
 1197               	.LVL100:
 570:main.c        **** 
 571:main.c        ****     INIT_LED_PINS
 1198               		.loc 1 571 0
 1199 0032 D29A      		sbi 0x1a,2
 572:main.c        **** 
 573:main.c        ****     SET_OWINT_FALLING;
 1200               		.loc 1 573 0
 1201 0034 D5BF      		out 0x35,r29
 1202 0036 85B7      		in r24,0x35
 1203 0038 8E7F      		andi r24,lo8(-2)
 1204 003a 85BF      		out 0x35,r24
 574:main.c        ****     DIS_TIMER;
 1205               		.loc 1 574 0
 1206 003c 89B7      		in r24,0x39
 1207 003e 8E7F      		andi r24,lo8(-2)
 1208 0040 89BF      		out 0x39,r24
 575:main.c        ****     EN_OWINT;
 1209               		.loc 1 575 0
 1210 0042 8BB7      		in r24,0x3b
 1211 0044 8064      		ori r24,lo8(64)
 1212 0046 8BBF      		out 0x3b,r24
 1213 0048 CABF      		out 0x3a,r28
 576:main.c        **** 
 577:main.c        ****     sei();
 1214               		.loc 1 577 0
 1215               	/* #APP */
 1216               	 ;  577 "main.c" 1
 1217 004a 7894      		sei
 1218               	 ;  0 "" 2
 578:main.c        ****     //force sleep first
 579:main.c        ****     DIS_TIMER;
 1219               		.loc 1 579 0
 1220               	/* #NOAPP */
 1221 004c 89B7      		in r24,0x39
 1222 004e 8E7F      		andi r24,lo8(-2)
 1223 0050 89BF      		out 0x39,r24
 580:main.c        ****     EN_OWINT; SET_OWINT_LOWLEVEL;
 1224               		.loc 1 580 0
 1225 0052 8BB7      		in r24,0x3b
 1226 0054 8064      		ori r24,lo8(64)
 1227 0056 8BBF      		out 0x3b,r24
 1228 0058 CABF      		out 0x3a,r28
 1229 005a 85B7      		in r24,0x35
 1230 005c 8C7F      		andi r24,lo8(-4)
 1231 005e 85BF      		out 0x35,r24
 581:main.c        ****     sleepmode=SLEEP_MODE_PWR_DOWN;
 1232               		.loc 1 581 0
 1233 0060 80E1      		ldi r24,lo8(16)
 1234 0062 8093 0000 		sts sleepmode,r24
 1235               	.L122:
 582:main.c        **** 
 583:main.c        ****     while(1){
 584:main.c        ****         if (ewrite_flag) {
 1236               		.loc 1 584 0
 1237 0066 8091 0000 		lds r24,ewrite_flag
 1238 006a 8823      		tst r24
 1239 006c 01F0      		breq .L121
 585:main.c        ****           eeprom_update_dword((uint32_t *) (ewrite_flag+0), eewrite_buf.u32_1);
 1240               		.loc 1 585 0
 1241 006e 8091 0000 		lds r24,ewrite_flag
 1242 0072 4091 0000 		lds r20,eewrite_buf
 1243 0076 5091 0000 		lds r21,eewrite_buf+1
 1244 007a 6091 0000 		lds r22,eewrite_buf+2
 1245 007e 7091 0000 		lds r23,eewrite_buf+3
 1246 0082 90E0      		ldi r25,0
 1247 0084 00D0      		rcall __eeupd_dword_tn84
 1248               	.LVL101:
 586:main.c        ****           ewrite_flag = 0;
 1249               		.loc 1 586 0
 1250 0086 1092 0000 		sts ewrite_flag,__zero_reg__
 1251               	.L121:
 587:main.c        ****         }
 588:main.c        ****         OWRXLED_PORT &= ~(1<<OWRXLED_PIN); /* led off */
 1252               		.loc 1 588 0
 1253 008a DA98      		cbi 0x1b,2
 589:main.c        ****         sleep_enable();
 1254               		.loc 1 589 0
 1255 008c 85B7      		in r24,0x35
 1256 008e 8062      		ori r24,lo8(32)
 1257 0090 85BF      		out 0x35,r24
 590:main.c        ****         set_sleep_mode(sleepmode);
 1258               		.loc 1 590 0
 1259 0092 85B7      		in r24,0x35
 1260 0094 9091 0000 		lds r25,sleepmode
 1261 0098 877E      		andi r24,lo8(-25)
 1262 009a 892B      		or r24,r25
 1263 009c 85BF      		out 0x35,r24
 591:main.c        ****         sleep_cpu();
 1264               		.loc 1 591 0
 1265               	/* #APP */
 1266               	 ;  591 "main.c" 1
 1267 009e 8895      		sleep
 1268               		
 1269               	 ;  0 "" 2
 592:main.c        ****     }
 1270               		.loc 1 592 0
 1271               	/* #NOAPP */
 1272 00a0 00C0      		rjmp .L122
 1273               	.LFE4:
 1275               		.comm	eewrite_buf,8,1
 1276               		.comm	ewrite_flag,1,1
 1277               	.global	crcerrcnt
 1278               		.section .bss
 1281               	crcerrcnt:
 1282 0000 00        		.zero	1
 1283               		.comm	eflag,1,1
 1284               	.global	rcnt
 1285               		.data
 1288               	rcnt:
 1289 0000 0100      		.word	1
 1290               	.global	stype
 1293               	stype:
 1294 0002 06        		.byte	6
 1295               	.global	version
 1298               	version:
 1299 0003 0601      		.word	262
 1300               		.comm	srcount,1,1
 1301               		.comm	actbit,1,1
 1302               		.comm	wmode,1,1
 1303               		.comm	mode,1,1
 1304               		.comm	bytep,1,1
 1305               		.comm	bitp,1,1
 1306               	.global	owid
 1309               	owid:
 1310 0005 E1        		.byte	-31
 1311 0006 E2        		.byte	-30
 1312 0007 00        		.byte	0
 1313 0008 00        		.byte	0
 1314 0009 00        		.byte	0
 1315 000a 06        		.byte	6
 1316 000b 84        		.byte	-124
 1317 000c 82        		.byte	-126
 1318               		.comm	cbuf,1,1
 1319               		.comm	sleepmode,1,1
 1320               		.comm	temperature,4,1
 1321               		.comm	pressure,4,1
 1322               		.comm	lastcps,1,1
 1323               		.comm	page,1,1
 1324               		.comm	scrc,2,1
 1325               	.global	nackmsg
 1326               		.section .bss
 1329               	nackmsg:
 1330 0001 00        		.zero	1
 1331               	.global	recv_state
 1334               	recv_state:
 1335 0002 00        		.zero	1
 1336               		.comm	scratchpad,11,1
 1337               	.global	uptime
 1340               	uptime:
 1341 0003 0000 0000 		.zero	4
 1342               	.global	EE_LABEL_MAXLEN
 1343               		.section	.rodata
 1346               	EE_LABEL_MAXLEN:
 1347 0000 20        		.byte	32
 1348               	.global	EE_LABEL_OFFSET
 1351               	EE_LABEL_OFFSET:
 1352 0001 32        		.byte	50
 1353               	.global	EE_VERSION_OFFSET
 1356               	EE_VERSION_OFFSET:
 1357 0002 2D        		.byte	45
 1358               	.global	EE_TYPE_OFFSET
 1361               	EE_TYPE_OFFSET:
 1362 0003 2C        		.byte	44
 1363               	.global	EE_RCNT_OFFSET
 1366               	EE_RCNT_OFFSET:
 1367 0004 0A        		.byte	10
 1368               	.global	EE_OWID_OFFSET
 1371               	EE_OWID_OFFSET:
 1372 0005 02        		.byte	2
 1373               	.global	EE_MAGIC_OFFSET
 1376               	EE_MAGIC_OFFSET:
 1377 0006 00        		.zero	1
 1378               	.global	EE_DEFTYPE
 1381               	EE_DEFTYPE:
 1382 0007 01        		.byte	1
 1383               	.global	EE_MAGIC_NUMBER
 1386               	EE_MAGIC_NUMBER:
 1387 0008 E2E1      		.word	-7710
 1650               	.Letext0:
 1651               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 1652               		.file 3 "common.h"
 1653               		.file 4 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccs7oFMO.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccs7oFMO.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccs7oFMO.s:4      *ABS*:0000003f __SREG__
     /tmp/ccs7oFMO.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccs7oFMO.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccs7oFMO.s:11     .text:00000000 __vector_1
                            *COM*:00000001 wmode
                            *COM*:00000001 mode
                            *COM*:00000001 sleepmode
                            *COM*:00000001 srcount
     /tmp/ccs7oFMO.s:163    .text:000000a6 __vector_11
                            *COM*:00000001 bytep
                            *COM*:00000001 bitp
                            *COM*:00000001 actbit
                            *COM*:00000002 scrc
                            *COM*:00000001 cbuf
     /tmp/ccs7oFMO.s:1309   .data:00000005 owid
                            *COM*:00000001 page
                            *COM*:0000000b scratchpad
     /tmp/ccs7oFMO.s:1293   .data:00000002 stype
                            *COM*:00000001 eflag
     /tmp/ccs7oFMO.s:1298   .data:00000003 version
     /tmp/ccs7oFMO.s:1340   .bss:00000003 uptime
     /tmp/ccs7oFMO.s:1288   .data:00000000 rcnt
     /tmp/ccs7oFMO.s:1281   .bss:00000000 crcerrcnt
                            *COM*:00000004 temperature
                            *COM*:00000004 pressure
                            *COM*:00000001 ewrite_flag
                            *COM*:00000008 eewrite_buf
     /tmp/ccs7oFMO.s:967    .text:00000538 init_eeprom
     /tmp/ccs7oFMO.s:1111   .text:000005f6 __vector_4
     /tmp/ccs7oFMO.s:1161   .text.startup:00000000 main
                            *COM*:00000001 lastcps
     /tmp/ccs7oFMO.s:1329   .bss:00000001 nackmsg
     /tmp/ccs7oFMO.s:1334   .bss:00000002 recv_state
     /tmp/ccs7oFMO.s:1346   .rodata:00000000 EE_LABEL_MAXLEN
     /tmp/ccs7oFMO.s:1351   .rodata:00000001 EE_LABEL_OFFSET
     /tmp/ccs7oFMO.s:1356   .rodata:00000002 EE_VERSION_OFFSET
     /tmp/ccs7oFMO.s:1361   .rodata:00000003 EE_TYPE_OFFSET
     /tmp/ccs7oFMO.s:1366   .rodata:00000004 EE_RCNT_OFFSET
     /tmp/ccs7oFMO.s:1371   .rodata:00000005 EE_OWID_OFFSET
     /tmp/ccs7oFMO.s:1376   .rodata:00000006 EE_MAGIC_OFFSET
     /tmp/ccs7oFMO.s:1381   .rodata:00000007 EE_DEFTYPE
     /tmp/ccs7oFMO.s:1386   .rodata:00000008 EE_MAGIC_NUMBER

UNDEFINED SYMBOLS
__eerd_dword_tn84
__eerd_word_tn84
__eerd_byte_tn84
__eeupd_word_tn84
__eewr_word_tn84
__eewr_byte_tn84
__eeupd_dword_tn84
__do_copy_data
__do_clear_bss
