
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f8  00800100  00002f62  00002ff6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f62  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001225  008001f8  008001f8  000030ee  2**0
                  ALLOC
  3 .stab         0000117c  00000000  00000000  000030f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a0e  00000000  00000000  0000426c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000658  00000000  00000000  00004c7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00001095  00000000  00000000  000052d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000b03e  00000000  00000000  00006367  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000031f3  00000000  00000000  000113a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000080f5  00000000  00000000  00014598  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000930  00000000  00000000  0001c690  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003d80  00000000  00000000  0001cfc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00004482  00000000  00000000  00020d40  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000728  00000000  00000000  000251c2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       4:	2c c2       	rjmp	.+1112   	; 0x45e <__bad_interrupt>

	return Serial_ReceiveByte();
}

int Serial_getchar_Blocking(FILE *Stream)
{
       6:	00 00       	nop
       8:	2a c2       	rjmp	.+1108   	; 0x45e <__bad_interrupt>
       a:	00 00       	nop
       c:	28 c2       	rjmp	.+1104   	; 0x45e <__bad_interrupt>
       e:	00 00       	nop
      10:	26 c2       	rjmp	.+1100   	; 0x45e <__bad_interrupt>
      12:	00 00       	nop
      14:	24 c2       	rjmp	.+1096   	; 0x45e <__bad_interrupt>
      16:	00 00       	nop
      18:	22 c2       	rjmp	.+1092   	; 0x45e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	20 c2       	rjmp	.+1088   	; 0x45e <__bad_interrupt>
      1e:	00 00       	nop
      20:	1e c2       	rjmp	.+1084   	; 0x45e <__bad_interrupt>
      22:	00 00       	nop
      24:	1c c2       	rjmp	.+1080   	; 0x45e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 e8 0e 	jmp	0x1dd0	; 0x1dd0 <__vector_10>
      2c:	18 c2       	rjmp	.+1072   	; 0x45e <__bad_interrupt>
      2e:	00 00       	nop
      30:	16 c2       	rjmp	.+1068   	; 0x45e <__bad_interrupt>
      32:	00 00       	nop
      34:	14 c2       	rjmp	.+1064   	; 0x45e <__bad_interrupt>
      36:	00 00       	nop
      38:	12 c2       	rjmp	.+1060   	; 0x45e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	10 c2       	rjmp	.+1056   	; 0x45e <__bad_interrupt>
      3e:	00 00       	nop
      40:	0e c2       	rjmp	.+1052   	; 0x45e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c c2       	rjmp	.+1048   	; 0x45e <__bad_interrupt>
      46:	00 00       	nop
      48:	0a c2       	rjmp	.+1044   	; 0x45e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	08 c2       	rjmp	.+1040   	; 0x45e <__bad_interrupt>
      4e:	00 00       	nop
      50:	06 c2       	rjmp	.+1036   	; 0x45e <__bad_interrupt>
      52:	00 00       	nop
      54:	04 c2       	rjmp	.+1032   	; 0x45e <__bad_interrupt>
      56:	00 00       	nop
      58:	02 c2       	rjmp	.+1028   	; 0x45e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	00 c2       	rjmp	.+1024   	; 0x45e <__bad_interrupt>
      5e:	00 00       	nop
      60:	fe c1       	rjmp	.+1020   	; 0x45e <__bad_interrupt>
      62:	00 00       	nop
      64:	fc c1       	rjmp	.+1016   	; 0x45e <__bad_interrupt>
      66:	00 00       	nop
      68:	fa c1       	rjmp	.+1012   	; 0x45e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f8 c1       	rjmp	.+1008   	; 0x45e <__bad_interrupt>
      6e:	00 00       	nop
      70:	f6 c1       	rjmp	.+1004   	; 0x45e <__bad_interrupt>
      72:	00 00       	nop
      74:	f4 c1       	rjmp	.+1000   	; 0x45e <__bad_interrupt>
      76:	00 00       	nop
      78:	f2 c1       	rjmp	.+996    	; 0x45e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f0 c1       	rjmp	.+992    	; 0x45e <__bad_interrupt>
      7e:	00 00       	nop
      80:	ee c1       	rjmp	.+988    	; 0x45e <__bad_interrupt>
      82:	00 00       	nop
      84:	ec c1       	rjmp	.+984    	; 0x45e <__bad_interrupt>
      86:	00 00       	nop
      88:	ea c1       	rjmp	.+980    	; 0x45e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e8 c1       	rjmp	.+976    	; 0x45e <__bad_interrupt>
      8e:	00 00       	nop
      90:	e6 c1       	rjmp	.+972    	; 0x45e <__bad_interrupt>
      92:	00 00       	nop
      94:	e4 c1       	rjmp	.+968    	; 0x45e <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 58 58 58 58 58 58 09 09 3c 2f 70 3e     </i>XXXXXX..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	11 e0       	ldi	r17, 0x01	; 1
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	e2 e6       	ldi	r30, 0x62	; 98
     436:	ff e2       	ldi	r31, 0x2F	; 47
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+
     440:	0d 92       	st	X+, r0
     442:	a8 3f       	cpi	r26, 0xF8	; 248
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>

00000448 <__do_clear_bss>:
     448:	14 e1       	ldi	r17, 0x14	; 20
     44a:	a8 ef       	ldi	r26, 0xF8	; 248
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	01 c0       	rjmp	.+2      	; 0x452 <.do_clear_bss_start>

00000450 <.do_clear_bss_loop>:
     450:	1d 92       	st	X+, r1

00000452 <.do_clear_bss_start>:
     452:	ad 31       	cpi	r26, 0x1D	; 29
     454:	b1 07       	cpc	r27, r17
     456:	e1 f7       	brne	.-8      	; 0x450 <.do_clear_bss_loop>
     458:	69 d0       	rcall	.+210    	; 0x52c <main>
     45a:	0c 94 af 17 	jmp	0x2f5e	; 0x2f5e <_exit>

0000045e <__bad_interrupt>:
     45e:	d0 cd       	rjmp	.-1120   	; 0x0 <__vectors>

00000460 <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     460:	8b b1       	in	r24, 0x0b	; 11
     462:	8f 70       	andi	r24, 0x0F	; 15
     464:	80 6a       	ori	r24, 0xA0	; 160
     466:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     468:	08 95       	ret

0000046a <EVENT_USB_Device_Disconnect>:
     46a:	8b b1       	in	r24, 0x0b	; 11
     46c:	8f 70       	andi	r24, 0x0F	; 15
     46e:	80 61       	ori	r24, 0x10	; 16
     470:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     472:	08 95       	ret

00000474 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
     474:	88 e1       	ldi	r24, 0x18	; 24
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	0c 94 6c 14 	jmp	0x28d8	; 0x28d8 <RNDIS_Device_ProcessControlRequest>

0000047c <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);
     47c:	88 e1       	ldi	r24, 0x18	; 24
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	0e 94 1c 14 	call	0x2838	; 0x2838 <RNDIS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     484:	80 fd       	sbrc	r24, 0
     486:	02 c0       	rjmp	.+4      	; 0x48c <EVENT_USB_Device_ConfigurationChanged+0x10>
     488:	90 e9       	ldi	r25, 0x90	; 144
     48a:	01 c0       	rjmp	.+2      	; 0x48e <EVENT_USB_Device_ConfigurationChanged+0x12>
     48c:	90 e6       	ldi	r25, 0x60	; 96
     48e:	8b b1       	in	r24, 0x0b	; 11
     490:	8f 70       	andi	r24, 0x0F	; 15
     492:	98 2b       	or	r25, r24
     494:	9b b9       	out	0x0b, r25	; 11
}
     496:	08 95       	ret

00000498 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     498:	84 b7       	in	r24, 0x34	; 52
     49a:	87 7f       	andi	r24, 0xF7	; 247
     49c:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     49e:	28 e1       	ldi	r18, 0x18	; 24
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	20 93 60 00 	sts	0x0060, r18
     4a8:	10 92 60 00 	sts	0x0060, r1
     4ac:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     4ae:	90 e0       	ldi	r25, 0x00	; 0
     4b0:	80 e8       	ldi	r24, 0x80	; 128
     4b2:	0f b6       	in	r0, 0x3f	; 63
     4b4:	f8 94       	cli
     4b6:	80 93 61 00 	sts	0x0061, r24
     4ba:	90 93 61 00 	sts	0x0061, r25
     4be:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4c0:	8a b1       	in	r24, 0x0a	; 10
     4c2:	80 6f       	ori	r24, 0xF0	; 240
     4c4:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4c6:	8b b1       	in	r24, 0x0b	; 11
     4c8:	8f 70       	andi	r24, 0x0F	; 15
     4ca:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4cc:	83 e3       	ldi	r24, 0x33	; 51
     4ce:	90 e0       	ldi	r25, 0x00	; 0
     4d0:	90 93 cd 00 	sts	0x00CD, r25
     4d4:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4d8:	86 e0       	ldi	r24, 0x06	; 6
     4da:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4de:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4e2:	20 93 c9 00 	sts	0x00C9, r18

				DDRD  |= (1 << 3);
     4e6:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4e8:	5a 9a       	sbi	0x0b, 2	; 11
	clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4ea:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <USB_Init>
			static inline void Serial_CreateStream(FILE* Stream)
			{
				if (!(Stream))
				{
					Stream = &USARTSerialStream;
					stdin  = Stream;
     4ee:	e9 e0       	ldi	r30, 0x09	; 9
     4f0:	f4 e1       	ldi	r31, 0x14	; 20
     4f2:	f0 93 18 14 	sts	0x1418, r31
     4f6:	e0 93 17 14 	sts	0x1417, r30
					stdout = Stream;
     4fa:	f0 93 1a 14 	sts	0x141A, r31
     4fe:	e0 93 19 14 	sts	0x1419, r30
				}
			
				*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
     502:	8e e0       	ldi	r24, 0x0E	; 14
     504:	df 01       	movw	r26, r30
     506:	1d 92       	st	X+, r1
     508:	8a 95       	dec	r24
     50a:	e9 f7       	brne	.-6      	; 0x506 <SetupHardware+0x6e>
     50c:	83 e0       	ldi	r24, 0x03	; 3
     50e:	80 93 0c 14 	sts	0x140C, r24
     512:	84 e3       	ldi	r24, 0x34	; 52
     514:	97 e1       	ldi	r25, 0x17	; 23
     516:	90 93 12 14 	sts	0x1412, r25
     51a:	80 93 11 14 	sts	0x1411, r24
     51e:	8e e3       	ldi	r24, 0x3E	; 62
     520:	97 e1       	ldi	r25, 0x17	; 23
     522:	90 93 14 14 	sts	0x1414, r25
     526:	80 93 13 14 	sts	0x1413, r24

	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);
}
     52a:	08 95       	ret

0000052c <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     52c:	b5 df       	rcall	.-150    	; 0x498 <SetupHardware>

	TCP_Init();
     52e:	5e d1       	rcall	.+700    	; 0x7ec <TCP_Init>
	Webserver_Init();
     530:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <Webserver_Init>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     534:	8b b1       	in	r24, 0x0b	; 11
     536:	8f 70       	andi	r24, 0x0F	; 15
     538:	80 61       	ori	r24, 0x10	; 16
     53a:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     53c:	78 94       	sei

	for (;;)
	{
		if (RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface))
     53e:	88 e1       	ldi	r24, 0x18	; 24
     540:	91 e0       	ldi	r25, 0x01	; 1
     542:	0e 94 ef 12 	call	0x25de	; 0x25de <RNDIS_Device_IsPacketReceived>
     546:	88 23       	and	r24, r24
     548:	31 f1       	breq	.+76     	; 0x596 <main+0x6a>
     54a:	8b b1       	in	r24, 0x0b	; 11
     54c:	8f 70       	andi	r24, 0x0F	; 15
     54e:	80 62       	ori	r24, 0x20	; 32
     550:	8b b9       	out	0x0b, r24	; 11
		{
			LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
			
			RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface, &FrameIN.FrameData, &FrameIN.FrameLength);
     552:	88 e1       	ldi	r24, 0x18	; 24
     554:	91 e0       	ldi	r25, 0x01	; 1
     556:	68 ef       	ldi	r22, 0xF8	; 248
     558:	71 e0       	ldi	r23, 0x01	; 1
     55a:	44 ed       	ldi	r20, 0xD4	; 212
     55c:	57 e0       	ldi	r21, 0x07	; 7
     55e:	0e 94 bf 13 	call	0x277e	; 0x277e <RNDIS_Device_ReadPacket>
			Ethernet_ProcessPacket(&FrameIN, &FrameOUT);
     562:	88 ef       	ldi	r24, 0xF8	; 248
     564:	91 e0       	ldi	r25, 0x01	; 1
     566:	66 ed       	ldi	r22, 0xD6	; 214
     568:	77 e0       	ldi	r23, 0x07	; 7
     56a:	81 d0       	rcall	.+258    	; 0x66e <Ethernet_ProcessPacket>
			
			if (FrameOUT.FrameLength)
     56c:	40 91 b2 0d 	lds	r20, 0x0DB2
     570:	50 91 b3 0d 	lds	r21, 0x0DB3
     574:	41 15       	cp	r20, r1
     576:	51 05       	cpc	r21, r1
     578:	51 f0       	breq	.+20     	; 0x58e <main+0x62>
			{
				RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface, &FrameOUT.FrameData, FrameOUT.FrameLength);				
     57a:	88 e1       	ldi	r24, 0x18	; 24
     57c:	91 e0       	ldi	r25, 0x01	; 1
     57e:	66 ed       	ldi	r22, 0xD6	; 214
     580:	77 e0       	ldi	r23, 0x07	; 7
     582:	0e 94 09 13 	call	0x2612	; 0x2612 <RNDIS_Device_SendPacket>
				FrameOUT.FrameLength = 0;
     586:	10 92 b3 0d 	sts	0x0DB3, r1
     58a:	10 92 b2 0d 	sts	0x0DB2, r1
     58e:	8b b1       	in	r24, 0x0b	; 11
     590:	8f 70       	andi	r24, 0x0F	; 15
     592:	80 66       	ori	r24, 0x60	; 96
     594:	8b b9       	out	0x0b, r24	; 11
			}
			
			LEDs_SetAllLEDs(LEDMASK_USB_READY);
		}

		TCP_TCPTask(&Ethernet_RNDIS_Interface, &FrameOUT);
     596:	88 e1       	ldi	r24, 0x18	; 24
     598:	91 e0       	ldi	r25, 0x01	; 1
     59a:	66 ed       	ldi	r22, 0xD6	; 214
     59c:	77 e0       	ldi	r23, 0x07	; 7
     59e:	a0 d6       	rcall	.+3392   	; 0x12e0 <TCP_TCPTask>

		RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
     5a0:	88 e1       	ldi	r24, 0x18	; 24
     5a2:	91 e0       	ldi	r25, 0x01	; 1
     5a4:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <RNDIS_Device_USBTask>
		USB_USBTask();
     5a8:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <USB_USBTask>
     5ac:	c8 cf       	rjmp	.-112    	; 0x53e <main+0x12>

000005ae <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     5ae:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     5b0:	92 30       	cpi	r25, 0x02	; 2
     5b2:	49 f0       	breq	.+18     	; 0x5c6 <CALLBACK_USB_GetDescriptor+0x18>
     5b4:	93 30       	cpi	r25, 0x03	; 3
     5b6:	61 f0       	breq	.+24     	; 0x5d0 <CALLBACK_USB_GetDescriptor+0x22>
     5b8:	91 30       	cpi	r25, 0x01	; 1
     5ba:	f9 f4       	brne	.+62     	; 0x5fa <CALLBACK_USB_GetDescriptor+0x4c>
     5bc:	e8 e9       	ldi	r30, 0x98	; 152
     5be:	f0 e0       	ldi	r31, 0x00	; 0
     5c0:	22 e1       	ldi	r18, 0x12	; 18
     5c2:	30 e0       	ldi	r19, 0x00	; 0
     5c4:	1e c0       	rjmp	.+60     	; 0x602 <CALLBACK_USB_GetDescriptor+0x54>
     5c6:	ea ea       	ldi	r30, 0xAA	; 170
     5c8:	f0 e0       	ldi	r31, 0x00	; 0
     5ca:	2e e3       	ldi	r18, 0x3E	; 62
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	19 c0       	rjmp	.+50     	; 0x602 <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     5d0:	81 30       	cpi	r24, 0x01	; 1
     5d2:	49 f0       	breq	.+18     	; 0x5e6 <CALLBACK_USB_GetDescriptor+0x38>
     5d4:	81 30       	cpi	r24, 0x01	; 1
     5d6:	18 f0       	brcs	.+6      	; 0x5de <CALLBACK_USB_GetDescriptor+0x30>
     5d8:	82 30       	cpi	r24, 0x02	; 2
     5da:	79 f4       	brne	.+30     	; 0x5fa <CALLBACK_USB_GetDescriptor+0x4c>
     5dc:	08 c0       	rjmp	.+16     	; 0x5ee <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     5de:	e8 ee       	ldi	r30, 0xE8	; 232
     5e0:	f0 e0       	ldi	r31, 0x00	; 0
     5e2:	84 91       	lpm	r24, Z+
     5e4:	07 c0       	rjmp	.+14     	; 0x5f4 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     5e6:	ec ee       	ldi	r30, 0xEC	; 236
     5e8:	f0 e0       	ldi	r31, 0x00	; 0
     5ea:	84 91       	lpm	r24, Z+
     5ec:	03 c0       	rjmp	.+6      	; 0x5f4 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     5ee:	e6 e0       	ldi	r30, 0x06	; 6
     5f0:	f1 e0       	ldi	r31, 0x01	; 1
     5f2:	84 91       	lpm	r24, Z+
     5f4:	28 2f       	mov	r18, r24
     5f6:	30 e0       	ldi	r19, 0x00	; 0
     5f8:	04 c0       	rjmp	.+8      	; 0x602 <CALLBACK_USB_GetDescriptor+0x54>
     5fa:	e0 e0       	ldi	r30, 0x00	; 0
     5fc:	f0 e0       	ldi	r31, 0x00	; 0
     5fe:	20 e0       	ldi	r18, 0x00	; 0
     600:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     602:	ed 93       	st	X+, r30
     604:	fc 93       	st	X, r31
	return Size;
}
     606:	c9 01       	movw	r24, r18
     608:	08 95       	ret

0000060a <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     60e:	76 95       	lsr	r23
     610:	67 95       	ror	r22
     612:	ec 01       	movw	r28, r24
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	40 e0       	ldi	r20, 0x00	; 0
     61a:	50 e0       	ldi	r21, 0x00	; 0
     61c:	e0 e0       	ldi	r30, 0x00	; 0
     61e:	f0 e0       	ldi	r31, 0x00	; 0
     620:	09 c0       	rjmp	.+18     	; 0x634 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     622:	89 91       	ld	r24, Y+
     624:	99 91       	ld	r25, Y+
     626:	a0 e0       	ldi	r26, 0x00	; 0
     628:	b0 e0       	ldi	r27, 0x00	; 0
     62a:	28 0f       	add	r18, r24
     62c:	39 1f       	adc	r19, r25
     62e:	4a 1f       	adc	r20, r26
     630:	5b 1f       	adc	r21, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     632:	31 96       	adiw	r30, 0x01	; 1
     634:	e6 17       	cp	r30, r22
     636:	f7 07       	cpc	r31, r23
     638:	a0 f3       	brcs	.-24     	; 0x622 <Ethernet_Checksum16+0x18>
     63a:	0b c0       	rjmp	.+22     	; 0x652 <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     63c:	da 01       	movw	r26, r20
     63e:	c9 01       	movw	r24, r18
     640:	a0 70       	andi	r26, 0x00	; 0
     642:	b0 70       	andi	r27, 0x00	; 0
     644:	9a 01       	movw	r18, r20
     646:	44 27       	eor	r20, r20
     648:	55 27       	eor	r21, r21
     64a:	28 0f       	add	r18, r24
     64c:	39 1f       	adc	r19, r25
     64e:	4a 1f       	adc	r20, r26
     650:	5b 1f       	adc	r21, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     652:	da 01       	movw	r26, r20
     654:	c9 01       	movw	r24, r18
     656:	80 70       	andi	r24, 0x00	; 0
     658:	90 70       	andi	r25, 0x00	; 0
     65a:	00 97       	sbiw	r24, 0x00	; 0
     65c:	a1 05       	cpc	r26, r1
     65e:	b1 05       	cpc	r27, r1
     660:	69 f7       	brne	.-38     	; 0x63c <Ethernet_Checksum16+0x32>
     662:	20 95       	com	r18
     664:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     666:	c9 01       	movw	r24, r18
     668:	df 91       	pop	r29
     66a:	cf 91       	pop	r28
     66c:	08 95       	ret

0000066e <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     66e:	0f 93       	push	r16
     670:	1f 93       	push	r17
     672:	cf 93       	push	r28
     674:	df 93       	push	r29
     676:	ec 01       	movw	r28, r24
     678:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN->FrameData);
     67a:	6c d0       	rcall	.+216    	; 0x754 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     67c:	ce 01       	movw	r24, r28
     67e:	63 eb       	ldi	r22, 0xB3	; 179
     680:	71 e0       	ldi	r23, 0x01	; 1
     682:	46 e0       	ldi	r20, 0x06	; 6
     684:	50 e0       	ldi	r21, 0x00	; 0
     686:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
     68a:	00 97       	sbiw	r24, 0x00	; 0
     68c:	51 f0       	breq	.+20     	; 0x6a2 <Ethernet_ProcessPacket+0x34>
     68e:	ce 01       	movw	r24, r28
     690:	6d eb       	ldi	r22, 0xBD	; 189
     692:	71 e0       	ldi	r23, 0x01	; 1
     694:	46 e0       	ldi	r20, 0x06	; 6
     696:	50 e0       	ldi	r21, 0x00	; 0
     698:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
     69c:	00 97       	sbiw	r24, 0x00	; 0
     69e:	09 f0       	breq	.+2      	; 0x6a2 <Ethernet_ProcessPacket+0x34>
     6a0:	50 c0       	rjmp	.+160    	; 0x742 <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     6a2:	c4 52       	subi	r28, 0x24	; 36
     6a4:	da 4f       	sbci	r29, 0xFA	; 250
     6a6:	88 81       	ld	r24, Y
     6a8:	99 81       	ldd	r25, Y+1	; 0x01
     6aa:	cc 5d       	subi	r28, 0xDC	; 220
     6ac:	d5 40       	sbci	r29, 0x05	; 5

				Temp = Data.Bytes[0];
     6ae:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
     6b0:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
     6b2:	92 2f       	mov	r25, r18
     6b4:	81 50       	subi	r24, 0x01	; 1
     6b6:	96 40       	sbci	r25, 0x06	; 6
     6b8:	08 f4       	brcc	.+2      	; 0x6bc <Ethernet_ProcessPacket+0x4e>
     6ba:	43 c0       	rjmp	.+134    	; 0x742 <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     6bc:	2c 85       	ldd	r18, Y+12	; 0x0c
     6be:	3d 85       	ldd	r19, Y+13	; 0x0d

				Temp = Data.Bytes[0];
     6c0:	82 2f       	mov	r24, r18
				Data.Bytes[0] = Data.Bytes[1];
     6c2:	23 2f       	mov	r18, r19
				Data.Bytes[1] = Temp;
     6c4:	38 2f       	mov	r19, r24
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     6c6:	88 e0       	ldi	r24, 0x08	; 8
     6c8:	20 30       	cpi	r18, 0x00	; 0
     6ca:	38 07       	cpc	r19, r24
     6cc:	59 f0       	breq	.+22     	; 0x6e4 <Ethernet_ProcessPacket+0x76>
     6ce:	26 50       	subi	r18, 0x06	; 6
     6d0:	38 40       	sbci	r19, 0x08	; 8
     6d2:	b9 f5       	brne	.+110    	; 0x742 <Ethernet_ProcessPacket+0xd4>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     6d4:	b8 01       	movw	r22, r16
     6d6:	62 5f       	subi	r22, 0xF2	; 242
     6d8:	7f 4f       	sbci	r23, 0xFF	; 255
     6da:	ce 01       	movw	r24, r28
     6dc:	0e 96       	adiw	r24, 0x0e	; 14
     6de:	0e 94 07 0c 	call	0x180e	; 0x180e <ARP_ProcessARPPacket>
     6e2:	09 c0       	rjmp	.+18     	; 0x6f6 <Ethernet_ProcessPacket+0x88>
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     6e4:	be 01       	movw	r22, r28
     6e6:	62 5f       	subi	r22, 0xF2	; 242
     6e8:	7f 4f       	sbci	r23, 0xFF	; 255
     6ea:	a8 01       	movw	r20, r16
     6ec:	42 5f       	subi	r20, 0xF2	; 242
     6ee:	5f 4f       	sbci	r21, 0xFF	; 255
     6f0:	ce 01       	movw	r24, r28
     6f2:	0e 94 86 0c 	call	0x190c	; 0x190c <IP_ProcessIPPacket>
     6f6:	9c 01       	movw	r18, r24
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     6f8:	18 16       	cp	r1, r24
     6fa:	19 06       	cpc	r1, r25
     6fc:	f4 f4       	brge	.+60     	; 0x73a <Ethernet_ProcessPacket+0xcc>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     6fe:	d8 01       	movw	r26, r16
     700:	16 96       	adiw	r26, 0x06	; 6
     702:	e3 eb       	ldi	r30, 0xB3	; 179
     704:	f1 e0       	ldi	r31, 0x01	; 1
     706:	86 e0       	ldi	r24, 0x06	; 6
     708:	01 90       	ld	r0, Z+
     70a:	0d 92       	st	X+, r0
     70c:	81 50       	subi	r24, 0x01	; 1
     70e:	e1 f7       	brne	.-8      	; 0x708 <Ethernet_ProcessPacket+0x9a>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     710:	d8 01       	movw	r26, r16
     712:	fe 01       	movw	r30, r28
     714:	36 96       	adiw	r30, 0x06	; 6
     716:	86 e0       	ldi	r24, 0x06	; 6
     718:	01 90       	ld	r0, Z+
     71a:	0d 92       	st	X+, r0
     71c:	81 50       	subi	r24, 0x01	; 1
     71e:	e1 f7       	brne	.-8      	; 0x718 <Ethernet_ProcessPacket+0xaa>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     720:	8c 85       	ldd	r24, Y+12	; 0x0c
     722:	9d 85       	ldd	r25, Y+13	; 0x0d
     724:	f8 01       	movw	r30, r16
     726:	95 87       	std	Z+13, r25	; 0x0d
     728:	84 87       	std	Z+12, r24	; 0x0c

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     72a:	04 52       	subi	r16, 0x24	; 36
     72c:	1a 4f       	sbci	r17, 0xFA	; 250
     72e:	22 5f       	subi	r18, 0xF2	; 242
     730:	3f 4f       	sbci	r19, 0xFF	; 255
     732:	f8 01       	movw	r30, r16
     734:	31 83       	std	Z+1, r19	; 0x01
     736:	20 83       	st	Z, r18
     738:	04 c0       	rjmp	.+8      	; 0x742 <Ethernet_ProcessPacket+0xd4>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     73a:	ff ef       	ldi	r31, 0xFF	; 255
     73c:	8f 3f       	cpi	r24, 0xFF	; 255
     73e:	9f 07       	cpc	r25, r31
     740:	21 f0       	breq	.+8      	; 0x74a <Ethernet_ProcessPacket+0xdc>
	{
		/* Clear the frame buffer */
		FrameIN->FrameLength = 0;
     742:	c4 52       	subi	r28, 0x24	; 36
     744:	da 4f       	sbci	r29, 0xFA	; 250
     746:	19 82       	std	Y+1, r1	; 0x01
     748:	18 82       	st	Y, r1
	}
}
     74a:	df 91       	pop	r29
     74c:	cf 91       	pop	r28
     74e:	1f 91       	pop	r17
     750:	0f 91       	pop	r16
     752:	08 95       	ret

00000754 <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     754:	08 95       	ret

00000756 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     756:	08 95       	ret

00000758 <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     758:	08 95       	ret

0000075a <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     75a:	08 95       	ret

0000075c <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     75c:	08 95       	ret

0000075e <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     75e:	08 95       	ret

00000760 <DecodeDHCPHeader>:

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}

	#endif
}
     760:	08 95       	ret

00000762 <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     762:	ef 92       	push	r14
     764:	ff 92       	push	r15
     766:	0f 93       	push	r16
     768:	1f 93       	push	r17
     76a:	cf 93       	push	r28
     76c:	df 93       	push	r29
     76e:	7c 01       	movw	r14, r24
     770:	8b 01       	movw	r16, r22
     772:	ea 01       	movw	r28, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     774:	cb 01       	movw	r24, r22
     776:	f1 df       	rcall	.-30     	; 0x75a <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     778:	f8 01       	movw	r30, r16
     77a:	80 81       	ld	r24, Z
     77c:	88 30       	cpi	r24, 0x08	; 8
     77e:	19 f0       	breq	.+6      	; 0x786 <ICMP_ProcessICMPPacket+0x24>
     780:	20 e0       	ldi	r18, 0x00	; 0
     782:	30 e0       	ldi	r19, 0x00	; 0
     784:	2b c0       	rjmp	.+86     	; 0x7dc <ICMP_ProcessICMPPacket+0x7a>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     786:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     788:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     78a:	1b 82       	std	Y+3, r1	; 0x03
     78c:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     78e:	f8 01       	movw	r30, r16
     790:	84 81       	ldd	r24, Z+4	; 0x04
     792:	95 81       	ldd	r25, Z+5	; 0x05
     794:	9d 83       	std	Y+5, r25	; 0x05
     796:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     798:	86 81       	ldd	r24, Z+6	; 0x06
     79a:	97 81       	ldd	r25, Z+7	; 0x07
     79c:	9f 83       	std	Y+7, r25	; 0x07
     79e:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     7a0:	b8 01       	movw	r22, r16
     7a2:	68 5f       	subi	r22, 0xF8	; 248
     7a4:	7f 4f       	sbci	r23, 0xFF	; 255
     7a6:	8c ed       	ldi	r24, 0xDC	; 220
     7a8:	95 e0       	ldi	r25, 0x05	; 5
     7aa:	e8 0e       	add	r14, r24
     7ac:	f9 1e       	adc	r15, r25
     7ae:	f7 01       	movw	r30, r14
     7b0:	80 81       	ld	r24, Z
     7b2:	91 81       	ldd	r25, Z+1	; 0x01
     7b4:	87 01       	movw	r16, r14
     7b6:	0c 5d       	subi	r16, 0xDC	; 220
     7b8:	15 40       	sbci	r17, 0x05	; 5
     7ba:	08 0f       	add	r16, r24
     7bc:	19 1f       	adc	r17, r25
     7be:	06 1b       	sub	r16, r22
     7c0:	17 0b       	sbc	r17, r23

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     7c2:	ce 01       	movw	r24, r28
     7c4:	08 96       	adiw	r24, 0x08	; 8
     7c6:	a8 01       	movw	r20, r16
     7c8:	0e 94 90 17 	call	0x2f20	; 0x2f20 <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     7cc:	08 5f       	subi	r16, 0xF8	; 248
     7ce:	1f 4f       	sbci	r17, 0xFF	; 255
     7d0:	ce 01       	movw	r24, r28
     7d2:	b8 01       	movw	r22, r16
     7d4:	1a df       	rcall	.-460    	; 0x60a <Ethernet_Checksum16>
     7d6:	9b 83       	std	Y+3, r25	; 0x03
     7d8:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     7da:	98 01       	movw	r18, r16
	}

	return NO_RESPONSE;
}
     7dc:	c9 01       	movw	r24, r18
     7de:	df 91       	pop	r29
     7e0:	cf 91       	pop	r28
     7e2:	1f 91       	pop	r17
     7e4:	0f 91       	pop	r16
     7e6:	ff 90       	pop	r15
     7e8:	ef 90       	pop	r14
     7ea:	08 95       	ret

000007ec <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     7ec:	10 92 f9 13 	sts	0x13F9, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     7f0:	8a e0       	ldi	r24, 0x0A	; 10
     7f2:	80 93 ca 0f 	sts	0x0FCA, r24
     7f6:	80 93 e0 11 	sts	0x11E0, r24
     7fa:	80 93 f6 13 	sts	0x13F6, r24
}
     7fe:	08 95       	ret

00000800 <TCP_SetPortState>:
 *  \return Boolean true if the port state was set, false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     800:	9c 01       	movw	r18, r24

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     802:	80 91 f7 13 	lds	r24, 0x13F7
     806:	90 91 f8 13 	lds	r25, 0x13F8
     80a:	82 17       	cp	r24, r18
     80c:	93 07       	cpc	r25, r19
     80e:	19 f4       	brne	.+6      	; 0x816 <TCP_SetPortState+0x16>
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	13 c0       	rjmp	.+38     	; 0x83c <TCP_SetPortState+0x3c>
     816:	80 91 fc 13 	lds	r24, 0x13FC
     81a:	90 91 fd 13 	lds	r25, 0x13FD
     81e:	82 17       	cp	r24, r18
     820:	93 07       	cpc	r25, r19
     822:	19 f4       	brne	.+6      	; 0x82a <TCP_SetPortState+0x2a>
     824:	81 e0       	ldi	r24, 0x01	; 1
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	09 c0       	rjmp	.+18     	; 0x83c <TCP_SetPortState+0x3c>
     82a:	80 91 01 14 	lds	r24, 0x1401
     82e:	90 91 02 14 	lds	r25, 0x1402
     832:	82 17       	cp	r24, r18
     834:	93 07       	cpc	r25, r19
     836:	79 f4       	brne	.+30     	; 0x856 <TCP_SetPortState+0x56>
     838:	82 e0       	ldi	r24, 0x02	; 2
     83a:	90 e0       	ldi	r25, 0x00	; 0
		{
			PortStateTable[PTableEntry].State = State;
     83c:	fc 01       	movw	r30, r24
     83e:	ee 0f       	add	r30, r30
     840:	ff 1f       	adc	r31, r31
     842:	ee 0f       	add	r30, r30
     844:	ff 1f       	adc	r31, r31
     846:	e8 0f       	add	r30, r24
     848:	f9 1f       	adc	r31, r25
     84a:	e9 50       	subi	r30, 0x09	; 9
     84c:	fc 4e       	sbci	r31, 0xEC	; 236
     84e:	62 83       	std	Z+2, r22	; 0x02
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     850:	54 83       	std	Z+4, r21	; 0x04
     852:	43 83       	std	Z+3, r20	; 0x03
     854:	02 c0       	rjmp	.+4      	; 0x85a <TCP_SetPortState+0x5a>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     856:	61 30       	cpi	r22, 0x01	; 1
     858:	11 f0       	breq	.+4      	; 0x85e <TCP_SetPortState+0x5e>
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	08 95       	ret
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     85e:	80 91 f9 13 	lds	r24, 0x13F9
     862:	88 23       	and	r24, r24
     864:	19 f4       	brne	.+6      	; 0x86c <TCP_SetPortState+0x6c>
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	0f c0       	rjmp	.+30     	; 0x88a <TCP_SetPortState+0x8a>
     86c:	80 91 fe 13 	lds	r24, 0x13FE
     870:	88 23       	and	r24, r24
     872:	19 f4       	brne	.+6      	; 0x87a <TCP_SetPortState+0x7a>
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	08 c0       	rjmp	.+16     	; 0x88a <TCP_SetPortState+0x8a>
     87a:	80 91 03 14 	lds	r24, 0x1403
     87e:	88 23       	and	r24, r24
     880:	11 f0       	breq	.+4      	; 0x886 <TCP_SetPortState+0x86>
     882:	80 e0       	ldi	r24, 0x00	; 0
     884:	08 95       	ret
     886:	82 e0       	ldi	r24, 0x02	; 2
     888:	90 e0       	ldi	r25, 0x00	; 0
			{
				PortStateTable[PTableEntry].Port  = Port;
     88a:	fc 01       	movw	r30, r24
     88c:	ee 0f       	add	r30, r30
     88e:	ff 1f       	adc	r31, r31
     890:	ee 0f       	add	r30, r30
     892:	ff 1f       	adc	r31, r31
     894:	e8 0f       	add	r30, r24
     896:	f9 1f       	adc	r31, r25
     898:	e9 50       	subi	r30, 0x09	; 9
     89a:	fc 4e       	sbci	r31, 0xEC	; 236
     89c:	31 83       	std	Z+1, r19	; 0x01
     89e:	20 83       	st	Z, r18
				PortStateTable[PTableEntry].State = State;
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	82 83       	std	Z+2, r24	; 0x02
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     8a4:	54 83       	std	Z+4, r21	; 0x04
     8a6:	43 83       	std	Z+3, r20	; 0x03
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     8a8:	08 95       	ret

000008aa <TCP_GetPortState>:
 *  \param[in] Port  TCP port whose state is to be retrieved, given in big-endian
 *
 *  \return A value from the \ref TCP_PortStates_t enum
 */
uint8_t TCP_GetPortState(const uint16_t Port)
{
     8aa:	9c 01       	movw	r18, r24
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_TCP_CONNECTIONS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     8ac:	80 91 f7 13 	lds	r24, 0x13F7
     8b0:	90 91 f8 13 	lds	r25, 0x13F8
     8b4:	82 17       	cp	r24, r18
     8b6:	93 07       	cpc	r25, r19
     8b8:	19 f4       	brne	.+6      	; 0x8c0 <TCP_GetPortState+0x16>
     8ba:	80 e0       	ldi	r24, 0x00	; 0
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	15 c0       	rjmp	.+42     	; 0x8ea <TCP_GetPortState+0x40>
     8c0:	80 91 fc 13 	lds	r24, 0x13FC
     8c4:	90 91 fd 13 	lds	r25, 0x13FD
     8c8:	82 17       	cp	r24, r18
     8ca:	93 07       	cpc	r25, r19
     8cc:	19 f4       	brne	.+6      	; 0x8d4 <TCP_GetPortState+0x2a>
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	0b c0       	rjmp	.+22     	; 0x8ea <TCP_GetPortState+0x40>
     8d4:	80 91 01 14 	lds	r24, 0x1401
     8d8:	90 91 02 14 	lds	r25, 0x1402
     8dc:	82 17       	cp	r24, r18
     8de:	93 07       	cpc	r25, r19
     8e0:	11 f0       	breq	.+4      	; 0x8e6 <TCP_GetPortState+0x3c>
     8e2:	80 e0       	ldi	r24, 0x00	; 0
     8e4:	08 95       	ret
     8e6:	82 e0       	ldi	r24, 0x02	; 2
     8e8:	90 e0       	ldi	r25, 0x00	; 0
		  return PortStateTable[PTableEntry].State;
     8ea:	fc 01       	movw	r30, r24
     8ec:	ee 0f       	add	r30, r30
     8ee:	ff 1f       	adc	r31, r31
     8f0:	ee 0f       	add	r30, r30
     8f2:	ff 1f       	adc	r31, r31
     8f4:	e8 0f       	add	r30, r24
     8f6:	f9 1f       	adc	r31, r25
     8f8:	e9 50       	subi	r30, 0x09	; 9
     8fa:	fc 4e       	sbci	r31, 0xEC	; 236
     8fc:	82 81       	ldd	r24, Z+2	; 0x02
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
}
     8fe:	08 95       	ret

00000900 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               const uint16_t TCPOutSize)
{
     900:	2f 92       	push	r2
     902:	3f 92       	push	r3
     904:	4f 92       	push	r4
     906:	5f 92       	push	r5
     908:	6f 92       	push	r6
     90a:	7f 92       	push	r7
     90c:	8f 92       	push	r8
     90e:	9f 92       	push	r9
     910:	af 92       	push	r10
     912:	bf 92       	push	r11
     914:	cf 92       	push	r12
     916:	df 92       	push	r13
     918:	ef 92       	push	r14
     91a:	ff 92       	push	r15
     91c:	0f 93       	push	r16
     91e:	1f 93       	push	r17
     920:	df 93       	push	r29
     922:	cf 93       	push	r28
     924:	cd b7       	in	r28, 0x3d	; 61
     926:	de b7       	in	r29, 0x3e	; 62
     928:	2a 97       	sbiw	r28, 0x0a	; 10
     92a:	0f b6       	in	r0, 0x3f	; 63
     92c:	f8 94       	cli
     92e:	de bf       	out	0x3e, r29	; 62
     930:	0f be       	out	0x3f, r0	; 63
     932:	cd bf       	out	0x3d, r28	; 61
     934:	9a 87       	std	Y+10, r25	; 0x0a
     936:	89 87       	std	Y+9, r24	; 0x09
     938:	3a 01       	movw	r6, r20
     93a:	49 83       	std	Y+1, r20	; 0x01
     93c:	5a 83       	std	Y+2, r21	; 0x02
     93e:	6b 83       	std	Y+3, r22	; 0x03
     940:	7c 83       	std	Y+4, r23	; 0x04
     942:	58 01       	movw	r10, r16
     944:	0d 83       	std	Y+5, r16	; 0x05
     946:	1e 83       	std	Y+6, r17	; 0x06
     948:	2f 83       	std	Y+7, r18	; 0x07
     94a:	38 87       	std	Y+8, r19	; 0x08
     94c:	b7 01       	movw	r22, r14
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
     94e:	88 24       	eor	r8, r8
     950:	99 24       	eor	r9, r9
	Checksum += ((uint16_t*)&SourceAddress)[1];
     952:	eb 80       	ldd	r14, Y+3	; 0x03
     954:	fc 80       	ldd	r15, Y+4	; 0x04
     956:	00 e0       	ldi	r16, 0x00	; 0
     958:	10 e0       	ldi	r17, 0x00	; 0
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     95a:	cc 24       	eor	r12, r12
     95c:	dd 24       	eor	r13, r13
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     95e:	2f 81       	ldd	r18, Y+7	; 0x07
     960:	38 85       	ldd	r19, Y+8	; 0x08
     962:	40 e0       	ldi	r20, 0x00	; 0
     964:	50 e0       	ldi	r21, 0x00	; 0
				} Data;

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
     966:	87 2f       	mov	r24, r23
				Data.Bytes[1] = Temp;
     968:	96 2f       	mov	r25, r22

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     96a:	1c 01       	movw	r2, r24
     96c:	44 24       	eor	r4, r4
     96e:	55 24       	eor	r5, r5
     970:	80 e0       	ldi	r24, 0x00	; 0
     972:	96 e0       	ldi	r25, 0x06	; 6
     974:	a0 e0       	ldi	r26, 0x00	; 0
     976:	b0 e0       	ldi	r27, 0x00	; 0
     978:	28 0e       	add	r2, r24
     97a:	39 1e       	adc	r3, r25
     97c:	4a 1e       	adc	r4, r26
     97e:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     980:	26 0c       	add	r2, r6
     982:	37 1c       	adc	r3, r7
     984:	48 1c       	adc	r4, r8
     986:	59 1c       	adc	r5, r9
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     988:	2a 0c       	add	r2, r10
     98a:	3b 1c       	adc	r3, r11
     98c:	4c 1c       	adc	r4, r12
     98e:	5d 1c       	adc	r5, r13
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     990:	2e 0c       	add	r2, r14
     992:	3f 1c       	adc	r3, r15
     994:	40 1e       	adc	r4, r16
     996:	51 1e       	adc	r5, r17
	Checksum += SwapEndian_16(TCPOutSize);
     998:	22 0e       	add	r2, r18
     99a:	33 1e       	adc	r3, r19
     99c:	44 1e       	adc	r4, r20
     99e:	55 1e       	adc	r5, r21

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     9a0:	fb 01       	movw	r30, r22
     9a2:	f6 95       	lsr	r31
     9a4:	e7 95       	ror	r30
     9a6:	49 85       	ldd	r20, Y+9	; 0x09
     9a8:	5a 85       	ldd	r21, Y+10	; 0x0a
     9aa:	20 e0       	ldi	r18, 0x00	; 0
     9ac:	30 e0       	ldi	r19, 0x00	; 0
     9ae:	0c c0       	rjmp	.+24     	; 0x9c8 <TCP_Checksum16+0xc8>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     9b0:	da 01       	movw	r26, r20
     9b2:	8d 91       	ld	r24, X+
     9b4:	9d 91       	ld	r25, X+
     9b6:	ad 01       	movw	r20, r26
     9b8:	a0 e0       	ldi	r26, 0x00	; 0
     9ba:	b0 e0       	ldi	r27, 0x00	; 0
     9bc:	28 0e       	add	r2, r24
     9be:	39 1e       	adc	r3, r25
     9c0:	4a 1e       	adc	r4, r26
     9c2:	5b 1e       	adc	r5, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     9c4:	2f 5f       	subi	r18, 0xFF	; 255
     9c6:	3f 4f       	sbci	r19, 0xFF	; 255
     9c8:	2e 17       	cp	r18, r30
     9ca:	3f 07       	cpc	r19, r31
     9cc:	88 f3       	brcs	.-30     	; 0x9b0 <TCP_Checksum16+0xb0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     9ce:	60 ff       	sbrs	r22, 0
     9d0:	17 c0       	rjmp	.+46     	; 0xa00 <TCP_Checksum16+0x100>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     9d2:	ee 0f       	add	r30, r30
     9d4:	ff 1f       	adc	r31, r31
     9d6:	89 85       	ldd	r24, Y+9	; 0x09
     9d8:	9a 85       	ldd	r25, Y+10	; 0x0a
     9da:	e8 0f       	add	r30, r24
     9dc:	f9 1f       	adc	r31, r25
     9de:	80 81       	ld	r24, Z
     9e0:	28 0e       	add	r2, r24
     9e2:	31 1c       	adc	r3, r1
     9e4:	41 1c       	adc	r4, r1
     9e6:	51 1c       	adc	r5, r1
     9e8:	0b c0       	rjmp	.+22     	; 0xa00 <TCP_Checksum16+0x100>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     9ea:	d2 01       	movw	r26, r4
     9ec:	c1 01       	movw	r24, r2
     9ee:	a0 70       	andi	r26, 0x00	; 0
     9f0:	b0 70       	andi	r27, 0x00	; 0
     9f2:	12 01       	movw	r2, r4
     9f4:	44 24       	eor	r4, r4
     9f6:	55 24       	eor	r5, r5
     9f8:	28 0e       	add	r2, r24
     9fa:	39 1e       	adc	r3, r25
     9fc:	4a 1e       	adc	r4, r26
     9fe:	5b 1e       	adc	r5, r27
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     a00:	d2 01       	movw	r26, r4
     a02:	c1 01       	movw	r24, r2
     a04:	80 70       	andi	r24, 0x00	; 0
     a06:	90 70       	andi	r25, 0x00	; 0
     a08:	00 97       	sbiw	r24, 0x00	; 0
     a0a:	a1 05       	cpc	r26, r1
     a0c:	b1 05       	cpc	r27, r1
     a0e:	69 f7       	brne	.-38     	; 0x9ea <TCP_Checksum16+0xea>
     a10:	91 01       	movw	r18, r2
     a12:	20 95       	com	r18
     a14:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     a16:	c9 01       	movw	r24, r18
     a18:	2a 96       	adiw	r28, 0x0a	; 10
     a1a:	0f b6       	in	r0, 0x3f	; 63
     a1c:	f8 94       	cli
     a1e:	de bf       	out	0x3e, r29	; 62
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	cd bf       	out	0x3d, r28	; 61
     a24:	cf 91       	pop	r28
     a26:	df 91       	pop	r29
     a28:	1f 91       	pop	r17
     a2a:	0f 91       	pop	r16
     a2c:	ff 90       	pop	r15
     a2e:	ef 90       	pop	r14
     a30:	df 90       	pop	r13
     a32:	cf 90       	pop	r12
     a34:	bf 90       	pop	r11
     a36:	af 90       	pop	r10
     a38:	9f 90       	pop	r9
     a3a:	8f 90       	pop	r8
     a3c:	7f 90       	pop	r7
     a3e:	6f 90       	pop	r6
     a40:	5f 90       	pop	r5
     a42:	4f 90       	pop	r4
     a44:	3f 90       	pop	r3
     a46:	2f 90       	pop	r2
     a48:	08 95       	ret

00000a4a <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     a4a:	4f 92       	push	r4
     a4c:	5f 92       	push	r5
     a4e:	6f 92       	push	r6
     a50:	7f 92       	push	r7
     a52:	8f 92       	push	r8
     a54:	9f 92       	push	r9
     a56:	af 92       	push	r10
     a58:	bf 92       	push	r11
     a5a:	cf 92       	push	r12
     a5c:	df 92       	push	r13
     a5e:	ef 92       	push	r14
     a60:	ff 92       	push	r15
     a62:	0f 93       	push	r16
     a64:	1f 93       	push	r17
     a66:	df 93       	push	r29
     a68:	cf 93       	push	r28
     a6a:	00 d0       	rcall	.+0      	; 0xa6c <TCP_GetConnectionInfo+0x22>
     a6c:	00 d0       	rcall	.+0      	; 0xa6e <TCP_GetConnectionInfo+0x24>
     a6e:	cd b7       	in	r28, 0x3d	; 61
     a70:	de b7       	in	r29, 0x3e	; 62
     a72:	4c 01       	movw	r8, r24
     a74:	49 83       	std	Y+1, r20	; 0x01
     a76:	5a 83       	std	Y+2, r21	; 0x02
     a78:	6b 83       	std	Y+3, r22	; 0x03
     a7a:	7c 83       	std	Y+4, r23	; 0x04
     a7c:	59 01       	movw	r10, r18
     a7e:	25 eb       	ldi	r18, 0xB5	; 181
     a80:	e2 2e       	mov	r14, r18
     a82:	2d e0       	ldi	r18, 0x0D	; 13
     a84:	f2 2e       	mov	r15, r18
     a86:	00 e0       	ldi	r16, 0x00	; 0
     a88:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     a8a:	96 e1       	ldi	r25, 0x16	; 22
     a8c:	49 2e       	mov	r4, r25
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	59 2e       	mov	r5, r25
     a92:	3e 01       	movw	r6, r28
     a94:	08 94       	sec
     a96:	61 1c       	adc	r6, r1
     a98:	71 1c       	adc	r7, r1
     a9a:	f7 01       	movw	r30, r14
     a9c:	80 81       	ld	r24, Z
     a9e:	91 81       	ldd	r25, Z+1	; 0x01
     aa0:	88 15       	cp	r24, r8
     aa2:	99 05       	cpc	r25, r9
     aa4:	d9 f4       	brne	.+54     	; 0xadc <TCP_GetConnectionInfo+0x92>
     aa6:	04 9d       	mul	r16, r4
     aa8:	60 01       	movw	r12, r0
     aaa:	05 9d       	mul	r16, r5
     aac:	d0 0c       	add	r13, r0
     aae:	14 9d       	mul	r17, r4
     ab0:	d0 0c       	add	r13, r0
     ab2:	11 24       	eor	r1, r1
     ab4:	c6 01       	movw	r24, r12
     ab6:	87 54       	subi	r24, 0x47	; 71
     ab8:	92 4f       	sbci	r25, 0xF2	; 242
     aba:	b3 01       	movw	r22, r6
     abc:	44 e0       	ldi	r20, 0x04	; 4
     abe:	50 e0       	ldi	r21, 0x00	; 0
     ac0:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
     ac4:	00 97       	sbiw	r24, 0x00	; 0
     ac6:	51 f4       	brne	.+20     	; 0xadc <TCP_GetConnectionInfo+0x92>
     ac8:	f7 01       	movw	r30, r14
     aca:	82 81       	ldd	r24, Z+2	; 0x02
     acc:	93 81       	ldd	r25, Z+3	; 0x03
     ace:	8a 15       	cp	r24, r10
     ad0:	9b 05       	cpc	r25, r11
     ad2:	21 f4       	brne	.+8      	; 0xadc <TCP_GetConnectionInfo+0x92>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     ad4:	96 01       	movw	r18, r12
     ad6:	23 54       	subi	r18, 0x43	; 67
     ad8:	32 4f       	sbci	r19, 0xF2	; 242
     ada:	0b c0       	rjmp	.+22     	; 0xaf2 <TCP_GetConnectionInfo+0xa8>
     adc:	0f 5f       	subi	r16, 0xFF	; 255
     ade:	1f 4f       	sbci	r17, 0xFF	; 255
     ae0:	86 e1       	ldi	r24, 0x16	; 22
     ae2:	92 e0       	ldi	r25, 0x02	; 2
     ae4:	e8 0e       	add	r14, r24
     ae6:	f9 1e       	adc	r15, r25
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     ae8:	03 30       	cpi	r16, 0x03	; 3
     aea:	11 05       	cpc	r17, r1
     aec:	b1 f6       	brne	.-84     	; 0xa9a <TCP_GetConnectionInfo+0x50>
     aee:	20 e0       	ldi	r18, 0x00	; 0
     af0:	30 e0       	ldi	r19, 0x00	; 0
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
}
     af2:	c9 01       	movw	r24, r18
     af4:	0f 90       	pop	r0
     af6:	0f 90       	pop	r0
     af8:	0f 90       	pop	r0
     afa:	0f 90       	pop	r0
     afc:	cf 91       	pop	r28
     afe:	df 91       	pop	r29
     b00:	1f 91       	pop	r17
     b02:	0f 91       	pop	r16
     b04:	ff 90       	pop	r15
     b06:	ef 90       	pop	r14
     b08:	df 90       	pop	r13
     b0a:	cf 90       	pop	r12
     b0c:	bf 90       	pop	r11
     b0e:	af 90       	pop	r10
     b10:	9f 90       	pop	r9
     b12:	8f 90       	pop	r8
     b14:	7f 90       	pop	r7
     b16:	6f 90       	pop	r6
     b18:	5f 90       	pop	r5
     b1a:	4f 90       	pop	r4
     b1c:	08 95       	ret

00000b1e <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     b1e:	4f 92       	push	r4
     b20:	5f 92       	push	r5
     b22:	6f 92       	push	r6
     b24:	7f 92       	push	r7
     b26:	8f 92       	push	r8
     b28:	9f 92       	push	r9
     b2a:	af 92       	push	r10
     b2c:	bf 92       	push	r11
     b2e:	cf 92       	push	r12
     b30:	df 92       	push	r13
     b32:	ef 92       	push	r14
     b34:	ff 92       	push	r15
     b36:	0f 93       	push	r16
     b38:	1f 93       	push	r17
     b3a:	df 93       	push	r29
     b3c:	cf 93       	push	r28
     b3e:	00 d0       	rcall	.+0      	; 0xb40 <TCP_GetConnectionState+0x22>
     b40:	00 d0       	rcall	.+0      	; 0xb42 <TCP_GetConnectionState+0x24>
     b42:	cd b7       	in	r28, 0x3d	; 61
     b44:	de b7       	in	r29, 0x3e	; 62
     b46:	4c 01       	movw	r8, r24
     b48:	49 83       	std	Y+1, r20	; 0x01
     b4a:	5a 83       	std	Y+2, r21	; 0x02
     b4c:	6b 83       	std	Y+3, r22	; 0x03
     b4e:	7c 83       	std	Y+4, r23	; 0x04
     b50:	59 01       	movw	r10, r18
     b52:	45 eb       	ldi	r20, 0xB5	; 181
     b54:	e4 2e       	mov	r14, r20
     b56:	4d e0       	ldi	r20, 0x0D	; 13
     b58:	f4 2e       	mov	r15, r20
     b5a:	00 e0       	ldi	r16, 0x00	; 0
     b5c:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     b5e:	36 e1       	ldi	r19, 0x16	; 22
     b60:	43 2e       	mov	r4, r19
     b62:	32 e0       	ldi	r19, 0x02	; 2
     b64:	53 2e       	mov	r5, r19
     b66:	3e 01       	movw	r6, r28
     b68:	08 94       	sec
     b6a:	61 1c       	adc	r6, r1
     b6c:	71 1c       	adc	r7, r1
     b6e:	f7 01       	movw	r30, r14
     b70:	80 81       	ld	r24, Z
     b72:	91 81       	ldd	r25, Z+1	; 0x01
     b74:	88 15       	cp	r24, r8
     b76:	99 05       	cpc	r25, r9
     b78:	e1 f4       	brne	.+56     	; 0xbb2 <TCP_GetConnectionState+0x94>
     b7a:	04 9d       	mul	r16, r4
     b7c:	60 01       	movw	r12, r0
     b7e:	05 9d       	mul	r16, r5
     b80:	d0 0c       	add	r13, r0
     b82:	14 9d       	mul	r17, r4
     b84:	d0 0c       	add	r13, r0
     b86:	11 24       	eor	r1, r1
     b88:	c6 01       	movw	r24, r12
     b8a:	87 54       	subi	r24, 0x47	; 71
     b8c:	92 4f       	sbci	r25, 0xF2	; 242
     b8e:	b3 01       	movw	r22, r6
     b90:	44 e0       	ldi	r20, 0x04	; 4
     b92:	50 e0       	ldi	r21, 0x00	; 0
     b94:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
     b98:	00 97       	sbiw	r24, 0x00	; 0
     b9a:	59 f4       	brne	.+22     	; 0xbb2 <TCP_GetConnectionState+0x94>
     b9c:	f7 01       	movw	r30, r14
     b9e:	82 81       	ldd	r24, Z+2	; 0x02
     ba0:	93 81       	ldd	r25, Z+3	; 0x03
     ba2:	8a 15       	cp	r24, r10
     ba4:	9b 05       	cpc	r25, r11
     ba6:	29 f4       	brne	.+10     	; 0xbb2 <TCP_GetConnectionState+0x94>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     ba8:	f6 01       	movw	r30, r12
     baa:	e6 53       	subi	r30, 0x36	; 54
     bac:	f0 4f       	sbci	r31, 0xF0	; 240
     bae:	80 81       	ld	r24, Z
     bb0:	0a c0       	rjmp	.+20     	; 0xbc6 <TCP_GetConnectionState+0xa8>
     bb2:	0f 5f       	subi	r16, 0xFF	; 255
     bb4:	1f 4f       	sbci	r17, 0xFF	; 255
     bb6:	86 e1       	ldi	r24, 0x16	; 22
     bb8:	92 e0       	ldi	r25, 0x02	; 2
     bba:	e8 0e       	add	r14, r24
     bbc:	f9 1e       	adc	r15, r25
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     bbe:	03 30       	cpi	r16, 0x03	; 3
     bc0:	11 05       	cpc	r17, r1
     bc2:	a9 f6       	brne	.-86     	; 0xb6e <TCP_GetConnectionState+0x50>
     bc4:	8a e0       	ldi	r24, 0x0A	; 10
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
}
     bc6:	0f 90       	pop	r0
     bc8:	0f 90       	pop	r0
     bca:	0f 90       	pop	r0
     bcc:	0f 90       	pop	r0
     bce:	cf 91       	pop	r28
     bd0:	df 91       	pop	r29
     bd2:	1f 91       	pop	r17
     bd4:	0f 91       	pop	r16
     bd6:	ff 90       	pop	r15
     bd8:	ef 90       	pop	r14
     bda:	df 90       	pop	r13
     bdc:	cf 90       	pop	r12
     bde:	bf 90       	pop	r11
     be0:	af 90       	pop	r10
     be2:	9f 90       	pop	r9
     be4:	8f 90       	pop	r8
     be6:	7f 90       	pop	r7
     be8:	6f 90       	pop	r6
     bea:	5f 90       	pop	r5
     bec:	4f 90       	pop	r4
     bee:	08 95       	ret

00000bf0 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     bf0:	3f 92       	push	r3
     bf2:	4f 92       	push	r4
     bf4:	5f 92       	push	r5
     bf6:	6f 92       	push	r6
     bf8:	7f 92       	push	r7
     bfa:	8f 92       	push	r8
     bfc:	9f 92       	push	r9
     bfe:	af 92       	push	r10
     c00:	bf 92       	push	r11
     c02:	cf 92       	push	r12
     c04:	df 92       	push	r13
     c06:	ef 92       	push	r14
     c08:	ff 92       	push	r15
     c0a:	0f 93       	push	r16
     c0c:	1f 93       	push	r17
     c0e:	df 93       	push	r29
     c10:	cf 93       	push	r28
     c12:	00 d0       	rcall	.+0      	; 0xc14 <TCP_SetConnectionState+0x24>
     c14:	00 d0       	rcall	.+0      	; 0xc16 <TCP_SetConnectionState+0x26>
     c16:	cd b7       	in	r28, 0x3d	; 61
     c18:	de b7       	in	r29, 0x3e	; 62
     c1a:	5c 01       	movw	r10, r24
     c1c:	49 83       	std	Y+1, r20	; 0x01
     c1e:	5a 83       	std	Y+2, r21	; 0x02
     c20:	6b 83       	std	Y+3, r22	; 0x03
     c22:	7c 83       	std	Y+4, r23	; 0x04
     c24:	49 01       	movw	r8, r18
     c26:	30 2e       	mov	r3, r16
     c28:	75 eb       	ldi	r23, 0xB5	; 181
     c2a:	e7 2e       	mov	r14, r23
     c2c:	7d e0       	ldi	r23, 0x0D	; 13
     c2e:	f7 2e       	mov	r15, r23
     c30:	00 e0       	ldi	r16, 0x00	; 0
     c32:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c34:	66 e1       	ldi	r22, 0x16	; 22
     c36:	46 2e       	mov	r4, r22
     c38:	62 e0       	ldi	r22, 0x02	; 2
     c3a:	56 2e       	mov	r5, r22
     c3c:	3e 01       	movw	r6, r28
     c3e:	08 94       	sec
     c40:	61 1c       	adc	r6, r1
     c42:	71 1c       	adc	r7, r1
     c44:	f7 01       	movw	r30, r14
     c46:	80 81       	ld	r24, Z
     c48:	91 81       	ldd	r25, Z+1	; 0x01
     c4a:	8a 15       	cp	r24, r10
     c4c:	9b 05       	cpc	r25, r11
     c4e:	d9 f4       	brne	.+54     	; 0xc86 <TCP_SetConnectionState+0x96>
     c50:	04 9d       	mul	r16, r4
     c52:	60 01       	movw	r12, r0
     c54:	05 9d       	mul	r16, r5
     c56:	d0 0c       	add	r13, r0
     c58:	14 9d       	mul	r17, r4
     c5a:	d0 0c       	add	r13, r0
     c5c:	11 24       	eor	r1, r1
     c5e:	c6 01       	movw	r24, r12
     c60:	87 54       	subi	r24, 0x47	; 71
     c62:	92 4f       	sbci	r25, 0xF2	; 242
     c64:	b3 01       	movw	r22, r6
     c66:	44 e0       	ldi	r20, 0x04	; 4
     c68:	50 e0       	ldi	r21, 0x00	; 0
     c6a:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
     c6e:	00 97       	sbiw	r24, 0x00	; 0
     c70:	51 f4       	brne	.+20     	; 0xc86 <TCP_SetConnectionState+0x96>
     c72:	f7 01       	movw	r30, r14
     c74:	82 81       	ldd	r24, Z+2	; 0x02
     c76:	93 81       	ldd	r25, Z+3	; 0x03
     c78:	88 15       	cp	r24, r8
     c7a:	99 05       	cpc	r25, r9
     c7c:	21 f4       	brne	.+8      	; 0xc86 <TCP_SetConnectionState+0x96>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     c7e:	f6 01       	movw	r30, r12
     c80:	e6 53       	subi	r30, 0x36	; 54
     c82:	f0 4f       	sbci	r31, 0xF0	; 240
     c84:	47 c0       	rjmp	.+142    	; 0xd14 <TCP_SetConnectionState+0x124>
			return true;
     c86:	0f 5f       	subi	r16, 0xFF	; 255
     c88:	1f 4f       	sbci	r17, 0xFF	; 255
     c8a:	86 e1       	ldi	r24, 0x16	; 22
     c8c:	92 e0       	ldi	r25, 0x02	; 2
     c8e:	e8 0e       	add	r14, r24
     c90:	f9 1e       	adc	r15, r25
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c92:	03 30       	cpi	r16, 0x03	; 3
     c94:	11 05       	cpc	r17, r1
     c96:	b1 f6       	brne	.-84     	; 0xc44 <TCP_SetConnectionState+0x54>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     c98:	80 91 ca 0f 	lds	r24, 0x0FCA
     c9c:	8a 30       	cpi	r24, 0x0A	; 10
     c9e:	19 f4       	brne	.+6      	; 0xca6 <TCP_SetConnectionState+0xb6>
     ca0:	40 e0       	ldi	r20, 0x00	; 0
     ca2:	50 e0       	ldi	r21, 0x00	; 0
     ca4:	0f c0       	rjmp	.+30     	; 0xcc4 <TCP_SetConnectionState+0xd4>
     ca6:	80 91 e0 11 	lds	r24, 0x11E0
     caa:	8a 30       	cpi	r24, 0x0A	; 10
     cac:	19 f4       	brne	.+6      	; 0xcb4 <TCP_SetConnectionState+0xc4>
     cae:	41 e0       	ldi	r20, 0x01	; 1
     cb0:	50 e0       	ldi	r21, 0x00	; 0
     cb2:	08 c0       	rjmp	.+16     	; 0xcc4 <TCP_SetConnectionState+0xd4>
     cb4:	80 91 f6 13 	lds	r24, 0x13F6
     cb8:	8a 30       	cpi	r24, 0x0A	; 10
     cba:	11 f0       	breq	.+4      	; 0xcc0 <TCP_SetConnectionState+0xd0>
     cbc:	80 e0       	ldi	r24, 0x00	; 0
     cbe:	2c c0       	rjmp	.+88     	; 0xd18 <TCP_SetConnectionState+0x128>
     cc0:	42 e0       	ldi	r20, 0x02	; 2
     cc2:	50 e0       	ldi	r21, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     cc4:	86 e1       	ldi	r24, 0x16	; 22
     cc6:	92 e0       	ldi	r25, 0x02	; 2
     cc8:	48 9f       	mul	r20, r24
     cca:	90 01       	movw	r18, r0
     ccc:	49 9f       	mul	r20, r25
     cce:	30 0d       	add	r19, r0
     cd0:	58 9f       	mul	r21, r24
     cd2:	30 0d       	add	r19, r0
     cd4:	11 24       	eor	r1, r1
     cd6:	2b 54       	subi	r18, 0x4B	; 75
     cd8:	32 4f       	sbci	r19, 0xF2	; 242
     cda:	f9 01       	movw	r30, r18
     cdc:	b1 82       	std	Z+1, r11	; 0x01
     cde:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     ce0:	89 81       	ldd	r24, Y+1	; 0x01
     ce2:	9a 81       	ldd	r25, Y+2	; 0x02
     ce4:	ab 81       	ldd	r26, Y+3	; 0x03
     ce6:	bc 81       	ldd	r27, Y+4	; 0x04
     ce8:	84 83       	std	Z+4, r24	; 0x04
     cea:	95 83       	std	Z+5, r25	; 0x05
     cec:	a6 83       	std	Z+6, r26	; 0x06
     cee:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     cf0:	8b e0       	ldi	r24, 0x0B	; 11
     cf2:	91 e0       	ldi	r25, 0x01	; 1
     cf4:	48 9f       	mul	r20, r24
     cf6:	f0 01       	movw	r30, r0
     cf8:	49 9f       	mul	r20, r25
     cfa:	f0 0d       	add	r31, r0
     cfc:	58 9f       	mul	r21, r24
     cfe:	f0 0d       	add	r31, r0
     d00:	11 24       	eor	r1, r1
     d02:	ee 0f       	add	r30, r30
     d04:	ff 1f       	adc	r31, r31
     d06:	e9 54       	subi	r30, 0x49	; 73
     d08:	f2 4f       	sbci	r31, 0xF2	; 242
     d0a:	91 82       	std	Z+1, r9	; 0x01
     d0c:	80 82       	st	Z, r8
			ConnectionStateTable[CSTableEntry].State         = State;
     d0e:	2b 5e       	subi	r18, 0xEB	; 235
     d10:	3d 4f       	sbci	r19, 0xFD	; 253
     d12:	f9 01       	movw	r30, r18
     d14:	30 82       	st	Z, r3
     d16:	81 e0       	ldi	r24, 0x01	; 1
			return true;
		}
	}

	return false;
}
     d18:	0f 90       	pop	r0
     d1a:	0f 90       	pop	r0
     d1c:	0f 90       	pop	r0
     d1e:	0f 90       	pop	r0
     d20:	cf 91       	pop	r28
     d22:	df 91       	pop	r29
     d24:	1f 91       	pop	r17
     d26:	0f 91       	pop	r16
     d28:	ff 90       	pop	r15
     d2a:	ef 90       	pop	r14
     d2c:	df 90       	pop	r13
     d2e:	cf 90       	pop	r12
     d30:	bf 90       	pop	r11
     d32:	af 90       	pop	r10
     d34:	9f 90       	pop	r9
     d36:	8f 90       	pop	r8
     d38:	7f 90       	pop	r7
     d3a:	6f 90       	pop	r6
     d3c:	5f 90       	pop	r5
     d3e:	4f 90       	pop	r4
     d40:	3f 90       	pop	r3
     d42:	08 95       	ret

00000d44 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     d44:	af 92       	push	r10
     d46:	bf 92       	push	r11
     d48:	cf 92       	push	r12
     d4a:	df 92       	push	r13
     d4c:	ef 92       	push	r14
     d4e:	ff 92       	push	r15
     d50:	0f 93       	push	r16
     d52:	1f 93       	push	r17
     d54:	cf 93       	push	r28
     d56:	df 93       	push	r29
     d58:	7b 01       	movw	r14, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     d5a:	5c 01       	movw	r10, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     d5c:	6a 01       	movw	r12, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     d5e:	cb 01       	movw	r24, r22
     d60:	fd dc       	rcall	.-1542   	; 0x75c <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     d62:	d7 01       	movw	r26, r14
     d64:	12 96       	adiw	r26, 0x02	; 2
     d66:	8d 91       	ld	r24, X+
     d68:	9c 91       	ld	r25, X
     d6a:	13 97       	sbiw	r26, 0x03	; 3
     d6c:	9e dd       	rcall	.-1220   	; 0x8aa <TCP_GetPortState>
     d6e:	81 30       	cpi	r24, 0x01	; 1
     d70:	09 f0       	breq	.+2      	; 0xd74 <TCP_ProcessTCPPacket+0x30>
     d72:	2a c2       	rjmp	.+1108   	; 0x11c8 <TCP_ProcessTCPPacket+0x484>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     d74:	e7 01       	movw	r28, r14
     d76:	8d 85       	ldd	r24, Y+13	; 0x0d
     d78:	81 ff       	sbrs	r24, 1
     d7a:	0b c0       	rjmp	.+22     	; 0xd92 <TCP_ProcessTCPPacket+0x4e>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     d7c:	f5 01       	movw	r30, r10
     d7e:	44 85       	ldd	r20, Z+12	; 0x0c
     d80:	55 85       	ldd	r21, Z+13	; 0x0d
     d82:	66 85       	ldd	r22, Z+14	; 0x0e
     d84:	77 85       	ldd	r23, Z+15	; 0x0f
     d86:	28 81       	ld	r18, Y
     d88:	39 81       	ldd	r19, Y+1	; 0x01
     d8a:	8a 81       	ldd	r24, Y+2	; 0x02
     d8c:	9b 81       	ldd	r25, Y+3	; 0x03
     d8e:	00 e0       	ldi	r16, 0x00	; 0
     d90:	2f df       	rcall	.-418    	; 0xbf0 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     d92:	d7 01       	movw	r26, r14
     d94:	1d 96       	adiw	r26, 0x0d	; 13
     d96:	8c 91       	ld	r24, X
     d98:	1d 97       	sbiw	r26, 0x0d	; 13
     d9a:	12 96       	adiw	r26, 0x02	; 2
     d9c:	ed 91       	ld	r30, X+
     d9e:	fc 91       	ld	r31, X
     da0:	13 97       	sbiw	r26, 0x03	; 3
     da2:	e5 01       	movw	r28, r10
     da4:	4c 85       	ldd	r20, Y+12	; 0x0c
     da6:	5d 85       	ldd	r21, Y+13	; 0x0d
     da8:	6e 85       	ldd	r22, Y+14	; 0x0e
     daa:	7f 85       	ldd	r23, Y+15	; 0x0f
     dac:	2d 91       	ld	r18, X+
     dae:	3c 91       	ld	r19, X
     db0:	82 ff       	sbrs	r24, 2
     db2:	08 c0       	rjmp	.+16     	; 0xdc4 <TCP_ProcessTCPPacket+0x80>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     db4:	cf 01       	movw	r24, r30
     db6:	0a e0       	ldi	r16, 0x0A	; 10
     db8:	1b df       	rcall	.-458    	; 0xbf0 <TCP_SetConnectionState>
     dba:	88 23       	and	r24, r24
     dbc:	09 f4       	brne	.+2      	; 0xdc0 <TCP_ProcessTCPPacket+0x7c>
     dbe:	38 c2       	rjmp	.+1136   	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
     dc0:	84 e1       	ldi	r24, 0x14	; 20
     dc2:	5d c0       	rjmp	.+186    	; 0xe7e <TCP_ProcessTCPPacket+0x13a>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     dc4:	cf 01       	movw	r24, r30
     dc6:	ab de       	rcall	.-682    	; 0xb1e <TCP_GetConnectionState>
     dc8:	84 30       	cpi	r24, 0x04	; 4
     dca:	09 f4       	brne	.+2      	; 0xdce <TCP_ProcessTCPPacket+0x8a>
     dcc:	68 c1       	rjmp	.+720    	; 0x109e <TCP_ProcessTCPPacket+0x35a>
     dce:	85 30       	cpi	r24, 0x05	; 5
     dd0:	48 f4       	brcc	.+18     	; 0xde4 <TCP_ProcessTCPPacket+0xa0>
     dd2:	82 30       	cpi	r24, 0x02	; 2
     dd4:	09 f4       	brne	.+2      	; 0xdd8 <TCP_ProcessTCPPacket+0x94>
     dd6:	56 c0       	rjmp	.+172    	; 0xe84 <TCP_ProcessTCPPacket+0x140>
     dd8:	83 30       	cpi	r24, 0x03	; 3
     dda:	08 f0       	brcs	.+2      	; 0xdde <TCP_ProcessTCPPacket+0x9a>
     ddc:	7f c0       	rjmp	.+254    	; 0xedc <TCP_ProcessTCPPacket+0x198>
     dde:	88 23       	and	r24, r24
     de0:	59 f0       	breq	.+22     	; 0xdf8 <TCP_ProcessTCPPacket+0xb4>
     de2:	26 c2       	rjmp	.+1100   	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
     de4:	86 30       	cpi	r24, 0x06	; 6
     de6:	09 f4       	brne	.+2      	; 0xdea <TCP_ProcessTCPPacket+0xa6>
     de8:	dc c1       	rjmp	.+952    	; 0x11a2 <TCP_ProcessTCPPacket+0x45e>
     dea:	86 30       	cpi	r24, 0x06	; 6
     dec:	08 f4       	brcc	.+2      	; 0xdf0 <TCP_ProcessTCPPacket+0xac>
     dee:	9e c1       	rjmp	.+828    	; 0x112c <TCP_ProcessTCPPacket+0x3e8>
     df0:	87 30       	cpi	r24, 0x07	; 7
     df2:	09 f0       	breq	.+2      	; 0xdf6 <TCP_ProcessTCPPacket+0xb2>
     df4:	1d c2       	rjmp	.+1082   	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
     df6:	35 c1       	rjmp	.+618    	; 0x1062 <TCP_ProcessTCPPacket+0x31e>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     df8:	d7 01       	movw	r26, r14
     dfa:	1d 96       	adiw	r26, 0x0d	; 13
     dfc:	8c 91       	ld	r24, X
     dfe:	1d 97       	sbiw	r26, 0x0d	; 13
     e00:	82 30       	cpi	r24, 0x02	; 2
     e02:	09 f0       	breq	.+2      	; 0xe06 <TCP_ProcessTCPPacket+0xc2>
     e04:	15 c2       	rjmp	.+1066   	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e06:	e5 01       	movw	r28, r10
     e08:	4c 85       	ldd	r20, Y+12	; 0x0c
     e0a:	5d 85       	ldd	r21, Y+13	; 0x0d
     e0c:	6e 85       	ldd	r22, Y+14	; 0x0e
     e0e:	7f 85       	ldd	r23, Y+15	; 0x0f
     e10:	2d 91       	ld	r18, X+
     e12:	3c 91       	ld	r19, X
     e14:	11 97       	sbiw	r26, 0x01	; 1
     e16:	12 96       	adiw	r26, 0x02	; 2
     e18:	8d 91       	ld	r24, X+
     e1a:	9c 91       	ld	r25, X
     e1c:	13 97       	sbiw	r26, 0x03	; 3
     e1e:	02 e0       	ldi	r16, 0x02	; 2
     e20:	e7 de       	rcall	.-562    	; 0xbf0 <TCP_SetConnectionState>
     e22:	88 23       	and	r24, r24
     e24:	59 f1       	breq	.+86     	; 0xe7c <TCP_ProcessTCPPacket+0x138>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     e26:	82 e1       	ldi	r24, 0x12	; 18
     e28:	f6 01       	movw	r30, r12
     e2a:	85 87       	std	Z+13, r24	; 0x0d

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     e2c:	4c 85       	ldd	r20, Y+12	; 0x0c
     e2e:	5d 85       	ldd	r21, Y+13	; 0x0d
     e30:	6e 85       	ldd	r22, Y+14	; 0x0e
     e32:	7f 85       	ldd	r23, Y+15	; 0x0f
     e34:	d7 01       	movw	r26, r14
     e36:	2d 91       	ld	r18, X+
     e38:	3c 91       	ld	r19, X
     e3a:	11 97       	sbiw	r26, 0x01	; 1
     e3c:	12 96       	adiw	r26, 0x02	; 2
     e3e:	8d 91       	ld	r24, X+
     e40:	9c 91       	ld	r25, X
     e42:	13 97       	sbiw	r26, 0x03	; 3
     e44:	02 de       	rcall	.-1020   	; 0xa4a <TCP_GetConnectionInfo>
     e46:	fc 01       	movw	r30, r24
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
     e48:	e7 01       	movw	r28, r14
     e4a:	8c 81       	ldd	r24, Y+4	; 0x04
     e4c:	9d 81       	ldd	r25, Y+5	; 0x05
     e4e:	ae 81       	ldd	r26, Y+6	; 0x06
     e50:	bf 81       	ldd	r27, Y+7	; 0x07

				Temp = Data.Bytes[0];
     e52:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[3];
     e54:	8b 2f       	mov	r24, r27
				Data.Bytes[3] = Temp;
     e56:	b2 2f       	mov	r27, r18

				Temp = Data.Bytes[1];
     e58:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
     e5a:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
     e5c:	a2 2f       	mov	r26, r18

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     e5e:	01 96       	adiw	r24, 0x01	; 1
     e60:	a1 1d       	adc	r26, r1
     e62:	b1 1d       	adc	r27, r1
     e64:	80 83       	st	Z, r24
     e66:	91 83       	std	Z+1, r25	; 0x01
     e68:	a2 83       	std	Z+2, r26	; 0x02
     e6a:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
     e6c:	14 82       	std	Z+4, r1	; 0x04
     e6e:	15 82       	std	Z+5, r1	; 0x05
     e70:	16 82       	std	Z+6, r1	; 0x06
     e72:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
     e74:	e4 5f       	subi	r30, 0xF4	; 244
     e76:	fd 4f       	sbci	r31, 0xFD	; 253
     e78:	10 82       	st	Z, r1
     e7a:	e8 c1       	rjmp	.+976    	; 0x124c <TCP_ProcessTCPPacket+0x508>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     e7c:	84 e0       	ldi	r24, 0x04	; 4
     e7e:	f6 01       	movw	r30, r12
     e80:	85 87       	std	Z+13, r24	; 0x0d
     e82:	e4 c1       	rjmp	.+968    	; 0x124c <TCP_ProcessTCPPacket+0x508>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     e84:	d7 01       	movw	r26, r14
     e86:	1d 96       	adiw	r26, 0x0d	; 13
     e88:	8c 91       	ld	r24, X
     e8a:	1d 97       	sbiw	r26, 0x0d	; 13
     e8c:	80 31       	cpi	r24, 0x10	; 16
     e8e:	09 f0       	breq	.+2      	; 0xe92 <TCP_ProcessTCPPacket+0x14e>
     e90:	cf c1       	rjmp	.+926    	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e92:	e5 01       	movw	r28, r10
     e94:	4c 85       	ldd	r20, Y+12	; 0x0c
     e96:	5d 85       	ldd	r21, Y+13	; 0x0d
     e98:	6e 85       	ldd	r22, Y+14	; 0x0e
     e9a:	7f 85       	ldd	r23, Y+15	; 0x0f
     e9c:	2d 91       	ld	r18, X+
     e9e:	3c 91       	ld	r19, X
     ea0:	11 97       	sbiw	r26, 0x01	; 1
     ea2:	12 96       	adiw	r26, 0x02	; 2
     ea4:	8d 91       	ld	r24, X+
     ea6:	9c 91       	ld	r25, X
     ea8:	13 97       	sbiw	r26, 0x03	; 3
     eaa:	03 e0       	ldi	r16, 0x03	; 3
     eac:	a1 de       	rcall	.-702    	; 0xbf0 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     eae:	4c 85       	ldd	r20, Y+12	; 0x0c
     eb0:	5d 85       	ldd	r21, Y+13	; 0x0d
     eb2:	6e 85       	ldd	r22, Y+14	; 0x0e
     eb4:	7f 85       	ldd	r23, Y+15	; 0x0f
     eb6:	f7 01       	movw	r30, r14
     eb8:	20 81       	ld	r18, Z
     eba:	31 81       	ldd	r19, Z+1	; 0x01
     ebc:	82 81       	ldd	r24, Z+2	; 0x02
     ebe:	93 81       	ldd	r25, Z+3	; 0x03
     ec0:	c4 dd       	rcall	.-1144   	; 0xa4a <TCP_GetConnectionInfo>
     ec2:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     ec4:	84 81       	ldd	r24, Z+4	; 0x04
     ec6:	95 81       	ldd	r25, Z+5	; 0x05
     ec8:	a6 81       	ldd	r26, Z+6	; 0x06
     eca:	b7 81       	ldd	r27, Z+7	; 0x07
     ecc:	01 96       	adiw	r24, 0x01	; 1
     ece:	a1 1d       	adc	r26, r1
     ed0:	b1 1d       	adc	r27, r1
     ed2:	84 83       	std	Z+4, r24	; 0x04
     ed4:	95 83       	std	Z+5, r25	; 0x05
     ed6:	a6 83       	std	Z+6, r26	; 0x06
     ed8:	b7 83       	std	Z+7, r27	; 0x07
     eda:	aa c1       	rjmp	.+852    	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     edc:	d7 01       	movw	r26, r14
     ede:	1d 96       	adiw	r26, 0x0d	; 13
     ee0:	8c 91       	ld	r24, X
     ee2:	1d 97       	sbiw	r26, 0x0d	; 13
     ee4:	81 31       	cpi	r24, 0x11	; 17
     ee6:	a9 f5       	brne	.+106    	; 0xf52 <TCP_ProcessTCPPacket+0x20e>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     ee8:	e6 01       	movw	r28, r12
     eea:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     eec:	f5 01       	movw	r30, r10
     eee:	44 85       	ldd	r20, Z+12	; 0x0c
     ef0:	55 85       	ldd	r21, Z+13	; 0x0d
     ef2:	66 85       	ldd	r22, Z+14	; 0x0e
     ef4:	77 85       	ldd	r23, Z+15	; 0x0f
     ef6:	2d 91       	ld	r18, X+
     ef8:	3c 91       	ld	r19, X
     efa:	11 97       	sbiw	r26, 0x01	; 1
     efc:	12 96       	adiw	r26, 0x02	; 2
     efe:	8d 91       	ld	r24, X+
     f00:	9c 91       	ld	r25, X
     f02:	13 97       	sbiw	r26, 0x03	; 3
     f04:	06 e0       	ldi	r16, 0x06	; 6
     f06:	74 de       	rcall	.-792    	; 0xbf0 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     f08:	d5 01       	movw	r26, r10
     f0a:	1c 96       	adiw	r26, 0x0c	; 12
     f0c:	4d 91       	ld	r20, X+
     f0e:	5d 91       	ld	r21, X+
     f10:	6d 91       	ld	r22, X+
     f12:	7c 91       	ld	r23, X
     f14:	1f 97       	sbiw	r26, 0x0f	; 15
     f16:	e7 01       	movw	r28, r14
     f18:	28 81       	ld	r18, Y
     f1a:	39 81       	ldd	r19, Y+1	; 0x01
     f1c:	8a 81       	ldd	r24, Y+2	; 0x02
     f1e:	9b 81       	ldd	r25, Y+3	; 0x03
     f20:	94 dd       	rcall	.-1240   	; 0xa4a <TCP_GetConnectionInfo>
     f22:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     f24:	80 81       	ld	r24, Z
     f26:	91 81       	ldd	r25, Z+1	; 0x01
     f28:	a2 81       	ldd	r26, Z+2	; 0x02
     f2a:	b3 81       	ldd	r27, Z+3	; 0x03
     f2c:	01 96       	adiw	r24, 0x01	; 1
     f2e:	a1 1d       	adc	r26, r1
     f30:	b1 1d       	adc	r27, r1
     f32:	80 83       	st	Z, r24
     f34:	91 83       	std	Z+1, r25	; 0x01
     f36:	a2 83       	std	Z+2, r26	; 0x02
     f38:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
     f3a:	84 81       	ldd	r24, Z+4	; 0x04
     f3c:	95 81       	ldd	r25, Z+5	; 0x05
     f3e:	a6 81       	ldd	r26, Z+6	; 0x06
     f40:	b7 81       	ldd	r27, Z+7	; 0x07
     f42:	01 96       	adiw	r24, 0x01	; 1
     f44:	a1 1d       	adc	r26, r1
     f46:	b1 1d       	adc	r27, r1
     f48:	84 83       	std	Z+4, r24	; 0x04
     f4a:	95 83       	std	Z+5, r25	; 0x05
     f4c:	a6 83       	std	Z+6, r26	; 0x06
     f4e:	b7 83       	std	Z+7, r27	; 0x07
     f50:	7d c1       	rjmp	.+762    	; 0x124c <TCP_ProcessTCPPacket+0x508>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     f52:	80 31       	cpi	r24, 0x10	; 16
     f54:	19 f0       	breq	.+6      	; 0xf5c <TCP_ProcessTCPPacket+0x218>
     f56:	88 31       	cpi	r24, 0x18	; 24
     f58:	09 f0       	breq	.+2      	; 0xf5c <TCP_ProcessTCPPacket+0x218>
     f5a:	6a c1       	rjmp	.+724    	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     f5c:	f5 01       	movw	r30, r10
     f5e:	44 85       	ldd	r20, Z+12	; 0x0c
     f60:	55 85       	ldd	r21, Z+13	; 0x0d
     f62:	66 85       	ldd	r22, Z+14	; 0x0e
     f64:	77 85       	ldd	r23, Z+15	; 0x0f
     f66:	d7 01       	movw	r26, r14
     f68:	2d 91       	ld	r18, X+
     f6a:	3c 91       	ld	r19, X
     f6c:	11 97       	sbiw	r26, 0x01	; 1
     f6e:	12 96       	adiw	r26, 0x02	; 2
     f70:	8d 91       	ld	r24, X+
     f72:	9c 91       	ld	r25, X
     f74:	13 97       	sbiw	r26, 0x03	; 3
     f76:	69 dd       	rcall	.-1326   	; 0xa4a <TCP_GetConnectionInfo>
     f78:	ec 01       	movw	r28, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     f7a:	fc 01       	movw	r30, r24
     f7c:	e4 5f       	subi	r30, 0xF4	; 244
     f7e:	fd 4f       	sbci	r31, 0xFD	; 253
     f80:	80 81       	ld	r24, Z
     f82:	88 23       	and	r24, r24
     f84:	81 f4       	brne	.+32     	; 0xfa6 <TCP_ProcessTCPPacket+0x262>
     f86:	c5 5f       	subi	r28, 0xF5	; 245
     f88:	dd 4f       	sbci	r29, 0xFD	; 253
     f8a:	88 81       	ld	r24, Y
     f8c:	cb 50       	subi	r28, 0x0B	; 11
     f8e:	d2 40       	sbci	r29, 0x02	; 2
     f90:	88 23       	and	r24, r24
     f92:	49 f4       	brne	.+18     	; 0xfa6 <TCP_ProcessTCPPacket+0x262>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     f94:	c6 5f       	subi	r28, 0xF6	; 246
     f96:	dd 4f       	sbci	r29, 0xFD	; 253
     f98:	18 82       	st	Y, r1
     f9a:	ca 50       	subi	r28, 0x0A	; 10
     f9c:	d2 40       	sbci	r29, 0x02	; 2
							ConnectionInfo->Buffer.InUse     = true;
     f9e:	81 e0       	ldi	r24, 0x01	; 1
     fa0:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
     fa2:	19 86       	std	Y+9, r1	; 0x09
     fa4:	18 86       	std	Y+8, r1	; 0x08
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     fa6:	c6 5f       	subi	r28, 0xF6	; 246
     fa8:	dd 4f       	sbci	r29, 0xFD	; 253
     faa:	88 81       	ld	r24, Y
     fac:	ca 50       	subi	r28, 0x0A	; 10
     fae:	d2 40       	sbci	r29, 0x02	; 2
     fb0:	88 23       	and	r24, r24
     fb2:	09 f0       	breq	.+2      	; 0xfb6 <TCP_ProcessTCPPacket+0x272>
     fb4:	3a c1       	rjmp	.+628    	; 0x122a <TCP_ProcessTCPPacket+0x4e6>
     fb6:	68 85       	ldd	r22, Y+8	; 0x08
     fb8:	79 85       	ldd	r23, Y+9	; 0x09
     fba:	b2 e0       	ldi	r27, 0x02	; 2
     fbc:	60 30       	cpi	r22, 0x00	; 0
     fbe:	7b 07       	cpc	r23, r27
     fc0:	09 f4       	brne	.+2      	; 0xfc4 <TCP_ProcessTCPPacket+0x280>
     fc2:	33 c1       	rjmp	.+614    	; 0x122a <TCP_ProcessTCPPacket+0x4e6>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
     fc4:	f5 01       	movw	r30, r10
     fc6:	20 81       	ld	r18, Z
     fc8:	2f 70       	andi	r18, 0x0F	; 15
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	22 0f       	add	r18, r18
     fce:	33 1f       	adc	r19, r19
     fd0:	22 0f       	add	r18, r18
     fd2:	33 1f       	adc	r19, r19
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
     fd4:	d7 01       	movw	r26, r14
     fd6:	1c 96       	adiw	r26, 0x0c	; 12
     fd8:	8c 91       	ld	r24, X
     fda:	82 95       	swap	r24
     fdc:	8f 70       	andi	r24, 0x0F	; 15
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	88 0f       	add	r24, r24
     fe2:	99 1f       	adc	r25, r25
     fe4:	88 0f       	add	r24, r24
     fe6:	99 1f       	adc	r25, r25
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     fe8:	02 81       	ldd	r16, Z+2	; 0x02
     fea:	13 81       	ldd	r17, Z+3	; 0x03

				Temp = Data.Bytes[0];
     fec:	40 2f       	mov	r20, r16
				Data.Bytes[0] = Data.Bytes[1];
     fee:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
     ff0:	14 2f       	mov	r17, r20
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
     ff2:	02 1b       	sub	r16, r18
     ff4:	13 0b       	sbc	r17, r19
     ff6:	08 1b       	sub	r16, r24
     ff8:	19 0b       	sbc	r17, r25

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
     ffa:	9b 01       	movw	r18, r22
     ffc:	26 5f       	subi	r18, 0xF6	; 246
     ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    1000:	2c 0f       	add	r18, r28
    1002:	3d 1f       	adc	r19, r29
    1004:	a7 01       	movw	r20, r14
    1006:	48 0f       	add	r20, r24
    1008:	59 1f       	adc	r21, r25
    100a:	c9 01       	movw	r24, r18
    100c:	ba 01       	movw	r22, r20
    100e:	a8 01       	movw	r20, r16
    1010:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1014:	98 01       	movw	r18, r16
    1016:	40 e0       	ldi	r20, 0x00	; 0
    1018:	50 e0       	ldi	r21, 0x00	; 0
    101a:	88 81       	ld	r24, Y
    101c:	99 81       	ldd	r25, Y+1	; 0x01
    101e:	aa 81       	ldd	r26, Y+2	; 0x02
    1020:	bb 81       	ldd	r27, Y+3	; 0x03
    1022:	82 0f       	add	r24, r18
    1024:	93 1f       	adc	r25, r19
    1026:	a4 1f       	adc	r26, r20
    1028:	b5 1f       	adc	r27, r21
    102a:	88 83       	st	Y, r24
    102c:	99 83       	std	Y+1, r25	; 0x01
    102e:	aa 83       	std	Y+2, r26	; 0x02
    1030:	bb 83       	std	Y+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    1032:	88 85       	ldd	r24, Y+8	; 0x08
    1034:	99 85       	ldd	r25, Y+9	; 0x09
    1036:	80 0f       	add	r24, r16
    1038:	91 1f       	adc	r25, r17
    103a:	99 87       	std	Y+9, r25	; 0x09
    103c:	88 87       	std	Y+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    103e:	80 50       	subi	r24, 0x00	; 0
    1040:	92 40       	sbci	r25, 0x02	; 2
    1042:	21 f0       	breq	.+8      	; 0x104c <TCP_ProcessTCPPacket+0x308>
    1044:	f7 01       	movw	r30, r14
    1046:	85 85       	ldd	r24, Z+13	; 0x0d
    1048:	83 ff       	sbrs	r24, 3
    104a:	f2 c0       	rjmp	.+484    	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
							{
								ConnectionInfo->Buffer.InUse = false;
    104c:	c4 5f       	subi	r28, 0xF4	; 244
    104e:	dd 4f       	sbci	r29, 0xFD	; 253
    1050:	18 82       	st	Y, r1
								ConnectionInfo->Buffer.Ready = true;
    1052:	fe 01       	movw	r30, r28
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	82 93       	st	-Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1058:	80 e1       	ldi	r24, 0x10	; 16
    105a:	d6 01       	movw	r26, r12
    105c:	1d 96       	adiw	r26, 0x0d	; 13
    105e:	8c 93       	st	X, r24
    1060:	f5 c0       	rjmp	.+490    	; 0x124c <TCP_ProcessTCPPacket+0x508>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1062:	e5 01       	movw	r28, r10
    1064:	4c 85       	ldd	r20, Y+12	; 0x0c
    1066:	5d 85       	ldd	r21, Y+13	; 0x0d
    1068:	6e 85       	ldd	r22, Y+14	; 0x0e
    106a:	7f 85       	ldd	r23, Y+15	; 0x0f
    106c:	f7 01       	movw	r30, r14
    106e:	20 81       	ld	r18, Z
    1070:	31 81       	ldd	r19, Z+1	; 0x01
    1072:	82 81       	ldd	r24, Z+2	; 0x02
    1074:	93 81       	ldd	r25, Z+3	; 0x03
    1076:	e9 dc       	rcall	.-1582   	; 0xa4a <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    1078:	21 e1       	ldi	r18, 0x11	; 17
    107a:	d6 01       	movw	r26, r12
    107c:	1d 96       	adiw	r26, 0x0d	; 13
    107e:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    1080:	fc 01       	movw	r30, r24
    1082:	e4 5f       	subi	r30, 0xF4	; 244
    1084:	fd 4f       	sbci	r31, 0xFD	; 253
    1086:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1088:	4c 85       	ldd	r20, Y+12	; 0x0c
    108a:	5d 85       	ldd	r21, Y+13	; 0x0d
    108c:	6e 85       	ldd	r22, Y+14	; 0x0e
    108e:	7f 85       	ldd	r23, Y+15	; 0x0f
    1090:	e7 01       	movw	r28, r14
    1092:	28 81       	ld	r18, Y
    1094:	39 81       	ldd	r19, Y+1	; 0x01
    1096:	8a 81       	ldd	r24, Y+2	; 0x02
    1098:	9b 81       	ldd	r25, Y+3	; 0x03
    109a:	04 e0       	ldi	r16, 0x04	; 4
    109c:	80 c0       	rjmp	.+256    	; 0x119e <TCP_ProcessTCPPacket+0x45a>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    109e:	f7 01       	movw	r30, r14
    10a0:	85 85       	ldd	r24, Z+13	; 0x0d
    10a2:	81 31       	cpi	r24, 0x11	; 17
    10a4:	a1 f5       	brne	.+104    	; 0x110e <TCP_ProcessTCPPacket+0x3ca>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10a6:	d5 01       	movw	r26, r10
    10a8:	1c 96       	adiw	r26, 0x0c	; 12
    10aa:	4d 91       	ld	r20, X+
    10ac:	5d 91       	ld	r21, X+
    10ae:	6d 91       	ld	r22, X+
    10b0:	7c 91       	ld	r23, X
    10b2:	1f 97       	sbiw	r26, 0x0f	; 15
    10b4:	20 81       	ld	r18, Z
    10b6:	31 81       	ldd	r19, Z+1	; 0x01
    10b8:	82 81       	ldd	r24, Z+2	; 0x02
    10ba:	93 81       	ldd	r25, Z+3	; 0x03
    10bc:	c6 dc       	rcall	.-1652   	; 0xa4a <TCP_GetConnectionInfo>
    10be:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    10c0:	80 e1       	ldi	r24, 0x10	; 16
    10c2:	e6 01       	movw	r28, r12
    10c4:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    10c6:	80 81       	ld	r24, Z
    10c8:	91 81       	ldd	r25, Z+1	; 0x01
    10ca:	a2 81       	ldd	r26, Z+2	; 0x02
    10cc:	b3 81       	ldd	r27, Z+3	; 0x03
    10ce:	01 96       	adiw	r24, 0x01	; 1
    10d0:	a1 1d       	adc	r26, r1
    10d2:	b1 1d       	adc	r27, r1
    10d4:	80 83       	st	Z, r24
    10d6:	91 83       	std	Z+1, r25	; 0x01
    10d8:	a2 83       	std	Z+2, r26	; 0x02
    10da:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    10dc:	84 81       	ldd	r24, Z+4	; 0x04
    10de:	95 81       	ldd	r25, Z+5	; 0x05
    10e0:	a6 81       	ldd	r26, Z+6	; 0x06
    10e2:	b7 81       	ldd	r27, Z+7	; 0x07
    10e4:	01 96       	adiw	r24, 0x01	; 1
    10e6:	a1 1d       	adc	r26, r1
    10e8:	b1 1d       	adc	r27, r1
    10ea:	84 83       	std	Z+4, r24	; 0x04
    10ec:	95 83       	std	Z+5, r25	; 0x05
    10ee:	a6 83       	std	Z+6, r26	; 0x06
    10f0:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10f2:	f5 01       	movw	r30, r10
    10f4:	44 85       	ldd	r20, Z+12	; 0x0c
    10f6:	55 85       	ldd	r21, Z+13	; 0x0d
    10f8:	66 85       	ldd	r22, Z+14	; 0x0e
    10fa:	77 85       	ldd	r23, Z+15	; 0x0f
    10fc:	d7 01       	movw	r26, r14
    10fe:	2d 91       	ld	r18, X+
    1100:	3c 91       	ld	r19, X
    1102:	11 97       	sbiw	r26, 0x01	; 1
    1104:	12 96       	adiw	r26, 0x02	; 2
    1106:	8d 91       	ld	r24, X+
    1108:	9c 91       	ld	r25, X
    110a:	13 97       	sbiw	r26, 0x03	; 3
    110c:	47 c0       	rjmp	.+142    	; 0x119c <TCP_ProcessTCPPacket+0x458>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    110e:	80 31       	cpi	r24, 0x10	; 16
    1110:	09 f0       	breq	.+2      	; 0x1114 <TCP_ProcessTCPPacket+0x3d0>
    1112:	8e c0       	rjmp	.+284    	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1114:	e5 01       	movw	r28, r10
    1116:	4c 85       	ldd	r20, Y+12	; 0x0c
    1118:	5d 85       	ldd	r21, Y+13	; 0x0d
    111a:	6e 85       	ldd	r22, Y+14	; 0x0e
    111c:	7f 85       	ldd	r23, Y+15	; 0x0f
    111e:	f7 01       	movw	r30, r14
    1120:	20 81       	ld	r18, Z
    1122:	31 81       	ldd	r19, Z+1	; 0x01
    1124:	82 81       	ldd	r24, Z+2	; 0x02
    1126:	93 81       	ldd	r25, Z+3	; 0x03
    1128:	05 e0       	ldi	r16, 0x05	; 5
    112a:	4c c0       	rjmp	.+152    	; 0x11c4 <TCP_ProcessTCPPacket+0x480>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    112c:	d7 01       	movw	r26, r14
    112e:	1d 96       	adiw	r26, 0x0d	; 13
    1130:	8c 91       	ld	r24, X
    1132:	1d 97       	sbiw	r26, 0x0d	; 13
    1134:	81 31       	cpi	r24, 0x11	; 17
    1136:	09 f0       	breq	.+2      	; 0x113a <TCP_ProcessTCPPacket+0x3f6>
    1138:	7b c0       	rjmp	.+246    	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    113a:	e5 01       	movw	r28, r10
    113c:	4c 85       	ldd	r20, Y+12	; 0x0c
    113e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1140:	6e 85       	ldd	r22, Y+14	; 0x0e
    1142:	7f 85       	ldd	r23, Y+15	; 0x0f
    1144:	2d 91       	ld	r18, X+
    1146:	3c 91       	ld	r19, X
    1148:	11 97       	sbiw	r26, 0x01	; 1
    114a:	12 96       	adiw	r26, 0x02	; 2
    114c:	8d 91       	ld	r24, X+
    114e:	9c 91       	ld	r25, X
    1150:	13 97       	sbiw	r26, 0x03	; 3
    1152:	7b dc       	rcall	.-1802   	; 0xa4a <TCP_GetConnectionInfo>
    1154:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    1156:	80 e1       	ldi	r24, 0x10	; 16
    1158:	d6 01       	movw	r26, r12
    115a:	1d 96       	adiw	r26, 0x0d	; 13
    115c:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    115e:	80 81       	ld	r24, Z
    1160:	91 81       	ldd	r25, Z+1	; 0x01
    1162:	a2 81       	ldd	r26, Z+2	; 0x02
    1164:	b3 81       	ldd	r27, Z+3	; 0x03
    1166:	01 96       	adiw	r24, 0x01	; 1
    1168:	a1 1d       	adc	r26, r1
    116a:	b1 1d       	adc	r27, r1
    116c:	80 83       	st	Z, r24
    116e:	91 83       	std	Z+1, r25	; 0x01
    1170:	a2 83       	std	Z+2, r26	; 0x02
    1172:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1174:	84 81       	ldd	r24, Z+4	; 0x04
    1176:	95 81       	ldd	r25, Z+5	; 0x05
    1178:	a6 81       	ldd	r26, Z+6	; 0x06
    117a:	b7 81       	ldd	r27, Z+7	; 0x07
    117c:	01 96       	adiw	r24, 0x01	; 1
    117e:	a1 1d       	adc	r26, r1
    1180:	b1 1d       	adc	r27, r1
    1182:	84 83       	std	Z+4, r24	; 0x04
    1184:	95 83       	std	Z+5, r25	; 0x05
    1186:	a6 83       	std	Z+6, r26	; 0x06
    1188:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    118a:	4c 85       	ldd	r20, Y+12	; 0x0c
    118c:	5d 85       	ldd	r21, Y+13	; 0x0d
    118e:	6e 85       	ldd	r22, Y+14	; 0x0e
    1190:	7f 85       	ldd	r23, Y+15	; 0x0f
    1192:	e7 01       	movw	r28, r14
    1194:	28 81       	ld	r18, Y
    1196:	39 81       	ldd	r19, Y+1	; 0x01
    1198:	8a 81       	ldd	r24, Y+2	; 0x02
    119a:	9b 81       	ldd	r25, Y+3	; 0x03
    119c:	0a e0       	ldi	r16, 0x0A	; 10
    119e:	28 dd       	rcall	.-1456   	; 0xbf0 <TCP_SetConnectionState>
    11a0:	55 c0       	rjmp	.+170    	; 0x124c <TCP_ProcessTCPPacket+0x508>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    11a2:	f7 01       	movw	r30, r14
    11a4:	85 85       	ldd	r24, Z+13	; 0x0d
    11a6:	80 31       	cpi	r24, 0x10	; 16
    11a8:	09 f0       	breq	.+2      	; 0x11ac <TCP_ProcessTCPPacket+0x468>
    11aa:	42 c0       	rjmp	.+132    	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    11ac:	d5 01       	movw	r26, r10
    11ae:	1c 96       	adiw	r26, 0x0c	; 12
    11b0:	4d 91       	ld	r20, X+
    11b2:	5d 91       	ld	r21, X+
    11b4:	6d 91       	ld	r22, X+
    11b6:	7c 91       	ld	r23, X
    11b8:	1f 97       	sbiw	r26, 0x0f	; 15
    11ba:	20 81       	ld	r18, Z
    11bc:	31 81       	ldd	r19, Z+1	; 0x01
    11be:	82 81       	ldd	r24, Z+2	; 0x02
    11c0:	93 81       	ldd	r25, Z+3	; 0x03
    11c2:	0a e0       	ldi	r16, 0x0A	; 10
    11c4:	15 dd       	rcall	.-1494   	; 0xbf0 <TCP_SetConnectionState>
    11c6:	34 c0       	rjmp	.+104    	; 0x1230 <TCP_ProcessTCPPacket+0x4ec>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    11c8:	84 e1       	ldi	r24, 0x14	; 20
    11ca:	e6 01       	movw	r28, r12
    11cc:	8d 87       	std	Y+13, r24	; 0x0d
    11ce:	3e c0       	rjmp	.+124    	; 0x124c <TCP_ProcessTCPPacket+0x508>
    11d0:	82 e0       	ldi	r24, 0x02	; 2
    11d2:	90 e0       	ldi	r25, 0x00	; 0
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    11d4:	f6 01       	movw	r30, r12
    11d6:	97 87       	std	Z+15, r25	; 0x0f
    11d8:	86 87       	std	Z+14, r24	; 0x0e
    11da:	0c c0       	rjmp	.+24     	; 0x11f4 <TCP_ProcessTCPPacket+0x4b0>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    11dc:	80 e0       	ldi	r24, 0x00	; 0
    11de:	92 e0       	ldi	r25, 0x02	; 2
    11e0:	20 85       	ldd	r18, Z+8	; 0x08
    11e2:	31 85       	ldd	r19, Z+9	; 0x09
    11e4:	82 1b       	sub	r24, r18
    11e6:	93 0b       	sbc	r25, r19
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    11e8:	d6 01       	movw	r26, r12
    11ea:	1e 96       	adiw	r26, 0x0e	; 14
    11ec:	9c 93       	st	X, r25
    11ee:	1e 97       	sbiw	r26, 0x0e	; 14
    11f0:	1f 96       	adiw	r26, 0x0f	; 15
    11f2:	8c 93       	st	X, r24

		TCPHeaderOUT->UrgentPointer        = 0;
    11f4:	e6 01       	movw	r28, r12
    11f6:	1b 8a       	std	Y+19, r1	; 0x13
    11f8:	1a 8a       	std	Y+18, r1	; 0x12
		TCPHeaderOUT->Checksum             = 0;
    11fa:	19 8a       	std	Y+17, r1	; 0x11
    11fc:	18 8a       	std	Y+16, r1	; 0x10
		TCPHeaderOUT->Reserved             = 0;
    11fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1200:	80 7f       	andi	r24, 0xF0	; 240
    1202:	8c 87       	std	Y+12, r24	; 0x0c

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    1204:	f5 01       	movw	r30, r10
    1206:	40 89       	ldd	r20, Z+16	; 0x10
    1208:	51 89       	ldd	r21, Z+17	; 0x11
    120a:	62 89       	ldd	r22, Z+18	; 0x12
    120c:	73 89       	ldd	r23, Z+19	; 0x13
    120e:	04 85       	ldd	r16, Z+12	; 0x0c
    1210:	15 85       	ldd	r17, Z+13	; 0x0d
    1212:	26 85       	ldd	r18, Z+14	; 0x0e
    1214:	37 85       	ldd	r19, Z+15	; 0x0f
    1216:	c6 01       	movw	r24, r12
    1218:	e4 e1       	ldi	r30, 0x14	; 20
    121a:	ee 2e       	mov	r14, r30
    121c:	f1 2c       	mov	r15, r1
    121e:	70 db       	rcall	.-2336   	; 0x900 <TCP_Checksum16>
    1220:	99 8b       	std	Y+17, r25	; 0x11
    1222:	88 8b       	std	Y+16, r24	; 0x10
    1224:	24 e1       	ldi	r18, 0x14	; 20
    1226:	30 e0       	ldi	r19, 0x00	; 0
    1228:	05 c0       	rjmp	.+10     	; 0x1234 <TCP_ProcessTCPPacket+0x4f0>
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    122a:	2f ef       	ldi	r18, 0xFF	; 255
    122c:	3f ef       	ldi	r19, 0xFF	; 255
    122e:	02 c0       	rjmp	.+4      	; 0x1234 <TCP_ProcessTCPPacket+0x4f0>
    1230:	20 e0       	ldi	r18, 0x00	; 0
    1232:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1234:	c9 01       	movw	r24, r18
    1236:	df 91       	pop	r29
    1238:	cf 91       	pop	r28
    123a:	1f 91       	pop	r17
    123c:	0f 91       	pop	r16
    123e:	ff 90       	pop	r15
    1240:	ef 90       	pop	r14
    1242:	df 90       	pop	r13
    1244:	cf 90       	pop	r12
    1246:	bf 90       	pop	r11
    1248:	af 90       	pop	r10
    124a:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    124c:	d5 01       	movw	r26, r10
    124e:	1c 96       	adiw	r26, 0x0c	; 12
    1250:	4d 91       	ld	r20, X+
    1252:	5d 91       	ld	r21, X+
    1254:	6d 91       	ld	r22, X+
    1256:	7c 91       	ld	r23, X
    1258:	1f 97       	sbiw	r26, 0x0f	; 15
    125a:	e7 01       	movw	r28, r14
    125c:	28 81       	ld	r18, Y
    125e:	39 81       	ldd	r19, Y+1	; 0x01
    1260:	8a 81       	ldd	r24, Y+2	; 0x02
    1262:	9b 81       	ldd	r25, Y+3	; 0x03
    1264:	f2 db       	rcall	.-2076   	; 0xa4a <TCP_GetConnectionInfo>
    1266:	fc 01       	movw	r30, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    1268:	8a 81       	ldd	r24, Y+2	; 0x02
    126a:	9b 81       	ldd	r25, Y+3	; 0x03
    126c:	d6 01       	movw	r26, r12
    126e:	11 96       	adiw	r26, 0x01	; 1
    1270:	9c 93       	st	X, r25
    1272:	8e 93       	st	-X, r24
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1274:	88 81       	ld	r24, Y
    1276:	99 81       	ldd	r25, Y+1	; 0x01
    1278:	13 96       	adiw	r26, 0x03	; 3
    127a:	9c 93       	st	X, r25
    127c:	8e 93       	st	-X, r24
    127e:	12 97       	sbiw	r26, 0x02	; 2
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
    1280:	34 81       	ldd	r19, Z+4	; 0x04
    1282:	25 81       	ldd	r18, Z+5	; 0x05
    1284:	96 81       	ldd	r25, Z+6	; 0x06
    1286:	87 81       	ldd	r24, Z+7	; 0x07
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    1288:	14 96       	adiw	r26, 0x04	; 4
    128a:	8c 93       	st	X, r24
    128c:	14 97       	sbiw	r26, 0x04	; 4
    128e:	15 96       	adiw	r26, 0x05	; 5
    1290:	9c 93       	st	X, r25
    1292:	15 97       	sbiw	r26, 0x05	; 5
    1294:	16 96       	adiw	r26, 0x06	; 6
    1296:	2c 93       	st	X, r18
    1298:	16 97       	sbiw	r26, 0x06	; 6
    129a:	17 96       	adiw	r26, 0x07	; 7
    129c:	3c 93       	st	X, r19
    129e:	17 97       	sbiw	r26, 0x07	; 7
    12a0:	30 81       	ld	r19, Z
    12a2:	21 81       	ldd	r18, Z+1	; 0x01
    12a4:	92 81       	ldd	r25, Z+2	; 0x02
    12a6:	83 81       	ldd	r24, Z+3	; 0x03
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    12a8:	18 96       	adiw	r26, 0x08	; 8
    12aa:	8c 93       	st	X, r24
    12ac:	18 97       	sbiw	r26, 0x08	; 8
    12ae:	19 96       	adiw	r26, 0x09	; 9
    12b0:	9c 93       	st	X, r25
    12b2:	19 97       	sbiw	r26, 0x09	; 9
    12b4:	1a 96       	adiw	r26, 0x0a	; 10
    12b6:	2c 93       	st	X, r18
    12b8:	1a 97       	sbiw	r26, 0x0a	; 10
    12ba:	1b 96       	adiw	r26, 0x0b	; 11
    12bc:	3c 93       	st	X, r19
    12be:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    12c0:	1c 96       	adiw	r26, 0x0c	; 12
    12c2:	8c 91       	ld	r24, X
    12c4:	1c 97       	sbiw	r26, 0x0c	; 12
    12c6:	8f 70       	andi	r24, 0x0F	; 15
    12c8:	80 65       	ori	r24, 0x50	; 80
    12ca:	1c 96       	adiw	r26, 0x0c	; 12
    12cc:	8c 93       	st	X, r24

		if (!(ConnectionInfo->Buffer.InUse))
    12ce:	e4 5f       	subi	r30, 0xF4	; 244
    12d0:	fd 4f       	sbci	r31, 0xFD	; 253
    12d2:	80 81       	ld	r24, Z
    12d4:	ec 50       	subi	r30, 0x0C	; 12
    12d6:	f2 40       	sbci	r31, 0x02	; 2
    12d8:	88 23       	and	r24, r24
    12da:	09 f4       	brne	.+2      	; 0x12de <TCP_ProcessTCPPacket+0x59a>
    12dc:	79 cf       	rjmp	.-270    	; 0x11d0 <TCP_ProcessTCPPacket+0x48c>
    12de:	7e cf       	rjmp	.-260    	; 0x11dc <TCP_ProcessTCPPacket+0x498>

000012e0 <TCP_TCPTask>:
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
    12e0:	2f 92       	push	r2
    12e2:	3f 92       	push	r3
    12e4:	4f 92       	push	r4
    12e6:	5f 92       	push	r5
    12e8:	6f 92       	push	r6
    12ea:	7f 92       	push	r7
    12ec:	8f 92       	push	r8
    12ee:	9f 92       	push	r9
    12f0:	af 92       	push	r10
    12f2:	bf 92       	push	r11
    12f4:	cf 92       	push	r12
    12f6:	df 92       	push	r13
    12f8:	ef 92       	push	r14
    12fa:	ff 92       	push	r15
    12fc:	0f 93       	push	r16
    12fe:	1f 93       	push	r17
    1300:	df 93       	push	r29
    1302:	cf 93       	push	r28
    1304:	00 d0       	rcall	.+0      	; 0x1306 <TCP_TCPTask+0x26>
    1306:	00 d0       	rcall	.+0      	; 0x1308 <TCP_TCPTask+0x28>
    1308:	cd b7       	in	r28, 0x3d	; 61
    130a:	de b7       	in	r29, 0x3e	; 62
    130c:	7c 83       	std	Y+4, r23	; 0x04
    130e:	6b 83       	std	Y+3, r22	; 0x03
    1310:	95 eb       	ldi	r25, 0xB5	; 181
    1312:	c9 2e       	mov	r12, r25
    1314:	9d e0       	ldi	r25, 0x0D	; 13
    1316:	d9 2e       	mov	r13, r25
    1318:	00 e0       	ldi	r16, 0x00	; 0
    131a:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    131c:	86 e1       	ldi	r24, 0x16	; 22
    131e:	e8 2e       	mov	r14, r24
    1320:	82 e0       	ldi	r24, 0x02	; 2
    1322:	f8 2e       	mov	r15, r24
    1324:	1c c0       	rjmp	.+56     	; 0x135e <TCP_TCPTask+0x7e>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1326:	80 91 f9 13 	lds	r24, 0x13F9
    132a:	81 30       	cpi	r24, 0x01	; 1
    132c:	79 f4       	brne	.+30     	; 0x134c <TCP_TCPTask+0x6c>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    132e:	0e 9d       	mul	r16, r14
    1330:	b0 01       	movw	r22, r0
    1332:	0f 9d       	mul	r16, r15
    1334:	70 0d       	add	r23, r0
    1336:	1e 9d       	mul	r17, r14
    1338:	70 0d       	add	r23, r0
    133a:	11 24       	eor	r1, r1
    133c:	6b 53       	subi	r22, 0x3B	; 59
    133e:	72 4f       	sbci	r23, 0xF2	; 242
    1340:	e0 91 fa 13 	lds	r30, 0x13FA
    1344:	f0 91 fb 13 	lds	r31, 0x13FB
    1348:	c6 01       	movw	r24, r12
    134a:	09 95       	icall
    134c:	0f 5f       	subi	r16, 0xFF	; 255
    134e:	1f 4f       	sbci	r17, 0xFF	; 255
    1350:	26 e1       	ldi	r18, 0x16	; 22
    1352:	32 e0       	ldi	r19, 0x02	; 2
    1354:	c2 0e       	add	r12, r18
    1356:	d3 1e       	adc	r13, r19
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1358:	03 30       	cpi	r16, 0x03	; 3
    135a:	11 05       	cpc	r17, r1
    135c:	59 f0       	breq	.+22     	; 0x1374 <TCP_TCPTask+0x94>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    135e:	20 91 f7 13 	lds	r18, 0x13F7
    1362:	30 91 f8 13 	lds	r19, 0x13F8
    1366:	d6 01       	movw	r26, r12
    1368:	8d 91       	ld	r24, X+
    136a:	9c 91       	ld	r25, X
    136c:	28 17       	cp	r18, r24
    136e:	39 07       	cpc	r19, r25
    1370:	69 f7       	brne	.-38     	; 0x134c <TCP_TCPTask+0x6c>
    1372:	d9 cf       	rjmp	.-78     	; 0x1326 <TCP_TCPTask+0x46>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
    1374:	eb 81       	ldd	r30, Y+3	; 0x03
    1376:	fc 81       	ldd	r31, Y+4	; 0x04
    1378:	e4 52       	subi	r30, 0x24	; 36
    137a:	fa 4f       	sbci	r31, 0xFA	; 250
    137c:	80 81       	ld	r24, Z
    137e:	91 81       	ldd	r25, Z+1	; 0x01
    1380:	ec 5d       	subi	r30, 0xDC	; 220
    1382:	f5 40       	sbci	r31, 0x05	; 5
    1384:	fc 83       	std	Y+4, r31	; 0x04
    1386:	eb 83       	std	Y+3, r30	; 0x03
    1388:	89 2b       	or	r24, r25
    138a:	09 f0       	breq	.+2      	; 0x138e <TCP_TCPTask+0xae>
    138c:	17 c1       	rjmp	.+558    	; 0x15bc <TCP_TCPTask+0x2dc>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    138e:	80 91 c7 0f 	lds	r24, 0x0FC7
    1392:	88 23       	and	r24, r24
    1394:	39 f0       	breq	.+14     	; 0x13a4 <TCP_TCPTask+0xc4>
    1396:	80 91 c8 0f 	lds	r24, 0x0FC8
    139a:	88 23       	and	r24, r24
    139c:	19 f0       	breq	.+6      	; 0x13a4 <TCP_TCPTask+0xc4>
    139e:	1a 82       	std	Y+2, r1	; 0x02
    13a0:	19 82       	std	Y+1, r1	; 0x01
    13a2:	1b c0       	rjmp	.+54     	; 0x13da <TCP_TCPTask+0xfa>
    13a4:	80 91 dd 11 	lds	r24, 0x11DD
    13a8:	88 23       	and	r24, r24
    13aa:	49 f0       	breq	.+18     	; 0x13be <TCP_TCPTask+0xde>
    13ac:	80 91 de 11 	lds	r24, 0x11DE
    13b0:	88 23       	and	r24, r24
    13b2:	29 f0       	breq	.+10     	; 0x13be <TCP_TCPTask+0xde>
    13b4:	21 e0       	ldi	r18, 0x01	; 1
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	3a 83       	std	Y+2, r19	; 0x02
    13ba:	29 83       	std	Y+1, r18	; 0x01
    13bc:	0e c0       	rjmp	.+28     	; 0x13da <TCP_TCPTask+0xfa>
    13be:	80 91 f3 13 	lds	r24, 0x13F3
    13c2:	88 23       	and	r24, r24
    13c4:	09 f4       	brne	.+2      	; 0x13c8 <TCP_TCPTask+0xe8>
    13c6:	fa c0       	rjmp	.+500    	; 0x15bc <TCP_TCPTask+0x2dc>
    13c8:	80 91 f4 13 	lds	r24, 0x13F4
    13cc:	88 23       	and	r24, r24
    13ce:	09 f4       	brne	.+2      	; 0x13d2 <TCP_TCPTask+0xf2>
    13d0:	f5 c0       	rjmp	.+490    	; 0x15bc <TCP_TCPTask+0x2dc>
    13d2:	82 e0       	ldi	r24, 0x02	; 2
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	9a 83       	std	Y+2, r25	; 0x02
    13d8:	89 83       	std	Y+1, r24	; 0x01
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
    13da:	ab 80       	ldd	r10, Y+3	; 0x03
    13dc:	bc 80       	ldd	r11, Y+4	; 0x04
    13de:	ae e0       	ldi	r26, 0x0E	; 14
    13e0:	b0 e0       	ldi	r27, 0x00	; 0
    13e2:	aa 0e       	add	r10, r26
    13e4:	bb 1e       	adc	r11, r27
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                              sizeof(IP_Header_t)];
    13e6:	cb 80       	ldd	r12, Y+3	; 0x03
    13e8:	dc 80       	ldd	r13, Y+4	; 0x04
    13ea:	e2 e2       	ldi	r30, 0x22	; 34
    13ec:	f0 e0       	ldi	r31, 0x00	; 0
    13ee:	ce 0e       	add	r12, r30
    13f0:	df 1e       	adc	r13, r31
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    13f2:	86 e1       	ldi	r24, 0x16	; 22
    13f4:	92 e0       	ldi	r25, 0x02	; 2
    13f6:	29 81       	ldd	r18, Y+1	; 0x01
    13f8:	3a 81       	ldd	r19, Y+2	; 0x02
    13fa:	28 9f       	mul	r18, r24
    13fc:	a0 01       	movw	r20, r0
    13fe:	29 9f       	mul	r18, r25
    1400:	50 0d       	add	r21, r0
    1402:	38 9f       	mul	r19, r24
    1404:	50 0d       	add	r21, r0
    1406:	11 24       	eor	r1, r1
    1408:	05 eb       	ldi	r16, 0xB5	; 181
    140a:	80 2e       	mov	r8, r16
    140c:	0d e0       	ldi	r16, 0x0D	; 13
    140e:	90 2e       	mov	r9, r16
    1410:	84 0e       	add	r8, r20
    1412:	95 1e       	adc	r9, r21
    1414:	d4 01       	movw	r26, r8
    1416:	50 96       	adiw	r26, 0x10	; 16
    1418:	6d 90       	ld	r6, X+
    141a:	7c 90       	ld	r7, X
    141c:	51 97       	sbiw	r26, 0x11	; 17

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    141e:	8d 91       	ld	r24, X+
    1420:	9c 91       	ld	r25, X
    1422:	eb 81       	ldd	r30, Y+3	; 0x03
    1424:	fc 81       	ldd	r31, Y+4	; 0x04
    1426:	93 a3       	std	Z+35, r25	; 0x23
    1428:	82 a3       	std	Z+34, r24	; 0x22
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    142a:	8b e0       	ldi	r24, 0x0B	; 11
    142c:	91 e0       	ldi	r25, 0x01	; 1
    142e:	28 9f       	mul	r18, r24
    1430:	f0 01       	movw	r30, r0
    1432:	29 9f       	mul	r18, r25
    1434:	f0 0d       	add	r31, r0
    1436:	38 9f       	mul	r19, r24
    1438:	f0 0d       	add	r31, r0
    143a:	11 24       	eor	r1, r1
    143c:	ee 0f       	add	r30, r30
    143e:	ff 1f       	adc	r31, r31
    1440:	e9 54       	subi	r30, 0x49	; 73
    1442:	f2 4f       	sbci	r31, 0xF2	; 242
    1444:	80 81       	ld	r24, Z
    1446:	91 81       	ldd	r25, Z+1	; 0x01
    1448:	d6 01       	movw	r26, r12
    144a:	13 96       	adiw	r26, 0x03	; 3
    144c:	9c 93       	st	X, r25
    144e:	8e 93       	st	-X, r24
    1450:	12 97       	sbiw	r26, 0x02	; 2
    1452:	f4 01       	movw	r30, r8
    1454:	3c 96       	adiw	r30, 0x0c	; 12
    1456:	d4 01       	movw	r26, r8
    1458:	1c 96       	adiw	r26, 0x0c	; 12
    145a:	3c 91       	ld	r19, X
    145c:	1c 97       	sbiw	r26, 0x0c	; 12
    145e:	21 81       	ldd	r18, Z+1	; 0x01
    1460:	92 81       	ldd	r25, Z+2	; 0x02
    1462:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    1464:	f6 01       	movw	r30, r12
    1466:	84 83       	std	Z+4, r24	; 0x04
    1468:	95 83       	std	Z+5, r25	; 0x05
    146a:	26 83       	std	Z+6, r18	; 0x06
    146c:	37 83       	std	Z+7, r19	; 0x07
    146e:	f4 01       	movw	r30, r8
    1470:	38 96       	adiw	r30, 0x08	; 8
    1472:	18 96       	adiw	r26, 0x08	; 8
    1474:	3c 91       	ld	r19, X
    1476:	21 81       	ldd	r18, Z+1	; 0x01
    1478:	92 81       	ldd	r25, Z+2	; 0x02
    147a:	83 81       	ldd	r24, Z+3	; 0x03
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    147c:	f6 01       	movw	r30, r12
    147e:	80 87       	std	Z+8, r24	; 0x08
    1480:	91 87       	std	Z+9, r25	; 0x09
    1482:	22 87       	std	Z+10, r18	; 0x0a
    1484:	33 87       	std	Z+11, r19	; 0x0b

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;
    1486:	82 e0       	ldi	r24, 0x02	; 2
    1488:	90 e0       	ldi	r25, 0x00	; 0
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    148a:	97 87       	std	Z+15, r25	; 0x0f
    148c:	86 87       	std	Z+14, r24	; 0x0e

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    148e:	80 e1       	ldi	r24, 0x10	; 16
    1490:	85 87       	std	Z+13, r24	; 0x0d
			TCPHeaderOUT->UrgentPointer        = 0;
    1492:	13 8a       	std	Z+19, r1	; 0x13
    1494:	12 8a       	std	Z+18, r1	; 0x12
			TCPHeaderOUT->Checksum             = 0;
    1496:	11 8a       	std	Z+17, r1	; 0x11
    1498:	10 8a       	std	Z+16, r1	; 0x10
			TCPHeaderOUT->Reserved             = 0;
    149a:	80 e5       	ldi	r24, 0x50	; 80
    149c:	84 87       	std	Z+12, r24	; 0x0c

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    149e:	2b 81       	ldd	r18, Y+3	; 0x03
    14a0:	3c 81       	ldd	r19, Y+4	; 0x04
    14a2:	2a 5c       	subi	r18, 0xCA	; 202
    14a4:	3f 4f       	sbci	r19, 0xFF	; 255
    14a6:	49 53       	subi	r20, 0x39	; 57
    14a8:	52 4f       	sbci	r21, 0xF2	; 242
    14aa:	c9 01       	movw	r24, r18
    14ac:	ba 01       	movw	r22, r20
    14ae:	a3 01       	movw	r20, r6
    14b0:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    14b4:	c3 01       	movw	r24, r6
    14b6:	a0 e0       	ldi	r26, 0x00	; 0
    14b8:	b0 e0       	ldi	r27, 0x00	; 0
    14ba:	f4 01       	movw	r30, r8
    14bc:	24 85       	ldd	r18, Z+12	; 0x0c
    14be:	35 85       	ldd	r19, Z+13	; 0x0d
    14c0:	46 85       	ldd	r20, Z+14	; 0x0e
    14c2:	57 85       	ldd	r21, Z+15	; 0x0f
    14c4:	82 0f       	add	r24, r18
    14c6:	93 1f       	adc	r25, r19
    14c8:	a4 1f       	adc	r26, r20
    14ca:	b5 1f       	adc	r27, r21
    14cc:	84 87       	std	Z+12, r24	; 0x0c
    14ce:	95 87       	std	Z+13, r25	; 0x0d
    14d0:	a6 87       	std	Z+14, r26	; 0x0e
    14d2:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
    14d4:	24 e1       	ldi	r18, 0x14	; 20
    14d6:	30 e0       	ldi	r19, 0x00	; 0
    14d8:	62 0e       	add	r6, r18
    14da:	73 1e       	adc	r7, r19
    14dc:	20 90 b9 01 	lds	r2, 0x01B9
    14e0:	30 90 ba 01 	lds	r3, 0x01BA
    14e4:	40 90 bb 01 	lds	r4, 0x01BB
    14e8:	50 90 bc 01 	lds	r5, 0x01BC
    14ec:	04 81       	ldd	r16, Z+4	; 0x04
    14ee:	15 81       	ldd	r17, Z+5	; 0x05
    14f0:	26 81       	ldd	r18, Z+6	; 0x06
    14f2:	37 81       	ldd	r19, Z+7	; 0x07
    14f4:	c6 01       	movw	r24, r12
    14f6:	b2 01       	movw	r22, r4
    14f8:	a1 01       	movw	r20, r2
    14fa:	73 01       	movw	r14, r6
    14fc:	01 da       	rcall	.-3070   	; 0x900 <TCP_Checksum16>
    14fe:	d6 01       	movw	r26, r12
    1500:	51 96       	adiw	r26, 0x11	; 17
    1502:	9c 93       	st	X, r25
    1504:	8e 93       	st	-X, r24
    1506:	50 97       	sbiw	r26, 0x10	; 16
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    1508:	83 01       	movw	r16, r6
    150a:	0c 5e       	subi	r16, 0xEC	; 236
    150c:	1f 4f       	sbci	r17, 0xFF	; 255
    150e:	f5 01       	movw	r30, r10
    1510:	12 83       	std	Z+2, r17	; 0x02
    1512:	03 83       	std	Z+3, r16	; 0x03
			IPHeaderOUT->TypeOfService      = 0;
    1514:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    1516:	85 e4       	ldi	r24, 0x45	; 69
    1518:	ab 81       	ldd	r26, Y+3	; 0x03
    151a:	bc 81       	ldd	r27, Y+4	; 0x04
    151c:	1e 96       	adiw	r26, 0x0e	; 14
    151e:	8c 93       	st	X, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    1520:	16 82       	std	Z+6, r1	; 0x06
    1522:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    1524:	15 82       	std	Z+5, r1	; 0x05
    1526:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    1528:	13 86       	std	Z+11, r1	; 0x0b
    152a:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    152c:	86 e0       	ldi	r24, 0x06	; 6
    152e:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    1530:	80 e8       	ldi	r24, 0x80	; 128
    1532:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    1534:	24 86       	std	Z+12, r2	; 0x0c
    1536:	35 86       	std	Z+13, r3	; 0x0d
    1538:	46 86       	std	Z+14, r4	; 0x0e
    153a:	57 86       	std	Z+15, r5	; 0x0f
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    153c:	f4 01       	movw	r30, r8
    153e:	84 81       	ldd	r24, Z+4	; 0x04
    1540:	95 81       	ldd	r25, Z+5	; 0x05
    1542:	a6 81       	ldd	r26, Z+6	; 0x06
    1544:	b7 81       	ldd	r27, Z+7	; 0x07
    1546:	f5 01       	movw	r30, r10
    1548:	80 8b       	std	Z+16, r24	; 0x10
    154a:	91 8b       	std	Z+17, r25	; 0x11
    154c:	a2 8b       	std	Z+18, r26	; 0x12
    154e:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1550:	c5 01       	movw	r24, r10
    1552:	64 e1       	ldi	r22, 0x14	; 20
    1554:	70 e0       	ldi	r23, 0x00	; 0
    1556:	59 d8       	rcall	.-3918   	; 0x60a <Ethernet_Checksum16>
    1558:	d5 01       	movw	r26, r10
    155a:	1b 96       	adiw	r26, 0x0b	; 11
    155c:	9c 93       	st	X, r25
    155e:	8e 93       	st	-X, r24
    1560:	1a 97       	sbiw	r26, 0x0a	; 10

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    1562:	ab 81       	ldd	r26, Y+3	; 0x03
    1564:	bc 81       	ldd	r27, Y+4	; 0x04
    1566:	16 96       	adiw	r26, 0x06	; 6
    1568:	e3 eb       	ldi	r30, 0xB3	; 179
    156a:	f1 e0       	ldi	r31, 0x01	; 1
    156c:	86 e0       	ldi	r24, 0x06	; 6
    156e:	01 90       	ld	r0, Z+
    1570:	0d 92       	st	X+, r0
    1572:	81 50       	subi	r24, 0x01	; 1
    1574:	e1 f7       	brne	.-8      	; 0x156e <TCP_TCPTask+0x28e>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    1576:	ab 81       	ldd	r26, Y+3	; 0x03
    1578:	bc 81       	ldd	r27, Y+4	; 0x04
    157a:	eb ec       	ldi	r30, 0xCB	; 203
    157c:	f1 e0       	ldi	r31, 0x01	; 1
    157e:	86 e0       	ldi	r24, 0x06	; 6
    1580:	01 90       	ld	r0, Z+
    1582:	0d 92       	st	X+, r0
    1584:	81 50       	subi	r24, 0x01	; 1
    1586:	e1 f7       	brne	.-8      	; 0x1580 <TCP_TCPTask+0x2a0>
    1588:	88 e0       	ldi	r24, 0x08	; 8
    158a:	90 e0       	ldi	r25, 0x00	; 0
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    158c:	eb 81       	ldd	r30, Y+3	; 0x03
    158e:	fc 81       	ldd	r31, Y+4	; 0x04
    1590:	95 87       	std	Z+13, r25	; 0x0d
    1592:	84 87       	std	Z+12, r24	; 0x0c

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
    1594:	e4 52       	subi	r30, 0x24	; 36
    1596:	fa 4f       	sbci	r31, 0xFA	; 250
    1598:	02 5f       	subi	r16, 0xF2	; 242
    159a:	1f 4f       	sbci	r17, 0xFF	; 255
    159c:	11 83       	std	Z+1, r17	; 0x01
    159e:	00 83       	st	Z, r16

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    15a0:	86 e1       	ldi	r24, 0x16	; 22
    15a2:	92 e0       	ldi	r25, 0x02	; 2
    15a4:	29 81       	ldd	r18, Y+1	; 0x01
    15a6:	3a 81       	ldd	r19, Y+2	; 0x02
    15a8:	28 9f       	mul	r18, r24
    15aa:	f0 01       	movw	r30, r0
    15ac:	29 9f       	mul	r18, r25
    15ae:	f0 0d       	add	r31, r0
    15b0:	38 9f       	mul	r19, r24
    15b2:	f0 0d       	add	r31, r0
    15b4:	11 24       	eor	r1, r1
    15b6:	e8 53       	subi	r30, 0x38	; 56
    15b8:	f0 4f       	sbci	r31, 0xF0	; 240
    15ba:	10 82       	st	Z, r1

			break;
		}
	}
}
    15bc:	0f 90       	pop	r0
    15be:	0f 90       	pop	r0
    15c0:	0f 90       	pop	r0
    15c2:	0f 90       	pop	r0
    15c4:	cf 91       	pop	r28
    15c6:	df 91       	pop	r29
    15c8:	1f 91       	pop	r17
    15ca:	0f 91       	pop	r16
    15cc:	ff 90       	pop	r15
    15ce:	ef 90       	pop	r14
    15d0:	df 90       	pop	r13
    15d2:	cf 90       	pop	r12
    15d4:	bf 90       	pop	r11
    15d6:	af 90       	pop	r10
    15d8:	9f 90       	pop	r9
    15da:	8f 90       	pop	r8
    15dc:	7f 90       	pop	r7
    15de:	6f 90       	pop	r6
    15e0:	5f 90       	pop	r5
    15e2:	4f 90       	pop	r4
    15e4:	3f 90       	pop	r3
    15e6:	2f 90       	pop	r2
    15e8:	08 95       	ret

000015ea <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    15ea:	ef 92       	push	r14
    15ec:	ff 92       	push	r15
    15ee:	0f 93       	push	r16
    15f0:	1f 93       	push	r17
    15f2:	cf 93       	push	r28
    15f4:	df 93       	push	r29
    15f6:	7c 01       	movw	r14, r24
    15f8:	eb 01       	movw	r28, r22
    15fa:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    15fc:	cb 01       	movw	r24, r22
    15fe:	af d8       	rcall	.-3746   	; 0x75e <DecodeUDPHeader>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1600:	8a 81       	ldd	r24, Y+2	; 0x02
    1602:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1604:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1606:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1608:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    160a:	83 34       	cpi	r24, 0x43	; 67
    160c:	91 05       	cpc	r25, r1
    160e:	e9 f4       	brne	.+58     	; 0x164a <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1610:	be 01       	movw	r22, r28
    1612:	68 5f       	subi	r22, 0xF8	; 248
    1614:	7f 4f       	sbci	r23, 0xFF	; 255
    1616:	a8 01       	movw	r20, r16
    1618:	48 5f       	subi	r20, 0xF8	; 248
    161a:	5f 4f       	sbci	r21, 0xFF	; 255
    161c:	c7 01       	movw	r24, r14
    161e:	1f d0       	rcall	.+62     	; 0x165e <DHCP_ProcessDHCPPacket>
    1620:	9c 01       	movw	r18, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1622:	18 16       	cp	r1, r24
    1624:	19 06       	cpc	r1, r25
    1626:	8c f4       	brge	.+34     	; 0x164a <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    1628:	8a 81       	ldd	r24, Y+2	; 0x02
    162a:	9b 81       	ldd	r25, Y+3	; 0x03
    162c:	f8 01       	movw	r30, r16
    162e:	91 83       	std	Z+1, r25	; 0x01
    1630:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1632:	88 81       	ld	r24, Y
    1634:	99 81       	ldd	r25, Y+1	; 0x01
    1636:	93 83       	std	Z+3, r25	; 0x03
    1638:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    163a:	17 82       	std	Z+7, r1	; 0x07
    163c:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    163e:	c9 01       	movw	r24, r18
    1640:	08 96       	adiw	r24, 0x08	; 8
    1642:	94 83       	std	Z+4, r25	; 0x04
    1644:	85 83       	std	Z+5, r24	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    1646:	9c 01       	movw	r18, r24
    1648:	02 c0       	rjmp	.+4      	; 0x164e <UDP_ProcessUDPPacket+0x64>
    164a:	20 e0       	ldi	r18, 0x00	; 0
    164c:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    164e:	c9 01       	movw	r24, r18
    1650:	df 91       	pop	r29
    1652:	cf 91       	pop	r28
    1654:	1f 91       	pop	r17
    1656:	0f 91       	pop	r16
    1658:	ff 90       	pop	r15
    165a:	ef 90       	pop	r14
    165c:	08 95       	ret

0000165e <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    165e:	8f 92       	push	r8
    1660:	9f 92       	push	r9
    1662:	af 92       	push	r10
    1664:	bf 92       	push	r11
    1666:	cf 92       	push	r12
    1668:	df 92       	push	r13
    166a:	ef 92       	push	r14
    166c:	ff 92       	push	r15
    166e:	0f 93       	push	r16
    1670:	1f 93       	push	r17
    1672:	cf 93       	push	r28
    1674:	df 93       	push	r29
    1676:	8b 01       	movw	r16, r22
    1678:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    167a:	5c 01       	movw	r10, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    167c:	80 ef       	ldi	r24, 0xF0	; 240
    167e:	88 2e       	mov	r8, r24
    1680:	91 2c       	mov	r9, r1
    1682:	86 0e       	add	r8, r22
    1684:	97 1e       	adc	r9, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    1686:	cb 01       	movw	r24, r22
    1688:	6b d8       	rcall	.-3882   	; 0x760 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    168a:	80 ef       	ldi	r24, 0xF0	; 240
    168c:	fe 01       	movw	r30, r28
    168e:	11 92       	st	Z+, r1
    1690:	8a 95       	dec	r24
    1692:	e9 f7       	brne	.-6      	; 0x168e <DHCP_ProcessDHCPPacket+0x30>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    1694:	f8 01       	movw	r30, r16
    1696:	81 81       	ldd	r24, Z+1	; 0x01
    1698:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    169a:	82 e0       	ldi	r24, 0x02	; 2
    169c:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    169e:	82 81       	ldd	r24, Z+2	; 0x02
    16a0:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    16a2:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    16a4:	84 81       	ldd	r24, Z+4	; 0x04
    16a6:	95 81       	ldd	r25, Z+5	; 0x05
    16a8:	a6 81       	ldd	r26, Z+6	; 0x06
    16aa:	b7 81       	ldd	r27, Z+7	; 0x07
    16ac:	8c 83       	std	Y+4, r24	; 0x04
    16ae:	9d 83       	std	Y+5, r25	; 0x05
    16b0:	ae 83       	std	Y+6, r26	; 0x06
    16b2:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    16b4:	19 86       	std	Y+9, r1	; 0x09
    16b6:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    16b8:	82 85       	ldd	r24, Z+10	; 0x0a
    16ba:	93 85       	ldd	r25, Z+11	; 0x0b
    16bc:	9b 87       	std	Y+11, r25	; 0x0b
    16be:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    16c0:	c0 90 c7 01 	lds	r12, 0x01C7
    16c4:	d0 90 c8 01 	lds	r13, 0x01C8
    16c8:	e0 90 c9 01 	lds	r14, 0x01C9
    16cc:	f0 90 ca 01 	lds	r15, 0x01CA
    16d0:	c8 8a       	std	Y+16, r12	; 0x10
    16d2:	d9 8a       	std	Y+17, r13	; 0x11
    16d4:	ea 8a       	std	Y+18, r14	; 0x12
    16d6:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    16d8:	04 5e       	subi	r16, 0xE4	; 228
    16da:	1f 4f       	sbci	r17, 0xFF	; 255
    16dc:	ce 01       	movw	r24, r28
    16de:	4c 96       	adiw	r24, 0x1c	; 28
    16e0:	b8 01       	movw	r22, r16
    16e2:	46 e0       	ldi	r20, 0x06	; 6
    16e4:	50 e0       	ldi	r21, 0x00	; 0
    16e6:	0e 94 90 17 	call	0x2f20	; 0x2f20 <memmove>
				} Data;

				Data.DWord = DWord;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[3];
    16ea:	83 e6       	ldi	r24, 0x63	; 99
    16ec:	93 e5       	ldi	r25, 0x53	; 83
    16ee:	a2 e8       	ldi	r26, 0x82	; 130
    16f0:	b3 e6       	ldi	r27, 0x63	; 99
				Data.Bytes[3] = Temp;
    16f2:	b3 e6       	ldi	r27, 0x63	; 99

				Temp = Data.Bytes[1];
    16f4:	29 2f       	mov	r18, r25
				Data.Bytes[1] = Data.Bytes[2];
    16f6:	9a 2f       	mov	r25, r26
				Data.Bytes[2] = Temp;
    16f8:	a2 2f       	mov	r26, r18
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    16fa:	c4 51       	subi	r28, 0x14	; 20
    16fc:	df 4f       	sbci	r29, 0xFF	; 255
    16fe:	88 83       	st	Y, r24
    1700:	99 83       	std	Y+1, r25	; 0x01
    1702:	aa 83       	std	Y+2, r26	; 0x02
    1704:	bb 83       	std	Y+3, r27	; 0x03
    1706:	cc 5e       	subi	r28, 0xEC	; 236
    1708:	d0 40       	sbci	r29, 0x00	; 0

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    170a:	f5 01       	movw	r30, r10
    170c:	c4 86       	std	Z+12, r12	; 0x0c
    170e:	d5 86       	std	Z+13, r13	; 0x0d
    1710:	e6 86       	std	Z+14, r14	; 0x0e
    1712:	f7 86       	std	Z+15, r15	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1714:	80 91 b9 01 	lds	r24, 0x01B9
    1718:	90 91 ba 01 	lds	r25, 0x01BA
    171c:	a0 91 bb 01 	lds	r26, 0x01BB
    1720:	b0 91 bc 01 	lds	r27, 0x01BC
    1724:	80 8b       	std	Z+16, r24	; 0x10
    1726:	91 8b       	std	Z+17, r25	; 0x11
    1728:	a2 8b       	std	Z+18, r26	; 0x12
    172a:	b3 8b       	std	Z+19, r27	; 0x13
    172c:	5b c0       	rjmp	.+182    	; 0x17e4 <DHCP_ProcessDHCPPacket+0x186>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    172e:	85 33       	cpi	r24, 0x35	; 53
    1730:	09 f0       	breq	.+2      	; 0x1734 <DHCP_ProcessDHCPPacket+0xd6>
    1732:	4d c0       	rjmp	.+154    	; 0x17ce <DHCP_ProcessDHCPPacket+0x170>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1734:	94 01       	movw	r18, r8
    1736:	2e 5f       	subi	r18, 0xFE	; 254
    1738:	3f 4f       	sbci	r19, 0xFF	; 255
    173a:	f4 01       	movw	r30, r8
    173c:	82 81       	ldd	r24, Z+2	; 0x02
    173e:	81 30       	cpi	r24, 0x01	; 1
    1740:	19 f0       	breq	.+6      	; 0x1748 <DHCP_ProcessDHCPPacket+0xea>
    1742:	83 30       	cpi	r24, 0x03	; 3
    1744:	09 f0       	breq	.+2      	; 0x1748 <DHCP_ProcessDHCPPacket+0xea>
    1746:	48 c0       	rjmp	.+144    	; 0x17d8 <DHCP_ProcessDHCPPacket+0x17a>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    1748:	fe 01       	movw	r30, r28
    174a:	e0 51       	subi	r30, 0x10	; 16
    174c:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    174e:	df 01       	movw	r26, r30
    1750:	85 e3       	ldi	r24, 0x35	; 53
    1752:	8d 93       	st	X+, r24
				*(DHCPOptionsOUTStart++) = 1;
    1754:	81 e0       	ldi	r24, 0x01	; 1
    1756:	81 83       	std	Z+1, r24	; 0x01
    1758:	ed 01       	movw	r28, r26
    175a:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    175c:	f9 01       	movw	r30, r18
    175e:	80 81       	ld	r24, Z
    1760:	81 30       	cpi	r24, 0x01	; 1
    1762:	11 f0       	breq	.+4      	; 0x1768 <DHCP_ProcessDHCPPacket+0x10a>
    1764:	85 e0       	ldi	r24, 0x05	; 5
    1766:	01 c0       	rjmp	.+2      	; 0x176a <DHCP_ProcessDHCPPacket+0x10c>
    1768:	82 e0       	ldi	r24, 0x02	; 2
    176a:	11 96       	adiw	r26, 0x01	; 1
    176c:	8c 93       	st	X, r24
    176e:	fe 01       	movw	r30, r28
    1770:	31 96       	adiw	r30, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	89 83       	std	Y+1, r24	; 0x01
    1776:	cf 01       	movw	r24, r30
    1778:	01 96       	adiw	r24, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    177a:	34 e0       	ldi	r19, 0x04	; 4
    177c:	31 83       	std	Z+1, r19	; 0x01
    177e:	dc 01       	movw	r26, r24
    1780:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1782:	2f ef       	ldi	r18, 0xFF	; 255
    1784:	fc 01       	movw	r30, r24
    1786:	21 83       	std	Z+1, r18	; 0x01
    1788:	fd 01       	movw	r30, r26
    178a:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    178c:	11 96       	adiw	r26, 0x01	; 1
    178e:	2c 93       	st	X, r18
    1790:	df 01       	movw	r26, r30
    1792:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    1794:	21 83       	std	Z+1, r18	; 0x01
    1796:	fd 01       	movw	r30, r26
    1798:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    179a:	11 96       	adiw	r26, 0x01	; 1
    179c:	1c 92       	st	X, r1
    179e:	df 01       	movw	r26, r30
    17a0:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    17a2:	86 e3       	ldi	r24, 0x36	; 54
    17a4:	81 83       	std	Z+1, r24	; 0x01
    17a6:	fd 01       	movw	r30, r26
    17a8:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    17aa:	11 96       	adiw	r26, 0x01	; 1
    17ac:	3c 93       	st	X, r19
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    17ae:	80 91 b9 01 	lds	r24, 0x01B9
    17b2:	90 91 ba 01 	lds	r25, 0x01BA
    17b6:	a0 91 bb 01 	lds	r26, 0x01BB
    17ba:	b0 91 bc 01 	lds	r27, 0x01BC
    17be:	81 83       	std	Z+1, r24	; 0x01
    17c0:	92 83       	std	Z+2, r25	; 0x02
    17c2:	a3 83       	std	Z+3, r26	; 0x03
    17c4:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    17c6:	25 83       	std	Z+5, r18	; 0x05
    17c8:	20 e0       	ldi	r18, 0x00	; 0
    17ca:	31 e0       	ldi	r19, 0x01	; 1
    17cc:	12 c0       	rjmp	.+36     	; 0x17f2 <DHCP_ProcessDHCPPacket+0x194>
				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    17ce:	88 23       	and	r24, r24
    17d0:	19 f4       	brne	.+6      	; 0x17d8 <DHCP_ProcessDHCPPacket+0x17a>
    17d2:	81 e0       	ldi	r24, 0x01	; 1
    17d4:	90 e0       	ldi	r25, 0x00	; 0
    17d6:	04 c0       	rjmp	.+8      	; 0x17e0 <DHCP_ProcessDHCPPacket+0x182>
    17d8:	f4 01       	movw	r30, r8
    17da:	81 81       	ldd	r24, Z+1	; 0x01
    17dc:	90 e0       	ldi	r25, 0x00	; 0
    17de:	02 96       	adiw	r24, 0x02	; 2
    17e0:	88 0e       	add	r8, r24
    17e2:	99 1e       	adc	r9, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    17e4:	f4 01       	movw	r30, r8
    17e6:	80 81       	ld	r24, Z
    17e8:	8f 3f       	cpi	r24, 0xFF	; 255
    17ea:	09 f0       	breq	.+2      	; 0x17ee <DHCP_ProcessDHCPPacket+0x190>
    17ec:	a0 cf       	rjmp	.-192    	; 0x172e <DHCP_ProcessDHCPPacket+0xd0>
    17ee:	20 e0       	ldi	r18, 0x00	; 0
    17f0:	30 e0       	ldi	r19, 0x00	; 0
		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
}
    17f2:	c9 01       	movw	r24, r18
    17f4:	df 91       	pop	r29
    17f6:	cf 91       	pop	r28
    17f8:	1f 91       	pop	r17
    17fa:	0f 91       	pop	r16
    17fc:	ff 90       	pop	r15
    17fe:	ef 90       	pop	r14
    1800:	df 90       	pop	r13
    1802:	cf 90       	pop	r12
    1804:	bf 90       	pop	r11
    1806:	af 90       	pop	r10
    1808:	9f 90       	pop	r9
    180a:	8f 90       	pop	r8
    180c:	08 95       	ret

0000180e <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    180e:	ef 92       	push	r14
    1810:	ff 92       	push	r15
    1812:	0f 93       	push	r16
    1814:	1f 93       	push	r17
    1816:	cf 93       	push	r28
    1818:	df 93       	push	r29
    181a:	18 2f       	mov	r17, r24
    181c:	09 2f       	mov	r16, r25
    181e:	f6 2e       	mov	r15, r22
    1820:	e7 2e       	mov	r14, r23
	DecodeARPHeader(InDataStart);
    1822:	0e 94 ab 03 	call	0x756	; 0x756 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    1826:	c1 2f       	mov	r28, r17
    1828:	d0 2f       	mov	r29, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    182a:	8a 81       	ldd	r24, Y+2	; 0x02
    182c:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    182e:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1830:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1832:	92 2f       	mov	r25, r18
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1834:	80 50       	subi	r24, 0x00	; 0
    1836:	98 40       	sbci	r25, 0x08	; 8
    1838:	09 f0       	breq	.+2      	; 0x183c <ARP_ProcessARPPacket+0x2e>
    183a:	5e c0       	rjmp	.+188    	; 0x18f8 <ARP_ProcessARPPacket+0xea>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    183c:	8e 81       	ldd	r24, Y+6	; 0x06
    183e:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    1840:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    1842:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1844:	92 2f       	mov	r25, r18
    1846:	01 97       	sbiw	r24, 0x01	; 1
    1848:	09 f0       	breq	.+2      	; 0x184c <ARP_ProcessARPPacket+0x3e>
    184a:	56 c0       	rjmp	.+172    	; 0x18f8 <ARP_ProcessARPPacket+0xea>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    184c:	ce 01       	movw	r24, r28
    184e:	48 96       	adiw	r24, 0x18	; 24
    1850:	69 eb       	ldi	r22, 0xB9	; 185
    1852:	71 e0       	ldi	r23, 0x01	; 1
    1854:	44 e0       	ldi	r20, 0x04	; 4
    1856:	50 e0       	ldi	r21, 0x00	; 0
    1858:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
    185c:	00 97       	sbiw	r24, 0x00	; 0
    185e:	59 f0       	breq	.+22     	; 0x1876 <ARP_ProcessARPPacket+0x68>
    1860:	ce 01       	movw	r24, r28
    1862:	42 96       	adiw	r24, 0x12	; 18
    1864:	63 eb       	ldi	r22, 0xB3	; 179
    1866:	71 e0       	ldi	r23, 0x01	; 1
    1868:	46 e0       	ldi	r20, 0x06	; 6
    186a:	50 e0       	ldi	r21, 0x00	; 0
    186c:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
    1870:	00 97       	sbiw	r24, 0x00	; 0
    1872:	09 f0       	breq	.+2      	; 0x1876 <ARP_ProcessARPPacket+0x68>
    1874:	41 c0       	rjmp	.+130    	; 0x18f8 <ARP_ProcessARPPacket+0xea>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    1876:	ef 2d       	mov	r30, r15
    1878:	fe 2d       	mov	r31, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    187a:	88 81       	ld	r24, Y
    187c:	99 81       	ldd	r25, Y+1	; 0x01
    187e:	91 83       	std	Z+1, r25	; 0x01
    1880:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    1882:	8a 81       	ldd	r24, Y+2	; 0x02
    1884:	9b 81       	ldd	r25, Y+3	; 0x03
    1886:	93 83       	std	Z+3, r25	; 0x03
    1888:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    188a:	8c 81       	ldd	r24, Y+4	; 0x04
    188c:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    188e:	8d 81       	ldd	r24, Y+5	; 0x05
    1890:	85 83       	std	Z+5, r24	; 0x05
    1892:	80 e0       	ldi	r24, 0x00	; 0
    1894:	92 e0       	ldi	r25, 0x02	; 2
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    1896:	97 83       	std	Z+7, r25	; 0x07
    1898:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    189a:	9f 01       	movw	r18, r30
    189c:	2e 5e       	subi	r18, 0xEE	; 238
    189e:	3f 4f       	sbci	r19, 0xFF	; 255
    18a0:	ae 01       	movw	r20, r28
    18a2:	48 5f       	subi	r20, 0xF8	; 248
    18a4:	5f 4f       	sbci	r21, 0xFF	; 255
    18a6:	86 e0       	ldi	r24, 0x06	; 6
    18a8:	da 01       	movw	r26, r20
    18aa:	0d 90       	ld	r0, X+
    18ac:	ad 01       	movw	r20, r26
    18ae:	d9 01       	movw	r26, r18
    18b0:	0d 92       	st	X+, r0
    18b2:	9d 01       	movw	r18, r26
    18b4:	81 50       	subi	r24, 0x01	; 1
    18b6:	c1 f7       	brne	.-16     	; 0x18a8 <ARP_ProcessARPPacket+0x9a>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    18b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    18ba:	9f 85       	ldd	r25, Y+15	; 0x0f
    18bc:	a8 89       	ldd	r26, Y+16	; 0x10
    18be:	b9 89       	ldd	r27, Y+17	; 0x11
    18c0:	80 8f       	std	Z+24, r24	; 0x18
    18c2:	91 8f       	std	Z+25, r25	; 0x19
    18c4:	a2 8f       	std	Z+26, r26	; 0x1a
    18c6:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    18c8:	ef 01       	movw	r28, r30
    18ca:	28 96       	adiw	r28, 0x08	; 8
    18cc:	a3 eb       	ldi	r26, 0xB3	; 179
    18ce:	b1 e0       	ldi	r27, 0x01	; 1
    18d0:	86 e0       	ldi	r24, 0x06	; 6
    18d2:	0d 90       	ld	r0, X+
    18d4:	09 92       	st	Y+, r0
    18d6:	81 50       	subi	r24, 0x01	; 1
    18d8:	e1 f7       	brne	.-8      	; 0x18d2 <ARP_ProcessARPPacket+0xc4>
			ARPHeaderOUT->SPA = ServerIPAddress;
    18da:	80 91 b9 01 	lds	r24, 0x01B9
    18de:	90 91 ba 01 	lds	r25, 0x01BA
    18e2:	a0 91 bb 01 	lds	r26, 0x01BB
    18e6:	b0 91 bc 01 	lds	r27, 0x01BC
    18ea:	86 87       	std	Z+14, r24	; 0x0e
    18ec:	97 87       	std	Z+15, r25	; 0x0f
    18ee:	a0 8b       	std	Z+16, r26	; 0x10
    18f0:	b1 8b       	std	Z+17, r27	; 0x11
    18f2:	2c e1       	ldi	r18, 0x1C	; 28
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	02 c0       	rjmp	.+4      	; 0x18fc <ARP_ProcessARPPacket+0xee>

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    18f8:	20 e0       	ldi	r18, 0x00	; 0
    18fa:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    18fc:	c9 01       	movw	r24, r18
    18fe:	df 91       	pop	r29
    1900:	cf 91       	pop	r28
    1902:	1f 91       	pop	r17
    1904:	0f 91       	pop	r16
    1906:	ff 90       	pop	r15
    1908:	ef 90       	pop	r14
    190a:	08 95       	ret

0000190c <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    190c:	af 92       	push	r10
    190e:	bf 92       	push	r11
    1910:	df 92       	push	r13
    1912:	ef 92       	push	r14
    1914:	ff 92       	push	r15
    1916:	0f 93       	push	r16
    1918:	1f 93       	push	r17
    191a:	cf 93       	push	r28
    191c:	df 93       	push	r29
    191e:	5c 01       	movw	r10, r24
    1920:	7b 01       	movw	r14, r22
    1922:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
    1924:	cb 01       	movw	r24, r22
    1926:	0e 94 ac 03 	call	0x758	; 0x758 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    192a:	f7 01       	movw	r30, r14
    192c:	d0 80       	ld	r13, Z
    192e:	ff e0       	ldi	r31, 0x0F	; 15
    1930:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1932:	87 01       	movw	r16, r14
    1934:	00 5f       	subi	r16, 0xF0	; 240
    1936:	1f 4f       	sbci	r17, 0xFF	; 255
    1938:	c8 01       	movw	r24, r16
    193a:	69 eb       	ldi	r22, 0xB9	; 185
    193c:	71 e0       	ldi	r23, 0x01	; 1
    193e:	44 e0       	ldi	r20, 0x04	; 4
    1940:	50 e0       	ldi	r21, 0x00	; 0
    1942:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
    1946:	00 97       	sbiw	r24, 0x00	; 0
    1948:	49 f0       	breq	.+18     	; 0x195c <IP_ProcessIPPacket+0x50>
    194a:	c8 01       	movw	r24, r16
    194c:	63 ec       	ldi	r22, 0xC3	; 195
    194e:	71 e0       	ldi	r23, 0x01	; 1
    1950:	44 e0       	ldi	r20, 0x04	; 4
    1952:	50 e0       	ldi	r21, 0x00	; 0
    1954:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <memcmp>
    1958:	00 97       	sbiw	r24, 0x00	; 0
    195a:	71 f4       	brne	.+28     	; 0x1978 <IP_ProcessIPPacket+0x6c>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    195c:	6d 2d       	mov	r22, r13
    195e:	70 e0       	ldi	r23, 0x00	; 0
    1960:	66 0f       	add	r22, r22
    1962:	77 1f       	adc	r23, r23
    1964:	66 0f       	add	r22, r22
    1966:	77 1f       	adc	r23, r23
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1968:	f7 01       	movw	r30, r14
    196a:	81 85       	ldd	r24, Z+9	; 0x09
    196c:	86 30       	cpi	r24, 0x06	; 6
    196e:	81 f0       	breq	.+32     	; 0x1990 <IP_ProcessIPPacket+0x84>
    1970:	81 31       	cpi	r24, 0x11	; 17
    1972:	b1 f0       	breq	.+44     	; 0x19a0 <IP_ProcessIPPacket+0x94>
    1974:	81 30       	cpi	r24, 0x01	; 1
    1976:	19 f0       	breq	.+6      	; 0x197e <IP_ProcessIPPacket+0x72>
    1978:	20 e0       	ldi	r18, 0x00	; 0
    197a:	30 e0       	ldi	r19, 0x00	; 0
    197c:	47 c0       	rjmp	.+142    	; 0x1a0c <IP_ProcessIPPacket+0x100>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    197e:	6e 0d       	add	r22, r14
    1980:	7f 1d       	adc	r23, r15
    1982:	ae 01       	movw	r20, r28
    1984:	4c 5e       	subi	r20, 0xEC	; 236
    1986:	5f 4f       	sbci	r21, 0xFF	; 255
    1988:	c5 01       	movw	r24, r10
    198a:	0e 94 b1 03 	call	0x762	; 0x762 <ICMP_ProcessICMPPacket>
    198e:	0f c0       	rjmp	.+30     	; 0x19ae <IP_ProcessIPPacket+0xa2>
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1990:	6e 0d       	add	r22, r14
    1992:	7f 1d       	adc	r23, r15
    1994:	ae 01       	movw	r20, r28
    1996:	4c 5e       	subi	r20, 0xEC	; 236
    1998:	5f 4f       	sbci	r21, 0xFF	; 255
    199a:	c7 01       	movw	r24, r14
    199c:	d3 d9       	rcall	.-3162   	; 0xd44 <TCP_ProcessTCPPacket>
    199e:	07 c0       	rjmp	.+14     	; 0x19ae <IP_ProcessIPPacket+0xa2>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    19a0:	6e 0d       	add	r22, r14
    19a2:	7f 1d       	adc	r23, r15
    19a4:	ae 01       	movw	r20, r28
    19a6:	4c 5e       	subi	r20, 0xEC	; 236
    19a8:	5f 4f       	sbci	r21, 0xFF	; 255
    19aa:	c7 01       	movw	r24, r14
    19ac:	1e de       	rcall	.-964    	; 0x15ea <UDP_ProcessUDPPacket>
    19ae:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    19b0:	18 16       	cp	r1, r24
    19b2:	19 06       	cpc	r1, r25
    19b4:	5c f5       	brge	.+86     	; 0x1a0c <IP_ProcessIPPacket+0x100>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    19b6:	8c 01       	movw	r16, r24
    19b8:	0c 5e       	subi	r16, 0xEC	; 236
    19ba:	1f 4f       	sbci	r17, 0xFF	; 255
    19bc:	1a 83       	std	Y+2, r17	; 0x02
    19be:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    19c0:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    19c2:	85 e4       	ldi	r24, 0x45	; 69
    19c4:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    19c6:	1e 82       	std	Y+6, r1	; 0x06
    19c8:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    19ca:	1d 82       	std	Y+5, r1	; 0x05
    19cc:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    19ce:	1b 86       	std	Y+11, r1	; 0x0b
    19d0:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    19d2:	f7 01       	movw	r30, r14
    19d4:	81 85       	ldd	r24, Z+9	; 0x09
    19d6:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    19d8:	80 e8       	ldi	r24, 0x80	; 128
    19da:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    19dc:	80 89       	ldd	r24, Z+16	; 0x10
    19de:	91 89       	ldd	r25, Z+17	; 0x11
    19e0:	a2 89       	ldd	r26, Z+18	; 0x12
    19e2:	b3 89       	ldd	r27, Z+19	; 0x13
    19e4:	8c 87       	std	Y+12, r24	; 0x0c
    19e6:	9d 87       	std	Y+13, r25	; 0x0d
    19e8:	ae 87       	std	Y+14, r26	; 0x0e
    19ea:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    19ec:	84 85       	ldd	r24, Z+12	; 0x0c
    19ee:	95 85       	ldd	r25, Z+13	; 0x0d
    19f0:	a6 85       	ldd	r26, Z+14	; 0x0e
    19f2:	b7 85       	ldd	r27, Z+15	; 0x0f
    19f4:	88 8b       	std	Y+16, r24	; 0x10
    19f6:	99 8b       	std	Y+17, r25	; 0x11
    19f8:	aa 8b       	std	Y+18, r26	; 0x12
    19fa:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    19fc:	ce 01       	movw	r24, r28
    19fe:	64 e1       	ldi	r22, 0x14	; 20
    1a00:	70 e0       	ldi	r23, 0x00	; 0
    1a02:	0e 94 05 03 	call	0x60a	; 0x60a <Ethernet_Checksum16>
    1a06:	9b 87       	std	Y+11, r25	; 0x0b
    1a08:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1a0a:	98 01       	movw	r18, r16
	}

	return RetSize;
}
    1a0c:	c9 01       	movw	r24, r18
    1a0e:	df 91       	pop	r29
    1a10:	cf 91       	pop	r28
    1a12:	1f 91       	pop	r17
    1a14:	0f 91       	pop	r16
    1a16:	ff 90       	pop	r15
    1a18:	ef 90       	pop	r14
    1a1a:	df 90       	pop	r13
    1a1c:	bf 90       	pop	r11
    1a1e:	af 90       	pop	r10
    1a20:	08 95       	ret

00001a22 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1a22:	db 01       	movw	r26, r22
    1a24:	0d 90       	ld	r0, X+
    1a26:	00 20       	and	r0, r0
    1a28:	e9 f7       	brne	.-6      	; 0x1a24 <IsHTTPCommand+0x2>
    1a2a:	11 97       	sbiw	r26, 0x01	; 1
    1a2c:	a6 1b       	sub	r26, r22
    1a2e:	b7 0b       	sbc	r27, r23
    1a30:	ad 01       	movw	r20, r26
    1a32:	0e 94 a1 17 	call	0x2f42	; 0x2f42 <strncmp>
    1a36:	9c 01       	movw	r18, r24
    1a38:	80 e0       	ldi	r24, 0x00	; 0
    1a3a:	23 2b       	or	r18, r19
    1a3c:	09 f4       	brne	.+2      	; 0x1a40 <IsHTTPCommand+0x1e>
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
}
    1a40:	08 95       	ret

00001a42 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1a42:	af 92       	push	r10
    1a44:	bf 92       	push	r11
    1a46:	cf 92       	push	r12
    1a48:	df 92       	push	r13
    1a4a:	ef 92       	push	r14
    1a4c:	ff 92       	push	r15
    1a4e:	0f 93       	push	r16
    1a50:	1f 93       	push	r17
    1a52:	cf 93       	push	r28
    1a54:	df 93       	push	r29
    1a56:	5c 01       	movw	r10, r24
    1a58:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1a5a:	8b 01       	movw	r16, r22
    1a5c:	0e 5f       	subi	r16, 0xFE	; 254
    1a5e:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1a60:	33 e0       	ldi	r19, 0x03	; 3
    1a62:	c3 2e       	mov	r12, r19
    1a64:	32 e0       	ldi	r19, 0x02	; 2
    1a66:	d3 2e       	mov	r13, r19
    1a68:	c6 0e       	add	r12, r22
    1a6a:	d7 1e       	adc	r13, r23
    1a6c:	f6 01       	movw	r30, r12
    1a6e:	80 81       	ld	r24, Z
    1a70:	88 23       	and	r24, r24
    1a72:	09 f4       	brne	.+2      	; 0x1a76 <Webserver_ApplicationCallback+0x34>
    1a74:	68 c0       	rjmp	.+208    	; 0x1b46 <Webserver_ApplicationCallback+0x104>
    1a76:	22 e0       	ldi	r18, 0x02	; 2
    1a78:	e2 2e       	mov	r14, r18
    1a7a:	f2 2e       	mov	r15, r18
    1a7c:	e6 0e       	add	r14, r22
    1a7e:	f7 1e       	adc	r15, r23
    1a80:	f7 01       	movw	r30, r14
    1a82:	80 81       	ld	r24, Z
    1a84:	88 23       	and	r24, r24
    1a86:	09 f0       	breq	.+2      	; 0x1a8a <Webserver_ApplicationCallback+0x48>
    1a88:	a9 c0       	rjmp	.+338    	; 0x1bdc <Webserver_ApplicationCallback+0x19a>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1a8a:	c8 01       	movw	r24, r16
    1a8c:	61 ed       	ldi	r22, 0xD1	; 209
    1a8e:	71 e0       	ldi	r23, 0x01	; 1
    1a90:	c8 df       	rcall	.-112    	; 0x1a22 <IsHTTPCommand>
    1a92:	88 23       	and	r24, r24
    1a94:	09 f1       	breq	.+66     	; 0x1ad8 <Webserver_ApplicationCallback+0x96>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1a96:	c8 01       	movw	r24, r16
    1a98:	65 ed       	ldi	r22, 0xD5	; 213
    1a9a:	71 e0       	ldi	r23, 0x01	; 1
    1a9c:	c2 df       	rcall	.-124    	; 0x1a22 <IsHTTPCommand>
    1a9e:	88 23       	and	r24, r24
    1aa0:	59 f1       	breq	.+86     	; 0x1af8 <Webserver_ApplicationCallback+0xb6>
			{
				PageBlock = 0;
    1aa2:	10 92 b4 0d 	sts	0x0DB4, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1aa6:	c8 01       	movw	r24, r16
    1aa8:	60 e3       	ldi	r22, 0x30	; 48
    1aaa:	71 e0       	ldi	r23, 0x01	; 1
    1aac:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1ab0:	81 e0       	ldi	r24, 0x01	; 1
    1ab2:	f7 01       	movw	r30, r14
    1ab4:	80 83       	st	Z, r24
    1ab6:	f8 01       	movw	r30, r16
    1ab8:	01 90       	ld	r0, Z+
    1aba:	00 20       	and	r0, r0
    1abc:	e9 f7       	brne	.-6      	; 0x1ab8 <Webserver_ApplicationCallback+0x76>
    1abe:	31 97       	sbiw	r30, 0x01	; 1
    1ac0:	e0 1b       	sub	r30, r16
    1ac2:	f1 0b       	sbc	r31, r17
    1ac4:	f9 83       	std	Y+1, r31	; 0x01
    1ac6:	e8 83       	st	Y, r30
    1ac8:	f6 01       	movw	r30, r12
    1aca:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1acc:	f7 01       	movw	r30, r14
    1ace:	80 83       	st	Z, r24
    1ad0:	cc 5f       	subi	r28, 0xFC	; 252
    1ad2:	dd 4f       	sbci	r29, 0xFD	; 253
    1ad4:	88 83       	st	Y, r24
    1ad6:	82 c0       	rjmp	.+260    	; 0x1bdc <Webserver_ApplicationCallback+0x19a>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1ad8:	c8 01       	movw	r24, r16
    1ada:	6c ed       	ldi	r22, 0xDC	; 220
    1adc:	71 e0       	ldi	r23, 0x01	; 1
    1ade:	a1 df       	rcall	.-190    	; 0x1a22 <IsHTTPCommand>
    1ae0:	88 23       	and	r24, r24
    1ae2:	11 f1       	breq	.+68     	; 0x1b28 <Webserver_ApplicationCallback+0xe6>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1ae4:	c8 01       	movw	r24, r16
    1ae6:	61 ee       	ldi	r22, 0xE1	; 225
    1ae8:	71 e0       	ldi	r23, 0x01	; 1
    1aea:	9b df       	rcall	.-202    	; 0x1a22 <IsHTTPCommand>
    1aec:	88 23       	and	r24, r24
    1aee:	21 f0       	breq	.+8      	; 0x1af8 <Webserver_ApplicationCallback+0xb6>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1af0:	c8 01       	movw	r24, r16
    1af2:	60 e3       	ldi	r22, 0x30	; 48
    1af4:	71 e0       	ldi	r23, 0x01	; 1
    1af6:	03 c0       	rjmp	.+6      	; 0x1afe <Webserver_ApplicationCallback+0xbc>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1af8:	c8 01       	movw	r24, r16
    1afa:	64 e8       	ldi	r22, 0x84	; 132
    1afc:	71 e0       	ldi	r23, 0x01	; 1
    1afe:	0e 94 5b 17 	call	0x2eb6	; 0x2eb6 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1b02:	81 e0       	ldi	r24, 0x01	; 1
    1b04:	f7 01       	movw	r30, r14
    1b06:	80 83       	st	Z, r24
    1b08:	f8 01       	movw	r30, r16
    1b0a:	01 90       	ld	r0, Z+
    1b0c:	00 20       	and	r0, r0
    1b0e:	e9 f7       	brne	.-6      	; 0x1b0a <Webserver_ApplicationCallback+0xc8>
    1b10:	31 97       	sbiw	r30, 0x01	; 1
    1b12:	e0 1b       	sub	r30, r16
    1b14:	f1 0b       	sbc	r31, r17
    1b16:	f9 83       	std	Y+1, r31	; 0x01
    1b18:	e8 83       	st	Y, r30
    1b1a:	f6 01       	movw	r30, r12
    1b1c:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1b1e:	85 e1       	ldi	r24, 0x15	; 21
    1b20:	92 e0       	ldi	r25, 0x02	; 2
    1b22:	a8 0e       	add	r10, r24
    1b24:	b9 1e       	adc	r11, r25
    1b26:	57 c0       	rjmp	.+174    	; 0x1bd6 <Webserver_ApplicationCallback+0x194>
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1b28:	c8 01       	movw	r24, r16
    1b2a:	69 ee       	ldi	r22, 0xE9	; 233
    1b2c:	71 e0       	ldi	r23, 0x01	; 1
    1b2e:	79 df       	rcall	.-270    	; 0x1a22 <IsHTTPCommand>
    1b30:	88 23       	and	r24, r24
    1b32:	21 f0       	breq	.+8      	; 0x1b3c <Webserver_ApplicationCallback+0xfa>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	f7 01       	movw	r30, r14
    1b38:	80 83       	st	Z, r24
    1b3a:	ef cf       	rjmp	.-34     	; 0x1b1a <Webserver_ApplicationCallback+0xd8>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1b3c:	f6 01       	movw	r30, r12
    1b3e:	10 82       	st	Z, r1
    1b40:	19 82       	std	Y+1, r1	; 0x01
    1b42:	18 82       	st	Y, r1
    1b44:	4b c0       	rjmp	.+150    	; 0x1bdc <Webserver_ApplicationCallback+0x19a>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1b46:	cc 5f       	subi	r28, 0xFC	; 252
    1b48:	dd 4f       	sbci	r29, 0xFD	; 253
    1b4a:	88 81       	ld	r24, Y
    1b4c:	c4 50       	subi	r28, 0x04	; 4
    1b4e:	d2 40       	sbci	r29, 0x02	; 2
    1b50:	88 23       	and	r24, r24
    1b52:	09 f4       	brne	.+2      	; 0x1b56 <Webserver_ApplicationCallback+0x114>
    1b54:	43 c0       	rjmp	.+134    	; 0x1bdc <Webserver_ApplicationCallback+0x19a>
    1b56:	ce 5f       	subi	r28, 0xFE	; 254
    1b58:	dd 4f       	sbci	r29, 0xFD	; 253
    1b5a:	88 81       	ld	r24, Y
    1b5c:	c2 50       	subi	r28, 0x02	; 2
    1b5e:	d2 40       	sbci	r29, 0x02	; 2
    1b60:	88 23       	and	r24, r24
    1b62:	e1 f1       	breq	.+120    	; 0x1bdc <Webserver_ApplicationCallback+0x19a>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1b64:	80 91 b4 0d 	lds	r24, 0x0DB4
    1b68:	c8 2e       	mov	r12, r24
    1b6a:	dd 24       	eor	r13, r13
    1b6c:	d6 94       	lsr	r13
    1b6e:	dc 2c       	mov	r13, r12
    1b70:	cc 24       	eor	r12, r12
    1b72:	d7 94       	ror	r13
    1b74:	c7 94       	ror	r12
    1b76:	86 ec       	ldi	r24, 0xC6	; 198
    1b78:	91 e0       	ldi	r25, 0x01	; 1
    1b7a:	c8 0e       	add	r12, r24
    1b7c:	d9 1e       	adc	r13, r25
    1b7e:	c6 01       	movw	r24, r12
    1b80:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    1b84:	7c 01       	movw	r14, r24
    1b86:	91 e8       	ldi	r25, 0x81	; 129
    1b88:	e9 16       	cp	r14, r25
    1b8a:	f1 04       	cpc	r15, r1
    1b8c:	18 f0       	brcs	.+6      	; 0x1b94 <Webserver_ApplicationCallback+0x152>
    1b8e:	80 e8       	ldi	r24, 0x80	; 128
    1b90:	e8 2e       	mov	r14, r24
    1b92:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1b94:	c8 01       	movw	r24, r16
    1b96:	b6 01       	movw	r22, r12
    1b98:	a7 01       	movw	r20, r14
    1b9a:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1b9e:	ce 5f       	subi	r28, 0xFE	; 254
    1ba0:	dd 4f       	sbci	r29, 0xFD	; 253
    1ba2:	81 e0       	ldi	r24, 0x01	; 1
    1ba4:	88 83       	st	Y, r24
    1ba6:	c2 50       	subi	r28, 0x02	; 2
    1ba8:	d2 40       	sbci	r29, 0x02	; 2
    1baa:	f9 82       	std	Y+1, r15	; 0x01
    1bac:	e8 82       	st	Y, r14
    1bae:	cd 5f       	subi	r28, 0xFD	; 253
    1bb0:	dd 4f       	sbci	r29, 0xFD	; 253
    1bb2:	88 83       	st	Y, r24
    1bb4:	c3 50       	subi	r28, 0x03	; 3
    1bb6:	d2 40       	sbci	r29, 0x02	; 2

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1bb8:	80 91 b4 0d 	lds	r24, 0x0DB4
    1bbc:	8f 5f       	subi	r24, 0xFF	; 255
    1bbe:	80 93 b4 0d 	sts	0x0DB4, r24
    1bc2:	81 50       	subi	r24, 0x01	; 1
    1bc4:	83 30       	cpi	r24, 0x03	; 3
    1bc6:	51 f4       	brne	.+20     	; 0x1bdc <Webserver_ApplicationCallback+0x19a>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1bc8:	cc 5f       	subi	r28, 0xFC	; 252
    1bca:	dd 4f       	sbci	r29, 0xFD	; 253
    1bcc:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1bce:	e5 e1       	ldi	r30, 0x15	; 21
    1bd0:	f2 e0       	ldi	r31, 0x02	; 2
    1bd2:	ae 0e       	add	r10, r30
    1bd4:	bf 1e       	adc	r11, r31
    1bd6:	87 e0       	ldi	r24, 0x07	; 7
    1bd8:	f5 01       	movw	r30, r10
    1bda:	80 83       	st	Z, r24
		}
	}
}
    1bdc:	df 91       	pop	r29
    1bde:	cf 91       	pop	r28
    1be0:	1f 91       	pop	r17
    1be2:	0f 91       	pop	r16
    1be4:	ff 90       	pop	r15
    1be6:	ef 90       	pop	r14
    1be8:	df 90       	pop	r13
    1bea:	cf 90       	pop	r12
    1bec:	bf 90       	pop	r11
    1bee:	af 90       	pop	r10
    1bf0:	08 95       	ret

00001bf2 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1bf2:	80 e0       	ldi	r24, 0x00	; 0
    1bf4:	90 e5       	ldi	r25, 0x50	; 80
    1bf6:	61 e0       	ldi	r22, 0x01	; 1
    1bf8:	41 e2       	ldi	r20, 0x21	; 33
    1bfa:	5d e0       	ldi	r21, 0x0D	; 13
    1bfc:	0c 94 00 04 	jmp	0x800	; 0x800 <TCP_SetPortState>

00001c00 <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
    1c00:	38 2f       	mov	r19, r24
    1c02:	28 2f       	mov	r18, r24
    1c04:	2c c0       	rjmp	.+88     	; 0x1c5e <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1c06:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);
		
		if (EPNum == Number)
    1c0a:	23 17       	cp	r18, r19
    1c0c:	21 f4       	brne	.+8      	; 0x1c16 <Endpoint_ConfigureEndpoint_Prv+0x16>
    1c0e:	76 2f       	mov	r23, r22
    1c10:	94 2f       	mov	r25, r20
    1c12:	50 e0       	ldi	r21, 0x00	; 0
    1c14:	06 c0       	rjmp	.+12     	; 0x1c22 <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    1c16:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    1c1a:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
    1c1e:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    1c22:	91 ff       	sbrs	r25, 1
    1c24:	1b c0       	rjmp	.+54     	; 0x1c5c <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1c26:	80 91 eb 00 	lds	r24, 0x00EB
    1c2a:	8e 7f       	andi	r24, 0xFE	; 254
    1c2c:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    1c30:	80 91 ed 00 	lds	r24, 0x00ED
    1c34:	8d 7f       	andi	r24, 0xFD	; 253
    1c36:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1c3a:	80 91 eb 00 	lds	r24, 0x00EB
    1c3e:	81 60       	ori	r24, 0x01	; 1
    1c40:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    1c44:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    1c48:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
    1c4c:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1c50:	80 91 ee 00 	lds	r24, 0x00EE
			
		if (!(Endpoint_IsConfigured()))
    1c54:	87 fd       	sbrc	r24, 7
    1c56:	02 c0       	rjmp	.+4      	; 0x1c5c <Endpoint_ConfigureEndpoint_Prv+0x5c>
    1c58:	80 e0       	ldi	r24, 0x00	; 0
    1c5a:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else	
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1c5c:	2f 5f       	subi	r18, 0xFF	; 255
    1c5e:	27 30       	cpi	r18, 0x07	; 7
    1c60:	90 f2       	brcs	.-92     	; 0x1c06 <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1c62:	30 93 e9 00 	sts	0x00E9, r19
    1c66:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    1c68:	08 95       	ret

00001c6a <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1c6a:	80 91 01 14 	lds	r24, 0x1401
    1c6e:	88 23       	and	r24, r24
    1c70:	9c f4       	brge	.+38     	; 0x1c98 <Endpoint_ClearStatusStage+0x2e>
    1c72:	04 c0       	rjmp	.+8      	; 0x1c7c <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c74:	80 91 00 14 	lds	r24, 0x1400
    1c78:	88 23       	and	r24, r24
    1c7a:	b9 f0       	breq	.+46     	; 0x1caa <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1c7c:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1c80:	82 ff       	sbrs	r24, 2
    1c82:	f8 cf       	rjmp	.-16     	; 0x1c74 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1c84:	80 91 e8 00 	lds	r24, 0x00E8
    1c88:	8b 77       	andi	r24, 0x7B	; 123
    1c8a:	80 93 e8 00 	sts	0x00E8, r24
    1c8e:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1c90:	80 91 00 14 	lds	r24, 0x1400
    1c94:	88 23       	and	r24, r24
    1c96:	49 f0       	breq	.+18     	; 0x1caa <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1c98:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1c9c:	80 ff       	sbrs	r24, 0
    1c9e:	f8 cf       	rjmp	.-16     	; 0x1c90 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1ca0:	80 91 e8 00 	lds	r24, 0x00E8
    1ca4:	8e 77       	andi	r24, 0x7E	; 126
    1ca6:	80 93 e8 00 	sts	0x00E8, r24
    1caa:	08 95       	ret

00001cac <Endpoint_WaitUntilReady>:
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1cac:	40 91 e4 00 	lds	r20, 0x00E4
    1cb0:	50 91 e5 00 	lds	r21, 0x00E5
    1cb4:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
    1cb6:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    1cba:	80 78       	andi	r24, 0x80	; 128
    1cbc:	80 38       	cpi	r24, 0x80	; 128
    1cbe:	29 f4       	brne	.+10     	; 0x1cca <Endpoint_WaitUntilReady+0x1e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1cc0:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
    1cc4:	80 ff       	sbrs	r24, 0
    1cc6:	05 c0       	rjmp	.+10     	; 0x1cd2 <Endpoint_WaitUntilReady+0x26>
    1cc8:	22 c0       	rjmp	.+68     	; 0x1d0e <Endpoint_WaitUntilReady+0x62>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1cca:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1cce:	82 fd       	sbrc	r24, 2
    1cd0:	1e c0       	rjmp	.+60     	; 0x1d0e <Endpoint_WaitUntilReady+0x62>
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1cd2:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1cd6:	88 23       	and	r24, r24
    1cd8:	11 f4       	brne	.+4      	; 0x1cde <Endpoint_WaitUntilReady+0x32>
    1cda:	82 e0       	ldi	r24, 0x02	; 2
    1cdc:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1cde:	85 30       	cpi	r24, 0x05	; 5
    1ce0:	11 f4       	brne	.+4      	; 0x1ce6 <Endpoint_WaitUntilReady+0x3a>
    1ce2:	83 e0       	ldi	r24, 0x03	; 3
    1ce4:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1ce6:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1cea:	85 ff       	sbrs	r24, 5
    1cec:	02 c0       	rjmp	.+4      	; 0x1cf2 <Endpoint_WaitUntilReady+0x46>
    1cee:	81 e0       	ldi	r24, 0x01	; 1
    1cf0:	08 95       	ret
    1cf2:	80 91 e4 00 	lds	r24, 0x00E4
    1cf6:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1cfa:	84 17       	cp	r24, r20
    1cfc:	95 07       	cpc	r25, r21
    1cfe:	d9 f2       	breq	.-74     	; 0x1cb6 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1d00:	22 23       	and	r18, r18
    1d02:	11 f4       	brne	.+4      	; 0x1d08 <Endpoint_WaitUntilReady+0x5c>
    1d04:	84 e0       	ldi	r24, 0x04	; 4
    1d06:	08 95       	ret
    1d08:	21 50       	subi	r18, 0x01	; 1
    1d0a:	ac 01       	movw	r20, r24
    1d0c:	d4 cf       	rjmp	.-88     	; 0x1cb6 <Endpoint_WaitUntilReady+0xa>
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1d10:	08 95       	ret

00001d12 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    1d12:	ef 92       	push	r14
    1d14:	ff 92       	push	r15
    1d16:	0f 93       	push	r16
    1d18:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1d1a:	4d d0       	rcall	.+154    	; 0x1db6 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1d1c:	54 d0       	rcall	.+168    	; 0x1dc6 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    1d1e:	08 ed       	ldi	r16, 0xD8	; 216
    1d20:	10 e0       	ldi	r17, 0x00	; 0
    1d22:	f8 01       	movw	r30, r16
    1d24:	80 81       	ld	r24, Z
    1d26:	8f 77       	andi	r24, 0x7F	; 127
    1d28:	80 83       	st	Z, r24
				USBCON |=  (1 << USBE);
    1d2a:	80 81       	ld	r24, Z
    1d2c:	80 68       	ori	r24, 0x80	; 128
    1d2e:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1d30:	80 81       	ld	r24, Z
    1d32:	8f 7d       	andi	r24, 0xDF	; 223
    1d34:	80 83       	st	Z, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    1d36:	e7 ed       	ldi	r30, 0xD7	; 215
    1d38:	f0 e0       	ldi	r31, 0x00	; 0
    1d3a:	80 81       	ld	r24, Z
    1d3c:	80 68       	ori	r24, 0x80	; 128
    1d3e:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1d40:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1d42:	10 92 00 14 	sts	0x1400, r1
	USB_Device_ConfigurationNumber  = 0;
    1d46:	10 92 fc 13 	sts	0x13FC, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1d4a:	10 92 fe 13 	sts	0x13FE, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1d4e:	10 92 fd 13 	sts	0x13FD, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1d52:	80 ee       	ldi	r24, 0xE0	; 224
    1d54:	e8 2e       	mov	r14, r24
    1d56:	f1 2c       	mov	r15, r1
    1d58:	f7 01       	movw	r30, r14
    1d5a:	80 81       	ld	r24, Z
    1d5c:	8b 7f       	andi	r24, 0xFB	; 251
    1d5e:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    1d60:	f8 01       	movw	r30, r16
    1d62:	80 81       	ld	r24, Z
    1d64:	81 60       	ori	r24, 0x01	; 1
    1d66:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    1d68:	80 e0       	ldi	r24, 0x00	; 0
    1d6a:	60 e0       	ldi	r22, 0x00	; 0
    1d6c:	42 e0       	ldi	r20, 0x02	; 2
    1d6e:	48 df       	rcall	.-368    	; 0x1c00 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1d70:	e1 ee       	ldi	r30, 0xE1	; 225
    1d72:	f0 e0       	ldi	r31, 0x00	; 0
    1d74:	80 81       	ld	r24, Z
    1d76:	8e 7f       	andi	r24, 0xFE	; 254
    1d78:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1d7a:	e2 ee       	ldi	r30, 0xE2	; 226
    1d7c:	f0 e0       	ldi	r31, 0x00	; 0
    1d7e:	80 81       	ld	r24, Z
    1d80:	81 60       	ori	r24, 0x01	; 1
    1d82:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1d84:	80 81       	ld	r24, Z
    1d86:	88 60       	ori	r24, 0x08	; 8
    1d88:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1d8a:	f7 01       	movw	r30, r14
    1d8c:	80 81       	ld	r24, Z
    1d8e:	8e 7f       	andi	r24, 0xFE	; 254
    1d90:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    1d92:	f8 01       	movw	r30, r16
    1d94:	80 81       	ld	r24, Z
    1d96:	80 61       	ori	r24, 0x10	; 16
    1d98:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1d9a:	1f 91       	pop	r17
    1d9c:	0f 91       	pop	r16
    1d9e:	ff 90       	pop	r15
    1da0:	ef 90       	pop	r14
    1da2:	08 95       	ret

00001da4 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    1da4:	e7 ed       	ldi	r30, 0xD7	; 215
    1da6:	f0 e0       	ldi	r31, 0x00	; 0
    1da8:	80 81       	ld	r24, Z
    1daa:	81 60       	ori	r24, 0x01	; 1
    1dac:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1dae:	81 e0       	ldi	r24, 0x01	; 1
    1db0:	80 93 ff 13 	sts	0x13FF, r24

	USB_ResetInterface();
}
    1db4:	ae cf       	rjmp	.-164    	; 0x1d12 <USB_ResetInterface>

00001db6 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1db6:	e8 ed       	ldi	r30, 0xD8	; 216
    1db8:	f0 e0       	ldi	r31, 0x00	; 0
    1dba:	80 81       	ld	r24, Z
    1dbc:	8c 7f       	andi	r24, 0xFC	; 252
    1dbe:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1dc0:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    1dc4:	08 95       	ret

00001dc6 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1dc6:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1dca:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    1dce:	08 95       	ret

00001dd0 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1dd0:	1f 92       	push	r1
    1dd2:	0f 92       	push	r0
    1dd4:	0f b6       	in	r0, 0x3f	; 63
    1dd6:	0f 92       	push	r0
    1dd8:	0b b6       	in	r0, 0x3b	; 59
    1dda:	0f 92       	push	r0
    1ddc:	11 24       	eor	r1, r1
    1dde:	2f 93       	push	r18
    1de0:	3f 93       	push	r19
    1de2:	4f 93       	push	r20
    1de4:	5f 93       	push	r21
    1de6:	6f 93       	push	r22
    1de8:	7f 93       	push	r23
    1dea:	8f 93       	push	r24
    1dec:	9f 93       	push	r25
    1dee:	af 93       	push	r26
    1df0:	bf 93       	push	r27
    1df2:	ef 93       	push	r30
    1df4:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1df6:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1dfa:	82 ff       	sbrs	r24, 2
    1dfc:	0a c0       	rjmp	.+20     	; 0x1e12 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    1dfe:	80 91 e2 00 	lds	r24, 0x00E2
    1e02:	82 ff       	sbrs	r24, 2
    1e04:	06 c0       	rjmp	.+12     	; 0x1e12 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1e06:	80 91 e1 00 	lds	r24, 0x00E1
    1e0a:	8b 7f       	andi	r24, 0xFB	; 251
    1e0c:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1e10:	d2 d3       	rcall	.+1956   	; 0x25b6 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1e12:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1e16:	80 ff       	sbrs	r24, 0
    1e18:	1f c0       	rjmp	.+62     	; 0x1e58 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1e1a:	80 91 d8 00 	lds	r24, 0x00D8
    1e1e:	80 ff       	sbrs	r24, 0
    1e20:	1b c0       	rjmp	.+54     	; 0x1e58 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    1e22:	80 91 da 00 	lds	r24, 0x00DA
    1e26:	8e 7f       	andi	r24, 0xFE	; 254
    1e28:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1e2c:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    1e30:	80 ff       	sbrs	r24, 0
    1e32:	0d c0       	rjmp	.+26     	; 0x1e4e <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1e34:	8c e0       	ldi	r24, 0x0C	; 12
    1e36:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1e38:	8e e0       	ldi	r24, 0x0E	; 14
    1e3a:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    1e3c:	09 b4       	in	r0, 0x29	; 41
    1e3e:	00 fe       	sbrs	r0, 0
    1e40:	fd cf       	rjmp	.-6      	; 0x1e3c <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    1e42:	81 e0       	ldi	r24, 0x01	; 1
    1e44:	80 93 00 14 	sts	0x1400, r24
			EVENT_USB_Device_Connect();
    1e48:	0e 94 30 02 	call	0x460	; 0x460 <EVENT_USB_Device_Connect>
    1e4c:	05 c0       	rjmp	.+10     	; 0x1e58 <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1e4e:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    1e50:	10 92 00 14 	sts	0x1400, r1
			EVENT_USB_Device_Disconnect();
    1e54:	0e 94 35 02 	call	0x46a	; 0x46a <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    1e58:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1e5c:	80 ff       	sbrs	r24, 0
    1e5e:	18 c0       	rjmp	.+48     	; 0x1e90 <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    1e60:	80 91 e2 00 	lds	r24, 0x00E2
    1e64:	80 ff       	sbrs	r24, 0
    1e66:	14 c0       	rjmp	.+40     	; 0x1e90 <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1e68:	80 91 e2 00 	lds	r24, 0x00E2
    1e6c:	8e 7f       	andi	r24, 0xFE	; 254
    1e6e:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1e72:	80 91 e2 00 	lds	r24, 0x00E2
    1e76:	80 61       	ori	r24, 0x10	; 16
    1e78:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    1e7c:	80 91 d8 00 	lds	r24, 0x00D8
    1e80:	80 62       	ori	r24, 0x20	; 32
    1e82:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1e86:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1e88:	85 e0       	ldi	r24, 0x05	; 5
    1e8a:	80 93 00 14 	sts	0x1400, r24
		EVENT_USB_Device_Suspend();
    1e8e:	93 d3       	rcall	.+1830   	; 0x25b6 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1e90:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1e94:	84 ff       	sbrs	r24, 4
    1e96:	2d c0       	rjmp	.+90     	; 0x1ef2 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1e98:	80 91 e2 00 	lds	r24, 0x00E2
    1e9c:	84 ff       	sbrs	r24, 4
    1e9e:	29 c0       	rjmp	.+82     	; 0x1ef2 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1ea0:	8c e0       	ldi	r24, 0x0C	; 12
    1ea2:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1ea4:	8e e0       	ldi	r24, 0x0E	; 14
    1ea6:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1ea8:	09 b4       	in	r0, 0x29	; 41
    1eaa:	00 fe       	sbrs	r0, 0
    1eac:	fd cf       	rjmp	.-6      	; 0x1ea8 <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1eae:	80 91 d8 00 	lds	r24, 0x00D8
    1eb2:	8f 7d       	andi	r24, 0xDF	; 223
    1eb4:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1eb8:	80 91 e1 00 	lds	r24, 0x00E1
    1ebc:	8f 7e       	andi	r24, 0xEF	; 239
    1ebe:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1ec2:	80 91 e2 00 	lds	r24, 0x00E2
    1ec6:	8f 7e       	andi	r24, 0xEF	; 239
    1ec8:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1ecc:	80 91 e2 00 	lds	r24, 0x00E2
    1ed0:	81 60       	ori	r24, 0x01	; 1
    1ed2:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    1ed6:	80 91 fc 13 	lds	r24, 0x13FC
    1eda:	88 23       	and	r24, r24
    1edc:	31 f4       	brne	.+12     	; 0x1eea <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1ede:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1ee2:	87 fd       	sbrc	r24, 7
    1ee4:	02 c0       	rjmp	.+4      	; 0x1eea <__vector_10+0x11a>
    1ee6:	81 e0       	ldi	r24, 0x01	; 1
    1ee8:	01 c0       	rjmp	.+2      	; 0x1eec <__vector_10+0x11c>
    1eea:	84 e0       	ldi	r24, 0x04	; 4
    1eec:	80 93 00 14 	sts	0x1400, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1ef0:	62 d3       	rcall	.+1732   	; 0x25b6 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1ef2:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1ef6:	83 ff       	sbrs	r24, 3
    1ef8:	22 c0       	rjmp	.+68     	; 0x1f3e <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1efa:	80 91 e2 00 	lds	r24, 0x00E2
    1efe:	83 ff       	sbrs	r24, 3
    1f00:	1e c0       	rjmp	.+60     	; 0x1f3e <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1f02:	80 91 e1 00 	lds	r24, 0x00E1
    1f06:	87 7f       	andi	r24, 0xF7	; 247
    1f08:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    1f0c:	82 e0       	ldi	r24, 0x02	; 2
    1f0e:	80 93 00 14 	sts	0x1400, r24
		USB_Device_ConfigurationNumber = 0;
    1f12:	10 92 fc 13 	sts	0x13FC, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1f16:	80 91 e1 00 	lds	r24, 0x00E1
    1f1a:	8e 7f       	andi	r24, 0xFE	; 254
    1f1c:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1f20:	80 91 e2 00 	lds	r24, 0x00E2
    1f24:	8e 7f       	andi	r24, 0xFE	; 254
    1f26:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1f2a:	80 91 e2 00 	lds	r24, 0x00E2
    1f2e:	80 61       	ori	r24, 0x10	; 16
    1f30:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    1f34:	80 e0       	ldi	r24, 0x00	; 0
    1f36:	60 e0       	ldi	r22, 0x00	; 0
    1f38:	42 e0       	ldi	r20, 0x02	; 2
    1f3a:	62 de       	rcall	.-828    	; 0x1c00 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1f3c:	3c d3       	rcall	.+1656   	; 0x25b6 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1f3e:	ff 91       	pop	r31
    1f40:	ef 91       	pop	r30
    1f42:	bf 91       	pop	r27
    1f44:	af 91       	pop	r26
    1f46:	9f 91       	pop	r25
    1f48:	8f 91       	pop	r24
    1f4a:	7f 91       	pop	r23
    1f4c:	6f 91       	pop	r22
    1f4e:	5f 91       	pop	r21
    1f50:	4f 91       	pop	r20
    1f52:	3f 91       	pop	r19
    1f54:	2f 91       	pop	r18
    1f56:	0f 90       	pop	r0
    1f58:	0b be       	out	0x3b, r0	; 59
    1f5a:	0f 90       	pop	r0
    1f5c:	0f be       	out	0x3f, r0	; 63
    1f5e:	0f 90       	pop	r0
    1f60:	1f 90       	pop	r1
    1f62:	18 95       	reti

00001f64 <Endpoint_Write_Control_Stream_LE>:
    1f64:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1f66:	40 91 07 14 	lds	r20, 0x1407
    1f6a:	50 91 08 14 	lds	r21, 0x1408
    1f6e:	46 17       	cp	r20, r22
    1f70:	57 07       	cpc	r21, r23
    1f72:	18 f4       	brcc	.+6      	; 0x1f7a <Endpoint_Write_Control_Stream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1f74:	f9 01       	movw	r30, r18
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	3d c0       	rjmp	.+122    	; 0x1ff4 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1f7a:	61 15       	cp	r22, r1
    1f7c:	71 05       	cpc	r23, r1
    1f7e:	11 f0       	breq	.+4      	; 0x1f84 <Endpoint_Write_Control_Stream_LE+0x20>
    1f80:	ab 01       	movw	r20, r22
    1f82:	f8 cf       	rjmp	.-16     	; 0x1f74 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1f84:	80 91 e8 00 	lds	r24, 0x00E8
    1f88:	8e 77       	andi	r24, 0x7E	; 126
    1f8a:	80 93 e8 00 	sts	0x00E8, r24
    1f8e:	40 e0       	ldi	r20, 0x00	; 0
    1f90:	50 e0       	ldi	r21, 0x00	; 0
    1f92:	f0 cf       	rjmp	.-32     	; 0x1f74 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f94:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f98:	88 23       	and	r24, r24
    1f9a:	f1 f1       	breq	.+124    	; 0x2018 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f9c:	85 30       	cpi	r24, 0x05	; 5
    1f9e:	f1 f1       	breq	.+124    	; 0x201c <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1fa0:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1fa4:	83 ff       	sbrs	r24, 3
    1fa6:	02 c0       	rjmp	.+4      	; 0x1fac <Endpoint_Write_Control_Stream_LE+0x48>
    1fa8:	81 e0       	ldi	r24, 0x01	; 1
    1faa:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1fac:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1fb0:	82 fd       	sbrc	r24, 2
    1fb2:	2c c0       	rjmp	.+88     	; 0x200c <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1fb4:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1fb8:	80 ff       	sbrs	r24, 0
    1fba:	1c c0       	rjmp	.+56     	; 0x1ff4 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    1fbc:	20 91 f2 00 	lds	r18, 0x00F2
    1fc0:	30 91 f3 00 	lds	r19, 0x00F3
    1fc4:	07 c0       	rjmp	.+14     	; 0x1fd4 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1fc6:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1fc8:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1fcc:	41 50       	subi	r20, 0x01	; 1
    1fce:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    1fd0:	2f 5f       	subi	r18, 0xFF	; 255
    1fd2:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1fd4:	41 15       	cp	r20, r1
    1fd6:	51 05       	cpc	r21, r1
    1fd8:	19 f0       	breq	.+6      	; 0x1fe0 <Endpoint_Write_Control_Stream_LE+0x7c>
    1fda:	28 30       	cpi	r18, 0x08	; 8
    1fdc:	31 05       	cpc	r19, r1
    1fde:	98 f3       	brcs	.-26     	; 0x1fc6 <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1fe0:	90 e0       	ldi	r25, 0x00	; 0
    1fe2:	28 30       	cpi	r18, 0x08	; 8
    1fe4:	31 05       	cpc	r19, r1
    1fe6:	09 f4       	brne	.+2      	; 0x1fea <Endpoint_Write_Control_Stream_LE+0x86>
    1fe8:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1fea:	80 91 e8 00 	lds	r24, 0x00E8
    1fee:	8e 77       	andi	r24, 0x7E	; 126
    1ff0:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1ff4:	41 15       	cp	r20, r1
    1ff6:	51 05       	cpc	r21, r1
    1ff8:	69 f6       	brne	.-102    	; 0x1f94 <Endpoint_Write_Control_Stream_LE+0x30>
    1ffa:	99 23       	and	r25, r25
    1ffc:	59 f6       	brne	.-106    	; 0x1f94 <Endpoint_Write_Control_Stream_LE+0x30>
    1ffe:	06 c0       	rjmp	.+12     	; 0x200c <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2000:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2004:	88 23       	and	r24, r24
    2006:	41 f0       	breq	.+16     	; 0x2018 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2008:	85 30       	cpi	r24, 0x05	; 5
    200a:	41 f0       	breq	.+16     	; 0x201c <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    200c:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2010:	82 ff       	sbrs	r24, 2
    2012:	f6 cf       	rjmp	.-20     	; 0x2000 <Endpoint_Write_Control_Stream_LE+0x9c>
    2014:	80 e0       	ldi	r24, 0x00	; 0
    2016:	08 95       	ret
    2018:	82 e0       	ldi	r24, 0x02	; 2
    201a:	08 95       	ret
    201c:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    201e:	08 95       	ret

00002020 <Endpoint_Read_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    2020:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    2022:	61 15       	cp	r22, r1
    2024:	71 05       	cpc	r23, r1
    2026:	29 f4       	brne	.+10     	; 0x2032 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2028:	80 91 e8 00 	lds	r24, 0x00E8
    202c:	8b 77       	andi	r24, 0x7B	; 123
    202e:	80 93 e8 00 	sts	0x00E8, r24
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2032:	f9 01       	movw	r30, r18
    2034:	22 c0       	rjmp	.+68     	; 0x207a <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2036:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    203a:	88 23       	and	r24, r24
    203c:	71 f1       	breq	.+92     	; 0x209a <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    203e:	85 30       	cpi	r24, 0x05	; 5
    2040:	71 f1       	breq	.+92     	; 0x209e <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2042:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2046:	83 ff       	sbrs	r24, 3
    2048:	02 c0       	rjmp	.+4      	; 0x204e <Endpoint_Read_Control_Stream_LE+0x2e>
    204a:	81 e0       	ldi	r24, 0x01	; 1
    204c:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    204e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    2052:	82 ff       	sbrs	r24, 2
    2054:	f0 cf       	rjmp	.-32     	; 0x2036 <Endpoint_Read_Control_Stream_LE+0x16>
    2056:	06 c0       	rjmp	.+12     	; 0x2064 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2058:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    205c:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    205e:	61 50       	subi	r22, 0x01	; 1
    2060:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    2062:	31 f0       	breq	.+12     	; 0x2070 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2064:	80 91 f2 00 	lds	r24, 0x00F2
    2068:	90 91 f3 00 	lds	r25, 0x00F3
    206c:	89 2b       	or	r24, r25
    206e:	a1 f7       	brne	.-24     	; 0x2058 <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2070:	80 91 e8 00 	lds	r24, 0x00E8
    2074:	8b 77       	andi	r24, 0x7B	; 123
    2076:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    207a:	61 15       	cp	r22, r1
    207c:	71 05       	cpc	r23, r1
    207e:	d9 f6       	brne	.-74     	; 0x2036 <Endpoint_Read_Control_Stream_LE+0x16>
    2080:	06 c0       	rjmp	.+12     	; 0x208e <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2082:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2086:	88 23       	and	r24, r24
    2088:	41 f0       	breq	.+16     	; 0x209a <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    208a:	85 30       	cpi	r24, 0x05	; 5
    208c:	41 f0       	breq	.+16     	; 0x209e <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    208e:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    2092:	80 ff       	sbrs	r24, 0
    2094:	f6 cf       	rjmp	.-20     	; 0x2082 <Endpoint_Read_Control_Stream_LE+0x62>
    2096:	80 e0       	ldi	r24, 0x00	; 0
    2098:	08 95       	ret
    209a:	82 e0       	ldi	r24, 0x02	; 2
    209c:	08 95       	ret
    209e:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    20a0:	08 95       	ret

000020a2 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    20a2:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    20a4:	40 91 07 14 	lds	r20, 0x1407
    20a8:	50 91 08 14 	lds	r21, 0x1408
    20ac:	46 17       	cp	r20, r22
    20ae:	57 07       	cpc	r21, r23
    20b0:	18 f4       	brcc	.+6      	; 0x20b8 <Endpoint_Write_Control_PStream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    20b2:	f9 01       	movw	r30, r18
    20b4:	90 e0       	ldi	r25, 0x00	; 0
    20b6:	40 c0       	rjmp	.+128    	; 0x2138 <__stack+0x39>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    20b8:	61 15       	cp	r22, r1
    20ba:	71 05       	cpc	r23, r1
    20bc:	11 f0       	breq	.+4      	; 0x20c2 <Endpoint_Write_Control_PStream_LE+0x20>
    20be:	ab 01       	movw	r20, r22
    20c0:	f8 cf       	rjmp	.-16     	; 0x20b2 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    20c2:	80 91 e8 00 	lds	r24, 0x00E8
    20c6:	8e 77       	andi	r24, 0x7E	; 126
    20c8:	80 93 e8 00 	sts	0x00E8, r24
    20cc:	40 e0       	ldi	r20, 0x00	; 0
    20ce:	50 e0       	ldi	r21, 0x00	; 0
    20d0:	f0 cf       	rjmp	.-32     	; 0x20b2 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    20d2:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    20d6:	88 23       	and	r24, r24
    20d8:	09 f4       	brne	.+2      	; 0x20dc <Endpoint_Write_Control_PStream_LE+0x3a>
    20da:	40 c0       	rjmp	.+128    	; 0x215c <__stack+0x5d>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    20dc:	85 30       	cpi	r24, 0x05	; 5
    20de:	09 f4       	brne	.+2      	; 0x20e2 <Endpoint_Write_Control_PStream_LE+0x40>
    20e0:	3f c0       	rjmp	.+126    	; 0x2160 <__stack+0x61>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    20e2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    20e6:	83 ff       	sbrs	r24, 3
    20e8:	02 c0       	rjmp	.+4      	; 0x20ee <Endpoint_Write_Control_PStream_LE+0x4c>
    20ea:	81 e0       	ldi	r24, 0x01	; 1
    20ec:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    20ee:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    20f2:	82 fd       	sbrc	r24, 2
    20f4:	2d c0       	rjmp	.+90     	; 0x2150 <__stack+0x51>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    20f6:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    20fa:	80 ff       	sbrs	r24, 0
    20fc:	1d c0       	rjmp	.+58     	; 0x2138 <__stack+0x39>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    20fe:	20 91 f2 00 	lds	r18, 0x00F2
    2102:	30 91 f3 00 	lds	r19, 0x00F3
    2106:	08 c0       	rjmp	.+16     	; 0x2118 <__stack+0x19>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2108:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    210a:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    210e:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    2110:	41 50       	subi	r20, 0x01	; 1
    2112:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    2114:	2f 5f       	subi	r18, 0xFF	; 255
    2116:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    2118:	41 15       	cp	r20, r1
    211a:	51 05       	cpc	r21, r1
    211c:	19 f0       	breq	.+6      	; 0x2124 <__stack+0x25>
    211e:	28 30       	cpi	r18, 0x08	; 8
    2120:	31 05       	cpc	r19, r1
    2122:	90 f3       	brcs	.-28     	; 0x2108 <__stack+0x9>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    2124:	90 e0       	ldi	r25, 0x00	; 0
    2126:	28 30       	cpi	r18, 0x08	; 8
    2128:	31 05       	cpc	r19, r1
    212a:	09 f4       	brne	.+2      	; 0x212e <__stack+0x2f>
    212c:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    212e:	80 91 e8 00 	lds	r24, 0x00E8
    2132:	8e 77       	andi	r24, 0x7E	; 126
    2134:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    2138:	41 15       	cp	r20, r1
    213a:	51 05       	cpc	r21, r1
    213c:	51 f6       	brne	.-108    	; 0x20d2 <Endpoint_Write_Control_PStream_LE+0x30>
    213e:	99 23       	and	r25, r25
    2140:	41 f6       	brne	.-112    	; 0x20d2 <Endpoint_Write_Control_PStream_LE+0x30>
    2142:	06 c0       	rjmp	.+12     	; 0x2150 <__stack+0x51>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2144:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2148:	88 23       	and	r24, r24
    214a:	41 f0       	breq	.+16     	; 0x215c <__stack+0x5d>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    214c:	85 30       	cpi	r24, 0x05	; 5
    214e:	41 f0       	breq	.+16     	; 0x2160 <__stack+0x61>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2150:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2154:	82 ff       	sbrs	r24, 2
    2156:	f6 cf       	rjmp	.-20     	; 0x2144 <__stack+0x45>
    2158:	80 e0       	ldi	r24, 0x00	; 0
    215a:	08 95       	ret
    215c:	82 e0       	ldi	r24, 0x02	; 2
    215e:	08 95       	ret
    2160:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2162:	08 95       	ret

00002164 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2164:	bf 92       	push	r11
    2166:	cf 92       	push	r12
    2168:	df 92       	push	r13
    216a:	ef 92       	push	r14
    216c:	ff 92       	push	r15
    216e:	0f 93       	push	r16
    2170:	1f 93       	push	r17
    2172:	cf 93       	push	r28
    2174:	df 93       	push	r29
    2176:	18 2f       	mov	r17, r24
    2178:	09 2f       	mov	r16, r25
    217a:	7b 01       	movw	r14, r22
    217c:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    217e:	96 dd       	rcall	.-1236   	; 0x1cac <Endpoint_WaitUntilReady>
    2180:	b8 2e       	mov	r11, r24
    2182:	88 23       	and	r24, r24
    2184:	b1 f5       	brne	.+108    	; 0x21f2 <Endpoint_Read_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2186:	81 2f       	mov	r24, r17
    2188:	90 2f       	mov	r25, r16
    218a:	9c 01       	movw	r18, r24
    218c:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    218e:	c1 14       	cp	r12, r1
    2190:	d1 04       	cpc	r13, r1
    2192:	39 f0       	breq	.+14     	; 0x21a2 <Endpoint_Read_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    2194:	f6 01       	movw	r30, r12
    2196:	80 81       	ld	r24, Z
    2198:	91 81       	ldd	r25, Z+1	; 0x01
    219a:	e8 1a       	sub	r14, r24
    219c:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    219e:	c8 0f       	add	r28, r24
    21a0:	d9 1f       	adc	r29, r25
    21a2:	00 e0       	ldi	r16, 0x00	; 0
    21a4:	10 e0       	ldi	r17, 0x00	; 0
    21a6:	22 c0       	rjmp	.+68     	; 0x21ec <Endpoint_Read_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    21a8:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    21ac:	85 fd       	sbrc	r24, 5
    21ae:	16 c0       	rjmp	.+44     	; 0x21dc <Endpoint_Read_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    21b0:	80 91 e8 00 	lds	r24, 0x00E8
    21b4:	8b 77       	andi	r24, 0x7B	; 123
    21b6:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    21ba:	c1 14       	cp	r12, r1
    21bc:	d1 04       	cpc	r13, r1
    21be:	49 f0       	breq	.+18     	; 0x21d2 <Endpoint_Read_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
    21c0:	f6 01       	movw	r30, r12
    21c2:	80 81       	ld	r24, Z
    21c4:	91 81       	ldd	r25, Z+1	; 0x01
    21c6:	80 0f       	add	r24, r16
    21c8:	91 1f       	adc	r25, r17
    21ca:	91 83       	std	Z+1, r25	; 0x01
    21cc:	80 83       	st	Z, r24
    21ce:	85 e0       	ldi	r24, 0x05	; 5
    21d0:	11 c0       	rjmp	.+34     	; 0x21f4 <Endpoint_Read_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    21d2:	f2 d1       	rcall	.+996    	; 0x25b8 <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    21d4:	6b dd       	rcall	.-1322   	; 0x1cac <Endpoint_WaitUntilReady>
    21d6:	88 23       	and	r24, r24
    21d8:	49 f0       	breq	.+18     	; 0x21ec <Endpoint_Read_Stream_LE+0x88>
    21da:	0c c0       	rjmp	.+24     	; 0x21f4 <Endpoint_Read_Stream_LE+0x90>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    21dc:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    21e0:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    21e2:	08 94       	sec
    21e4:	e1 08       	sbc	r14, r1
    21e6:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    21e8:	0f 5f       	subi	r16, 0xFF	; 255
    21ea:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    21ec:	e1 14       	cp	r14, r1
    21ee:	f1 04       	cpc	r15, r1
    21f0:	d9 f6       	brne	.-74     	; 0x21a8 <Endpoint_Read_Stream_LE+0x44>
    21f2:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    21f4:	df 91       	pop	r29
    21f6:	cf 91       	pop	r28
    21f8:	1f 91       	pop	r17
    21fa:	0f 91       	pop	r16
    21fc:	ff 90       	pop	r15
    21fe:	ef 90       	pop	r14
    2200:	df 90       	pop	r13
    2202:	cf 90       	pop	r12
    2204:	bf 90       	pop	r11
    2206:	08 95       	ret

00002208 <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2208:	bf 92       	push	r11
    220a:	cf 92       	push	r12
    220c:	df 92       	push	r13
    220e:	ef 92       	push	r14
    2210:	ff 92       	push	r15
    2212:	0f 93       	push	r16
    2214:	1f 93       	push	r17
    2216:	cf 93       	push	r28
    2218:	df 93       	push	r29
    221a:	18 2f       	mov	r17, r24
    221c:	09 2f       	mov	r16, r25
    221e:	7b 01       	movw	r14, r22
    2220:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2222:	44 dd       	rcall	.-1400   	; 0x1cac <Endpoint_WaitUntilReady>
    2224:	b8 2e       	mov	r11, r24
    2226:	88 23       	and	r24, r24
    2228:	b1 f5       	brne	.+108    	; 0x2296 <Endpoint_Write_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    222a:	81 2f       	mov	r24, r17
    222c:	90 2f       	mov	r25, r16
    222e:	9c 01       	movw	r18, r24
    2230:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2232:	c1 14       	cp	r12, r1
    2234:	d1 04       	cpc	r13, r1
    2236:	39 f0       	breq	.+14     	; 0x2246 <Endpoint_Write_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    2238:	f6 01       	movw	r30, r12
    223a:	80 81       	ld	r24, Z
    223c:	91 81       	ldd	r25, Z+1	; 0x01
    223e:	e8 1a       	sub	r14, r24
    2240:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2242:	c8 0f       	add	r28, r24
    2244:	d9 1f       	adc	r29, r25
    2246:	00 e0       	ldi	r16, 0x00	; 0
    2248:	10 e0       	ldi	r17, 0x00	; 0
    224a:	22 c0       	rjmp	.+68     	; 0x2290 <Endpoint_Write_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    224c:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2250:	85 fd       	sbrc	r24, 5
    2252:	16 c0       	rjmp	.+44     	; 0x2280 <Endpoint_Write_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2254:	80 91 e8 00 	lds	r24, 0x00E8
    2258:	8e 77       	andi	r24, 0x7E	; 126
    225a:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    225e:	c1 14       	cp	r12, r1
    2260:	d1 04       	cpc	r13, r1
    2262:	49 f0       	breq	.+18     	; 0x2276 <Endpoint_Write_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
    2264:	f6 01       	movw	r30, r12
    2266:	80 81       	ld	r24, Z
    2268:	91 81       	ldd	r25, Z+1	; 0x01
    226a:	80 0f       	add	r24, r16
    226c:	91 1f       	adc	r25, r17
    226e:	91 83       	std	Z+1, r25	; 0x01
    2270:	80 83       	st	Z, r24
    2272:	85 e0       	ldi	r24, 0x05	; 5
    2274:	11 c0       	rjmp	.+34     	; 0x2298 <Endpoint_Write_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2276:	a0 d1       	rcall	.+832    	; 0x25b8 <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    2278:	19 dd       	rcall	.-1486   	; 0x1cac <Endpoint_WaitUntilReady>
    227a:	88 23       	and	r24, r24
    227c:	49 f0       	breq	.+18     	; 0x2290 <Endpoint_Write_Stream_LE+0x88>
    227e:	0c c0       	rjmp	.+24     	; 0x2298 <Endpoint_Write_Stream_LE+0x90>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2280:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2282:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    2286:	08 94       	sec
    2288:	e1 08       	sbc	r14, r1
    228a:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    228c:	0f 5f       	subi	r16, 0xFF	; 255
    228e:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    2290:	e1 14       	cp	r14, r1
    2292:	f1 04       	cpc	r15, r1
    2294:	d9 f6       	brne	.-74     	; 0x224c <Endpoint_Write_Stream_LE+0x44>
    2296:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2298:	df 91       	pop	r29
    229a:	cf 91       	pop	r28
    229c:	1f 91       	pop	r17
    229e:	0f 91       	pop	r16
    22a0:	ff 90       	pop	r15
    22a2:	ef 90       	pop	r14
    22a4:	df 90       	pop	r13
    22a6:	cf 90       	pop	r12
    22a8:	bf 90       	pop	r11
    22aa:	08 95       	ret

000022ac <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    22ac:	0f 93       	push	r16
    22ae:	1f 93       	push	r17
    22b0:	df 93       	push	r29
    22b2:	cf 93       	push	r28
    22b4:	cd b7       	in	r28, 0x3d	; 61
    22b6:	de b7       	in	r29, 0x3e	; 62
    22b8:	ac 97       	sbiw	r28, 0x2c	; 44
    22ba:	0f b6       	in	r0, 0x3f	; 63
    22bc:	f8 94       	cli
    22be:	de bf       	out	0x3e, r29	; 62
    22c0:	0f be       	out	0x3f, r0	; 63
    22c2:	cd bf       	out	0x3d, r28	; 61
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    22c4:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bmRequestType = Endpoint_Read_8();
    22c8:	80 93 01 14 	sts	0x1401, r24
    22cc:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
    22d0:	80 93 02 14 	sts	0x1402, r24
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    22d4:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    22d8:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
    22dc:	e3 e0       	ldi	r30, 0x03	; 3
    22de:	f4 e1       	ldi	r31, 0x14	; 20
    22e0:	80 93 03 14 	sts	0x1403, r24
    22e4:	90 93 04 14 	sts	0x1404, r25
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    22e8:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    22ec:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
    22f0:	80 93 05 14 	sts	0x1405, r24
    22f4:	93 83       	std	Z+3, r25	; 0x03
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    22f6:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    22fa:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
    22fe:	80 93 07 14 	sts	0x1407, r24
    2302:	95 83       	std	Z+5, r25	; 0x05

	EVENT_USB_Device_ControlRequest();
    2304:	0e 94 3a 02 	call	0x474	; 0x474 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2308:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    230c:	83 ff       	sbrs	r24, 3
    230e:	3a c1       	rjmp	.+628    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    2310:	80 91 01 14 	lds	r24, 0x1401

		switch (USB_ControlRequest.bRequest)
    2314:	30 91 02 14 	lds	r19, 0x1402
    2318:	35 30       	cpi	r19, 0x05	; 5
    231a:	09 f4       	brne	.+2      	; 0x231e <USB_Device_ProcessControlRequest+0x72>
    231c:	87 c0       	rjmp	.+270    	; 0x242c <USB_Device_ProcessControlRequest+0x180>
    231e:	36 30       	cpi	r19, 0x06	; 6
    2320:	40 f4       	brcc	.+16     	; 0x2332 <USB_Device_ProcessControlRequest+0x86>
    2322:	31 30       	cpi	r19, 0x01	; 1
    2324:	c9 f1       	breq	.+114    	; 0x2398 <USB_Device_ProcessControlRequest+0xec>
    2326:	31 30       	cpi	r19, 0x01	; 1
    2328:	70 f0       	brcs	.+28     	; 0x2346 <USB_Device_ProcessControlRequest+0x9a>
    232a:	33 30       	cpi	r19, 0x03	; 3
    232c:	09 f0       	breq	.+2      	; 0x2330 <USB_Device_ProcessControlRequest+0x84>
    232e:	2a c1       	rjmp	.+596    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
    2330:	33 c0       	rjmp	.+102    	; 0x2398 <USB_Device_ProcessControlRequest+0xec>
    2332:	38 30       	cpi	r19, 0x08	; 8
    2334:	09 f4       	brne	.+2      	; 0x2338 <USB_Device_ProcessControlRequest+0x8c>
    2336:	f7 c0       	rjmp	.+494    	; 0x2526 <USB_Device_ProcessControlRequest+0x27a>
    2338:	39 30       	cpi	r19, 0x09	; 9
    233a:	09 f4       	brne	.+2      	; 0x233e <USB_Device_ProcessControlRequest+0x92>
    233c:	06 c1       	rjmp	.+524    	; 0x254a <USB_Device_ProcessControlRequest+0x29e>
    233e:	36 30       	cpi	r19, 0x06	; 6
    2340:	09 f0       	breq	.+2      	; 0x2344 <USB_Device_ProcessControlRequest+0x98>
    2342:	20 c1       	rjmp	.+576    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
    2344:	97 c0       	rjmp	.+302    	; 0x2474 <USB_Device_ProcessControlRequest+0x1c8>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2346:	80 38       	cpi	r24, 0x80	; 128
    2348:	21 f0       	breq	.+8      	; 0x2352 <USB_Device_ProcessControlRequest+0xa6>
    234a:	82 38       	cpi	r24, 0x82	; 130
    234c:	09 f0       	breq	.+2      	; 0x2350 <USB_Device_ProcessControlRequest+0xa4>
    234e:	1a c1       	rjmp	.+564    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
    2350:	08 c0       	rjmp	.+16     	; 0x2362 <USB_Device_ProcessControlRequest+0xb6>
    2352:	90 91 fd 13 	lds	r25, 0x13FD
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    2356:	80 91 fe 13 	lds	r24, 0x13FE
    235a:	88 23       	and	r24, r24
    235c:	99 f0       	breq	.+38     	; 0x2384 <USB_Device_ProcessControlRequest+0xd8>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    235e:	92 60       	ori	r25, 0x02	; 2
    2360:	11 c0       	rjmp	.+34     	; 0x2384 <USB_Device_ProcessControlRequest+0xd8>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2362:	80 91 05 14 	lds	r24, 0x1405
    2366:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2368:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    236c:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    2370:	90 e0       	ldi	r25, 0x00	; 0
    2372:	25 e0       	ldi	r18, 0x05	; 5
    2374:	96 95       	lsr	r25
    2376:	87 95       	ror	r24
    2378:	2a 95       	dec	r18
    237a:	e1 f7       	brne	.-8      	; 0x2374 <USB_Device_ProcessControlRequest+0xc8>
    237c:	98 2f       	mov	r25, r24
    237e:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2380:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2384:	80 91 e8 00 	lds	r24, 0x00E8
    2388:	87 7f       	andi	r24, 0xF7	; 247
    238a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    238e:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
    2392:	10 92 f1 00 	sts	0x00F1, r1
    2396:	d2 c0       	rjmp	.+420    	; 0x253c <USB_Device_ProcessControlRequest+0x290>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2398:	88 23       	and	r24, r24
    239a:	19 f0       	breq	.+6      	; 0x23a2 <USB_Device_ProcessControlRequest+0xf6>
    239c:	82 30       	cpi	r24, 0x02	; 2
    239e:	09 f0       	breq	.+2      	; 0x23a2 <USB_Device_ProcessControlRequest+0xf6>
    23a0:	f1 c0       	rjmp	.+482    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    23a2:	90 e0       	ldi	r25, 0x00	; 0
    23a4:	8f 71       	andi	r24, 0x1F	; 31
    23a6:	90 70       	andi	r25, 0x00	; 0
    23a8:	00 97       	sbiw	r24, 0x00	; 0
    23aa:	21 f0       	breq	.+8      	; 0x23b4 <USB_Device_ProcessControlRequest+0x108>
    23ac:	02 97       	sbiw	r24, 0x02	; 2
    23ae:	09 f0       	breq	.+2      	; 0x23b2 <USB_Device_ProcessControlRequest+0x106>
    23b0:	e9 c0       	rjmp	.+466    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
    23b2:	0c c0       	rjmp	.+24     	; 0x23cc <USB_Device_ProcessControlRequest+0x120>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    23b4:	80 91 03 14 	lds	r24, 0x1403
    23b8:	81 30       	cpi	r24, 0x01	; 1
    23ba:	09 f0       	breq	.+2      	; 0x23be <USB_Device_ProcessControlRequest+0x112>
    23bc:	e3 c0       	rjmp	.+454    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    23be:	10 92 fe 13 	sts	0x13FE, r1
    23c2:	33 30       	cpi	r19, 0x03	; 3
    23c4:	69 f5       	brne	.+90     	; 0x2420 <USB_Device_ProcessControlRequest+0x174>
    23c6:	80 93 fe 13 	sts	0x13FE, r24
    23ca:	2a c0       	rjmp	.+84     	; 0x2420 <USB_Device_ProcessControlRequest+0x174>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    23cc:	80 91 03 14 	lds	r24, 0x1403
    23d0:	88 23       	and	r24, r24
    23d2:	31 f5       	brne	.+76     	; 0x2420 <USB_Device_ProcessControlRequest+0x174>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    23d4:	20 91 05 14 	lds	r18, 0x1405
    23d8:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    23da:	09 f4       	brne	.+2      	; 0x23de <USB_Device_ProcessControlRequest+0x132>
    23dc:	d3 c0       	rjmp	.+422    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    23de:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    23e2:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    23e6:	80 ff       	sbrs	r24, 0
    23e8:	1b c0       	rjmp	.+54     	; 0x2420 <USB_Device_ProcessControlRequest+0x174>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    23ea:	33 30       	cpi	r19, 0x03	; 3
    23ec:	21 f4       	brne	.+8      	; 0x23f6 <USB_Device_ProcessControlRequest+0x14a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    23ee:	80 91 eb 00 	lds	r24, 0x00EB
    23f2:	80 62       	ori	r24, 0x20	; 32
    23f4:	13 c0       	rjmp	.+38     	; 0x241c <USB_Device_ProcessControlRequest+0x170>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    23f6:	80 91 eb 00 	lds	r24, 0x00EB
    23fa:	80 61       	ori	r24, 0x10	; 16
    23fc:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    2400:	81 e0       	ldi	r24, 0x01	; 1
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	02 c0       	rjmp	.+4      	; 0x240a <USB_Device_ProcessControlRequest+0x15e>
    2406:	88 0f       	add	r24, r24
    2408:	99 1f       	adc	r25, r25
    240a:	2a 95       	dec	r18
    240c:	e2 f7       	brpl	.-8      	; 0x2406 <USB_Device_ProcessControlRequest+0x15a>
    240e:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    2412:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2416:	80 91 eb 00 	lds	r24, 0x00EB
    241a:	88 60       	ori	r24, 0x08	; 8
    241c:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2420:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2424:	80 91 e8 00 	lds	r24, 0x00E8
    2428:	87 7f       	andi	r24, 0xF7	; 247
    242a:	8b c0       	rjmp	.+278    	; 0x2542 <USB_Device_ProcessControlRequest+0x296>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    242c:	88 23       	and	r24, r24
    242e:	09 f0       	breq	.+2      	; 0x2432 <USB_Device_ProcessControlRequest+0x186>
    2430:	a9 c0       	rjmp	.+338    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    2432:	10 91 03 14 	lds	r17, 0x1403
    2436:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2438:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    243a:	f8 94       	cli
    243c:	80 91 e8 00 	lds	r24, 0x00E8
    2440:	87 7f       	andi	r24, 0xF7	; 247
    2442:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    2446:	11 dc       	rcall	.-2014   	; 0x1c6a <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2448:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    244c:	80 ff       	sbrs	r24, 0
    244e:	fc cf       	rjmp	.-8      	; 0x2448 <USB_Device_ProcessControlRequest+0x19c>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2450:	80 91 e3 00 	lds	r24, 0x00E3
    2454:	80 78       	andi	r24, 0x80	; 128
    2456:	81 2b       	or	r24, r17

				UDADDR = Temp;
    2458:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR = Temp | (1 << ADDEN);
    245c:	80 68       	ori	r24, 0x80	; 128
    245e:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2462:	11 23       	and	r17, r17
    2464:	11 f4       	brne	.+4      	; 0x246a <USB_Device_ProcessControlRequest+0x1be>
    2466:	82 e0       	ldi	r24, 0x02	; 2
    2468:	01 c0       	rjmp	.+2      	; 0x246c <USB_Device_ProcessControlRequest+0x1c0>
    246a:	83 e0       	ldi	r24, 0x03	; 3
    246c:	80 93 00 14 	sts	0x1400, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2470:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    2472:	88 c0       	rjmp	.+272    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2474:	80 58       	subi	r24, 0x80	; 128
    2476:	82 30       	cpi	r24, 0x02	; 2
    2478:	08 f0       	brcs	.+2      	; 0x247c <USB_Device_ProcessControlRequest+0x1d0>
    247a:	84 c0       	rjmp	.+264    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    247c:	80 91 03 14 	lds	r24, 0x1403
    2480:	90 91 04 14 	lds	r25, 0x1404
    2484:	23 e0       	ldi	r18, 0x03	; 3
    2486:	8c 3d       	cpi	r24, 0xDC	; 220
    2488:	92 07       	cpc	r25, r18
    248a:	09 f0       	breq	.+2      	; 0x248e <USB_Device_ProcessControlRequest+0x1e2>
    248c:	33 c0       	rjmp	.+102    	; 0x24f4 <USB_Device_ProcessControlRequest+0x248>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    248e:	83 e0       	ldi	r24, 0x03	; 3
    2490:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    2492:	8a e2       	ldi	r24, 0x2A	; 42
    2494:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2496:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2498:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    249a:	de 01       	movw	r26, r28
    249c:	15 96       	adiw	r26, 0x05	; 5
    249e:	6e e0       	ldi	r22, 0x0E	; 14
    24a0:	40 e0       	ldi	r20, 0x00	; 0
    24a2:	50 e0       	ldi	r21, 0x00	; 0
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    24a4:	11 e2       	ldi	r17, 0x21	; 33
    24a6:	e6 2f       	mov	r30, r22
    24a8:	f0 e0       	ldi	r31, 0x00	; 0
    24aa:	10 93 57 00 	sts	0x0057, r17
    24ae:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
    24b0:	40 ff       	sbrs	r20, 0
    24b2:	03 c0       	rjmp	.+6      	; 0x24ba <USB_Device_ProcessControlRequest+0x20e>
					{
						SerialByte >>= 4;
    24b4:	82 95       	swap	r24
    24b6:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    24b8:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    24ba:	8f 70       	andi	r24, 0x0F	; 15
    24bc:	28 2f       	mov	r18, r24
    24be:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    24c0:	8a 30       	cpi	r24, 0x0A	; 10
    24c2:	18 f0       	brcs	.+6      	; 0x24ca <USB_Device_ProcessControlRequest+0x21e>
    24c4:	c9 01       	movw	r24, r18
    24c6:	c7 96       	adiw	r24, 0x37	; 55
    24c8:	02 c0       	rjmp	.+4      	; 0x24ce <USB_Device_ProcessControlRequest+0x222>
    24ca:	c9 01       	movw	r24, r18
    24cc:	c0 96       	adiw	r24, 0x30	; 48
    24ce:	8d 93       	st	X+, r24
    24d0:	9d 93       	st	X+, r25
    24d2:	4f 5f       	subi	r20, 0xFF	; 255
    24d4:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    24d6:	44 31       	cpi	r20, 0x14	; 20
    24d8:	51 05       	cpc	r21, r1
    24da:	29 f7       	brne	.-54     	; 0x24a6 <USB_Device_ProcessControlRequest+0x1fa>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    24dc:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    24de:	80 91 e8 00 	lds	r24, 0x00E8
    24e2:	87 7f       	andi	r24, 0xF7	; 247
    24e4:	80 93 e8 00 	sts	0x00E8, r24
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    24e8:	ce 01       	movw	r24, r28
    24ea:	03 96       	adiw	r24, 0x03	; 3
    24ec:	6a e2       	ldi	r22, 0x2A	; 42
    24ee:	70 e0       	ldi	r23, 0x00	; 0
    24f0:	39 dd       	rcall	.-1422   	; 0x1f64 <Endpoint_Write_Control_Stream_LE>
    24f2:	13 c0       	rjmp	.+38     	; 0x251a <USB_Device_ProcessControlRequest+0x26e>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    24f4:	60 91 05 14 	lds	r22, 0x1405
    24f8:	ae 01       	movw	r20, r28
    24fa:	4f 5f       	subi	r20, 0xFF	; 255
    24fc:	5f 4f       	sbci	r21, 0xFF	; 255
    24fe:	0e 94 d7 02 	call	0x5ae	; 0x5ae <CALLBACK_USB_GetDescriptor>
    2502:	bc 01       	movw	r22, r24
    2504:	00 97       	sbiw	r24, 0x00	; 0
    2506:	09 f4       	brne	.+2      	; 0x250a <USB_Device_ProcessControlRequest+0x25e>
    2508:	3d c0       	rjmp	.+122    	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
    250a:	80 91 e8 00 	lds	r24, 0x00E8
    250e:	87 7f       	andi	r24, 0xF7	; 247
    2510:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2514:	89 81       	ldd	r24, Y+1	; 0x01
    2516:	9a 81       	ldd	r25, Y+2	; 0x02
    2518:	c4 dd       	rcall	.-1144   	; 0x20a2 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    251a:	80 91 e8 00 	lds	r24, 0x00E8
    251e:	8b 77       	andi	r24, 0x7B	; 123
    2520:	80 93 e8 00 	sts	0x00E8, r24
    2524:	2f c0       	rjmp	.+94     	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    2526:	80 38       	cpi	r24, 0x80	; 128
    2528:	69 f5       	brne	.+90     	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    252a:	80 91 e8 00 	lds	r24, 0x00E8
    252e:	87 7f       	andi	r24, 0xF7	; 247
    2530:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2534:	80 91 fc 13 	lds	r24, 0x13FC
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2538:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    253c:	80 91 e8 00 	lds	r24, 0x00E8
    2540:	8e 77       	andi	r24, 0x7E	; 126
    2542:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2546:	91 db       	rcall	.-2270   	; 0x1c6a <Endpoint_ClearStatusStage>
    2548:	1d c0       	rjmp	.+58     	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    254a:	88 23       	and	r24, r24
    254c:	d9 f4       	brne	.+54     	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    254e:	90 91 03 14 	lds	r25, 0x1403
    2552:	92 30       	cpi	r25, 0x02	; 2
    2554:	b8 f4       	brcc	.+46     	; 0x2584 <USB_Device_ProcessControlRequest+0x2d8>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2556:	80 91 e8 00 	lds	r24, 0x00E8
    255a:	87 7f       	andi	r24, 0xF7	; 247
    255c:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2560:	90 93 fc 13 	sts	0x13FC, r25

	Endpoint_ClearStatusStage();
    2564:	82 db       	rcall	.-2300   	; 0x1c6a <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    2566:	80 91 fc 13 	lds	r24, 0x13FC
    256a:	88 23       	and	r24, r24
    256c:	31 f4       	brne	.+12     	; 0x257a <USB_Device_ProcessControlRequest+0x2ce>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    256e:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2572:	87 fd       	sbrc	r24, 7
    2574:	02 c0       	rjmp	.+4      	; 0x257a <USB_Device_ProcessControlRequest+0x2ce>
    2576:	81 e0       	ldi	r24, 0x01	; 1
    2578:	01 c0       	rjmp	.+2      	; 0x257c <USB_Device_ProcessControlRequest+0x2d0>
    257a:	84 e0       	ldi	r24, 0x04	; 4
    257c:	80 93 00 14 	sts	0x1400, r24

	EVENT_USB_Device_ConfigurationChanged();
    2580:	0e 94 3e 02 	call	0x47c	; 0x47c <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2584:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2588:	83 ff       	sbrs	r24, 3
    258a:	0a c0       	rjmp	.+20     	; 0x25a0 <USB_Device_ProcessControlRequest+0x2f4>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    258c:	80 91 eb 00 	lds	r24, 0x00EB
    2590:	80 62       	ori	r24, 0x20	; 32
    2592:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2596:	80 91 e8 00 	lds	r24, 0x00E8
    259a:	87 7f       	andi	r24, 0xF7	; 247
    259c:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    25a0:	ac 96       	adiw	r28, 0x2c	; 44
    25a2:	0f b6       	in	r0, 0x3f	; 63
    25a4:	f8 94       	cli
    25a6:	de bf       	out	0x3e, r29	; 62
    25a8:	0f be       	out	0x3f, r0	; 63
    25aa:	cd bf       	out	0x3d, r28	; 61
    25ac:	cf 91       	pop	r28
    25ae:	df 91       	pop	r29
    25b0:	1f 91       	pop	r17
    25b2:	0f 91       	pop	r16
    25b4:	08 95       	ret

000025b6 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    25b6:	08 95       	ret

000025b8 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    25b8:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    25ba:	80 91 00 14 	lds	r24, 0x1400
    25be:	88 23       	and	r24, r24
    25c0:	61 f0       	breq	.+24     	; 0x25da <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    25c2:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25c6:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    25ca:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    25ce:	83 ff       	sbrs	r24, 3
    25d0:	01 c0       	rjmp	.+2      	; 0x25d4 <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    25d2:	6c de       	rcall	.-808    	; 0x22ac <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    25d4:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25d6:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    25da:	1f 91       	pop	r17
    25dc:	08 95       	ret

000025de <RNDIS_Device_IsPacketReceived>:
			return false;
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    25de:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    25e0:	80 91 00 14 	lds	r24, 0x1400
    25e4:	84 30       	cpi	r24, 0x04	; 4
    25e6:	99 f4       	brne	.+38     	; 0x260e <RNDIS_Device_IsPacketReceived+0x30>
    25e8:	ea 56       	subi	r30, 0x6A	; 106
    25ea:	ff 4f       	sbci	r31, 0xFF	; 255
    25ec:	80 81       	ld	r24, Z
    25ee:	e6 59       	subi	r30, 0x96	; 150
    25f0:	f0 40       	sbci	r31, 0x00	; 0
    25f2:	82 30       	cpi	r24, 0x02	; 2
    25f4:	61 f4       	brne	.+24     	; 0x260e <RNDIS_Device_IsPacketReceived+0x30>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    25f6:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    25f8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    25fc:	80 91 e8 00 	lds	r24, 0x00E8
    2600:	90 e0       	ldi	r25, 0x00	; 0
    2602:	96 95       	lsr	r25
    2604:	87 95       	ror	r24
    2606:	96 95       	lsr	r25
    2608:	87 95       	ror	r24
    260a:	81 70       	andi	r24, 0x01	; 1
    260c:	08 95       	ret
	return Endpoint_IsOUTReceived();
    260e:	80 e0       	ldi	r24, 0x00	; 0
}
    2610:	08 95       	ret

00002612 <RNDIS_Device_SendPacket>:
}

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    2612:	cf 92       	push	r12
    2614:	df 92       	push	r13
    2616:	ff 92       	push	r15
    2618:	0f 93       	push	r16
    261a:	1f 93       	push	r17
    261c:	df 93       	push	r29
    261e:	cf 93       	push	r28
    2620:	cd b7       	in	r28, 0x3d	; 61
    2622:	de b7       	in	r29, 0x3e	; 62
    2624:	ac 97       	sbiw	r28, 0x2c	; 44
    2626:	0f b6       	in	r0, 0x3f	; 63
    2628:	f8 94       	cli
    262a:	de bf       	out	0x3e, r29	; 62
    262c:	0f be       	out	0x3f, r0	; 63
    262e:	cd bf       	out	0x3d, r28	; 61
    2630:	fc 01       	movw	r30, r24
    2632:	6b 01       	movw	r12, r22
    2634:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2636:	80 91 00 14 	lds	r24, 0x1400
    263a:	84 30       	cpi	r24, 0x04	; 4
    263c:	09 f0       	breq	.+2      	; 0x2640 <RNDIS_Device_SendPacket+0x2e>
    263e:	49 c0       	rjmp	.+146    	; 0x26d2 <RNDIS_Device_SendPacket+0xc0>
    2640:	ea 56       	subi	r30, 0x6A	; 106
    2642:	ff 4f       	sbci	r31, 0xFF	; 255
    2644:	80 81       	ld	r24, Z
    2646:	e6 59       	subi	r30, 0x96	; 150
    2648:	f0 40       	sbci	r31, 0x00	; 0
    264a:	82 30       	cpi	r24, 0x02	; 2
    264c:	09 f0       	breq	.+2      	; 0x2650 <RNDIS_Device_SendPacket+0x3e>
    264e:	41 c0       	rjmp	.+130    	; 0x26d2 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpointNumber);
    2650:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2652:	80 93 e9 00 	sts	0x00E9, r24

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    2656:	2a db       	rcall	.-2476   	; 0x1cac <Endpoint_WaitUntilReady>
    2658:	f8 2e       	mov	r15, r24
    265a:	88 23       	and	r24, r24
    265c:	e1 f5       	brne	.+120    	; 0x26d6 <RNDIS_Device_SendPacket+0xc4>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    265e:	fe 01       	movw	r30, r28
    2660:	31 96       	adiw	r30, 0x01	; 1
    2662:	8c e2       	ldi	r24, 0x2C	; 44
    2664:	df 01       	movw	r26, r30
    2666:	1d 92       	st	X+, r1
    2668:	8a 95       	dec	r24
    266a:	e9 f7       	brne	.-6      	; 0x2666 <RNDIS_Device_SendPacket+0x54>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	a0 e0       	ldi	r26, 0x00	; 0
    2672:	b0 e0       	ldi	r27, 0x00	; 0
    2674:	89 83       	std	Y+1, r24	; 0x01
    2676:	9a 83       	std	Y+2, r25	; 0x02
    2678:	ab 83       	std	Y+3, r26	; 0x03
    267a:	bc 83       	std	Y+4, r27	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    267c:	04 5d       	subi	r16, 0xD4	; 212
    267e:	1f 4f       	sbci	r17, 0xFF	; 255
    2680:	c8 01       	movw	r24, r16
    2682:	a0 e0       	ldi	r26, 0x00	; 0
    2684:	b0 e0       	ldi	r27, 0x00	; 0
    2686:	0c 52       	subi	r16, 0x2C	; 44
    2688:	10 40       	sbci	r17, 0x00	; 0
    268a:	8d 83       	std	Y+5, r24	; 0x05
    268c:	9e 83       	std	Y+6, r25	; 0x06
    268e:	af 83       	std	Y+7, r26	; 0x07
    2690:	b8 87       	std	Y+8, r27	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    2692:	84 e2       	ldi	r24, 0x24	; 36
    2694:	90 e0       	ldi	r25, 0x00	; 0
    2696:	a0 e0       	ldi	r26, 0x00	; 0
    2698:	b0 e0       	ldi	r27, 0x00	; 0
    269a:	89 87       	std	Y+9, r24	; 0x09
    269c:	9a 87       	std	Y+10, r25	; 0x0a
    269e:	ab 87       	std	Y+11, r26	; 0x0b
    26a0:	bc 87       	std	Y+12, r27	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    26a2:	c8 01       	movw	r24, r16
    26a4:	a0 e0       	ldi	r26, 0x00	; 0
    26a6:	b0 e0       	ldi	r27, 0x00	; 0
    26a8:	8d 87       	std	Y+13, r24	; 0x0d
    26aa:	9e 87       	std	Y+14, r25	; 0x0e
    26ac:	af 87       	std	Y+15, r26	; 0x0f
    26ae:	b8 8b       	std	Y+16, r27	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    26b0:	cf 01       	movw	r24, r30
    26b2:	6c e2       	ldi	r22, 0x2C	; 44
    26b4:	70 e0       	ldi	r23, 0x00	; 0
    26b6:	40 e0       	ldi	r20, 0x00	; 0
    26b8:	50 e0       	ldi	r21, 0x00	; 0
    26ba:	a6 dd       	rcall	.-1204   	; 0x2208 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    26bc:	c6 01       	movw	r24, r12
    26be:	b8 01       	movw	r22, r16
    26c0:	40 e0       	ldi	r20, 0x00	; 0
    26c2:	50 e0       	ldi	r21, 0x00	; 0
    26c4:	a1 dd       	rcall	.-1214   	; 0x2208 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    26c6:	80 91 e8 00 	lds	r24, 0x00E8
    26ca:	8e 77       	andi	r24, 0x7E	; 126
    26cc:	80 93 e8 00 	sts	0x00E8, r24
    26d0:	02 c0       	rjmp	.+4      	; 0x26d6 <RNDIS_Device_SendPacket+0xc4>
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    26d2:	32 e0       	ldi	r19, 0x02	; 2
    26d4:	f3 2e       	mov	r15, r19
}
    26d6:	8f 2d       	mov	r24, r15
    26d8:	ac 96       	adiw	r28, 0x2c	; 44
    26da:	0f b6       	in	r0, 0x3f	; 63
    26dc:	f8 94       	cli
    26de:	de bf       	out	0x3e, r29	; 62
    26e0:	0f be       	out	0x3f, r0	; 63
    26e2:	cd bf       	out	0x3d, r28	; 61
    26e4:	cf 91       	pop	r28
    26e6:	df 91       	pop	r29
    26e8:	1f 91       	pop	r17
    26ea:	0f 91       	pop	r16
    26ec:	ff 90       	pop	r15
    26ee:	df 90       	pop	r13
    26f0:	cf 90       	pop	r12
    26f2:	08 95       	ret

000026f4 <RNDIS_Device_USBTask>:

	return true;
}

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    26f4:	0f 93       	push	r16
    26f6:	1f 93       	push	r17
    26f8:	df 93       	push	r29
    26fa:	cf 93       	push	r28
    26fc:	cd b7       	in	r28, 0x3d	; 61
    26fe:	de b7       	in	r29, 0x3e	; 62
    2700:	28 97       	sbiw	r28, 0x08	; 8
    2702:	0f b6       	in	r0, 0x3f	; 63
    2704:	f8 94       	cli
    2706:	de bf       	out	0x3e, r29	; 62
    2708:	0f be       	out	0x3f, r0	; 63
    270a:	cd bf       	out	0x3d, r28	; 61
    270c:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    270e:	80 91 00 14 	lds	r24, 0x1400
    2712:	84 30       	cpi	r24, 0x04	; 4
    2714:	49 f5       	brne	.+82     	; 0x2768 <RNDIS_Device_USBTask+0x74>
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpointNumber);
    2716:	f8 01       	movw	r30, r16
    2718:	81 85       	ldd	r24, Z+9	; 0x09
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    271a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    271e:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    2722:	80 ff       	sbrs	r24, 0
    2724:	21 c0       	rjmp	.+66     	; 0x2768 <RNDIS_Device_USBTask+0x74>
    2726:	0b 56       	subi	r16, 0x6B	; 107
    2728:	1f 4f       	sbci	r17, 0xFF	; 255
    272a:	f8 01       	movw	r30, r16
    272c:	80 81       	ld	r24, Z
    272e:	05 59       	subi	r16, 0x95	; 149
    2730:	10 40       	sbci	r17, 0x00	; 0
    2732:	88 23       	and	r24, r24
    2734:	c9 f0       	breq	.+50     	; 0x2768 <RNDIS_Device_USBTask+0x74>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};
    2736:	de 01       	movw	r26, r28
    2738:	11 96       	adiw	r26, 0x01	; 1
    273a:	ef ee       	ldi	r30, 0xEF	; 239
    273c:	f1 e0       	ldi	r31, 0x01	; 1
    273e:	88 e0       	ldi	r24, 0x08	; 8
    2740:	01 90       	ld	r0, Z+
    2742:	0d 92       	st	X+, r0
    2744:	81 50       	subi	r24, 0x01	; 1
    2746:	e1 f7       	brne	.-8      	; 0x2740 <RNDIS_Device_USBTask+0x4c>

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    2748:	ce 01       	movw	r24, r28
    274a:	01 96       	adiw	r24, 0x01	; 1
    274c:	68 e0       	ldi	r22, 0x08	; 8
    274e:	70 e0       	ldi	r23, 0x00	; 0
    2750:	40 e0       	ldi	r20, 0x00	; 0
    2752:	50 e0       	ldi	r21, 0x00	; 0
    2754:	59 dd       	rcall	.-1358   	; 0x2208 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2756:	80 91 e8 00 	lds	r24, 0x00E8
    275a:	8e 77       	andi	r24, 0x7E	; 126
    275c:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    2760:	0b 56       	subi	r16, 0x6B	; 107
    2762:	1f 4f       	sbci	r17, 0xFF	; 255
    2764:	f8 01       	movw	r30, r16
    2766:	10 82       	st	Z, r1
	}
}
    2768:	28 96       	adiw	r28, 0x08	; 8
    276a:	0f b6       	in	r0, 0x3f	; 63
    276c:	f8 94       	cli
    276e:	de bf       	out	0x3e, r29	; 62
    2770:	0f be       	out	0x3f, r0	; 63
    2772:	cd bf       	out	0x3d, r28	; 61
    2774:	cf 91       	pop	r28
    2776:	df 91       	pop	r29
    2778:	1f 91       	pop	r17
    277a:	0f 91       	pop	r16
    277c:	08 95       	ret

0000277e <RNDIS_Device_ReadPacket>:
}

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    277e:	ef 92       	push	r14
    2780:	ff 92       	push	r15
    2782:	0f 93       	push	r16
    2784:	1f 93       	push	r17
    2786:	df 93       	push	r29
    2788:	cf 93       	push	r28
    278a:	cd b7       	in	r28, 0x3d	; 61
    278c:	de b7       	in	r29, 0x3e	; 62
    278e:	ac 97       	sbiw	r28, 0x2c	; 44
    2790:	0f b6       	in	r0, 0x3f	; 63
    2792:	f8 94       	cli
    2794:	de bf       	out	0x3e, r29	; 62
    2796:	0f be       	out	0x3f, r0	; 63
    2798:	cd bf       	out	0x3d, r28	; 61
    279a:	fc 01       	movw	r30, r24
    279c:	7b 01       	movw	r14, r22
    279e:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    27a0:	80 91 00 14 	lds	r24, 0x1400
    27a4:	84 30       	cpi	r24, 0x04	; 4
    27a6:	d1 f5       	brne	.+116    	; 0x281c <RNDIS_Device_ReadPacket+0x9e>
    27a8:	ea 56       	subi	r30, 0x6A	; 106
    27aa:	ff 4f       	sbci	r31, 0xFF	; 255
    27ac:	80 81       	ld	r24, Z
    27ae:	e6 59       	subi	r30, 0x96	; 150
    27b0:	f0 40       	sbci	r31, 0x00	; 0
    27b2:	82 30       	cpi	r24, 0x02	; 2
    27b4:	99 f5       	brne	.+102    	; 0x281c <RNDIS_Device_ReadPacket+0x9e>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    27b6:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    27b8:	80 93 e9 00 	sts	0x00E9, r24
	
	*PacketLength = 0;
    27bc:	fa 01       	movw	r30, r20
    27be:	11 82       	std	Z+1, r1	; 0x01
    27c0:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    27c2:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    27c6:	82 ff       	sbrs	r24, 2
    27c8:	27 c0       	rjmp	.+78     	; 0x2818 <RNDIS_Device_ReadPacket+0x9a>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;	
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    27ca:	ce 01       	movw	r24, r28
    27cc:	01 96       	adiw	r24, 0x01	; 1
    27ce:	6c e2       	ldi	r22, 0x2C	; 44
    27d0:	70 e0       	ldi	r23, 0x00	; 0
    27d2:	40 e0       	ldi	r20, 0x00	; 0
    27d4:	50 e0       	ldi	r21, 0x00	; 0
    27d6:	c6 dc       	rcall	.-1652   	; 0x2164 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    27d8:	2d 85       	ldd	r18, Y+13	; 0x0d
    27da:	3e 85       	ldd	r19, Y+14	; 0x0e
    27dc:	4f 85       	ldd	r20, Y+15	; 0x0f
    27de:	58 89       	ldd	r21, Y+16	; 0x10
    27e0:	2d 3d       	cpi	r18, 0xDD	; 221
    27e2:	f5 e0       	ldi	r31, 0x05	; 5
    27e4:	3f 07       	cpc	r19, r31
    27e6:	f0 e0       	ldi	r31, 0x00	; 0
    27e8:	4f 07       	cpc	r20, r31
    27ea:	f0 e0       	ldi	r31, 0x00	; 0
    27ec:	5f 07       	cpc	r21, r31
    27ee:	38 f0       	brcs	.+14     	; 0x27fe <RNDIS_Device_ReadPacket+0x80>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    27f0:	80 91 eb 00 	lds	r24, 0x00EB
    27f4:	80 62       	ori	r24, 0x20	; 32
    27f6:	80 93 eb 00 	sts	0x00EB, r24
    27fa:	80 e8       	ldi	r24, 0x80	; 128
    27fc:	10 c0       	rjmp	.+32     	; 0x281e <RNDIS_Device_ReadPacket+0xa0>
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
	}
	
	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    27fe:	f8 01       	movw	r30, r16
    2800:	31 83       	std	Z+1, r19	; 0x01
    2802:	20 83       	st	Z, r18

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    2804:	c7 01       	movw	r24, r14
    2806:	b9 01       	movw	r22, r18
    2808:	40 e0       	ldi	r20, 0x00	; 0
    280a:	50 e0       	ldi	r21, 0x00	; 0
    280c:	ab dc       	rcall	.-1706   	; 0x2164 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    280e:	80 91 e8 00 	lds	r24, 0x00E8
    2812:	8b 77       	andi	r24, 0x7B	; 123
    2814:	80 93 e8 00 	sts	0x00E8, r24
    2818:	80 e0       	ldi	r24, 0x00	; 0
    281a:	01 c0       	rjmp	.+2      	; 0x281e <RNDIS_Device_ReadPacket+0xa0>
	Endpoint_ClearOUT();
	
	return ENDPOINT_RWSTREAM_NoError;
    281c:	82 e0       	ldi	r24, 0x02	; 2
}
    281e:	ac 96       	adiw	r28, 0x2c	; 44
    2820:	0f b6       	in	r0, 0x3f	; 63
    2822:	f8 94       	cli
    2824:	de bf       	out	0x3e, r29	; 62
    2826:	0f be       	out	0x3f, r0	; 63
    2828:	cd bf       	out	0x3d, r28	; 61
    282a:	cf 91       	pop	r28
    282c:	df 91       	pop	r29
    282e:	1f 91       	pop	r17
    2830:	0f 91       	pop	r16
    2832:	ff 90       	pop	r15
    2834:	ef 90       	pop	r14
    2836:	08 95       	ret

00002838 <RNDIS_Device_ConfigureEndpoints>:
			break;
	}
}

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    2838:	1f 93       	push	r17
    283a:	cf 93       	push	r28
    283c:	df 93       	push	r29
    283e:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    2840:	45 96       	adiw	r24, 0x15	; 21
    2842:	fc 01       	movw	r30, r24
    2844:	86 e8       	ldi	r24, 0x86	; 134
    2846:	df 01       	movw	r26, r30
    2848:	1d 92       	st	X+, r1
    284a:	8a 95       	dec	r24
    284c:	e9 f7       	brne	.-6      	; 0x2848 <RNDIS_Device_ConfigureEndpoints+0x10>
    284e:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
    2850:	89 81       	ldd	r24, Y+1	; 0x01
    2852:	18 17       	cp	r17, r24
    2854:	29 f4       	brne	.+10     	; 0x2860 <RNDIS_Device_ConfigureEndpoints+0x28>
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
    2856:	6a 81       	ldd	r22, Y+2	; 0x02
    2858:	7b 81       	ldd	r23, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
    285a:	8c 81       	ldd	r24, Y+4	; 0x04
    285c:	52 e0       	ldi	r21, 0x02	; 2
    285e:	10 c0       	rjmp	.+32     	; 0x2880 <RNDIS_Device_ConfigureEndpoints+0x48>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
    2860:	8d 81       	ldd	r24, Y+5	; 0x05
    2862:	18 17       	cp	r17, r24
    2864:	31 f4       	brne	.+12     	; 0x2872 <RNDIS_Device_ConfigureEndpoints+0x3a>
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
    2866:	6e 81       	ldd	r22, Y+6	; 0x06
    2868:	7f 81       	ldd	r23, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    286a:	88 85       	ldd	r24, Y+8	; 0x08
    286c:	52 e0       	ldi	r21, 0x02	; 2
    286e:	30 e0       	ldi	r19, 0x00	; 0
    2870:	08 c0       	rjmp	.+16     	; 0x2882 <RNDIS_Device_ConfigureEndpoints+0x4a>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
    2872:	89 85       	ldd	r24, Y+9	; 0x09
    2874:	18 17       	cp	r17, r24
    2876:	39 f5       	brne	.+78     	; 0x28c6 <RNDIS_Device_ConfigureEndpoints+0x8e>
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
    2878:	6a 85       	ldd	r22, Y+10	; 0x0a
    287a:	7b 85       	ldd	r23, Y+11	; 0x0b
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_INTERRUPT;
			DoubleBanked = RNDISInterfaceInfo->Config.NotificationEndpointDoubleBank;
    287c:	8c 85       	ldd	r24, Y+12	; 0x0c
    287e:	53 e0       	ldi	r21, 0x03	; 3
    2880:	30 e8       	ldi	r19, 0x80	; 128
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    2882:	88 23       	and	r24, r24
    2884:	11 f4       	brne	.+4      	; 0x288a <RNDIS_Device_ConfigureEndpoints+0x52>
    2886:	40 e0       	ldi	r20, 0x00	; 0
    2888:	01 c0       	rjmp	.+2      	; 0x288c <RNDIS_Device_ConfigureEndpoints+0x54>
    288a:	44 e0       	ldi	r20, 0x04	; 4
    288c:	20 e0       	ldi	r18, 0x00	; 0
    288e:	88 e0       	ldi	r24, 0x08	; 8
    2890:	90 e0       	ldi	r25, 0x00	; 0
    2892:	03 c0       	rjmp	.+6      	; 0x289a <RNDIS_Device_ConfigureEndpoints+0x62>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    2894:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    2896:	88 0f       	add	r24, r24
    2898:	99 1f       	adc	r25, r25
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    289a:	86 17       	cp	r24, r22
    289c:	97 07       	cpc	r25, r23
    289e:	d0 f3       	brcs	.-12     	; 0x2894 <RNDIS_Device_ConfigureEndpoints+0x5c>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    28a0:	85 2f       	mov	r24, r21
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	56 e0       	ldi	r21, 0x06	; 6
    28a6:	88 0f       	add	r24, r24
    28a8:	99 1f       	adc	r25, r25
    28aa:	5a 95       	dec	r21
    28ac:	e1 f7       	brne	.-8      	; 0x28a6 <RNDIS_Device_ConfigureEndpoints+0x6e>
    28ae:	60 e0       	ldi	r22, 0x00	; 0
    28b0:	31 11       	cpse	r19, r1
    28b2:	61 e0       	ldi	r22, 0x01	; 1
    28b4:	68 2b       	or	r22, r24
    28b6:	42 60       	ori	r20, 0x02	; 2
    28b8:	22 95       	swap	r18
    28ba:	20 7f       	andi	r18, 0xF0	; 240
    28bc:	42 2b       	or	r20, r18
    28be:	81 2f       	mov	r24, r17
    28c0:	9f d9       	rcall	.-3266   	; 0x1c00 <Endpoint_ConfigureEndpoint_Prv>
    28c2:	88 23       	and	r24, r24
    28c4:	29 f0       	breq	.+10     	; 0x28d0 <RNDIS_Device_ConfigureEndpoints+0x98>

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    28c6:	1f 5f       	subi	r17, 0xFF	; 255
    28c8:	17 30       	cpi	r17, 0x07	; 7
    28ca:	09 f0       	breq	.+2      	; 0x28ce <RNDIS_Device_ConfigureEndpoints+0x96>
    28cc:	c1 cf       	rjmp	.-126    	; 0x2850 <RNDIS_Device_ConfigureEndpoints+0x18>
    28ce:	81 e0       	ldi	r24, 0x01	; 1
			return false;
		}
	}

	return true;
}
    28d0:	df 91       	pop	r29
    28d2:	cf 91       	pop	r28
    28d4:	1f 91       	pop	r17
    28d6:	08 95       	ret

000028d8 <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    28d8:	ef 92       	push	r14
    28da:	ff 92       	push	r15
    28dc:	0f 93       	push	r16
    28de:	1f 93       	push	r17
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    28e6:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    28ea:	83 ff       	sbrs	r24, 3
    28ec:	b6 c2       	rjmp	.+1388   	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    28ee:	88 81       	ld	r24, Y
    28f0:	90 e0       	ldi	r25, 0x00	; 0
    28f2:	20 91 05 14 	lds	r18, 0x1405
    28f6:	30 91 06 14 	lds	r19, 0x1406
    28fa:	28 17       	cp	r18, r24
    28fc:	39 07       	cpc	r19, r25
    28fe:	09 f0       	breq	.+2      	; 0x2902 <RNDIS_Device_ProcessControlRequest+0x2a>
    2900:	ac c2       	rjmp	.+1368   	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
	  return;

	switch (USB_ControlRequest.bRequest)
    2902:	80 91 02 14 	lds	r24, 0x1402
    2906:	88 23       	and	r24, r24
    2908:	21 f0       	breq	.+8      	; 0x2912 <RNDIS_Device_ProcessControlRequest+0x3a>
    290a:	81 30       	cpi	r24, 0x01	; 1
    290c:	09 f0       	breq	.+2      	; 0x2910 <RNDIS_Device_ProcessControlRequest+0x38>
    290e:	a5 c2       	rjmp	.+1354   	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
    2910:	57 c2       	rjmp	.+1198   	; 0x2dc0 <RNDIS_Device_ProcessControlRequest+0x4e8>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    2912:	80 91 01 14 	lds	r24, 0x1401
    2916:	81 32       	cpi	r24, 0x21	; 33
    2918:	09 f0       	breq	.+2      	; 0x291c <RNDIS_Device_ProcessControlRequest+0x44>
    291a:	9f c2       	rjmp	.+1342   	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    291c:	80 91 e8 00 	lds	r24, 0x00E8
    2920:	87 7f       	andi	r24, 0xF7	; 247
    2922:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    2926:	8e 01       	movw	r16, r28
    2928:	0b 5e       	subi	r16, 0xEB	; 235
    292a:	1f 4f       	sbci	r17, 0xFF	; 255
    292c:	60 91 07 14 	lds	r22, 0x1407
    2930:	70 91 08 14 	lds	r23, 0x1408
    2934:	c8 01       	movw	r24, r16
    2936:	74 db       	rcall	.-2328   	; 0x2020 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2938:	80 91 e8 00 	lds	r24, 0x00E8
    293c:	8e 77       	andi	r24, 0x7E	; 126
    293e:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    2942:	8d 89       	ldd	r24, Y+21	; 0x15
    2944:	9e 89       	ldd	r25, Y+22	; 0x16
    2946:	af 89       	ldd	r26, Y+23	; 0x17
    2948:	b8 8d       	ldd	r27, Y+24	; 0x18
    294a:	84 30       	cpi	r24, 0x04	; 4
    294c:	91 05       	cpc	r25, r1
    294e:	a1 05       	cpc	r26, r1
    2950:	b1 05       	cpc	r27, r1
    2952:	09 f4       	brne	.+2      	; 0x2956 <RNDIS_Device_ProcessControlRequest+0x7e>
    2954:	77 c0       	rjmp	.+238    	; 0x2a44 <RNDIS_Device_ProcessControlRequest+0x16c>
    2956:	85 30       	cpi	r24, 0x05	; 5
    2958:	91 05       	cpc	r25, r1
    295a:	a1 05       	cpc	r26, r1
    295c:	b1 05       	cpc	r27, r1
    295e:	58 f4       	brcc	.+22     	; 0x2976 <RNDIS_Device_ProcessControlRequest+0x9e>
    2960:	82 30       	cpi	r24, 0x02	; 2
    2962:	91 05       	cpc	r25, r1
    2964:	a1 05       	cpc	r26, r1
    2966:	b1 05       	cpc	r27, r1
    2968:	c1 f0       	breq	.+48     	; 0x299a <RNDIS_Device_ProcessControlRequest+0xc2>
    296a:	03 97       	sbiw	r24, 0x03	; 3
    296c:	a1 05       	cpc	r26, r1
    296e:	b1 05       	cpc	r27, r1
    2970:	09 f0       	breq	.+2      	; 0x2974 <RNDIS_Device_ProcessControlRequest+0x9c>
    2972:	73 c2       	rjmp	.+1254   	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
    2974:	5d c0       	rjmp	.+186    	; 0x2a30 <RNDIS_Device_ProcessControlRequest+0x158>
    2976:	86 30       	cpi	r24, 0x06	; 6
    2978:	91 05       	cpc	r25, r1
    297a:	a1 05       	cpc	r26, r1
    297c:	b1 05       	cpc	r27, r1
    297e:	09 f4       	brne	.+2      	; 0x2982 <RNDIS_Device_ProcessControlRequest+0xaa>
    2980:	e7 c1       	rjmp	.+974    	; 0x2d50 <RNDIS_Device_ProcessControlRequest+0x478>
    2982:	86 30       	cpi	r24, 0x06	; 6
    2984:	91 05       	cpc	r25, r1
    2986:	a1 05       	cpc	r26, r1
    2988:	b1 05       	cpc	r27, r1
    298a:	08 f4       	brcc	.+2      	; 0x298e <RNDIS_Device_ProcessControlRequest+0xb6>
    298c:	96 c1       	rjmp	.+812    	; 0x2cba <RNDIS_Device_ProcessControlRequest+0x3e2>
    298e:	08 97       	sbiw	r24, 0x08	; 8
    2990:	a1 05       	cpc	r26, r1
    2992:	b1 05       	cpc	r27, r1
    2994:	09 f0       	breq	.+2      	; 0x2998 <RNDIS_Device_ProcessControlRequest+0xc0>
    2996:	61 c2       	rjmp	.+1218   	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
    2998:	f7 c1       	rjmp	.+1006   	; 0x2d88 <RNDIS_Device_ProcessControlRequest+0x4b0>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    299a:	cb 56       	subi	r28, 0x6B	; 107
    299c:	df 4f       	sbci	r29, 0xFF	; 255
    299e:	21 e0       	ldi	r18, 0x01	; 1
    29a0:	28 83       	st	Y, r18
    29a2:	c5 59       	subi	r28, 0x95	; 149
    29a4:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    29a6:	82 e0       	ldi	r24, 0x02	; 2
    29a8:	90 e0       	ldi	r25, 0x00	; 0
    29aa:	a0 e0       	ldi	r26, 0x00	; 0
    29ac:	b0 e8       	ldi	r27, 0x80	; 128
    29ae:	8d 8b       	std	Y+21, r24	; 0x15
    29b0:	9e 8b       	std	Y+22, r25	; 0x16
    29b2:	af 8b       	std	Y+23, r26	; 0x17
    29b4:	b8 8f       	std	Y+24, r27	; 0x18
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    29b6:	84 e3       	ldi	r24, 0x34	; 52
    29b8:	90 e0       	ldi	r25, 0x00	; 0
    29ba:	a0 e0       	ldi	r26, 0x00	; 0
    29bc:	b0 e0       	ldi	r27, 0x00	; 0
    29be:	f8 01       	movw	r30, r16
    29c0:	84 83       	std	Z+4, r24	; 0x04
    29c2:	95 83       	std	Z+5, r25	; 0x05
    29c4:	a6 83       	std	Z+6, r26	; 0x06
    29c6:	b7 83       	std	Z+7, r27	; 0x07
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    29c8:	14 86       	std	Z+12, r1	; 0x0c
    29ca:	15 86       	std	Z+13, r1	; 0x0d
    29cc:	16 86       	std	Z+14, r1	; 0x0e
    29ce:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    29d0:	81 e0       	ldi	r24, 0x01	; 1
    29d2:	90 e0       	ldi	r25, 0x00	; 0
    29d4:	a0 e0       	ldi	r26, 0x00	; 0
    29d6:	b0 e0       	ldi	r27, 0x00	; 0
    29d8:	80 8b       	std	Z+16, r24	; 0x10
    29da:	91 8b       	std	Z+17, r25	; 0x11
    29dc:	a2 8b       	std	Z+18, r26	; 0x12
    29de:	b3 8b       	std	Z+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    29e0:	14 8a       	std	Z+20, r1	; 0x14
    29e2:	15 8a       	std	Z+21, r1	; 0x15
    29e4:	16 8a       	std	Z+22, r1	; 0x16
    29e6:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    29e8:	80 8f       	std	Z+24, r24	; 0x18
    29ea:	91 8f       	std	Z+25, r25	; 0x19
    29ec:	a2 8f       	std	Z+26, r26	; 0x1a
    29ee:	b3 8f       	std	Z+27, r27	; 0x1b
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    29f0:	14 8e       	std	Z+28, r1	; 0x1c
    29f2:	15 8e       	std	Z+29, r1	; 0x1d
    29f4:	16 8e       	std	Z+30, r1	; 0x1e
    29f6:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    29f8:	80 a3       	std	Z+32, r24	; 0x20
    29fa:	91 a3       	std	Z+33, r25	; 0x21
    29fc:	a2 a3       	std	Z+34, r26	; 0x22
    29fe:	b3 a3       	std	Z+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    2a00:	88 e0       	ldi	r24, 0x08	; 8
    2a02:	96 e0       	ldi	r25, 0x06	; 6
    2a04:	a0 e0       	ldi	r26, 0x00	; 0
    2a06:	b0 e0       	ldi	r27, 0x00	; 0
    2a08:	84 a3       	std	Z+36, r24	; 0x24
    2a0a:	95 a3       	std	Z+37, r25	; 0x25
    2a0c:	a6 a3       	std	Z+38, r26	; 0x26
    2a0e:	b7 a3       	std	Z+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    2a10:	10 a6       	std	Z+40, r1	; 0x28
    2a12:	11 a6       	std	Z+41, r1	; 0x29
    2a14:	12 a6       	std	Z+42, r1	; 0x2a
    2a16:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    2a18:	14 a6       	std	Z+44, r1	; 0x2c
    2a1a:	15 a6       	std	Z+45, r1	; 0x2d
    2a1c:	16 a6       	std	Z+46, r1	; 0x2e
    2a1e:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    2a20:	10 aa       	std	Z+48, r1	; 0x30
    2a22:	11 aa       	std	Z+49, r1	; 0x31
    2a24:	12 aa       	std	Z+50, r1	; 0x32
    2a26:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    2a28:	ca 56       	subi	r28, 0x6A	; 106
    2a2a:	df 4f       	sbci	r29, 0xFF	; 255
    2a2c:	28 83       	st	Y, r18
    2a2e:	15 c2       	rjmp	.+1066   	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    2a30:	cb 56       	subi	r28, 0x6B	; 107
    2a32:	df 4f       	sbci	r29, 0xFF	; 255
    2a34:	19 92       	st	Y+, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    2a36:	f8 01       	movw	r30, r16
    2a38:	14 82       	std	Z+4, r1	; 0x04
    2a3a:	15 82       	std	Z+5, r1	; 0x05
    2a3c:	16 82       	std	Z+6, r1	; 0x06
    2a3e:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    2a40:	18 82       	st	Y, r1
    2a42:	0b c2       	rjmp	.+1046   	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2a44:	cb 56       	subi	r28, 0x6B	; 107
    2a46:	df 4f       	sbci	r29, 0xFF	; 255
    2a48:	81 e0       	ldi	r24, 0x01	; 1
    2a4a:	88 83       	st	Y, r24
    2a4c:	c5 59       	subi	r28, 0x95	; 149
    2a4e:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    2a50:	f8 01       	movw	r30, r16
    2a52:	24 85       	ldd	r18, Z+12	; 0x0c
    2a54:	35 85       	ldd	r19, Z+13	; 0x0d
    2a56:	46 85       	ldd	r20, Z+14	; 0x0e
    2a58:	57 85       	ldd	r21, Z+15	; 0x0f

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    2a5a:	fd e2       	ldi	r31, 0x2D	; 45
    2a5c:	ef 2e       	mov	r14, r31
    2a5e:	f1 2c       	mov	r15, r1
    2a60:	ec 0e       	add	r14, r28
    2a62:	fd 1e       	adc	r15, r29
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    2a64:	84 e0       	ldi	r24, 0x04	; 4
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	a0 e0       	ldi	r26, 0x00	; 0
    2a6a:	b0 e8       	ldi	r27, 0x80	; 128
    2a6c:	8d 8b       	std	Y+21, r24	; 0x15
    2a6e:	9e 8b       	std	Y+22, r25	; 0x16
    2a70:	af 8b       	std	Y+23, r26	; 0x17
    2a72:	b8 8f       	std	Y+24, r27	; 0x18
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    2a74:	2e 30       	cpi	r18, 0x0E	; 14
    2a76:	f1 e0       	ldi	r31, 0x01	; 1
    2a78:	3f 07       	cpc	r19, r31
    2a7a:	f1 e0       	ldi	r31, 0x01	; 1
    2a7c:	4f 07       	cpc	r20, r31
    2a7e:	f0 e0       	ldi	r31, 0x00	; 0
    2a80:	5f 07       	cpc	r21, r31
    2a82:	09 f4       	brne	.+2      	; 0x2a86 <RNDIS_Device_ProcessControlRequest+0x1ae>
    2a84:	e7 c0       	rjmp	.+462    	; 0x2c54 <RNDIS_Device_ProcessControlRequest+0x37c>
    2a86:	2f 30       	cpi	r18, 0x0F	; 15
    2a88:	61 e0       	ldi	r22, 0x01	; 1
    2a8a:	36 07       	cpc	r19, r22
    2a8c:	61 e0       	ldi	r22, 0x01	; 1
    2a8e:	46 07       	cpc	r20, r22
    2a90:	60 e0       	ldi	r22, 0x00	; 0
    2a92:	56 07       	cpc	r21, r22
    2a94:	08 f0       	brcs	.+2      	; 0x2a98 <RNDIS_Device_ProcessControlRequest+0x1c0>
    2a96:	58 c0       	rjmp	.+176    	; 0x2b48 <RNDIS_Device_ProcessControlRequest+0x270>
    2a98:	26 30       	cpi	r18, 0x06	; 6
    2a9a:	81 e0       	ldi	r24, 0x01	; 1
    2a9c:	38 07       	cpc	r19, r24
    2a9e:	81 e0       	ldi	r24, 0x01	; 1
    2aa0:	48 07       	cpc	r20, r24
    2aa2:	80 e0       	ldi	r24, 0x00	; 0
    2aa4:	58 07       	cpc	r21, r24
    2aa6:	09 f4       	brne	.+2      	; 0x2aaa <RNDIS_Device_ProcessControlRequest+0x1d2>
    2aa8:	ae c0       	rjmp	.+348    	; 0x2c06 <RNDIS_Device_ProcessControlRequest+0x32e>
    2aaa:	27 30       	cpi	r18, 0x07	; 7
    2aac:	e1 e0       	ldi	r30, 0x01	; 1
    2aae:	3e 07       	cpc	r19, r30
    2ab0:	e1 e0       	ldi	r30, 0x01	; 1
    2ab2:	4e 07       	cpc	r20, r30
    2ab4:	e0 e0       	ldi	r30, 0x00	; 0
    2ab6:	5e 07       	cpc	r21, r30
    2ab8:	f8 f4       	brcc	.+62     	; 0x2af8 <RNDIS_Device_ProcessControlRequest+0x220>
    2aba:	22 30       	cpi	r18, 0x02	; 2
    2abc:	f1 e0       	ldi	r31, 0x01	; 1
    2abe:	3f 07       	cpc	r19, r31
    2ac0:	f1 e0       	ldi	r31, 0x01	; 1
    2ac2:	4f 07       	cpc	r20, r31
    2ac4:	f0 e0       	ldi	r31, 0x00	; 0
    2ac6:	5f 07       	cpc	r21, r31
    2ac8:	09 f4       	brne	.+2      	; 0x2acc <RNDIS_Device_ProcessControlRequest+0x1f4>
    2aca:	cd c0       	rjmp	.+410    	; 0x2c66 <RNDIS_Device_ProcessControlRequest+0x38e>
    2acc:	23 30       	cpi	r18, 0x03	; 3
    2ace:	61 e0       	ldi	r22, 0x01	; 1
    2ad0:	36 07       	cpc	r19, r22
    2ad2:	61 e0       	ldi	r22, 0x01	; 1
    2ad4:	46 07       	cpc	r20, r22
    2ad6:	60 e0       	ldi	r22, 0x00	; 0
    2ad8:	56 07       	cpc	r21, r22
    2ada:	38 f4       	brcc	.+14     	; 0x2aea <RNDIS_Device_ProcessControlRequest+0x212>
    2adc:	21 50       	subi	r18, 0x01	; 1
    2ade:	31 40       	sbci	r19, 0x01	; 1
    2ae0:	41 40       	sbci	r20, 0x01	; 1
    2ae2:	50 40       	sbci	r21, 0x00	; 0
    2ae4:	09 f0       	breq	.+2      	; 0x2ae8 <RNDIS_Device_ProcessControlRequest+0x210>
    2ae6:	cf c0       	rjmp	.+414    	; 0x2c86 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2ae8:	80 c0       	rjmp	.+256    	; 0x2bea <RNDIS_Device_ProcessControlRequest+0x312>
    2aea:	25 50       	subi	r18, 0x05	; 5
    2aec:	31 40       	sbci	r19, 0x01	; 1
    2aee:	41 40       	sbci	r20, 0x01	; 1
    2af0:	50 40       	sbci	r21, 0x00	; 0
    2af2:	08 f0       	brcs	.+2      	; 0x2af6 <RNDIS_Device_ProcessControlRequest+0x21e>
    2af4:	c8 c0       	rjmp	.+400    	; 0x2c86 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2af6:	b7 c0       	rjmp	.+366    	; 0x2c66 <RNDIS_Device_ProcessControlRequest+0x38e>
    2af8:	2c 30       	cpi	r18, 0x0C	; 12
    2afa:	f1 e0       	ldi	r31, 0x01	; 1
    2afc:	3f 07       	cpc	r19, r31
    2afe:	f1 e0       	ldi	r31, 0x01	; 1
    2b00:	4f 07       	cpc	r20, r31
    2b02:	f0 e0       	ldi	r31, 0x00	; 0
    2b04:	5f 07       	cpc	r21, r31
    2b06:	80 f4       	brcc	.+32     	; 0x2b28 <RNDIS_Device_ProcessControlRequest+0x250>
    2b08:	2a 30       	cpi	r18, 0x0A	; 10
    2b0a:	61 e0       	ldi	r22, 0x01	; 1
    2b0c:	36 07       	cpc	r19, r22
    2b0e:	61 e0       	ldi	r22, 0x01	; 1
    2b10:	46 07       	cpc	r20, r22
    2b12:	60 e0       	ldi	r22, 0x00	; 0
    2b14:	56 07       	cpc	r21, r22
    2b16:	08 f0       	brcs	.+2      	; 0x2b1a <RNDIS_Device_ProcessControlRequest+0x242>
    2b18:	76 c0       	rjmp	.+236    	; 0x2c06 <RNDIS_Device_ProcessControlRequest+0x32e>
    2b1a:	27 50       	subi	r18, 0x07	; 7
    2b1c:	31 40       	sbci	r19, 0x01	; 1
    2b1e:	41 40       	sbci	r20, 0x01	; 1
    2b20:	50 40       	sbci	r21, 0x00	; 0
    2b22:	09 f0       	breq	.+2      	; 0x2b26 <RNDIS_Device_ProcessControlRequest+0x24e>
    2b24:	b0 c0       	rjmp	.+352    	; 0x2c86 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2b26:	81 c0       	rjmp	.+258    	; 0x2c2a <RNDIS_Device_ProcessControlRequest+0x352>
    2b28:	2c 30       	cpi	r18, 0x0C	; 12
    2b2a:	e1 e0       	ldi	r30, 0x01	; 1
    2b2c:	3e 07       	cpc	r19, r30
    2b2e:	e1 e0       	ldi	r30, 0x01	; 1
    2b30:	4e 07       	cpc	r20, r30
    2b32:	e0 e0       	ldi	r30, 0x00	; 0
    2b34:	5e 07       	cpc	r21, r30
    2b36:	09 f4       	brne	.+2      	; 0x2b3a <RNDIS_Device_ProcessControlRequest+0x262>
    2b38:	61 c0       	rjmp	.+194    	; 0x2bfc <RNDIS_Device_ProcessControlRequest+0x324>
    2b3a:	2d 50       	subi	r18, 0x0D	; 13
    2b3c:	31 40       	sbci	r19, 0x01	; 1
    2b3e:	41 40       	sbci	r20, 0x01	; 1
    2b40:	50 40       	sbci	r21, 0x00	; 0
    2b42:	09 f0       	breq	.+2      	; 0x2b46 <RNDIS_Device_ProcessControlRequest+0x26e>
    2b44:	a0 c0       	rjmp	.+320    	; 0x2c86 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2b46:	64 c0       	rjmp	.+200    	; 0x2c10 <RNDIS_Device_ProcessControlRequest+0x338>
    2b48:	26 30       	cpi	r18, 0x06	; 6
    2b4a:	61 e0       	ldi	r22, 0x01	; 1
    2b4c:	36 07       	cpc	r19, r22
    2b4e:	62 e0       	ldi	r22, 0x02	; 2
    2b50:	46 07       	cpc	r20, r22
    2b52:	60 e0       	ldi	r22, 0x00	; 0
    2b54:	56 07       	cpc	r21, r22
    2b56:	10 f5       	brcc	.+68     	; 0x2b9c <RNDIS_Device_ProcessControlRequest+0x2c4>
    2b58:	21 30       	cpi	r18, 0x01	; 1
    2b5a:	81 e0       	ldi	r24, 0x01	; 1
    2b5c:	38 07       	cpc	r19, r24
    2b5e:	82 e0       	ldi	r24, 0x02	; 2
    2b60:	48 07       	cpc	r20, r24
    2b62:	80 e0       	ldi	r24, 0x00	; 0
    2b64:	58 07       	cpc	r21, r24
    2b66:	08 f0       	brcs	.+2      	; 0x2b6a <RNDIS_Device_ProcessControlRequest+0x292>
    2b68:	7e c0       	rjmp	.+252    	; 0x2c66 <RNDIS_Device_ProcessControlRequest+0x38e>
    2b6a:	24 31       	cpi	r18, 0x14	; 20
    2b6c:	e1 e0       	ldi	r30, 0x01	; 1
    2b6e:	3e 07       	cpc	r19, r30
    2b70:	e1 e0       	ldi	r30, 0x01	; 1
    2b72:	4e 07       	cpc	r20, r30
    2b74:	e0 e0       	ldi	r30, 0x00	; 0
    2b76:	5e 07       	cpc	r21, r30
    2b78:	09 f4       	brne	.+2      	; 0x2b7c <RNDIS_Device_ProcessControlRequest+0x2a4>
    2b7a:	75 c0       	rjmp	.+234    	; 0x2c66 <RNDIS_Device_ProcessControlRequest+0x38e>
    2b7c:	22 30       	cpi	r18, 0x02	; 2
    2b7e:	f2 e0       	ldi	r31, 0x02	; 2
    2b80:	3f 07       	cpc	r19, r31
    2b82:	f1 e0       	ldi	r31, 0x01	; 1
    2b84:	4f 07       	cpc	r20, r31
    2b86:	f0 e0       	ldi	r31, 0x00	; 0
    2b88:	5f 07       	cpc	r21, r31
    2b8a:	09 f4       	brne	.+2      	; 0x2b8e <RNDIS_Device_ProcessControlRequest+0x2b6>
    2b8c:	6c c0       	rjmp	.+216    	; 0x2c66 <RNDIS_Device_ProcessControlRequest+0x38e>
    2b8e:	21 51       	subi	r18, 0x11	; 17
    2b90:	31 40       	sbci	r19, 0x01	; 1
    2b92:	41 40       	sbci	r20, 0x01	; 1
    2b94:	50 40       	sbci	r21, 0x00	; 0
    2b96:	09 f0       	breq	.+2      	; 0x2b9a <RNDIS_Device_ProcessControlRequest+0x2c2>
    2b98:	76 c0       	rjmp	.+236    	; 0x2c86 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2b9a:	6a c0       	rjmp	.+212    	; 0x2c70 <RNDIS_Device_ProcessControlRequest+0x398>
    2b9c:	24 30       	cpi	r18, 0x04	; 4
    2b9e:	81 e0       	ldi	r24, 0x01	; 1
    2ba0:	38 07       	cpc	r19, r24
    2ba2:	81 e0       	ldi	r24, 0x01	; 1
    2ba4:	48 07       	cpc	r20, r24
    2ba6:	81 e0       	ldi	r24, 0x01	; 1
    2ba8:	58 07       	cpc	r21, r24
    2baa:	09 f4       	brne	.+2      	; 0x2bae <RNDIS_Device_ProcessControlRequest+0x2d6>
    2bac:	4e c0       	rjmp	.+156    	; 0x2c4a <RNDIS_Device_ProcessControlRequest+0x372>
    2bae:	25 30       	cpi	r18, 0x05	; 5
    2bb0:	e1 e0       	ldi	r30, 0x01	; 1
    2bb2:	3e 07       	cpc	r19, r30
    2bb4:	e1 e0       	ldi	r30, 0x01	; 1
    2bb6:	4e 07       	cpc	r20, r30
    2bb8:	e1 e0       	ldi	r30, 0x01	; 1
    2bba:	5e 07       	cpc	r21, r30
    2bbc:	58 f4       	brcc	.+22     	; 0x2bd4 <RNDIS_Device_ProcessControlRequest+0x2fc>
    2bbe:	21 50       	subi	r18, 0x01	; 1
    2bc0:	31 40       	sbci	r19, 0x01	; 1
    2bc2:	41 40       	sbci	r20, 0x01	; 1
    2bc4:	51 40       	sbci	r21, 0x01	; 1
    2bc6:	22 30       	cpi	r18, 0x02	; 2
    2bc8:	31 05       	cpc	r19, r1
    2bca:	41 05       	cpc	r20, r1
    2bcc:	51 05       	cpc	r21, r1
    2bce:	08 f0       	brcs	.+2      	; 0x2bd2 <RNDIS_Device_ProcessControlRequest+0x2fa>
    2bd0:	5a c0       	rjmp	.+180    	; 0x2c86 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2bd2:	30 c0       	rjmp	.+96     	; 0x2c34 <RNDIS_Device_ProcessControlRequest+0x35c>
    2bd4:	21 50       	subi	r18, 0x01	; 1
    2bd6:	31 40       	sbci	r19, 0x01	; 1
    2bd8:	42 40       	sbci	r20, 0x02	; 2
    2bda:	51 40       	sbci	r21, 0x01	; 1
    2bdc:	23 30       	cpi	r18, 0x03	; 3
    2bde:	31 05       	cpc	r19, r1
    2be0:	41 05       	cpc	r20, r1
    2be2:	51 05       	cpc	r21, r1
    2be4:	08 f0       	brcs	.+2      	; 0x2be8 <RNDIS_Device_ProcessControlRequest+0x310>
    2be6:	4f c0       	rjmp	.+158    	; 0x2c86 <RNDIS_Device_ProcessControlRequest+0x3ae>
    2be8:	3e c0       	rjmp	.+124    	; 0x2c66 <RNDIS_Device_ProcessControlRequest+0x38e>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    2bea:	c7 01       	movw	r24, r14
    2bec:	66 eb       	ldi	r22, 0xB6	; 182
    2bee:	73 e0       	ldi	r23, 0x03	; 3
    2bf0:	4c e6       	ldi	r20, 0x6C	; 108
    2bf2:	50 e0       	ldi	r21, 0x00	; 0
    2bf4:	57 d1       	rcall	.+686    	; 0x2ea4 <memcpy_P>
    2bf6:	cc e6       	ldi	r28, 0x6C	; 108
    2bf8:	d0 e0       	ldi	r29, 0x00	; 0
    2bfa:	12 c1       	rjmp	.+548    	; 0x2e20 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    2bfc:	8f ef       	ldi	r24, 0xFF	; 255
    2bfe:	9f ef       	ldi	r25, 0xFF	; 255
    2c00:	af ef       	ldi	r26, 0xFF	; 255
    2c02:	b0 e0       	ldi	r27, 0x00	; 0
    2c04:	39 c0       	rjmp	.+114    	; 0x2c78 <RNDIS_Device_ProcessControlRequest+0x3a0>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    2c06:	8c ed       	ldi	r24, 0xDC	; 220
    2c08:	95 e0       	ldi	r25, 0x05	; 5
    2c0a:	a0 e0       	ldi	r26, 0x00	; 0
    2c0c:	b0 e0       	ldi	r27, 0x00	; 0
    2c0e:	34 c0       	rjmp	.+104    	; 0x2c78 <RNDIS_Device_ProcessControlRequest+0x3a0>

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    2c10:	6d 85       	ldd	r22, Y+13	; 0x0d
    2c12:	7e 85       	ldd	r23, Y+14	; 0x0e
    2c14:	fb 01       	movw	r30, r22
    2c16:	ef 01       	movw	r28, r30
    2c18:	09 90       	ld	r0, Y+
    2c1a:	00 20       	and	r0, r0
    2c1c:	e9 f7       	brne	.-6      	; 0x2c18 <RNDIS_Device_ProcessControlRequest+0x340>
    2c1e:	ce 1b       	sub	r28, r30
    2c20:	df 0b       	sbc	r29, r31

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    2c22:	c7 01       	movw	r24, r14
    2c24:	ae 01       	movw	r20, r28
    2c26:	73 d1       	rcall	.+742    	; 0x2f0e <memcpy>
    2c28:	fb c0       	rjmp	.+502    	; 0x2e20 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    2c2a:	80 ea       	ldi	r24, 0xA0	; 160
    2c2c:	96 e8       	ldi	r25, 0x86	; 134
    2c2e:	a1 e0       	ldi	r26, 0x01	; 1
    2c30:	b0 e0       	ldi	r27, 0x00	; 0
    2c32:	22 c0       	rjmp	.+68     	; 0x2c78 <RNDIS_Device_ProcessControlRequest+0x3a0>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    2c34:	d7 01       	movw	r26, r14
    2c36:	fe 01       	movw	r30, r28
    2c38:	3f 96       	adiw	r30, 0x0f	; 15
    2c3a:	86 e0       	ldi	r24, 0x06	; 6
    2c3c:	01 90       	ld	r0, Z+
    2c3e:	0d 92       	st	X+, r0
    2c40:	81 50       	subi	r24, 0x01	; 1
    2c42:	e1 f7       	brne	.-8      	; 0x2c3c <RNDIS_Device_ProcessControlRequest+0x364>
    2c44:	c6 e0       	ldi	r28, 0x06	; 6
    2c46:	d0 e0       	ldi	r29, 0x00	; 0
    2c48:	eb c0       	rjmp	.+470    	; 0x2e20 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    2c4a:	81 e0       	ldi	r24, 0x01	; 1
    2c4c:	90 e0       	ldi	r25, 0x00	; 0
    2c4e:	a0 e0       	ldi	r26, 0x00	; 0
    2c50:	b0 e0       	ldi	r27, 0x00	; 0
    2c52:	12 c0       	rjmp	.+36     	; 0x2c78 <RNDIS_Device_ProcessControlRequest+0x3a0>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    2c54:	c9 56       	subi	r28, 0x69	; 105
    2c56:	df 4f       	sbci	r29, 0xFF	; 255
    2c58:	88 81       	ld	r24, Y
    2c5a:	99 81       	ldd	r25, Y+1	; 0x01
    2c5c:	aa 81       	ldd	r26, Y+2	; 0x02
    2c5e:	bb 81       	ldd	r27, Y+3	; 0x03
    2c60:	c7 59       	subi	r28, 0x97	; 151
    2c62:	d0 40       	sbci	r29, 0x00	; 0
    2c64:	09 c0       	rjmp	.+18     	; 0x2c78 <RNDIS_Device_ProcessControlRequest+0x3a0>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    2c66:	1d a6       	std	Y+45, r1	; 0x2d
    2c68:	1e a6       	std	Y+46, r1	; 0x2e
    2c6a:	1f a6       	std	Y+47, r1	; 0x2f
    2c6c:	18 aa       	std	Y+48, r1	; 0x30
    2c6e:	08 c0       	rjmp	.+16     	; 0x2c80 <RNDIS_Device_ProcessControlRequest+0x3a8>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    2c70:	8c e5       	ldi	r24, 0x5C	; 92
    2c72:	96 e0       	ldi	r25, 0x06	; 6
    2c74:	a0 e0       	ldi	r26, 0x00	; 0
    2c76:	b0 e0       	ldi	r27, 0x00	; 0
    2c78:	8d a7       	std	Y+45, r24	; 0x2d
    2c7a:	9e a7       	std	Y+46, r25	; 0x2e
    2c7c:	af a7       	std	Y+47, r26	; 0x2f
    2c7e:	b8 ab       	std	Y+48, r27	; 0x30
    2c80:	c4 e0       	ldi	r28, 0x04	; 4
    2c82:	d0 e0       	ldi	r29, 0x00	; 0
    2c84:	cd c0       	rjmp	.+410    	; 0x2e20 <RNDIS_Device_ProcessControlRequest+0x548>
				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    2c86:	8b eb       	ldi	r24, 0xBB	; 187
    2c88:	90 e0       	ldi	r25, 0x00	; 0
    2c8a:	a0 e0       	ldi	r26, 0x00	; 0
    2c8c:	b0 ec       	ldi	r27, 0xC0	; 192
    2c8e:	f8 01       	movw	r30, r16
    2c90:	84 87       	std	Z+12, r24	; 0x0c
    2c92:	95 87       	std	Z+13, r25	; 0x0d
    2c94:	a6 87       	std	Z+14, r26	; 0x0e
    2c96:	b7 87       	std	Z+15, r27	; 0x0f
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    2c98:	88 e1       	ldi	r24, 0x18	; 24
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	a0 e0       	ldi	r26, 0x00	; 0
    2c9e:	b0 e0       	ldi	r27, 0x00	; 0
    2ca0:	84 83       	std	Z+4, r24	; 0x04
    2ca2:	95 83       	std	Z+5, r25	; 0x05
    2ca4:	a6 83       	std	Z+6, r26	; 0x06
    2ca6:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    2ca8:	10 8a       	std	Z+16, r1	; 0x10
    2caa:	11 8a       	std	Z+17, r1	; 0x11
    2cac:	12 8a       	std	Z+18, r1	; 0x12
    2cae:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    2cb0:	14 8a       	std	Z+20, r1	; 0x14
    2cb2:	15 8a       	std	Z+21, r1	; 0x15
    2cb4:	16 8a       	std	Z+22, r1	; 0x16
    2cb6:	17 8a       	std	Z+23, r1	; 0x17
    2cb8:	d0 c0       	rjmp	.+416    	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2cba:	cb 56       	subi	r28, 0x6B	; 107
    2cbc:	df 4f       	sbci	r29, 0xFF	; 255
    2cbe:	81 e0       	ldi	r24, 0x01	; 1
    2cc0:	88 83       	st	Y, r24
    2cc2:	c5 59       	subi	r28, 0x95	; 149
    2cc4:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    2cc6:	f8 01       	movw	r30, r16
    2cc8:	24 85       	ldd	r18, Z+12	; 0x0c
    2cca:	35 85       	ldd	r19, Z+13	; 0x0d
    2ccc:	46 85       	ldd	r20, Z+14	; 0x0e
    2cce:	57 85       	ldd	r21, Z+15	; 0x0f

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    2cd0:	85 e0       	ldi	r24, 0x05	; 5
    2cd2:	90 e0       	ldi	r25, 0x00	; 0
    2cd4:	a0 e0       	ldi	r26, 0x00	; 0
    2cd6:	b0 e8       	ldi	r27, 0x80	; 128
    2cd8:	8d 8b       	std	Y+21, r24	; 0x15
    2cda:	9e 8b       	std	Y+22, r25	; 0x16
    2cdc:	af 8b       	std	Y+23, r26	; 0x17
    2cde:	b8 8f       	std	Y+24, r27	; 0x18
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    2ce0:	80 e1       	ldi	r24, 0x10	; 16
    2ce2:	90 e0       	ldi	r25, 0x00	; 0
    2ce4:	a0 e0       	ldi	r26, 0x00	; 0
    2ce6:	b0 e0       	ldi	r27, 0x00	; 0
    2ce8:	84 83       	std	Z+4, r24	; 0x04
    2cea:	95 83       	std	Z+5, r25	; 0x05
    2cec:	a6 83       	std	Z+6, r26	; 0x06
    2cee:	b7 83       	std	Z+7, r27	; 0x07
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    2cf0:	84 89       	ldd	r24, Z+20	; 0x14
    2cf2:	95 89       	ldd	r25, Z+21	; 0x15
    2cf4:	a6 89       	ldd	r26, Z+22	; 0x16
    2cf6:	b7 89       	ldd	r27, Z+23	; 0x17
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    2cf8:	2e 30       	cpi	r18, 0x0E	; 14
    2cfa:	f1 e0       	ldi	r31, 0x01	; 1
    2cfc:	3f 07       	cpc	r19, r31
    2cfe:	f1 e0       	ldi	r31, 0x01	; 1
    2d00:	4f 07       	cpc	r20, r31
    2d02:	f0 e0       	ldi	r31, 0x00	; 0
    2d04:	5f 07       	cpc	r21, r31
    2d06:	51 f0       	breq	.+20     	; 0x2d1c <RNDIS_Device_ProcessControlRequest+0x444>
    2d08:	23 50       	subi	r18, 0x03	; 3
    2d0a:	31 40       	sbci	r19, 0x01	; 1
    2d0c:	41 40       	sbci	r20, 0x01	; 1
    2d0e:	51 40       	sbci	r21, 0x01	; 1
    2d10:	a9 f0       	breq	.+42     	; 0x2d3c <RNDIS_Device_ProcessControlRequest+0x464>
    2d12:	8b eb       	ldi	r24, 0xBB	; 187
    2d14:	90 e0       	ldi	r25, 0x00	; 0
    2d16:	a0 e0       	ldi	r26, 0x00	; 0
    2d18:	b0 ec       	ldi	r27, 0xC0	; 192
    2d1a:	14 c0       	rjmp	.+40     	; 0x2d44 <RNDIS_Device_ProcessControlRequest+0x46c>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    2d1c:	fe 01       	movw	r30, r28
    2d1e:	e8 0f       	add	r30, r24
    2d20:	f9 1f       	adc	r31, r25
    2d22:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d24:	96 8d       	ldd	r25, Z+30	; 0x1e
    2d26:	a7 8d       	ldd	r26, Z+31	; 0x1f
    2d28:	b0 a1       	ldd	r27, Z+32	; 0x20
    2d2a:	c9 56       	subi	r28, 0x69	; 105
    2d2c:	df 4f       	sbci	r29, 0xFF	; 255
    2d2e:	88 83       	st	Y, r24
    2d30:	99 83       	std	Y+1, r25	; 0x01
    2d32:	aa 83       	std	Y+2, r26	; 0x02
    2d34:	bb 83       	std	Y+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState   = le32_to_cpu((RNDISInterfaceInfo->State.CurrPacketFilter) ?
    2d36:	fe 01       	movw	r30, r28
    2d38:	82 e0       	ldi	r24, 0x02	; 2
    2d3a:	82 93       	st	-Z, r24
    2d3c:	80 e0       	ldi	r24, 0x00	; 0
    2d3e:	90 e0       	ldi	r25, 0x00	; 0
    2d40:	a0 e0       	ldi	r26, 0x00	; 0
    2d42:	b0 e0       	ldi	r27, 0x00	; 0
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    2d44:	f8 01       	movw	r30, r16
    2d46:	84 87       	std	Z+12, r24	; 0x0c
    2d48:	95 87       	std	Z+13, r25	; 0x0d
    2d4a:	a6 87       	std	Z+14, r26	; 0x0e
    2d4c:	b7 87       	std	Z+15, r27	; 0x0f
    2d4e:	85 c0       	rjmp	.+266    	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2d50:	cb 56       	subi	r28, 0x6B	; 107
    2d52:	df 4f       	sbci	r29, 0xFF	; 255
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	88 83       	st	Y, r24
    2d58:	c5 59       	subi	r28, 0x95	; 149
    2d5a:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    2d5c:	86 e0       	ldi	r24, 0x06	; 6
    2d5e:	90 e0       	ldi	r25, 0x00	; 0
    2d60:	a0 e0       	ldi	r26, 0x00	; 0
    2d62:	b0 e8       	ldi	r27, 0x80	; 128
    2d64:	8d 8b       	std	Y+21, r24	; 0x15
    2d66:	9e 8b       	std	Y+22, r25	; 0x16
    2d68:	af 8b       	std	Y+23, r26	; 0x17
    2d6a:	b8 8f       	std	Y+24, r27	; 0x18
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    2d6c:	80 e1       	ldi	r24, 0x10	; 16
    2d6e:	90 e0       	ldi	r25, 0x00	; 0
    2d70:	a0 e0       	ldi	r26, 0x00	; 0
    2d72:	b0 e0       	ldi	r27, 0x00	; 0
    2d74:	f8 01       	movw	r30, r16
    2d76:	84 83       	std	Z+4, r24	; 0x04
    2d78:	95 83       	std	Z+5, r25	; 0x05
    2d7a:	a6 83       	std	Z+6, r26	; 0x06
    2d7c:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2d7e:	10 86       	std	Z+8, r1	; 0x08
    2d80:	11 86       	std	Z+9, r1	; 0x09
    2d82:	12 86       	std	Z+10, r1	; 0x0a
    2d84:	13 86       	std	Z+11, r1	; 0x0b
    2d86:	17 c0       	rjmp	.+46     	; 0x2db6 <RNDIS_Device_ProcessControlRequest+0x4de>
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2d88:	cb 56       	subi	r28, 0x6B	; 107
    2d8a:	df 4f       	sbci	r29, 0xFF	; 255
    2d8c:	81 e0       	ldi	r24, 0x01	; 1
    2d8e:	88 83       	st	Y, r24
    2d90:	c5 59       	subi	r28, 0x95	; 149
    2d92:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    2d94:	88 e0       	ldi	r24, 0x08	; 8
    2d96:	90 e0       	ldi	r25, 0x00	; 0
    2d98:	a0 e0       	ldi	r26, 0x00	; 0
    2d9a:	b0 e8       	ldi	r27, 0x80	; 128
    2d9c:	8d 8b       	std	Y+21, r24	; 0x15
    2d9e:	9e 8b       	std	Y+22, r25	; 0x16
    2da0:	af 8b       	std	Y+23, r26	; 0x17
    2da2:	b8 8f       	std	Y+24, r27	; 0x18
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    2da4:	80 e1       	ldi	r24, 0x10	; 16
    2da6:	90 e0       	ldi	r25, 0x00	; 0
    2da8:	a0 e0       	ldi	r26, 0x00	; 0
    2daa:	b0 e0       	ldi	r27, 0x00	; 0
    2dac:	f8 01       	movw	r30, r16
    2dae:	84 83       	std	Z+4, r24	; 0x04
    2db0:	95 83       	std	Z+5, r25	; 0x05
    2db2:	a6 83       	std	Z+6, r26	; 0x06
    2db4:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2db6:	14 86       	std	Z+12, r1	; 0x0c
    2db8:	15 86       	std	Z+13, r1	; 0x0d
    2dba:	16 86       	std	Z+14, r1	; 0x0e
    2dbc:	17 86       	std	Z+15, r1	; 0x0f
    2dbe:	4d c0       	rjmp	.+154    	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2dc0:	80 91 01 14 	lds	r24, 0x1401
    2dc4:	81 3a       	cpi	r24, 0xA1	; 161
    2dc6:	09 f0       	breq	.+2      	; 0x2dca <RNDIS_Device_ProcessControlRequest+0x4f2>
    2dc8:	48 c0       	rjmp	.+144    	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
    2dca:	8e 01       	movw	r16, r28
    2dcc:	0b 5e       	subi	r16, 0xEB	; 235
    2dce:	1f 4f       	sbci	r17, 0xFF	; 255

				if (!(MessageHeader->MessageLength))
    2dd0:	f8 01       	movw	r30, r16
    2dd2:	84 81       	ldd	r24, Z+4	; 0x04
    2dd4:	95 81       	ldd	r25, Z+5	; 0x05
    2dd6:	a6 81       	ldd	r26, Z+6	; 0x06
    2dd8:	b7 81       	ldd	r27, Z+7	; 0x07
    2dda:	00 97       	sbiw	r24, 0x00	; 0
    2ddc:	a1 05       	cpc	r26, r1
    2dde:	b1 05       	cpc	r27, r1
    2de0:	49 f4       	brne	.+18     	; 0x2df4 <RNDIS_Device_ProcessControlRequest+0x51c>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    2de2:	1d 8a       	std	Y+21, r1	; 0x15
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    2de4:	81 e0       	ldi	r24, 0x01	; 1
    2de6:	90 e0       	ldi	r25, 0x00	; 0
    2de8:	a0 e0       	ldi	r26, 0x00	; 0
    2dea:	b0 e0       	ldi	r27, 0x00	; 0
    2dec:	84 83       	std	Z+4, r24	; 0x04
    2dee:	95 83       	std	Z+5, r25	; 0x05
    2df0:	a6 83       	std	Z+6, r26	; 0x06
    2df2:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2df4:	80 91 e8 00 	lds	r24, 0x00E8
    2df8:	87 7f       	andi	r24, 0xF7	; 247
    2dfa:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    2dfe:	f8 01       	movw	r30, r16
    2e00:	64 81       	ldd	r22, Z+4	; 0x04
    2e02:	75 81       	ldd	r23, Z+5	; 0x05
    2e04:	ce 01       	movw	r24, r28
    2e06:	45 96       	adiw	r24, 0x15	; 21
    2e08:	ad d8       	rcall	.-3750   	; 0x1f64 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2e0a:	80 91 e8 00 	lds	r24, 0x00E8
    2e0e:	8b 77       	andi	r24, 0x7B	; 123
    2e10:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    2e14:	f8 01       	movw	r30, r16
    2e16:	14 82       	std	Z+4, r1	; 0x04
    2e18:	15 82       	std	Z+5, r1	; 0x05
    2e1a:	16 82       	std	Z+6, r1	; 0x06
    2e1c:	17 82       	std	Z+7, r1	; 0x07
    2e1e:	1d c0       	rjmp	.+58     	; 0x2e5a <RNDIS_Device_ProcessControlRequest+0x582>
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
			
			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2e20:	f8 01       	movw	r30, r16
    2e22:	14 86       	std	Z+12, r1	; 0x0c
    2e24:	15 86       	std	Z+13, r1	; 0x0d
    2e26:	16 86       	std	Z+14, r1	; 0x0e
    2e28:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    2e2a:	68 96       	adiw	r28, 0x18	; 24
    2e2c:	ce 01       	movw	r24, r28
    2e2e:	a0 e0       	ldi	r26, 0x00	; 0
    2e30:	b0 e0       	ldi	r27, 0x00	; 0
    2e32:	68 97       	sbiw	r28, 0x18	; 24
    2e34:	84 83       	std	Z+4, r24	; 0x04
    2e36:	95 83       	std	Z+5, r25	; 0x05
    2e38:	a6 83       	std	Z+6, r26	; 0x06
    2e3a:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    2e3c:	ce 01       	movw	r24, r28
    2e3e:	a0 e0       	ldi	r26, 0x00	; 0
    2e40:	b0 e0       	ldi	r27, 0x00	; 0
    2e42:	80 8b       	std	Z+16, r24	; 0x10
    2e44:	91 8b       	std	Z+17, r25	; 0x11
    2e46:	a2 8b       	std	Z+18, r26	; 0x12
    2e48:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    2e4a:	80 e1       	ldi	r24, 0x10	; 16
    2e4c:	90 e0       	ldi	r25, 0x00	; 0
    2e4e:	a0 e0       	ldi	r26, 0x00	; 0
    2e50:	b0 e0       	ldi	r27, 0x00	; 0
    2e52:	84 8b       	std	Z+20, r24	; 0x14
    2e54:	95 8b       	std	Z+21, r25	; 0x15
    2e56:	a6 8b       	std	Z+22, r26	; 0x16
    2e58:	b7 8b       	std	Z+23, r27	; 0x17
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    2e5a:	df 91       	pop	r29
    2e5c:	cf 91       	pop	r28
    2e5e:	1f 91       	pop	r17
    2e60:	0f 91       	pop	r16
    2e62:	ff 90       	pop	r15
    2e64:	ef 90       	pop	r14
    2e66:	08 95       	ret

00002e68 <Serial_putchar>:

FILE USARTSerialStream;

int Serial_putchar(char DataByte,
                   FILE *Stream)
{
    2e68:	98 2f       	mov	r25, r24
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2e6a:	80 91 c8 00 	lds	r24, 0x00C8
    2e6e:	85 ff       	sbrs	r24, 5
    2e70:	fc cf       	rjmp	.-8      	; 0x2e6a <Serial_putchar+0x2>
				UDR1 = DataByte;
    2e72:	90 93 ce 00 	sts	0x00CE, r25
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2e76:	80 e0       	ldi	r24, 0x00	; 0
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	08 95       	ret

00002e7c <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2e7c:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2e80:	87 fd       	sbrc	r24, 7
    2e82:	03 c0       	rjmp	.+6      	; 0x2e8a <Serial_getchar+0xe>
    2e84:	2e ef       	ldi	r18, 0xFE	; 254
    2e86:	3f ef       	ldi	r19, 0xFF	; 255
    2e88:	0b c0       	rjmp	.+22     	; 0x2ea0 <Serial_getchar+0x24>
    2e8a:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2e8e:	87 fd       	sbrc	r24, 7
    2e90:	03 c0       	rjmp	.+6      	; 0x2e98 <Serial_getchar+0x1c>
    2e92:	2f ef       	ldi	r18, 0xFF	; 255
    2e94:	3f ef       	ldi	r19, 0xFF	; 255
    2e96:	04 c0       	rjmp	.+8      	; 0x2ea0 <Serial_getchar+0x24>
				  return -1;
				
				return UDR1;
    2e98:	80 91 ce 00 	lds	r24, 0x00CE
    2e9c:	28 2f       	mov	r18, r24
    2e9e:	30 e0       	ldi	r19, 0x00	; 0
	  return _FDEV_EOF;

	return Serial_ReceiveByte();
}
    2ea0:	c9 01       	movw	r24, r18
    2ea2:	08 95       	ret

00002ea4 <memcpy_P>:
    2ea4:	fb 01       	movw	r30, r22
    2ea6:	dc 01       	movw	r26, r24
    2ea8:	02 c0       	rjmp	.+4      	; 0x2eae <memcpy_P+0xa>
    2eaa:	05 90       	lpm	r0, Z+
    2eac:	0d 92       	st	X+, r0
    2eae:	41 50       	subi	r20, 0x01	; 1
    2eb0:	50 40       	sbci	r21, 0x00	; 0
    2eb2:	d8 f7       	brcc	.-10     	; 0x2eaa <memcpy_P+0x6>
    2eb4:	08 95       	ret

00002eb6 <strcpy_P>:
    2eb6:	fb 01       	movw	r30, r22
    2eb8:	dc 01       	movw	r26, r24
    2eba:	05 90       	lpm	r0, Z+
    2ebc:	0d 92       	st	X+, r0
    2ebe:	00 20       	and	r0, r0
    2ec0:	e1 f7       	brne	.-8      	; 0x2eba <strcpy_P+0x4>
    2ec2:	08 95       	ret

00002ec4 <strlen_P>:
    2ec4:	fc 01       	movw	r30, r24
    2ec6:	05 90       	lpm	r0, Z+
    2ec8:	00 20       	and	r0, r0
    2eca:	e9 f7       	brne	.-6      	; 0x2ec6 <strlen_P+0x2>
    2ecc:	80 95       	com	r24
    2ece:	90 95       	com	r25
    2ed0:	8e 0f       	add	r24, r30
    2ed2:	9f 1f       	adc	r25, r31
    2ed4:	08 95       	ret

00002ed6 <strncpy_P>:
    2ed6:	fb 01       	movw	r30, r22
    2ed8:	dc 01       	movw	r26, r24
    2eda:	41 50       	subi	r20, 0x01	; 1
    2edc:	50 40       	sbci	r21, 0x00	; 0
    2ede:	48 f0       	brcs	.+18     	; 0x2ef2 <strncpy_P+0x1c>
    2ee0:	05 90       	lpm	r0, Z+
    2ee2:	0d 92       	st	X+, r0
    2ee4:	00 20       	and	r0, r0
    2ee6:	c9 f7       	brne	.-14     	; 0x2eda <strncpy_P+0x4>
    2ee8:	01 c0       	rjmp	.+2      	; 0x2eec <strncpy_P+0x16>
    2eea:	1d 92       	st	X+, r1
    2eec:	41 50       	subi	r20, 0x01	; 1
    2eee:	50 40       	sbci	r21, 0x00	; 0
    2ef0:	e0 f7       	brcc	.-8      	; 0x2eea <strncpy_P+0x14>
    2ef2:	08 95       	ret

00002ef4 <memcmp>:
    2ef4:	fb 01       	movw	r30, r22
    2ef6:	dc 01       	movw	r26, r24
    2ef8:	04 c0       	rjmp	.+8      	; 0x2f02 <memcmp+0xe>
    2efa:	8d 91       	ld	r24, X+
    2efc:	01 90       	ld	r0, Z+
    2efe:	80 19       	sub	r24, r0
    2f00:	21 f4       	brne	.+8      	; 0x2f0a <memcmp+0x16>
    2f02:	41 50       	subi	r20, 0x01	; 1
    2f04:	50 40       	sbci	r21, 0x00	; 0
    2f06:	c8 f7       	brcc	.-14     	; 0x2efa <memcmp+0x6>
    2f08:	88 1b       	sub	r24, r24
    2f0a:	99 0b       	sbc	r25, r25
    2f0c:	08 95       	ret

00002f0e <memcpy>:
    2f0e:	fb 01       	movw	r30, r22
    2f10:	dc 01       	movw	r26, r24
    2f12:	02 c0       	rjmp	.+4      	; 0x2f18 <memcpy+0xa>
    2f14:	01 90       	ld	r0, Z+
    2f16:	0d 92       	st	X+, r0
    2f18:	41 50       	subi	r20, 0x01	; 1
    2f1a:	50 40       	sbci	r21, 0x00	; 0
    2f1c:	d8 f7       	brcc	.-10     	; 0x2f14 <memcpy+0x6>
    2f1e:	08 95       	ret

00002f20 <memmove>:
    2f20:	68 17       	cp	r22, r24
    2f22:	79 07       	cpc	r23, r25
    2f24:	68 f4       	brcc	.+26     	; 0x2f40 <memmove+0x20>
    2f26:	fb 01       	movw	r30, r22
    2f28:	dc 01       	movw	r26, r24
    2f2a:	e4 0f       	add	r30, r20
    2f2c:	f5 1f       	adc	r31, r21
    2f2e:	a4 0f       	add	r26, r20
    2f30:	b5 1f       	adc	r27, r21
    2f32:	02 c0       	rjmp	.+4      	; 0x2f38 <memmove+0x18>
    2f34:	02 90       	ld	r0, -Z
    2f36:	0e 92       	st	-X, r0
    2f38:	41 50       	subi	r20, 0x01	; 1
    2f3a:	50 40       	sbci	r21, 0x00	; 0
    2f3c:	d8 f7       	brcc	.-10     	; 0x2f34 <memmove+0x14>
    2f3e:	08 95       	ret
    2f40:	e6 cf       	rjmp	.-52     	; 0x2f0e <memcpy>

00002f42 <strncmp>:
    2f42:	fb 01       	movw	r30, r22
    2f44:	dc 01       	movw	r26, r24
    2f46:	41 50       	subi	r20, 0x01	; 1
    2f48:	50 40       	sbci	r21, 0x00	; 0
    2f4a:	30 f0       	brcs	.+12     	; 0x2f58 <strncmp+0x16>
    2f4c:	8d 91       	ld	r24, X+
    2f4e:	01 90       	ld	r0, Z+
    2f50:	80 19       	sub	r24, r0
    2f52:	19 f4       	brne	.+6      	; 0x2f5a <strncmp+0x18>
    2f54:	00 20       	and	r0, r0
    2f56:	b9 f7       	brne	.-18     	; 0x2f46 <strncmp+0x4>
    2f58:	88 1b       	sub	r24, r24
    2f5a:	99 0b       	sbc	r25, r25
    2f5c:	08 95       	ret

00002f5e <_exit>:
    2f5e:	f8 94       	cli

00002f60 <__stop_program>:
    2f60:	ff cf       	rjmp	.-2      	; 0x2f60 <__stop_program>
