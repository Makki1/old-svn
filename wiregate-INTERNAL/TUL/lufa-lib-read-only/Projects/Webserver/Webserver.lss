
Webserver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000024c  00800100  000080aa  0000813e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000080aa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a61  0080034c  0080034c  0000838a  2**0
                  ALLOC
  3 .stab         00002910  00000000  00000000  0000838c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000fe6  00000000  00000000  0000ac9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000da8  00000000  00000000  0000bc82  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00002134  00000000  00000000  0000ca2a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0001a1b2  00000000  00000000  0000eb5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00005b73  00000000  00000000  00028d10  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000115cc  00000000  00000000  0002e883  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001570  00000000  00000000  0003fe50  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00007623  00000000  00000000  000413c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000ad3f  00000000  00000000  000489e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00001178  00000000  00000000  00053722  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *  \param[in] BufferPtr     Pointer to the data source RAM buffer
 */
void DataflashManager_WriteBlocks_RAM(const uint32_t BlockAddress,
                                      uint16_t TotalBlocks,
                                      const uint8_t* BufferPtr)
{
       0:	07 c2       	rjmp	.+1038   	; 0x410 <__ctors_end>

static u16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(u16_t id) { ipid = id; }
       2:	00 00       	nop
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
       4:	23 c2       	rjmp	.+1094   	; 0x44c <__bad_interrupt>
	BYTE drv,			/* Physical drive number (0..) */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address (LBA) */
	BYTE count			/* Number of sectors to write (1..255) */
)
{
       6:	00 00       	nop
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       8:	21 c2       	rjmp	.+1090   	; 0x44c <__bad_interrupt>

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       a:	00 00       	nop
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
       c:	1f c2       	rjmp	.+1086   	; 0x44c <__bad_interrupt>
{
	USB_GetNextDescriptorOfType(BytesRem, CurrConfigLoc, AfterType);

	if (*BytesRem)
	  USB_GetNextDescriptorOfType(BytesRem, CurrConfigLoc, Type);
}
       e:	00 00       	nop
	return USB_Host_SendControlRequest(NULL);
}

uint8_t USB_Host_SetInterfaceAltSetting(const uint8_t InterfaceIndex,
                                        const uint8_t AltSetting)
{
      10:	1d c2       	rjmp	.+1082   	; 0x44c <__bad_interrupt>
	
	return USB_Host_SendControlRequest(Buffer);
}

uint8_t RNDIS_Host_SendKeepAlive(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
      12:	00 00       	nop
      14:	1b c2       	rjmp	.+1078   	; 0x44c <__bad_interrupt>
      16:	00 00       	nop
      18:	19 c2       	rjmp	.+1074   	; 0x44c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	17 c2       	rjmp	.+1070   	; 0x44c <__bad_interrupt>
      1e:	00 00       	nop
      20:	15 c2       	rjmp	.+1066   	; 0x44c <__bad_interrupt>
      22:	00 00       	nop
      24:	13 c2       	rjmp	.+1062   	; 0x44c <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 88 2a 	jmp	0x5510	; 0x5510 <__vector_10>
      2c:	0c 94 4b 2a 	jmp	0x5496	; 0x5496 <__vector_11>
      30:	0d c2       	rjmp	.+1050   	; 0x44c <__bad_interrupt>
      32:	00 00       	nop
      34:	0b c2       	rjmp	.+1046   	; 0x44c <__bad_interrupt>
      36:	00 00       	nop
      38:	09 c2       	rjmp	.+1042   	; 0x44c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	07 c2       	rjmp	.+1038   	; 0x44c <__bad_interrupt>
      3e:	00 00       	nop
      40:	05 c2       	rjmp	.+1034   	; 0x44c <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 50 1c 	jmp	0x38a0	; 0x38a0 <__vector_17>
      48:	01 c2       	rjmp	.+1026   	; 0x44c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ff c1       	rjmp	.+1022   	; 0x44c <__bad_interrupt>
      4e:	00 00       	nop
      50:	fd c1       	rjmp	.+1018   	; 0x44c <__bad_interrupt>
      52:	00 00       	nop
      54:	fb c1       	rjmp	.+1014   	; 0x44c <__bad_interrupt>
      56:	00 00       	nop
      58:	f9 c1       	rjmp	.+1010   	; 0x44c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	f7 c1       	rjmp	.+1006   	; 0x44c <__bad_interrupt>
      5e:	00 00       	nop
      60:	f5 c1       	rjmp	.+1002   	; 0x44c <__bad_interrupt>
      62:	00 00       	nop
      64:	f3 c1       	rjmp	.+998    	; 0x44c <__bad_interrupt>
      66:	00 00       	nop
      68:	f1 c1       	rjmp	.+994    	; 0x44c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	ef c1       	rjmp	.+990    	; 0x44c <__bad_interrupt>
      6e:	00 00       	nop
      70:	ed c1       	rjmp	.+986    	; 0x44c <__bad_interrupt>
      72:	00 00       	nop
      74:	eb c1       	rjmp	.+982    	; 0x44c <__bad_interrupt>
      76:	00 00       	nop
      78:	e9 c1       	rjmp	.+978    	; 0x44c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e7 c1       	rjmp	.+974    	; 0x44c <__bad_interrupt>
      7e:	00 00       	nop
      80:	e5 c1       	rjmp	.+970    	; 0x44c <__bad_interrupt>
      82:	00 00       	nop
      84:	e3 c1       	rjmp	.+966    	; 0x44c <__bad_interrupt>
      86:	00 00       	nop
      88:	e1 c1       	rjmp	.+962    	; 0x44c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	df c1       	rjmp	.+958    	; 0x44c <__bad_interrupt>
      8e:	00 00       	nop
      90:	dd c1       	rjmp	.+954    	; 0x44c <__bad_interrupt>
      92:	00 00       	nop
      94:	db c1       	rjmp	.+950    	; 0x44c <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 ef 02 01 08 eb 03 69 20 01 00 01 02     ..........i ....
      a8:	dc 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 5d 00 03 01 00 80 32 08 0b 00 02 02 02 ff     ..].....2.......
      ba:	00 09 04 00 00 01 02 02 ff 00 05 24 00 10 01 04     ...........$....
      ca:	24 02 00 05 24 06 00 01 07 05 85 03 08 00 ff 09     $...$...........
      da:	04 01 00 02 0a 00 00 00 07 05 02 02 40 00 01 07     ............@...
      ea:	05 81 02 40 00 01 09 04 02 00 02 08 06 50 00 07     ...@.........P..
      fa:	05 83 02 40 00 01 07 05 04 02 40 00 01              ...@......@..

00000107 <LanguageString>:
     107:	04 03 09 04                                         ....

0000010b <ManufacturerString>:
     10b:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
     11b:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000125 <ProductString>:
     125:	1e 03 4c 00 55 00 46 00 41 00 20 00 57 00 65 00     ..L.U.F.A. .W.e.
     135:	62 00 73 00 65 00 72 00 76 00 65 00 72 00 00 00     b.s.e.r.v.e.r...

00000145 <HTTP200Header>:
     145:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     155:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 58 58     .Server: LUFA XX
     165:	58 58 58 58 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e     XXXX..Connection
     175:	3a 20 63 6c 6f 73 65 0d 0a 4d 49 4d 45 2d 76 65     : close..MIME-ve
     185:	72 73 69 6f 6e 3a 20 31 2e 30 0d 0a 43 6f 6e 74     rsion: 1.0..Cont
     195:	65 6e 74 2d 54 79 70 65 3a 20 00                    ent-Type: .

000001a0 <HTTP404Header>:
     1a0:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     1b0:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1c0:	4c 55 46 41 20 58 58 58 58 58 58 0d 0a 43 6f 6e     LUFA XXXXXX..Con
     1d0:	6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a     nection: close..
     1e0:	4d 49 4d 45 2d 76 65 72 73 69 6f 6e 3a 20 31 2e     MIME-version: 1.
     1f0:	30 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a     0..Content-Type:
     200:	20 74 65 78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 45      text/plain....E
     210:	72 72 6f 72 20 34 30 34 3a 20 46 69 6c 65 20 4e     rror 404: File N
     220:	6f 74 20 46 6f 75 6e 64 3a 20 2f 00                 ot Found: /.

0000022c <DefaultDirFileName>:
     22c:	69 6e 64 65 78 2e 68 74 6d 00                       index.htm.

00000236 <DefaultMIMEType>:
     236:	74 65 78 74 2f 70 6c 61 69 6e 00                    text/plain.

00000241 <__c.1870>:
     241:	47 45 54 00                                         GET.

00000245 <__c.1907>:
     245:	0d 0a 0d 0a 00                                      .....

0000024a <WelcomeHeader>:
     24a:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     25a:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     26a:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 2a 20     ************..* 
     27a:	20 20 20 20 20 20 4c 55 46 41 20 75 49 50 20 57           LUFA uIP W
     28a:	65 62 73 65 72 76 65 72 20 28 54 45 4c 4e 45 54     ebserver (TELNET
     29a:	29 20 20 20 20 20 20 20 20 2a 0d 0a 2a 2a 2a 2a     )        *..****
     2aa:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     2ba:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     2ca:	2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 00                    ********...

000002d5 <TELNETMenu>:
     2d5:	0d 0a 20 20 3d 3d 20 41 76 61 69 6c 61 62 6c 65     ..  == Available
     2e5:	20 43 6f 6d 6d 61 6e 64 73 3a 20 3d 3d 0d 0a 20      Commands: ==.. 
     2f5:	20 20 20 20 63 29 20 4c 69 73 74 20 41 63 74 69         c) List Acti
     305:	76 65 20 54 43 50 20 43 6f 6e 6e 65 63 74 69 6f     ve TCP Connectio
     315:	6e 73 0d 0a 20 20 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d     ns..  ==========
     325:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 0d     ===============.
     335:	0a 0d 0a 3e 00                                      ...>.

0000033a <CurrentConnectionsHeader>:
     33a:	0d 0a 2a 20 43 75 72 72 65 6e 74 20 54 43 50 20     ..* Current TCP 
     34a:	43 6f 6e 6e 65 63 74 69 6f 6e 73 3a 20 2a 0d 0a     Connections: *..
     35a:	00                                                  .

0000035b <__c.1987>:
     35b:	49 6e 76 61 6c 69 64 20 43 6f 6d 6d 61 6e 64 2e     Invalid Command.
     36b:	0d 0a 00                                            ...

0000036e <__c.2022>:
     36e:	25 75 29 20 25 64 2e 25 64 2e 25 64 2e 25 64 20     %u) %d.%d.%d.%d 
     37e:	28 4c 6f 63 61 6c 20 50 6f 72 74 20 25 75 20 3c     (Local Port %u <
     38e:	3d 3e 20 52 65 6d 6f 74 65 20 50 6f 72 74 20 25     => Remote Port %
     39e:	75 29 0d 0a 00                                      u)...

000003a3 <AdapterSupportedOIDList>:
     3a3:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3b3:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3c3:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3d3:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3e3:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     3f3:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     403:	01 01 02 01 02 01 02 01 03 01 02 01 00              .............

00000410 <__ctors_end>:
     410:	11 24       	eor	r1, r1
     412:	1f be       	out	0x3f, r1	; 63
     414:	cf ef       	ldi	r28, 0xFF	; 255
     416:	d0 e2       	ldi	r29, 0x20	; 32
     418:	de bf       	out	0x3e, r29	; 62
     41a:	cd bf       	out	0x3d, r28	; 61

0000041c <__do_copy_data>:
     41c:	13 e0       	ldi	r17, 0x03	; 3
     41e:	a0 e0       	ldi	r26, 0x00	; 0
     420:	b1 e0       	ldi	r27, 0x01	; 1
     422:	ea ea       	ldi	r30, 0xAA	; 170
     424:	f0 e8       	ldi	r31, 0x80	; 128
     426:	00 e0       	ldi	r16, 0x00	; 0
     428:	0b bf       	out	0x3b, r16	; 59
     42a:	02 c0       	rjmp	.+4      	; 0x430 <__do_copy_data+0x14>
     42c:	07 90       	elpm	r0, Z+
     42e:	0d 92       	st	X+, r0
     430:	ac 34       	cpi	r26, 0x4C	; 76
     432:	b1 07       	cpc	r27, r17
     434:	d9 f7       	brne	.-10     	; 0x42c <__do_copy_data+0x10>

00000436 <__do_clear_bss>:
     436:	1d e0       	ldi	r17, 0x0D	; 13
     438:	ac e4       	ldi	r26, 0x4C	; 76
     43a:	b3 e0       	ldi	r27, 0x03	; 3
     43c:	01 c0       	rjmp	.+2      	; 0x440 <.do_clear_bss_start>

0000043e <.do_clear_bss_loop>:
     43e:	1d 92       	st	X+, r1

00000440 <.do_clear_bss_start>:
     440:	ad 3a       	cpi	r26, 0xAD	; 173
     442:	b1 07       	cpc	r27, r17
     444:	e1 f7       	brne	.-8      	; 0x43e <.do_clear_bss_loop>
     446:	33 d0       	rcall	.+102    	; 0x4ae <main>
     448:	0c 94 53 40 	jmp	0x80a6	; 0x80a6 <_exit>

0000044c <__bad_interrupt>:
     44c:	d9 cd       	rjmp	.-1102   	; 0x0 <__vectors>

0000044e <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     44e:	84 b7       	in	r24, 0x34	; 52
     450:	87 7f       	andi	r24, 0xF7	; 247
     452:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     454:	88 e1       	ldi	r24, 0x18	; 24
     456:	0f b6       	in	r0, 0x3f	; 63
     458:	f8 94       	cli
     45a:	80 93 60 00 	sts	0x0060, r24
     45e:	10 92 60 00 	sts	0x0060, r1
     462:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	80 e8       	ldi	r24, 0x80	; 128
     468:	0f b6       	in	r0, 0x3f	; 63
     46a:	f8 94       	cli
     46c:	80 93 61 00 	sts	0x0061, r24
     470:	90 93 61 00 	sts	0x0061, r25
     474:	0f be       	out	0x3f, r0	; 63
			 *                         \c SPI_SCK_*, \c SPI_SAMPLE_*, \c SPI_ORDER_* and \c SPI_MODE_* masks.
			 */
			static inline void SPI_Init(const uint8_t SPIOptions)
			{
				/* Prevent high rise times on PB.0 (/SS) from forcing a change to SPI slave mode */
				DDRB  |= (1 << 0);
     476:	20 9a       	sbi	0x04, 0	; 4
				PORTB |= (1 << 0);
     478:	28 9a       	sbi	0x05, 0	; 5

				DDRB  |=  ((1 << 1) | (1 << 2));
     47a:	84 b1       	in	r24, 0x04	; 4
     47c:	86 60       	ori	r24, 0x06	; 6
     47e:	84 b9       	out	0x04, r24	; 4
				DDRB  &= ~(1 << 3);
     480:	23 98       	cbi	0x04, 3	; 4
				PORTB |=  (1 << 3);
     482:	2b 9a       	sbi	0x05, 3	; 5

				if (SPIOptions & SPI_USE_DOUBLESPEED)
				  SPSR |= (1 << SPI2X);
     484:	8d b5       	in	r24, 0x2d	; 45
     486:	81 60       	ori	r24, 0x01	; 1
     488:	8d bd       	out	0x2d, r24	; 45
				else
				  SPSR &= ~(1 << SPI2X);

				/* Switch /SS to input mode after configuration to allow for forced mode changes */
				DDRB &= ~(1 << 0);
     48a:	20 98       	cbi	0x04, 0	; 4

				SPCR  = ((1 << SPE) | SPIOptions);
     48c:	8c e5       	ldi	r24, 0x5C	; 92
     48e:	8c bd       	out	0x2c, r24	; 44
			/** Initializes the dataflash driver so that commands and data may be sent to an attached dataflash IC.
			 *  The microcontroller's SPI driver MUST be initialized before any of the dataflash commands are used.
			 */
			static inline void Dataflash_Init(void)
			{
				DATAFLASH_CHIPCS_DDR  |= DATAFLASH_CHIPCS_MASK;
     490:	8d b1       	in	r24, 0x0d	; 13
     492:	83 60       	ori	r24, 0x03	; 3
     494:	8d b9       	out	0x0d, r24	; 13
				DATAFLASH_CHIPCS_PORT |= DATAFLASH_CHIPCS_MASK;
     496:	8e b1       	in	r24, 0x0e	; 14
     498:	83 60       	ori	r24, 0x03	; 3
     49a:	8e b9       	out	0x0e, r24	; 14

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     49c:	8a b1       	in	r24, 0x0a	; 10
     49e:	80 6f       	ori	r24, 0xF0	; 240
     4a0:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4a2:	8b b1       	in	r24, 0x0b	; 11
     4a4:	8f 70       	andi	r24, 0x0F	; 15
     4a6:	8b b9       	out	0x0b, r24	; 11

	/* Hardware Initialization */
	SPI_Init(SPI_SPEED_FCPU_DIV_2 | SPI_SCK_LEAD_FALLING | SPI_SAMPLE_TRAILING | SPI_MODE_MASTER);
	Dataflash_Init();
	LEDs_Init();
	USB_Init(USB_MODE_UID);
     4a8:	83 e0       	ldi	r24, 0x03	; 3
     4aa:	0c 94 0f 2a 	jmp	0x541e	; 0x541e <USB_Init>

000004ae <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     4ae:	cf df       	rcall	.-98     	; 0x44e <SetupHardware>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     4b0:	8b b1       	in	r24, 0x0b	; 11
     4b2:	8f 70       	andi	r24, 0x0F	; 15
     4b4:	80 61       	ori	r24, 0x10	; 16
     4b6:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     4b8:	78 94       	sei

	for (;;)
	{
		if (USB_CurrentMode == USB_MODE_Host)
     4ba:	80 91 cf 03 	lds	r24, 0x03CF
     4be:	82 30       	cpi	r24, 0x02	; 2
     4c0:	11 f4       	brne	.+4      	; 0x4c6 <main+0x18>
		  USBHostMode_USBTask();
     4c2:	03 d1       	rcall	.+518    	; 0x6ca <USBHostMode_USBTask>
     4c4:	01 c0       	rjmp	.+2      	; 0x4c8 <main+0x1a>
		else
		  USBDeviceMode_USBTask();
     4c6:	68 d0       	rcall	.+208    	; 0x598 <USBDeviceMode_USBTask>

		USB_USBTask();
     4c8:	0e 94 98 32 	call	0x6530	; 0x6530 <USB_USBTask>
     4cc:	f6 cf       	rjmp	.-20     	; 0x4ba <main+0xc>

000004ce <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     4ce:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     4d0:	29 2f       	mov	r18, r25
     4d2:	33 27       	eor	r19, r19
     4d4:	22 30       	cpi	r18, 0x02	; 2
     4d6:	49 f0       	breq	.+18     	; 0x4ea <CALLBACK_USB_GetDescriptor+0x1c>
     4d8:	23 30       	cpi	r18, 0x03	; 3
     4da:	61 f0       	breq	.+24     	; 0x4f4 <CALLBACK_USB_GetDescriptor+0x26>
     4dc:	21 30       	cpi	r18, 0x01	; 1
     4de:	f1 f4       	brne	.+60     	; 0x51c <CALLBACK_USB_GetDescriptor+0x4e>
     4e0:	e8 e9       	ldi	r30, 0x98	; 152
     4e2:	f0 e0       	ldi	r31, 0x00	; 0
     4e4:	82 e1       	ldi	r24, 0x12	; 18
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	1d c0       	rjmp	.+58     	; 0x524 <CALLBACK_USB_GetDescriptor+0x56>
     4ea:	ea ea       	ldi	r30, 0xAA	; 170
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	8d e5       	ldi	r24, 0x5D	; 93
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	18 c0       	rjmp	.+48     	; 0x524 <CALLBACK_USB_GetDescriptor+0x56>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     4f4:	81 30       	cpi	r24, 0x01	; 1
     4f6:	49 f0       	breq	.+18     	; 0x50a <CALLBACK_USB_GetDescriptor+0x3c>
     4f8:	81 30       	cpi	r24, 0x01	; 1
     4fa:	18 f0       	brcs	.+6      	; 0x502 <CALLBACK_USB_GetDescriptor+0x34>
     4fc:	82 30       	cpi	r24, 0x02	; 2
     4fe:	71 f4       	brne	.+28     	; 0x51c <CALLBACK_USB_GetDescriptor+0x4e>
     500:	08 c0       	rjmp	.+16     	; 0x512 <CALLBACK_USB_GetDescriptor+0x44>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     502:	e7 e0       	ldi	r30, 0x07	; 7
     504:	f1 e0       	ldi	r31, 0x01	; 1
     506:	84 91       	lpm	r24, Z+
     508:	07 c0       	rjmp	.+14     	; 0x518 <CALLBACK_USB_GetDescriptor+0x4a>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     50a:	eb e0       	ldi	r30, 0x0B	; 11
     50c:	f1 e0       	ldi	r31, 0x01	; 1
     50e:	84 91       	lpm	r24, Z+
     510:	03 c0       	rjmp	.+6      	; 0x518 <CALLBACK_USB_GetDescriptor+0x4a>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     512:	e5 e2       	ldi	r30, 0x25	; 37
     514:	f1 e0       	ldi	r31, 0x01	; 1
     516:	84 91       	lpm	r24, Z+
     518:	90 e0       	ldi	r25, 0x00	; 0
     51a:	04 c0       	rjmp	.+8      	; 0x524 <CALLBACK_USB_GetDescriptor+0x56>
     51c:	e0 e0       	ldi	r30, 0x00	; 0
     51e:	f0 e0       	ldi	r31, 0x00	; 0
     520:	80 e0       	ldi	r24, 0x00	; 0
     522:	90 e0       	ldi	r25, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     524:	ed 93       	st	X+, r30
     526:	fc 93       	st	X, r31
	return Size;
}
     528:	08 95       	ret

0000052a <EVENT_USB_Device_Disconnect>:
     52a:	8b b1       	in	r24, 0x0b	; 11
     52c:	8f 70       	andi	r24, 0x0F	; 15
     52e:	80 61       	ori	r24, 0x10	; 16
     530:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     532:	08 95       	ret

00000534 <CALLBACK_MS_Device_SCSICommandReceived>:
     534:	2b b1       	in	r18, 0x0b	; 11
     536:	2f 70       	andi	r18, 0x0F	; 15
     538:	20 6d       	ori	r18, 0xD0	; 208
     53a:	2b b9       	out	0x0b, r18	; 11
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess;

	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
     53c:	1d d1       	rcall	.+570    	; 0x778 <SCSI_DecodeSCSICommand>
     53e:	9b b1       	in	r25, 0x0b	; 11
     540:	9f 70       	andi	r25, 0x0F	; 15
     542:	90 62       	ori	r25, 0x20	; 32
     544:	9b b9       	out	0x0b, r25	; 11
	LEDs_SetAllLEDs(LEDMASK_USB_READY);

	return CommandSuccess;
}
     546:	08 95       	ret

00000548 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface_Device);
     548:	83 e1       	ldi	r24, 0x13	; 19
     54a:	91 e0       	ldi	r25, 0x01	; 1
     54c:	0e 94 d5 35 	call	0x6baa	; 0x6baa <RNDIS_Device_ProcessControlRequest>
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
     550:	8e ea       	ldi	r24, 0xAE	; 174
     552:	91 e0       	ldi	r25, 0x01	; 1
     554:	0c 94 1d 34 	jmp	0x683a	; 0x683a <MS_Device_ProcessControlRequest>

00000558 <EVENT_USB_Device_ConfigurationChanged>:
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}

/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     558:	0f 93       	push	r16
     55a:	1f 93       	push	r17
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface_Device);
     55c:	83 e1       	ldi	r24, 0x13	; 19
     55e:	91 e0       	ldi	r25, 0x01	; 1
     560:	0e 94 84 35 	call	0x6b08	; 0x6b08 <RNDIS_Device_ConfigureEndpoints>
     564:	08 2f       	mov	r16, r24
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
     566:	8e ea       	ldi	r24, 0xAE	; 174
     568:	91 e0       	ldi	r25, 0x01	; 1
     56a:	0e 94 de 33 	call	0x67bc	; 0x67bc <MS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     56e:	10 e0       	ldi	r17, 0x00	; 0
     570:	90 e0       	ldi	r25, 0x00	; 0
     572:	08 23       	and	r16, r24
     574:	19 23       	and	r17, r25
     576:	00 ff       	sbrs	r16, 0
     578:	02 c0       	rjmp	.+4      	; 0x57e <EVENT_USB_Device_ConfigurationChanged+0x26>
     57a:	90 e2       	ldi	r25, 0x20	; 32
     57c:	01 c0       	rjmp	.+2      	; 0x580 <EVENT_USB_Device_ConfigurationChanged+0x28>
     57e:	90 e9       	ldi	r25, 0x90	; 144
     580:	8b b1       	in	r24, 0x0b	; 11
     582:	8f 70       	andi	r24, 0x0F	; 15
     584:	98 2b       	or	r25, r24
     586:	9b b9       	out	0x0b, r25	; 11
}
     588:	1f 91       	pop	r17
     58a:	0f 91       	pop	r16
     58c:	08 95       	ret

0000058e <EVENT_USB_Device_Connect>:
     58e:	8b b1       	in	r24, 0x0b	; 11
     590:	8f 70       	andi	r24, 0x0F	; 15
     592:	80 63       	ori	r24, 0x30	; 48
     594:	8b b9       	out	0x0b, r24	; 11
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);

	uIPManagement_Init();
}
     596:	60 c6       	rjmp	.+3264   	; 0x1258 <uIPManagement_Init>

00000598 <USBDeviceMode_USBTask>:
/** USB device mode management task. This function manages the Mass Storage Device class driver when the device is
 *  initialized in USB device mode.
 */
void USBDeviceMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Device)
     598:	80 91 cf 03 	lds	r24, 0x03CF
     59c:	81 30       	cpi	r24, 0x01	; 1
     59e:	49 f4       	brne	.+18     	; 0x5b2 <USBDeviceMode_USBTask+0x1a>
	  return;

	uIPManagement_ManageNetwork();
     5a0:	8a d5       	rcall	.+2836   	; 0x10b6 <uIPManagement_ManageNetwork>

	RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface_Device);
     5a2:	83 e1       	ldi	r24, 0x13	; 19
     5a4:	91 e0       	ldi	r25, 0x01	; 1
     5a6:	0e 94 e2 34 	call	0x69c4	; 0x69c4 <RNDIS_Device_USBTask>
	MS_Device_USBTask(&Disk_MS_Interface);
     5aa:	8e ea       	ldi	r24, 0xAE	; 174
     5ac:	91 e0       	ldi	r25, 0x01	; 1
     5ae:	0c 94 bc 32 	jmp	0x6578	; 0x6578 <MS_Device_USBTask>
     5b2:	08 95       	ret

000005b4 <EVENT_USB_Host_DeviceAttached>:
     5b4:	8b b1       	in	r24, 0x0b	; 11
     5b6:	8f 70       	andi	r24, 0x0F	; 15
     5b8:	80 63       	ori	r24, 0x30	; 48
     5ba:	8b b9       	out	0x0b, r24	; 11
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Host_DeviceAttached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     5bc:	08 95       	ret

000005be <EVENT_USB_Host_DeviceUnattached>:
     5be:	8b b1       	in	r24, 0x0b	; 11
     5c0:	8f 70       	andi	r24, 0x0F	; 15
     5c2:	80 61       	ori	r24, 0x10	; 16
     5c4:	8b b9       	out	0x0b, r24	; 11
 *  stops the library USB task management process.
 */
void EVENT_USB_Host_DeviceUnattached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     5c6:	08 95       	ret

000005c8 <EVENT_USB_Host_DeviceEnumerationFailed>:
     5c8:	8b b1       	in	r24, 0x0b	; 11
     5ca:	8f 70       	andi	r24, 0x0F	; 15
     5cc:	80 69       	ori	r24, 0x90	; 144
     5ce:	8b b9       	out	0x0b, r24	; 11
 *  enumerating an attached USB device.
 */
void EVENT_USB_Host_DeviceEnumerationFailed(const uint8_t ErrorCode, const uint8_t SubErrorCode)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
}
     5d0:	08 95       	ret

000005d2 <EVENT_USB_Host_HostError>:
}

/** Event handler for the USB_HostError event. This indicates that a hardware error occurred while in host mode. */
void EVENT_USB_Host_HostError(const uint8_t ErrorCode)
{
	USB_Disable();
     5d2:	0e 94 67 29 	call	0x52ce	; 0x52ce <USB_Disable>
     5d6:	8b b1       	in	r24, 0x0b	; 11
     5d8:	8f 70       	andi	r24, 0x0F	; 15
     5da:	80 69       	ori	r24, 0x90	; 144
     5dc:	8b b9       	out	0x0b, r24	; 11
     5de:	ff cf       	rjmp	.-2      	; 0x5de <EVENT_USB_Host_HostError+0xc>

000005e0 <EVENT_USB_Host_DeviceEnumerationComplete>:

/** Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully
 *  enumerated by the host and is now ready to be used by the application.
 */
void EVENT_USB_Host_DeviceEnumerationComplete(void)
{
     5e0:	0f 93       	push	r16
     5e2:	1f 93       	push	r17
     5e4:	df 93       	push	r29
     5e6:	cf 93       	push	r28
     5e8:	cd b7       	in	r28, 0x3d	; 61
     5ea:	de b7       	in	r29, 0x3e	; 62
     5ec:	c6 50       	subi	r28, 0x06	; 6
     5ee:	d2 40       	sbci	r29, 0x02	; 2
     5f0:	0f b6       	in	r0, 0x3f	; 63
     5f2:	f8 94       	cli
     5f4:	de bf       	out	0x3e, r29	; 62
     5f6:	0f be       	out	0x3f, r0	; 63
     5f8:	cd bf       	out	0x3d, r28	; 61
     5fa:	8b b1       	in	r24, 0x0b	; 11
     5fc:	8f 70       	andi	r24, 0x0F	; 15
     5fe:	80 63       	ori	r24, 0x30	; 48
     600:	8b b9       	out	0x0b, r24	; 11
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);

	uint16_t ConfigDescriptorSize;
	uint8_t  ConfigDescriptorData[512];

	if (USB_Host_GetDeviceConfigDescriptor(1, &ConfigDescriptorSize, ConfigDescriptorData,
     602:	8e 01       	movw	r16, r28
     604:	09 5f       	subi	r16, 0xF9	; 249
     606:	1f 4f       	sbci	r17, 0xFF	; 255
     608:	81 e0       	ldi	r24, 0x01	; 1
     60a:	be 01       	movw	r22, r28
     60c:	6f 5f       	subi	r22, 0xFF	; 255
     60e:	7f 4f       	sbci	r23, 0xFF	; 255
     610:	a8 01       	movw	r20, r16
     612:	20 e0       	ldi	r18, 0x00	; 0
     614:	32 e0       	ldi	r19, 0x02	; 2
     616:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <USB_Host_GetDeviceConfigDescriptor>
     61a:	88 23       	and	r24, r24
     61c:	71 f4       	brne	.+28     	; 0x63a <EVENT_USB_Host_DeviceEnumerationComplete+0x5a>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (RNDIS_Host_ConfigurePipes(&Ethernet_RNDIS_Interface_Host,
     61e:	69 81       	ldd	r22, Y+1	; 0x01
     620:	7a 81       	ldd	r23, Y+2	; 0x02
     622:	85 ee       	ldi	r24, 0xE5	; 229
     624:	91 e0       	ldi	r25, 0x01	; 1
     626:	a8 01       	movw	r20, r16
     628:	0e 94 bb 3b 	call	0x7776	; 0x7776 <RNDIS_Host_ConfigurePipes>
     62c:	88 23       	and	r24, r24
     62e:	29 f4       	brne	.+10     	; 0x63a <EVENT_USB_Host_DeviceEnumerationComplete+0x5a>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (USB_Host_SetDeviceConfiguration(1) != HOST_SENDCONTROL_Successful)
     630:	81 e0       	ldi	r24, 0x01	; 1
     632:	0e 94 71 32 	call	0x64e2	; 0x64e2 <USB_Host_SetDeviceConfiguration>
     636:	88 23       	and	r24, r24
     638:	21 f0       	breq	.+8      	; 0x642 <EVENT_USB_Host_DeviceEnumerationComplete+0x62>
     63a:	8b b1       	in	r24, 0x0b	; 11
     63c:	8f 70       	andi	r24, 0x0F	; 15
     63e:	80 69       	ori	r24, 0x90	; 144
     640:	37 c0       	rjmp	.+110    	; 0x6b0 <EVENT_USB_Host_DeviceEnumerationComplete+0xd0>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (RNDIS_Host_InitializeDevice(&Ethernet_RNDIS_Interface_Host) != HOST_SENDCONTROL_Successful)
     642:	85 ee       	ldi	r24, 0xE5	; 229
     644:	91 e0       	ldi	r25, 0x01	; 1
     646:	0e 94 43 3b 	call	0x7686	; 0x7686 <RNDIS_Host_InitializeDevice>
     64a:	88 23       	and	r24, r24
     64c:	29 f5       	brne	.+74     	; 0x698 <EVENT_USB_Host_DeviceEnumerationComplete+0xb8>
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		USB_Host_SetDeviceConfiguration(0);
		return;
	}

	uint32_t PacketFilter = (REMOTE_NDIS_PACKET_DIRECTED | REMOTE_NDIS_PACKET_BROADCAST);
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	a0 e0       	ldi	r26, 0x00	; 0
     654:	b0 e0       	ldi	r27, 0x00	; 0
     656:	8b 83       	std	Y+3, r24	; 0x03
     658:	9c 83       	std	Y+4, r25	; 0x04
     65a:	ad 83       	std	Y+5, r26	; 0x05
     65c:	be 83       	std	Y+6, r27	; 0x06
	if (RNDIS_Host_SetRNDISProperty(&Ethernet_RNDIS_Interface_Host, OID_GEN_CURRENT_PACKET_FILTER,
     65e:	85 ee       	ldi	r24, 0xE5	; 229
     660:	91 e0       	ldi	r25, 0x01	; 1
     662:	4e e0       	ldi	r20, 0x0E	; 14
     664:	51 e0       	ldi	r21, 0x01	; 1
     666:	61 e0       	ldi	r22, 0x01	; 1
     668:	70 e0       	ldi	r23, 0x00	; 0
     66a:	9e 01       	movw	r18, r28
     66c:	2d 5f       	subi	r18, 0xFD	; 253
     66e:	3f 4f       	sbci	r19, 0xFF	; 255
     670:	04 e0       	ldi	r16, 0x04	; 4
     672:	10 e0       	ldi	r17, 0x00	; 0
     674:	0e 94 9f 3a 	call	0x753e	; 0x753e <RNDIS_Host_SetRNDISProperty>
     678:	88 23       	and	r24, r24
     67a:	71 f4       	brne	.+28     	; 0x698 <EVENT_USB_Host_DeviceEnumerationComplete+0xb8>
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		USB_Host_SetDeviceConfiguration(0);
		return;
	}

	if (RNDIS_Host_QueryRNDISProperty(&Ethernet_RNDIS_Interface_Host, OID_802_3_CURRENT_ADDRESS,
     67c:	85 ee       	ldi	r24, 0xE5	; 229
     67e:	91 e0       	ldi	r25, 0x01	; 1
     680:	42 e0       	ldi	r20, 0x02	; 2
     682:	51 e0       	ldi	r21, 0x01	; 1
     684:	61 e0       	ldi	r22, 0x01	; 1
     686:	71 e0       	ldi	r23, 0x01	; 1
     688:	22 ed       	ldi	r18, 0xD2	; 210
     68a:	33 e0       	ldi	r19, 0x03	; 3
     68c:	06 e0       	ldi	r16, 0x06	; 6
     68e:	10 e0       	ldi	r17, 0x00	; 0
     690:	0e 94 fe 39 	call	0x73fc	; 0x73fc <RNDIS_Host_QueryRNDISProperty>
     694:	88 23       	and	r24, r24
     696:	41 f0       	breq	.+16     	; 0x6a8 <EVENT_USB_Host_DeviceEnumerationComplete+0xc8>
     698:	8b b1       	in	r24, 0x0b	; 11
     69a:	8f 70       	andi	r24, 0x0F	; 15
     69c:	80 69       	ori	r24, 0x90	; 144
     69e:	8b b9       	out	0x0b, r24	; 11
	                                  &MACAddress, sizeof(MACAddress)) != HOST_SENDCONTROL_Successful)
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		USB_Host_SetDeviceConfiguration(0);
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	0e 94 71 32 	call	0x64e2	; 0x64e2 <USB_Host_SetDeviceConfiguration>
     6a6:	05 c0       	rjmp	.+10     	; 0x6b2 <EVENT_USB_Host_DeviceEnumerationComplete+0xd2>
		return;
	}

	/* Initialize uIP stack */
	uIPManagement_Init();
     6a8:	d7 d5       	rcall	.+2990   	; 0x1258 <uIPManagement_Init>
     6aa:	8b b1       	in	r24, 0x0b	; 11
     6ac:	8f 70       	andi	r24, 0x0F	; 15
     6ae:	80 62       	ori	r24, 0x20	; 32
     6b0:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_READY);
}
     6b2:	ca 5f       	subi	r28, 0xFA	; 250
     6b4:	dd 4f       	sbci	r29, 0xFD	; 253
     6b6:	0f b6       	in	r0, 0x3f	; 63
     6b8:	f8 94       	cli
     6ba:	de bf       	out	0x3e, r29	; 62
     6bc:	0f be       	out	0x3f, r0	; 63
     6be:	cd bf       	out	0x3d, r28	; 61
     6c0:	cf 91       	pop	r28
     6c2:	df 91       	pop	r29
     6c4:	1f 91       	pop	r17
     6c6:	0f 91       	pop	r16
     6c8:	08 95       	ret

000006ca <USBHostMode_USBTask>:
/** USB host mode management task. This function manages the RNDIS Host class driver and uIP stack when the device is
 *  initialized in USB host mode.
 */
void USBHostMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Host)
     6ca:	80 91 cf 03 	lds	r24, 0x03CF
     6ce:	82 30       	cpi	r24, 0x02	; 2
     6d0:	09 f4       	brne	.+2      	; 0x6d4 <USBHostMode_USBTask+0xa>
	  return;

	uIPManagement_ManageNetwork();
     6d2:	f1 c4       	rjmp	.+2530   	; 0x10b6 <uIPManagement_ManageNetwork>
     6d4:	08 95       	ret

000006d6 <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
     6d6:	0f 93       	push	r16
     6d8:	1f 93       	push	r17
     6da:	cf 93       	push	r28
     6dc:	df 93       	push	r29
     6de:	8c 01       	movw	r16, r24
     6e0:	96 2f       	mov	r25, r22
				{
					uint32_t DWord;
					uint8_t  Bytes[4];
				} Data;

				Data.DWord = DWord;
     6e2:	f8 01       	movw	r30, r16
     6e4:	43 8d       	ldd	r20, Z+27	; 0x1b
     6e6:	54 8d       	ldd	r21, Z+28	; 0x1c
     6e8:	65 8d       	ldd	r22, Z+29	; 0x1d
     6ea:	76 8d       	ldd	r23, Z+30	; 0x1e

				Temp = Data.Bytes[0];
     6ec:	84 2f       	mov	r24, r20
				Data.Bytes[0] = Data.Bytes[3];
     6ee:	47 2f       	mov	r20, r23
				Data.Bytes[3] = Temp;
     6f0:	78 2f       	mov	r23, r24

				Temp = Data.Bytes[1];
     6f2:	85 2f       	mov	r24, r21
				Data.Bytes[1] = Data.Bytes[2];
     6f4:	56 2f       	mov	r21, r22
				Data.Bytes[2] = Temp;
     6f6:	68 2f       	mov	r22, r24
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     6f8:	c0 a1       	ldd	r28, Z+32	; 0x20
     6fa:	d1 a1       	ldd	r29, Z+33	; 0x21

				Temp = Data.Bytes[0];
     6fc:	8c 2f       	mov	r24, r28
				Data.Bytes[0] = Data.Bytes[1];
     6fe:	cd 2f       	mov	r28, r29
				Data.Bytes[1] = Temp;
     700:	d8 2f       	mov	r29, r24

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= VIRTUAL_MEMORY_BLOCKS)
     702:	40 30       	cpi	r20, 0x00	; 0
     704:	f0 e8       	ldi	r31, 0x80	; 128
     706:	5f 07       	cpc	r21, r31
     708:	f0 e0       	ldi	r31, 0x00	; 0
     70a:	6f 07       	cpc	r22, r31
     70c:	f0 e0       	ldi	r31, 0x00	; 0
     70e:	7f 07       	cpc	r23, r31
     710:	68 f0       	brcs	.+26     	; 0x72c <SCSI_Command_ReadWrite_10+0x56>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     712:	80 91 01 02 	lds	r24, 0x0201
     716:	80 7f       	andi	r24, 0xF0	; 240
     718:	85 60       	ori	r24, 0x05	; 5
     71a:	80 93 01 02 	sts	0x0201, r24
     71e:	81 e2       	ldi	r24, 0x21	; 33
     720:	80 93 0b 02 	sts	0x020B, r24
     724:	10 92 0c 02 	sts	0x020C, r1
     728:	80 e0       	ldi	r24, 0x00	; 0
     72a:	21 c0       	rjmp	.+66     	; 0x76e <SCSI_Command_ReadWrite_10+0x98>

		return false;
	}
	
	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
     72c:	99 23       	and	r25, r25
     72e:	21 f0       	breq	.+8      	; 0x738 <SCSI_Command_ReadWrite_10+0x62>
	  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     730:	c8 01       	movw	r24, r16
     732:	9e 01       	movw	r18, r28
     734:	50 d2       	rcall	.+1184   	; 0xbd6 <DataflashManager_ReadBlocks>
     736:	03 c0       	rjmp	.+6      	; 0x73e <SCSI_Command_ReadWrite_10+0x68>
	else
	  DataflashManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     738:	c8 01       	movw	r24, r16
     73a:	9e 01       	movw	r18, r28
     73c:	62 d3       	rcall	.+1732   	; 0xe02 <DataflashManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
     73e:	9e 01       	movw	r18, r28
     740:	40 e0       	ldi	r20, 0x00	; 0
     742:	50 e0       	ldi	r21, 0x00	; 0
     744:	89 e0       	ldi	r24, 0x09	; 9
     746:	22 0f       	add	r18, r18
     748:	33 1f       	adc	r19, r19
     74a:	44 1f       	adc	r20, r20
     74c:	55 1f       	adc	r21, r21
     74e:	8a 95       	dec	r24
     750:	d1 f7       	brne	.-12     	; 0x746 <SCSI_Command_ReadWrite_10+0x70>
     752:	f8 01       	movw	r30, r16
     754:	82 89       	ldd	r24, Z+18	; 0x12
     756:	93 89       	ldd	r25, Z+19	; 0x13
     758:	a4 89       	ldd	r26, Z+20	; 0x14
     75a:	b5 89       	ldd	r27, Z+21	; 0x15
     75c:	82 1b       	sub	r24, r18
     75e:	93 0b       	sbc	r25, r19
     760:	a4 0b       	sbc	r26, r20
     762:	b5 0b       	sbc	r27, r21
     764:	82 8b       	std	Z+18, r24	; 0x12
     766:	93 8b       	std	Z+19, r25	; 0x13
     768:	a4 8b       	std	Z+20, r26	; 0x14
     76a:	b5 8b       	std	Z+21, r27	; 0x15
     76c:	81 e0       	ldi	r24, 0x01	; 1

	return true;
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	1f 91       	pop	r17
     774:	0f 91       	pop	r16
     776:	08 95       	ret

00000778 <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean true if the command completed successfully, false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     778:	cf 92       	push	r12
     77a:	df 92       	push	r13
     77c:	ef 92       	push	r14
     77e:	ff 92       	push	r15
     780:	0f 93       	push	r16
     782:	1f 93       	push	r17
     784:	df 93       	push	r29
     786:	cf 93       	push	r28
     788:	cd b7       	in	r28, 0x3d	; 61
     78a:	de b7       	in	r29, 0x3e	; 62
     78c:	28 97       	sbiw	r28, 0x08	; 8
     78e:	0f b6       	in	r0, 0x3f	; 63
     790:	f8 94       	cli
     792:	de bf       	out	0x3e, r29	; 62
     794:	0f be       	out	0x3f, r0	; 63
     796:	cd bf       	out	0x3d, r28	; 61
     798:	6c 01       	movw	r12, r24
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     79a:	fc 01       	movw	r30, r24
     79c:	81 8d       	ldd	r24, Z+25	; 0x19
     79e:	8d 31       	cpi	r24, 0x1D	; 29
     7a0:	09 f4       	brne	.+2      	; 0x7a4 <SCSI_DecodeSCSICommand+0x2c>
     7a2:	b2 c0       	rjmp	.+356    	; 0x908 <SCSI_DecodeSCSICommand+0x190>
     7a4:	8e 31       	cpi	r24, 0x1E	; 30
     7a6:	78 f4       	brcc	.+30     	; 0x7c6 <SCSI_DecodeSCSICommand+0x4e>
     7a8:	83 30       	cpi	r24, 0x03	; 3
     7aa:	09 f4       	brne	.+2      	; 0x7ae <SCSI_DecodeSCSICommand+0x36>
     7ac:	57 c0       	rjmp	.+174    	; 0x85c <SCSI_DecodeSCSICommand+0xe4>
     7ae:	84 30       	cpi	r24, 0x04	; 4
     7b0:	20 f4       	brcc	.+8      	; 0x7ba <SCSI_DecodeSCSICommand+0x42>
     7b2:	88 23       	and	r24, r24
     7b4:	09 f4       	brne	.+2      	; 0x7b8 <SCSI_DecodeSCSICommand+0x40>
     7b6:	e5 c0       	rjmp	.+458    	; 0x982 <SCSI_DecodeSCSICommand+0x20a>
     7b8:	ea c0       	rjmp	.+468    	; 0x98e <SCSI_DecodeSCSICommand+0x216>
     7ba:	82 31       	cpi	r24, 0x12	; 18
     7bc:	b9 f0       	breq	.+46     	; 0x7ec <SCSI_DecodeSCSICommand+0x74>
     7be:	8a 31       	cpi	r24, 0x1A	; 26
     7c0:	09 f0       	breq	.+2      	; 0x7c4 <SCSI_DecodeSCSICommand+0x4c>
     7c2:	e5 c0       	rjmp	.+458    	; 0x98e <SCSI_DecodeSCSICommand+0x216>
     7c4:	c4 c0       	rjmp	.+392    	; 0x94e <SCSI_DecodeSCSICommand+0x1d6>
     7c6:	88 32       	cpi	r24, 0x28	; 40
     7c8:	09 f4       	brne	.+2      	; 0x7cc <SCSI_DecodeSCSICommand+0x54>
     7ca:	bb c0       	rjmp	.+374    	; 0x942 <SCSI_DecodeSCSICommand+0x1ca>
     7cc:	89 32       	cpi	r24, 0x29	; 41
     7ce:	38 f4       	brcc	.+14     	; 0x7de <SCSI_DecodeSCSICommand+0x66>
     7d0:	8e 31       	cpi	r24, 0x1E	; 30
     7d2:	09 f4       	brne	.+2      	; 0x7d6 <SCSI_DecodeSCSICommand+0x5e>
     7d4:	d6 c0       	rjmp	.+428    	; 0x982 <SCSI_DecodeSCSICommand+0x20a>
     7d6:	85 32       	cpi	r24, 0x25	; 37
     7d8:	09 f0       	breq	.+2      	; 0x7dc <SCSI_DecodeSCSICommand+0x64>
     7da:	d9 c0       	rjmp	.+434    	; 0x98e <SCSI_DecodeSCSICommand+0x216>
     7dc:	67 c0       	rjmp	.+206    	; 0x8ac <SCSI_DecodeSCSICommand+0x134>
     7de:	8a 32       	cpi	r24, 0x2A	; 42
     7e0:	09 f4       	brne	.+2      	; 0x7e4 <SCSI_DecodeSCSICommand+0x6c>
     7e2:	ac c0       	rjmp	.+344    	; 0x93c <SCSI_DecodeSCSICommand+0x1c4>
     7e4:	8f 32       	cpi	r24, 0x2F	; 47
     7e6:	09 f0       	breq	.+2      	; 0x7ea <SCSI_DecodeSCSICommand+0x72>
     7e8:	d2 c0       	rjmp	.+420    	; 0x98e <SCSI_DecodeSCSICommand+0x216>
     7ea:	cb c0       	rjmp	.+406    	; 0x982 <SCSI_DecodeSCSICommand+0x20a>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     7ec:	f6 01       	movw	r30, r12
     7ee:	04 8d       	ldd	r16, Z+28	; 0x1c
     7f0:	15 8d       	ldd	r17, Z+29	; 0x1d

				Temp = Data.Bytes[0];
     7f2:	80 2f       	mov	r24, r16
				Data.Bytes[0] = Data.Bytes[1];
     7f4:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
     7f6:	18 2f       	mov	r17, r24
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
     7f8:	82 8d       	ldd	r24, Z+26	; 0x1a
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	83 70       	andi	r24, 0x03	; 3
     7fe:	90 70       	andi	r25, 0x00	; 0
     800:	89 2b       	or	r24, r25
     802:	09 f0       	breq	.+2      	; 0x806 <SCSI_DecodeSCSICommand+0x8e>
     804:	85 c0       	rjmp	.+266    	; 0x910 <SCSI_DecodeSCSICommand+0x198>
     806:	83 8d       	ldd	r24, Z+27	; 0x1b
     808:	88 23       	and	r24, r24
     80a:	09 f0       	breq	.+2      	; 0x80e <SCSI_DecodeSCSICommand+0x96>
     80c:	81 c0       	rjmp	.+258    	; 0x910 <SCSI_DecodeSCSICommand+0x198>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
     80e:	78 01       	movw	r14, r16
     810:	05 32       	cpi	r16, 0x25	; 37
     812:	11 05       	cpc	r17, r1
     814:	18 f0       	brcs	.+6      	; 0x81c <SCSI_DecodeSCSICommand+0xa4>
     816:	24 e2       	ldi	r18, 0x24	; 36
     818:	e2 2e       	mov	r14, r18
     81a:	f1 2c       	mov	r15, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
     81c:	81 e1       	ldi	r24, 0x11	; 17
     81e:	92 e0       	ldi	r25, 0x02	; 2
     820:	b7 01       	movw	r22, r14
     822:	40 e0       	ldi	r20, 0x00	; 0
     824:	50 e0       	ldi	r21, 0x00	; 0
     826:	0e 94 7e 2d 	call	0x5afc	; 0x5afc <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     82a:	c8 01       	movw	r24, r16
     82c:	8e 19       	sub	r24, r14
     82e:	9f 09       	sbc	r25, r15
     830:	60 e0       	ldi	r22, 0x00	; 0
     832:	70 e0       	ldi	r23, 0x00	; 0
     834:	0e 94 ca 2d 	call	0x5b94	; 0x5b94 <Endpoint_Null_Stream>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     838:	80 91 e8 00 	lds	r24, 0x00E8
     83c:	8e 77       	andi	r24, 0x7E	; 126
     83e:	80 93 e8 00 	sts	0x00E8, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     842:	97 01       	movw	r18, r14
     844:	40 e0       	ldi	r20, 0x00	; 0
     846:	50 e0       	ldi	r21, 0x00	; 0
     848:	f6 01       	movw	r30, r12
     84a:	82 89       	ldd	r24, Z+18	; 0x12
     84c:	93 89       	ldd	r25, Z+19	; 0x13
     84e:	a4 89       	ldd	r26, Z+20	; 0x14
     850:	b5 89       	ldd	r27, Z+21	; 0x15
     852:	82 1b       	sub	r24, r18
     854:	93 0b       	sbc	r25, r19
     856:	a4 0b       	sbc	r26, r20
     858:	b5 0b       	sbc	r27, r21
     85a:	8e c0       	rjmp	.+284    	; 0x978 <SCSI_DecodeSCSICommand+0x200>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
     85c:	f6 01       	movw	r30, r12
     85e:	f5 8c       	ldd	r15, Z+29	; 0x1d
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
     860:	ef 2c       	mov	r14, r15
     862:	f2 e1       	ldi	r31, 0x12	; 18
     864:	ff 15       	cp	r31, r15
     866:	10 f4       	brcc	.+4      	; 0x86c <SCSI_DecodeSCSICommand+0xf4>
     868:	92 e1       	ldi	r25, 0x12	; 18
     86a:	e9 2e       	mov	r14, r25

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
     86c:	0e 2d       	mov	r16, r14
     86e:	10 e0       	ldi	r17, 0x00	; 0
     870:	8f ef       	ldi	r24, 0xFF	; 255
     872:	91 e0       	ldi	r25, 0x01	; 1
     874:	b8 01       	movw	r22, r16
     876:	40 e0       	ldi	r20, 0x00	; 0
     878:	50 e0       	ldi	r21, 0x00	; 0
     87a:	0e 94 7e 2d 	call	0x5afc	; 0x5afc <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     87e:	8f 2d       	mov	r24, r15
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	80 1b       	sub	r24, r16
     884:	91 0b       	sbc	r25, r17
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	0e 94 ca 2d 	call	0x5b94	; 0x5b94 <Endpoint_Null_Stream>
     88e:	80 91 e8 00 	lds	r24, 0x00E8
     892:	8e 77       	andi	r24, 0x7E	; 126
     894:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     898:	f6 01       	movw	r30, r12
     89a:	82 89       	ldd	r24, Z+18	; 0x12
     89c:	93 89       	ldd	r25, Z+19	; 0x13
     89e:	a4 89       	ldd	r26, Z+20	; 0x14
     8a0:	b5 89       	ldd	r27, Z+21	; 0x15
     8a2:	8e 19       	sub	r24, r14
     8a4:	91 09       	sbc	r25, r1
     8a6:	a1 09       	sbc	r26, r1
     8a8:	b1 09       	sbc	r27, r1
     8aa:	66 c0       	rjmp	.+204    	; 0x978 <SCSI_DecodeSCSICommand+0x200>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN = (VIRTUAL_MEMORY_BLOCKS - 1);
     8ac:	8f ef       	ldi	r24, 0xFF	; 255
     8ae:	9f e7       	ldi	r25, 0x7F	; 127
     8b0:	a0 e0       	ldi	r26, 0x00	; 0
     8b2:	b0 e0       	ldi	r27, 0x00	; 0
     8b4:	89 83       	std	Y+1, r24	; 0x01
     8b6:	9a 83       	std	Y+2, r25	; 0x02
     8b8:	ab 83       	std	Y+3, r26	; 0x03
     8ba:	bc 83       	std	Y+4, r27	; 0x04
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
     8bc:	80 e0       	ldi	r24, 0x00	; 0
     8be:	92 e0       	ldi	r25, 0x02	; 2
     8c0:	a0 e0       	ldi	r26, 0x00	; 0
     8c2:	b0 e0       	ldi	r27, 0x00	; 0
     8c4:	8d 83       	std	Y+5, r24	; 0x05
     8c6:	9e 83       	std	Y+6, r25	; 0x06
     8c8:	af 83       	std	Y+7, r26	; 0x07
     8ca:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
     8cc:	ce 01       	movw	r24, r28
     8ce:	01 96       	adiw	r24, 0x01	; 1
     8d0:	64 e0       	ldi	r22, 0x04	; 4
     8d2:	70 e0       	ldi	r23, 0x00	; 0
     8d4:	40 e0       	ldi	r20, 0x00	; 0
     8d6:	50 e0       	ldi	r21, 0x00	; 0
     8d8:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
     8dc:	ce 01       	movw	r24, r28
     8de:	05 96       	adiw	r24, 0x05	; 5
     8e0:	64 e0       	ldi	r22, 0x04	; 4
     8e2:	70 e0       	ldi	r23, 0x00	; 0
     8e4:	40 e0       	ldi	r20, 0x00	; 0
     8e6:	50 e0       	ldi	r21, 0x00	; 0
     8e8:	0e 94 2d 2d 	call	0x5a5a	; 0x5a5a <Endpoint_Write_Stream_BE>
     8ec:	80 91 e8 00 	lds	r24, 0x00E8
     8f0:	8e 77       	andi	r24, 0x7E	; 126
     8f2:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
     8f6:	f6 01       	movw	r30, r12
     8f8:	82 89       	ldd	r24, Z+18	; 0x12
     8fa:	93 89       	ldd	r25, Z+19	; 0x13
     8fc:	a4 89       	ldd	r26, Z+20	; 0x14
     8fe:	b5 89       	ldd	r27, Z+21	; 0x15
     900:	08 97       	sbiw	r24, 0x08	; 8
     902:	a1 09       	sbc	r26, r1
     904:	b1 09       	sbc	r27, r1
     906:	38 c0       	rjmp	.+112    	; 0x978 <SCSI_DecodeSCSICommand+0x200>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
     908:	f6 01       	movw	r30, r12
     90a:	82 8d       	ldd	r24, Z+26	; 0x1a
     90c:	82 fd       	sbrc	r24, 2
     90e:	08 c0       	rjmp	.+16     	; 0x920 <SCSI_DecodeSCSICommand+0x1a8>
	{
		/* Only self-test supported - update SENSE key and fail the command */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     910:	80 91 01 02 	lds	r24, 0x0201
     914:	80 7f       	andi	r24, 0xF0	; 240
     916:	85 60       	ori	r24, 0x05	; 5
     918:	80 93 01 02 	sts	0x0201, r24
     91c:	84 e2       	ldi	r24, 0x24	; 36
     91e:	3e c0       	rjmp	.+124    	; 0x99c <SCSI_DecodeSCSICommand+0x224>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(DataflashManager_CheckDataflashOperation()))
     920:	2f d1       	rcall	.+606    	; 0xb80 <DataflashManager_CheckDataflashOperation>
     922:	88 23       	and	r24, r24
     924:	71 f5       	brne	.+92     	; 0x982 <SCSI_DecodeSCSICommand+0x20a>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
     926:	80 91 01 02 	lds	r24, 0x0201
     92a:	80 7f       	andi	r24, 0xF0	; 240
     92c:	84 60       	ori	r24, 0x04	; 4
     92e:	80 93 01 02 	sts	0x0201, r24
     932:	10 92 0b 02 	sts	0x020B, r1
     936:	10 92 0c 02 	sts	0x020C, r1
     93a:	33 c0       	rjmp	.+102    	; 0x9a2 <SCSI_DecodeSCSICommand+0x22a>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
     93c:	c6 01       	movw	r24, r12
     93e:	60 e0       	ldi	r22, 0x00	; 0
     940:	02 c0       	rjmp	.+4      	; 0x946 <SCSI_DecodeSCSICommand+0x1ce>
			break;
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
     942:	c6 01       	movw	r24, r12
     944:	61 e0       	ldi	r22, 0x01	; 1
     946:	c7 de       	rcall	.-626    	; 0x6d6 <SCSI_Command_ReadWrite_10>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
     948:	88 23       	and	r24, r24
     94a:	59 f1       	breq	.+86     	; 0x9a2 <SCSI_DecodeSCSICommand+0x22a>
     94c:	2c c0       	rjmp	.+88     	; 0x9a6 <SCSI_DecodeSCSICommand+0x22e>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     94e:	10 92 f1 00 	sts	0x00F1, r1
     952:	10 92 f1 00 	sts	0x00F1, r1
     956:	10 92 f1 00 	sts	0x00F1, r1
     95a:	10 92 f1 00 	sts	0x00F1, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     95e:	80 91 e8 00 	lds	r24, 0x00E8
     962:	8e 77       	andi	r24, 0x7E	; 126
     964:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
     968:	f6 01       	movw	r30, r12
     96a:	82 89       	ldd	r24, Z+18	; 0x12
     96c:	93 89       	ldd	r25, Z+19	; 0x13
     96e:	a4 89       	ldd	r26, Z+20	; 0x14
     970:	b5 89       	ldd	r27, Z+21	; 0x15
     972:	04 97       	sbiw	r24, 0x04	; 4
     974:	a1 09       	sbc	r26, r1
     976:	b1 09       	sbc	r27, r1
     978:	82 8b       	std	Z+18, r24	; 0x12
     97a:	93 8b       	std	Z+19, r25	; 0x13
     97c:	a4 8b       	std	Z+20, r26	; 0x14
     97e:	b5 8b       	std	Z+21, r27	; 0x15
     980:	12 c0       	rjmp	.+36     	; 0x9a6 <SCSI_DecodeSCSICommand+0x22e>
		case SCSI_CMD_TEST_UNIT_READY:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
     982:	f6 01       	movw	r30, r12
     984:	12 8a       	std	Z+18, r1	; 0x12
     986:	13 8a       	std	Z+19, r1	; 0x13
     988:	14 8a       	std	Z+20, r1	; 0x14
     98a:	15 8a       	std	Z+21, r1	; 0x15
     98c:	0c c0       	rjmp	.+24     	; 0x9a6 <SCSI_DecodeSCSICommand+0x22e>
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     98e:	80 91 01 02 	lds	r24, 0x0201
     992:	80 7f       	andi	r24, 0xF0	; 240
     994:	85 60       	ori	r24, 0x05	; 5
     996:	80 93 01 02 	sts	0x0201, r24
     99a:	80 e2       	ldi	r24, 0x20	; 32
     99c:	80 93 0b 02 	sts	0x020B, r24
     9a0:	ca cf       	rjmp	.-108    	; 0x936 <SCSI_DecodeSCSICommand+0x1be>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
     9a2:	80 e0       	ldi	r24, 0x00	; 0
     9a4:	0a c0       	rjmp	.+20     	; 0x9ba <SCSI_DecodeSCSICommand+0x242>
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
     9a6:	80 91 01 02 	lds	r24, 0x0201
     9aa:	80 7f       	andi	r24, 0xF0	; 240
     9ac:	80 93 01 02 	sts	0x0201, r24
     9b0:	10 92 0b 02 	sts	0x020B, r1
     9b4:	10 92 0c 02 	sts	0x020C, r1
     9b8:	81 e0       	ldi	r24, 0x01	; 1

		return true;
	}

	return false;
}
     9ba:	28 96       	adiw	r28, 0x08	; 8
     9bc:	0f b6       	in	r0, 0x3f	; 63
     9be:	f8 94       	cli
     9c0:	de bf       	out	0x3e, r29	; 62
     9c2:	0f be       	out	0x3f, r0	; 63
     9c4:	cd bf       	out	0x3d, r28	; 61
     9c6:	cf 91       	pop	r28
     9c8:	df 91       	pop	r29
     9ca:	1f 91       	pop	r17
     9cc:	0f 91       	pop	r16
     9ce:	ff 90       	pop	r15
     9d0:	ef 90       	pop	r14
     9d2:	df 90       	pop	r13
     9d4:	cf 90       	pop	r12
     9d6:	08 95       	ret

000009d8 <Dataflash_SelectChipFromPage>:
			 *
			 *  \param[in] PageAddress  Address of the page to manipulate, ranging from
			 *                          0 to ((DATAFLASH_PAGES * DATAFLASH_TOTALCHIPS) - 1).
			 */
			static inline void Dataflash_SelectChipFromPage(const uint16_t PageAddress)
			{
     9d8:	9c 01       	movw	r18, r24
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
     9da:	8e b1       	in	r24, 0x0e	; 14
     9dc:	83 60       	ori	r24, 0x03	; 3
     9de:	8e b9       	out	0x0e, r24	; 14
			 */
			static inline void Dataflash_SelectChipFromPage(const uint16_t PageAddress)
			{
				Dataflash_DeselectChip();

				if (PageAddress >= (DATAFLASH_PAGES * DATAFLASH_TOTALCHIPS))
     9e0:	80 e4       	ldi	r24, 0x40	; 64
     9e2:	20 30       	cpi	r18, 0x00	; 0
     9e4:	38 07       	cpc	r19, r24
     9e6:	58 f4       	brcc	.+22     	; 0x9fe <Dataflash_SelectChipFromPage+0x26>
				  return;

				if (PageAddress & 0x01)
     9e8:	20 ff       	sbrs	r18, 0
     9ea:	05 c0       	rjmp	.+10     	; 0x9f6 <Dataflash_SelectChipFromPage+0x1e>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
     9ec:	8e b1       	in	r24, 0x0e	; 14
     9ee:	8c 7f       	andi	r24, 0xFC	; 252
     9f0:	81 60       	ori	r24, 0x01	; 1
     9f2:	8e b9       	out	0x0e, r24	; 14
     9f4:	08 95       	ret
     9f6:	8e b1       	in	r24, 0x0e	; 14
     9f8:	8c 7f       	andi	r24, 0xFC	; 252
     9fa:	82 60       	ori	r24, 0x02	; 2
     9fc:	8e b9       	out	0x0e, r24	; 14
     9fe:	08 95       	ret

00000a00 <Dataflash_ToggleSelectedChipCS>:
			 *  or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     a00:	8e b1       	in	r24, 0x0e	; 14
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
     a02:	9e b1       	in	r25, 0x0e	; 14
     a04:	93 60       	ori	r25, 0x03	; 3
     a06:	9e b9       	out	0x0e, r25	; 14
     a08:	9e b1       	in	r25, 0x0e	; 14
     a0a:	83 70       	andi	r24, 0x03	; 3
     a0c:	9c 7f       	andi	r25, 0xFC	; 252
     a0e:	89 2b       	or	r24, r25
     a10:	8e b9       	out	0x0e, r24	; 14
			{
				uint8_t SelectedChipMask = Dataflash_GetSelectedChip();

				Dataflash_DeselectChip();
				Dataflash_SelectChip(SelectedChipMask);
			}
     a12:	08 95       	ret

00000a14 <Dataflash_WaitWhileBusy>:
			/** Spin-loops while the currently selected dataflash is busy executing a command, such as a main
			 *  memory page program or main memory to buffer transfer.
			 */
			static inline void Dataflash_WaitWhileBusy(void)
			{
				Dataflash_ToggleSelectedChipCS();
     a14:	f5 df       	rcall	.-22     	; 0xa00 <Dataflash_ToggleSelectedChipCS>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a16:	87 ed       	ldi	r24, 0xD7	; 215
     a18:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     a1a:	0d b4       	in	r0, 0x2d	; 45
     a1c:	07 fe       	sbrs	r0, 7
     a1e:	fd cf       	rjmp	.-6      	; 0xa1a <Dataflash_WaitWhileBusy+0x6>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     a20:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     a22:	0d b4       	in	r0, 0x2d	; 45
     a24:	07 fe       	sbrs	r0, 7
     a26:	fd cf       	rjmp	.-6      	; 0xa22 <Dataflash_WaitWhileBusy+0xe>
				Dataflash_SendByte(DF_CMD_GETSTATUS);
				while (!(Dataflash_ReceiveByte() & DF_STATUS_READY));
     a28:	0e b4       	in	r0, 0x2e	; 46
     a2a:	07 fe       	sbrs	r0, 7
     a2c:	f9 cf       	rjmp	.-14     	; 0xa20 <Dataflash_WaitWhileBusy+0xc>
				Dataflash_ToggleSelectedChipCS();
			}
     a2e:	e8 cf       	rjmp	.-48     	; 0xa00 <Dataflash_ToggleSelectedChipCS>

00000a30 <Dataflash_SendAddressBytes>:
			 *  \param[in] BufferByte   Address within the dataflash's buffer
			 */
			static inline void Dataflash_SendAddressBytes(uint16_t PageAddress,
			                                              const uint16_t BufferByte)
			{
				PageAddress >>= 1;
     a30:	ac 01       	movw	r20, r24
     a32:	56 95       	lsr	r21
     a34:	47 95       	ror	r20

				Dataflash_SendByte(PageAddress >> 5);
     a36:	26 e0       	ldi	r18, 0x06	; 6
     a38:	96 95       	lsr	r25
     a3a:	87 95       	ror	r24
     a3c:	2a 95       	dec	r18
     a3e:	e1 f7       	brne	.-8      	; 0xa38 <Dataflash_SendAddressBytes+0x8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a40:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     a42:	0d b4       	in	r0, 0x2d	; 45
     a44:	07 fe       	sbrs	r0, 7
     a46:	fd cf       	rjmp	.-6      	; 0xa42 <Dataflash_SendAddressBytes+0x12>
				Dataflash_SendByte((PageAddress << 3) | (BufferByte >> 8));
     a48:	27 2f       	mov	r18, r23
     a4a:	33 27       	eor	r19, r19
     a4c:	84 2f       	mov	r24, r20
     a4e:	88 0f       	add	r24, r24
     a50:	88 0f       	add	r24, r24
     a52:	88 0f       	add	r24, r24
     a54:	82 2b       	or	r24, r18
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a56:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     a58:	0d b4       	in	r0, 0x2d	; 45
     a5a:	07 fe       	sbrs	r0, 7
     a5c:	fd cf       	rjmp	.-6      	; 0xa58 <Dataflash_SendAddressBytes+0x28>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a5e:	6e bd       	out	0x2e, r22	; 46
				while (!(SPSR & (1 << SPIF)));
     a60:	0d b4       	in	r0, 0x2d	; 45
     a62:	07 fe       	sbrs	r0, 7
     a64:	fd cf       	rjmp	.-6      	; 0xa60 <Dataflash_SendAddressBytes+0x30>
				Dataflash_SendByte(BufferByte);
			}
     a66:	08 95       	ret

00000a68 <DataflashManager_ReadBlocks_RAM>:
 *  \param[out] BufferPtr    Pointer to the data destination RAM buffer
 */
void DataflashManager_ReadBlocks_RAM(const uint32_t BlockAddress,
                                     uint16_t TotalBlocks,
                                     uint8_t* BufferPtr)
{
     a68:	af 92       	push	r10
     a6a:	bf 92       	push	r11
     a6c:	cf 92       	push	r12
     a6e:	df 92       	push	r13
     a70:	ef 92       	push	r14
     a72:	ff 92       	push	r15
     a74:	0f 93       	push	r16
     a76:	1f 93       	push	r17
     a78:	cf 93       	push	r28
     a7a:	df 93       	push	r29
     a7c:	6a 01       	movw	r12, r20
     a7e:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     a80:	09 e0       	ldi	r16, 0x09	; 9
     a82:	66 0f       	add	r22, r22
     a84:	77 1f       	adc	r23, r23
     a86:	88 1f       	adc	r24, r24
     a88:	99 1f       	adc	r25, r25
     a8a:	0a 95       	dec	r16
     a8c:	d1 f7       	brne	.-12     	; 0xa82 <DataflashManager_ReadBlocks_RAM+0x1a>
     a8e:	9b 01       	movw	r18, r22
     a90:	ac 01       	movw	r20, r24
     a92:	1a e0       	ldi	r17, 0x0A	; 10
     a94:	56 95       	lsr	r21
     a96:	47 95       	ror	r20
     a98:	37 95       	ror	r19
     a9a:	27 95       	ror	r18
     a9c:	1a 95       	dec	r17
     a9e:	d1 f7       	brne	.-12     	; 0xa94 <DataflashManager_ReadBlocks_RAM+0x2c>
     aa0:	89 01       	movw	r16, r18
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     aa2:	eb 01       	movw	r28, r22
     aa4:	d3 70       	andi	r29, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     aa6:	c9 01       	movw	r24, r18
     aa8:	97 df       	rcall	.-210    	; 0x9d8 <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     aaa:	82 ed       	ldi	r24, 0xD2	; 210
     aac:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     aae:	0d b4       	in	r0, 0x2d	; 45
     ab0:	07 fe       	sbrs	r0, 7
     ab2:	fd cf       	rjmp	.-6      	; 0xaae <DataflashManager_ReadBlocks_RAM+0x46>

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     ab4:	c8 01       	movw	r24, r16
     ab6:	be 01       	movw	r22, r28
     ab8:	bb df       	rcall	.-138    	; 0xa30 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     aba:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     abc:	0d b4       	in	r0, 0x2d	; 45
     abe:	07 fe       	sbrs	r0, 7
     ac0:	fd cf       	rjmp	.-6      	; 0xabc <DataflashManager_ReadBlocks_RAM+0x54>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ac2:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ac4:	0d b4       	in	r0, 0x2d	; 45
     ac6:	07 fe       	sbrs	r0, 7
     ac8:	fd cf       	rjmp	.-6      	; 0xac4 <DataflashManager_ReadBlocks_RAM+0x5c>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     aca:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     acc:	0d b4       	in	r0, 0x2d	; 45
     ace:	07 fe       	sbrs	r0, 7
     ad0:	fd cf       	rjmp	.-6      	; 0xacc <DataflashManager_ReadBlocks_RAM+0x64>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ad2:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ad4:	0d b4       	in	r0, 0x2d	; 45
     ad6:	07 fe       	sbrs	r0, 7
     ad8:	fd cf       	rjmp	.-6      	; 0xad4 <DataflashManager_ReadBlocks_RAM+0x6c>
                                     uint16_t TotalBlocks,
                                     uint8_t* BufferPtr)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     ada:	b4 e0       	ldi	r27, 0x04	; 4
     adc:	d6 95       	lsr	r29
     ade:	c7 95       	ror	r28
     ae0:	ba 95       	dec	r27
     ae2:	e1 f7       	brne	.-8      	; 0xadc <DataflashManager_ReadBlocks_RAM+0x74>
     ae4:	6c 2f       	mov	r22, r28
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ae6:	a2 ed       	ldi	r26, 0xD2	; 210
     ae8:	aa 2e       	mov	r10, r26
     aea:	39 c0       	rjmp	.+114    	; 0xb5e <DataflashManager_ReadBlocks_RAM+0xf6>
     aec:	e7 01       	movw	r28, r14
     aee:	bb 24       	eor	r11, r11

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     af0:	60 34       	cpi	r22, 0x40	; 64
     af2:	e9 f4       	brne	.+58     	; 0xb2e <DataflashManager_ReadBlocks_RAM+0xc6>
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     af4:	0f 5f       	subi	r16, 0xFF	; 255
     af6:	1f 4f       	sbci	r17, 0xFF	; 255

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     af8:	c8 01       	movw	r24, r16
     afa:	6e df       	rcall	.-292    	; 0x9d8 <Dataflash_SelectChipFromPage>
     afc:	ae bc       	out	0x2e, r10	; 46
				while (!(SPSR & (1 << SPIF)));
     afe:	0d b4       	in	r0, 0x2d	; 45
     b00:	07 fe       	sbrs	r0, 7
     b02:	fd cf       	rjmp	.-6      	; 0xafe <DataflashManager_ReadBlocks_RAM+0x96>

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     b04:	c8 01       	movw	r24, r16
     b06:	60 e0       	ldi	r22, 0x00	; 0
     b08:	70 e0       	ldi	r23, 0x00	; 0
     b0a:	92 df       	rcall	.-220    	; 0xa30 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b0c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     b0e:	0d b4       	in	r0, 0x2d	; 45
     b10:	07 fe       	sbrs	r0, 7
     b12:	fd cf       	rjmp	.-6      	; 0xb0e <DataflashManager_ReadBlocks_RAM+0xa6>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b14:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     b16:	0d b4       	in	r0, 0x2d	; 45
     b18:	07 fe       	sbrs	r0, 7
     b1a:	fd cf       	rjmp	.-6      	; 0xb16 <DataflashManager_ReadBlocks_RAM+0xae>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b1c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     b1e:	0d b4       	in	r0, 0x2d	; 45
     b20:	07 fe       	sbrs	r0, 7
     b22:	fd cf       	rjmp	.-6      	; 0xb1e <DataflashManager_ReadBlocks_RAM+0xb6>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b24:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     b26:	0d b4       	in	r0, 0x2d	; 45
     b28:	07 fe       	sbrs	r0, 7
     b2a:	fd cf       	rjmp	.-6      	; 0xb26 <DataflashManager_ReadBlocks_RAM+0xbe>
     b2c:	60 e0       	ldi	r22, 0x00	; 0
     b2e:	fe 01       	movw	r30, r28
     b30:	90 e0       	ldi	r25, 0x00	; 0
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     b32:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     b34:	0d b4       	in	r0, 0x2d	; 45
     b36:	07 fe       	sbrs	r0, 7
     b38:	fd cf       	rjmp	.-6      	; 0xb34 <DataflashManager_ReadBlocks_RAM+0xcc>
				return SPDR;
     b3a:	8e b5       	in	r24, 0x2e	; 46
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
			  *(BufferPtr++) = Dataflash_ReceiveByte();
     b3c:	81 93       	st	Z+, r24
				Dataflash_SendByte(0x00);
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
     b3e:	9f 5f       	subi	r25, 0xFF	; 255
     b40:	90 31       	cpi	r25, 0x10	; 16
     b42:	b9 f7       	brne	.-18     	; 0xb32 <DataflashManager_ReadBlocks_RAM+0xca>
     b44:	60 96       	adiw	r28, 0x10	; 16
			  *(BufferPtr++) = Dataflash_ReceiveByte();

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     b46:	6f 5f       	subi	r22, 0xFF	; 255

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
     b48:	b3 94       	inc	r11
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     b4a:	80 e2       	ldi	r24, 0x20	; 32
     b4c:	b8 16       	cp	r11, r24
     b4e:	81 f6       	brne	.-96     	; 0xaf0 <DataflashManager_ReadBlocks_RAM+0x88>
     b50:	80 e0       	ldi	r24, 0x00	; 0
     b52:	92 e0       	ldi	r25, 0x02	; 2
     b54:	e8 0e       	add	r14, r24
     b56:	f9 1e       	adc	r15, r25
			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     b58:	08 94       	sec
     b5a:	c1 08       	sbc	r12, r1
     b5c:	d1 08       	sbc	r13, r1
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
     b5e:	c1 14       	cp	r12, r1
     b60:	d1 04       	cpc	r13, r1
     b62:	21 f6       	brne	.-120    	; 0xaec <DataflashManager_ReadBlocks_RAM+0x84>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
     b64:	8e b1       	in	r24, 0x0e	; 14
     b66:	83 60       	ori	r24, 0x03	; 3
     b68:	8e b9       	out	0x0e, r24	; 14
		TotalBlocks--;
	}

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     b6a:	df 91       	pop	r29
     b6c:	cf 91       	pop	r28
     b6e:	1f 91       	pop	r17
     b70:	0f 91       	pop	r16
     b72:	ff 90       	pop	r15
     b74:	ef 90       	pop	r14
     b76:	df 90       	pop	r13
     b78:	cf 90       	pop	r12
     b7a:	bf 90       	pop	r11
     b7c:	af 90       	pop	r10
     b7e:	08 95       	ret

00000b80 <DataflashManager_CheckDataflashOperation>:
     b80:	8e b1       	in	r24, 0x0e	; 14
     b82:	8c 7f       	andi	r24, 0xFC	; 252
     b84:	82 60       	ori	r24, 0x02	; 2
     b86:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b88:	8f e9       	ldi	r24, 0x9F	; 159
     b8a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     b8c:	0d b4       	in	r0, 0x2d	; 45
     b8e:	07 fe       	sbrs	r0, 7
     b90:	fd cf       	rjmp	.-6      	; 0xb8c <DataflashManager_CheckDataflashOperation+0xc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     b92:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     b94:	0d b4       	in	r0, 0x2d	; 45
     b96:	07 fe       	sbrs	r0, 7
     b98:	fd cf       	rjmp	.-6      	; 0xb94 <DataflashManager_CheckDataflashOperation+0x14>
				return SPDR;
     b9a:	9e b5       	in	r25, 0x2e	; 46
     b9c:	8e b1       	in	r24, 0x0e	; 14
     b9e:	83 60       	ori	r24, 0x03	; 3
     ba0:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
     ba2:	9f 31       	cpi	r25, 0x1F	; 31
     ba4:	11 f0       	breq	.+4      	; 0xbaa <DataflashManager_CheckDataflashOperation+0x2a>
     ba6:	80 e0       	ldi	r24, 0x00	; 0
     ba8:	08 95       	ret
     baa:	8e b1       	in	r24, 0x0e	; 14
     bac:	8c 7f       	andi	r24, 0xFC	; 252
     bae:	81 60       	ori	r24, 0x01	; 1
     bb0:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bb2:	8f e9       	ldi	r24, 0x9F	; 159
     bb4:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     bb6:	0d b4       	in	r0, 0x2d	; 45
     bb8:	07 fe       	sbrs	r0, 7
     bba:	fd cf       	rjmp	.-6      	; 0xbb6 <DataflashManager_CheckDataflashOperation+0x36>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     bbc:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     bbe:	0d b4       	in	r0, 0x2d	; 45
     bc0:	07 fe       	sbrs	r0, 7
     bc2:	fd cf       	rjmp	.-6      	; 0xbbe <DataflashManager_CheckDataflashOperation+0x3e>
				return SPDR;
     bc4:	9e b5       	in	r25, 0x2e	; 46
     bc6:	8e b1       	in	r24, 0x0e	; 14
     bc8:	83 60       	ori	r24, 0x03	; 3
     bca:	8e b9       	out	0x0e, r24	; 14
     bcc:	80 e0       	ldi	r24, 0x00	; 0
     bce:	9f 31       	cpi	r25, 0x1F	; 31
     bd0:	09 f4       	brne	.+2      	; 0xbd4 <DataflashManager_CheckDataflashOperation+0x54>
     bd2:	81 e0       	ldi	r24, 0x01	; 1
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
	#endif

	return true;
}
     bd4:	08 95       	ret

00000bd6 <DataflashManager_ReadBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void DataflashManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
     bd6:	af 92       	push	r10
     bd8:	bf 92       	push	r11
     bda:	cf 92       	push	r12
     bdc:	df 92       	push	r13
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	df 93       	push	r29
     be8:	cf 93       	push	r28
     bea:	0f 92       	push	r0
     bec:	cd b7       	in	r28, 0x3d	; 61
     bee:	de b7       	in	r29, 0x3e	; 62
     bf0:	5c 01       	movw	r10, r24
     bf2:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     bf4:	e9 e0       	ldi	r30, 0x09	; 9
     bf6:	44 0f       	add	r20, r20
     bf8:	55 1f       	adc	r21, r21
     bfa:	66 1f       	adc	r22, r22
     bfc:	77 1f       	adc	r23, r23
     bfe:	ea 95       	dec	r30
     c00:	d1 f7       	brne	.-12     	; 0xbf6 <DataflashManager_ReadBlocks+0x20>
     c02:	db 01       	movw	r26, r22
     c04:	ca 01       	movw	r24, r20
     c06:	3a e0       	ldi	r19, 0x0A	; 10
     c08:	b6 95       	lsr	r27
     c0a:	a7 95       	ror	r26
     c0c:	97 95       	ror	r25
     c0e:	87 95       	ror	r24
     c10:	3a 95       	dec	r19
     c12:	d1 f7       	brne	.-12     	; 0xc08 <DataflashManager_ReadBlocks+0x32>
     c14:	8c 01       	movw	r16, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     c16:	2f ef       	ldi	r18, 0xFF	; 255
     c18:	c2 2e       	mov	r12, r18
     c1a:	23 e0       	ldi	r18, 0x03	; 3
     c1c:	d2 2e       	mov	r13, r18
     c1e:	c4 22       	and	r12, r20
     c20:	d5 22       	and	r13, r21
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     c22:	da de       	rcall	.-588    	; 0x9d8 <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c24:	82 ed       	ldi	r24, 0xD2	; 210
     c26:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c28:	0d b4       	in	r0, 0x2d	; 45
     c2a:	07 fe       	sbrs	r0, 7
     c2c:	fd cf       	rjmp	.-6      	; 0xc28 <DataflashManager_ReadBlocks+0x52>

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     c2e:	c8 01       	movw	r24, r16
     c30:	b6 01       	movw	r22, r12
     c32:	fe de       	rcall	.-516    	; 0xa30 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c34:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c36:	0d b4       	in	r0, 0x2d	; 45
     c38:	07 fe       	sbrs	r0, 7
     c3a:	fd cf       	rjmp	.-6      	; 0xc36 <DataflashManager_ReadBlocks+0x60>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c3c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c3e:	0d b4       	in	r0, 0x2d	; 45
     c40:	07 fe       	sbrs	r0, 7
     c42:	fd cf       	rjmp	.-6      	; 0xc3e <DataflashManager_ReadBlocks+0x68>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c44:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c46:	0d b4       	in	r0, 0x2d	; 45
     c48:	07 fe       	sbrs	r0, 7
     c4a:	fd cf       	rjmp	.-6      	; 0xc46 <DataflashManager_ReadBlocks+0x70>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c4c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     c4e:	0d b4       	in	r0, 0x2d	; 45
     c50:	07 fe       	sbrs	r0, 7
     c52:	fd cf       	rjmp	.-6      	; 0xc4e <DataflashManager_ReadBlocks+0x78>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     c54:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Endpoint_WaitUntilReady>
     c58:	88 23       	and	r24, r24
     c5a:	09 f0       	breq	.+2      	; 0xc5e <DataflashManager_ReadBlocks+0x88>
     c5c:	c6 c0       	rjmp	.+396    	; 0xdea <DataflashManager_ReadBlocks+0x214>
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     c5e:	94 e0       	ldi	r25, 0x04	; 4
     c60:	d6 94       	lsr	r13
     c62:	c7 94       	ror	r12
     c64:	9a 95       	dec	r25
     c66:	e1 f7       	brne	.-8      	; 0xc60 <DataflashManager_ReadBlocks+0x8a>
     c68:	9c 2d       	mov	r25, r12
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c6a:	82 ed       	ldi	r24, 0xD2	; 210
     c6c:	c8 2e       	mov	r12, r24
     c6e:	ad c0       	rjmp	.+346    	; 0xdca <DataflashManager_ReadBlocks+0x1f4>
     c70:	dd 24       	eor	r13, r13
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     c72:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently full */
			if (!(Endpoint_IsReadWriteAllowed()))
     c76:	85 fd       	sbrc	r24, 5
     c78:	0c c0       	rjmp	.+24     	; 0xc92 <DataflashManager_ReadBlocks+0xbc>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     c7a:	80 91 e8 00 	lds	r24, 0x00E8
     c7e:	8e 77       	andi	r24, 0x7E	; 126
     c80:	80 93 e8 00 	sts	0x00E8, r24
			{
				/* Clear the endpoint bank to send its contents to the host */
				Endpoint_ClearIN();

				/* Wait until the endpoint is ready for more data */
				if (Endpoint_WaitUntilReady())
     c84:	99 83       	std	Y+1, r25	; 0x01
     c86:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Endpoint_WaitUntilReady>
     c8a:	99 81       	ldd	r25, Y+1	; 0x01
     c8c:	88 23       	and	r24, r24
     c8e:	09 f0       	breq	.+2      	; 0xc92 <DataflashManager_ReadBlocks+0xbc>
     c90:	ac c0       	rjmp	.+344    	; 0xdea <DataflashManager_ReadBlocks+0x214>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     c92:	90 34       	cpi	r25, 0x40	; 64
     c94:	e9 f4       	brne	.+58     	; 0xcd0 <DataflashManager_ReadBlocks+0xfa>
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     c96:	0f 5f       	subi	r16, 0xFF	; 255
     c98:	1f 4f       	sbci	r17, 0xFF	; 255

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     c9a:	c8 01       	movw	r24, r16
     c9c:	9d de       	rcall	.-710    	; 0x9d8 <Dataflash_SelectChipFromPage>
     c9e:	ce bc       	out	0x2e, r12	; 46
				while (!(SPSR & (1 << SPIF)));
     ca0:	0d b4       	in	r0, 0x2d	; 45
     ca2:	07 fe       	sbrs	r0, 7
     ca4:	fd cf       	rjmp	.-6      	; 0xca0 <DataflashManager_ReadBlocks+0xca>

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     ca6:	c8 01       	movw	r24, r16
     ca8:	60 e0       	ldi	r22, 0x00	; 0
     caa:	70 e0       	ldi	r23, 0x00	; 0
     cac:	c1 de       	rcall	.-638    	; 0xa30 <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     cae:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cb0:	0d b4       	in	r0, 0x2d	; 45
     cb2:	07 fe       	sbrs	r0, 7
     cb4:	fd cf       	rjmp	.-6      	; 0xcb0 <DataflashManager_ReadBlocks+0xda>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     cb6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cb8:	0d b4       	in	r0, 0x2d	; 45
     cba:	07 fe       	sbrs	r0, 7
     cbc:	fd cf       	rjmp	.-6      	; 0xcb8 <DataflashManager_ReadBlocks+0xe2>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     cbe:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cc0:	0d b4       	in	r0, 0x2d	; 45
     cc2:	07 fe       	sbrs	r0, 7
     cc4:	fd cf       	rjmp	.-6      	; 0xcc0 <DataflashManager_ReadBlocks+0xea>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     cc6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cc8:	0d b4       	in	r0, 0x2d	; 45
     cca:	07 fe       	sbrs	r0, 7
     ccc:	fd cf       	rjmp	.-6      	; 0xcc8 <DataflashManager_ReadBlocks+0xf2>
     cce:	90 e0       	ldi	r25, 0x00	; 0
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cd0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cd2:	0d b4       	in	r0, 0x2d	; 45
     cd4:	07 fe       	sbrs	r0, 7
     cd6:	fd cf       	rjmp	.-6      	; 0xcd2 <DataflashManager_ReadBlocks+0xfc>
				return SPDR;
     cd8:	8e b5       	in	r24, 0x2e	; 46
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     cda:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cde:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     ce0:	0d b4       	in	r0, 0x2d	; 45
     ce2:	07 fe       	sbrs	r0, 7
     ce4:	fd cf       	rjmp	.-6      	; 0xce0 <DataflashManager_ReadBlocks+0x10a>
				return SPDR;
     ce6:	8e b5       	in	r24, 0x2e	; 46
     ce8:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cec:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cee:	0d b4       	in	r0, 0x2d	; 45
     cf0:	07 fe       	sbrs	r0, 7
     cf2:	fd cf       	rjmp	.-6      	; 0xcee <DataflashManager_ReadBlocks+0x118>
				return SPDR;
     cf4:	8e b5       	in	r24, 0x2e	; 46
     cf6:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     cfa:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     cfc:	0d b4       	in	r0, 0x2d	; 45
     cfe:	07 fe       	sbrs	r0, 7
     d00:	fd cf       	rjmp	.-6      	; 0xcfc <DataflashManager_ReadBlocks+0x126>
				return SPDR;
     d02:	8e b5       	in	r24, 0x2e	; 46
     d04:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d08:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d0a:	0d b4       	in	r0, 0x2d	; 45
     d0c:	07 fe       	sbrs	r0, 7
     d0e:	fd cf       	rjmp	.-6      	; 0xd0a <DataflashManager_ReadBlocks+0x134>
				return SPDR;
     d10:	8e b5       	in	r24, 0x2e	; 46
     d12:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d16:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d18:	0d b4       	in	r0, 0x2d	; 45
     d1a:	07 fe       	sbrs	r0, 7
     d1c:	fd cf       	rjmp	.-6      	; 0xd18 <DataflashManager_ReadBlocks+0x142>
				return SPDR;
     d1e:	8e b5       	in	r24, 0x2e	; 46
     d20:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d24:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d26:	0d b4       	in	r0, 0x2d	; 45
     d28:	07 fe       	sbrs	r0, 7
     d2a:	fd cf       	rjmp	.-6      	; 0xd26 <DataflashManager_ReadBlocks+0x150>
				return SPDR;
     d2c:	8e b5       	in	r24, 0x2e	; 46
     d2e:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d32:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d34:	0d b4       	in	r0, 0x2d	; 45
     d36:	07 fe       	sbrs	r0, 7
     d38:	fd cf       	rjmp	.-6      	; 0xd34 <DataflashManager_ReadBlocks+0x15e>
				return SPDR;
     d3a:	8e b5       	in	r24, 0x2e	; 46
     d3c:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d40:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d42:	0d b4       	in	r0, 0x2d	; 45
     d44:	07 fe       	sbrs	r0, 7
     d46:	fd cf       	rjmp	.-6      	; 0xd42 <DataflashManager_ReadBlocks+0x16c>
				return SPDR;
     d48:	8e b5       	in	r24, 0x2e	; 46
     d4a:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d4e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d50:	0d b4       	in	r0, 0x2d	; 45
     d52:	07 fe       	sbrs	r0, 7
     d54:	fd cf       	rjmp	.-6      	; 0xd50 <DataflashManager_ReadBlocks+0x17a>
				return SPDR;
     d56:	8e b5       	in	r24, 0x2e	; 46
     d58:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d5c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d5e:	0d b4       	in	r0, 0x2d	; 45
     d60:	07 fe       	sbrs	r0, 7
     d62:	fd cf       	rjmp	.-6      	; 0xd5e <DataflashManager_ReadBlocks+0x188>
				return SPDR;
     d64:	8e b5       	in	r24, 0x2e	; 46
     d66:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d6a:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d6c:	0d b4       	in	r0, 0x2d	; 45
     d6e:	07 fe       	sbrs	r0, 7
     d70:	fd cf       	rjmp	.-6      	; 0xd6c <DataflashManager_ReadBlocks+0x196>
				return SPDR;
     d72:	8e b5       	in	r24, 0x2e	; 46
     d74:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d78:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d7a:	0d b4       	in	r0, 0x2d	; 45
     d7c:	07 fe       	sbrs	r0, 7
     d7e:	fd cf       	rjmp	.-6      	; 0xd7a <DataflashManager_ReadBlocks+0x1a4>
				return SPDR;
     d80:	8e b5       	in	r24, 0x2e	; 46
     d82:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d86:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d88:	0d b4       	in	r0, 0x2d	; 45
     d8a:	07 fe       	sbrs	r0, 7
     d8c:	fd cf       	rjmp	.-6      	; 0xd88 <DataflashManager_ReadBlocks+0x1b2>
				return SPDR;
     d8e:	8e b5       	in	r24, 0x2e	; 46
     d90:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     d94:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d96:	0d b4       	in	r0, 0x2d	; 45
     d98:	07 fe       	sbrs	r0, 7
     d9a:	fd cf       	rjmp	.-6      	; 0xd96 <DataflashManager_ReadBlocks+0x1c0>
				return SPDR;
     d9c:	8e b5       	in	r24, 0x2e	; 46
     d9e:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     da2:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     da4:	0d b4       	in	r0, 0x2d	; 45
     da6:	07 fe       	sbrs	r0, 7
     da8:	fd cf       	rjmp	.-6      	; 0xda4 <DataflashManager_ReadBlocks+0x1ce>
				return SPDR;
     daa:	8e b5       	in	r24, 0x2e	; 46
     dac:	80 93 f1 00 	sts	0x00F1, r24

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     db0:	f5 01       	movw	r30, r10
     db2:	86 a9       	ldd	r24, Z+54	; 0x36
     db4:	88 23       	and	r24, r24
     db6:	c9 f4       	brne	.+50     	; 0xdea <DataflashManager_ReadBlocks+0x214>
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     db8:	9f 5f       	subi	r25, 0xFF	; 255

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
     dba:	d3 94       	inc	r13
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     dbc:	f0 e2       	ldi	r31, 0x20	; 32
     dbe:	df 16       	cp	r13, r31
     dc0:	09 f0       	breq	.+2      	; 0xdc4 <DataflashManager_ReadBlocks+0x1ee>
     dc2:	57 cf       	rjmp	.-338    	; 0xc72 <DataflashManager_ReadBlocks+0x9c>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     dc4:	08 94       	sec
     dc6:	e1 08       	sbc	r14, r1
     dc8:	f1 08       	sbc	r15, r1

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     dca:	e1 14       	cp	r14, r1
     dcc:	f1 04       	cpc	r15, r1
     dce:	09 f0       	breq	.+2      	; 0xdd2 <DataflashManager_ReadBlocks+0x1fc>
     dd0:	4f cf       	rjmp	.-354    	; 0xc70 <DataflashManager_ReadBlocks+0x9a>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     dd2:	80 91 e8 00 	lds	r24, 0x00E8
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
     dd6:	85 fd       	sbrc	r24, 5
     dd8:	05 c0       	rjmp	.+10     	; 0xde4 <DataflashManager_ReadBlocks+0x20e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     dda:	80 91 e8 00 	lds	r24, 0x00E8
     dde:	8e 77       	andi	r24, 0x7E	; 126
     de0:	80 93 e8 00 	sts	0x00E8, r24
     de4:	8e b1       	in	r24, 0x0e	; 14
     de6:	83 60       	ori	r24, 0x03	; 3
     de8:	8e b9       	out	0x0e, r24	; 14
	  Endpoint_ClearIN();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     dea:	0f 90       	pop	r0
     dec:	cf 91       	pop	r28
     dee:	df 91       	pop	r29
     df0:	1f 91       	pop	r17
     df2:	0f 91       	pop	r16
     df4:	ff 90       	pop	r15
     df6:	ef 90       	pop	r14
     df8:	df 90       	pop	r13
     dfa:	cf 90       	pop	r12
     dfc:	bf 90       	pop	r11
     dfe:	af 90       	pop	r10
     e00:	08 95       	ret

00000e02 <DataflashManager_WriteBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void DataflashManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
     e02:	8f 92       	push	r8
     e04:	9f 92       	push	r9
     e06:	af 92       	push	r10
     e08:	bf 92       	push	r11
     e0a:	cf 92       	push	r12
     e0c:	df 92       	push	r13
     e0e:	ef 92       	push	r14
     e10:	ff 92       	push	r15
     e12:	0f 93       	push	r16
     e14:	1f 93       	push	r17
     e16:	df 93       	push	r29
     e18:	cf 93       	push	r28
     e1a:	0f 92       	push	r0
     e1c:	cd b7       	in	r28, 0x3d	; 61
     e1e:	de b7       	in	r29, 0x3e	; 62
     e20:	5c 01       	movw	r10, r24
     e22:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     e24:	09 e0       	ldi	r16, 0x09	; 9
     e26:	44 0f       	add	r20, r20
     e28:	55 1f       	adc	r21, r21
     e2a:	66 1f       	adc	r22, r22
     e2c:	77 1f       	adc	r23, r23
     e2e:	0a 95       	dec	r16
     e30:	d1 f7       	brne	.-12     	; 0xe26 <DataflashManager_WriteBlocks+0x24>
     e32:	db 01       	movw	r26, r22
     e34:	ca 01       	movw	r24, r20
     e36:	1a e0       	ldi	r17, 0x0A	; 10
     e38:	b6 95       	lsr	r27
     e3a:	a7 95       	ror	r26
     e3c:	97 95       	ror	r25
     e3e:	87 95       	ror	r24
     e40:	1a 95       	dec	r17
     e42:	d1 f7       	brne	.-12     	; 0xe38 <DataflashManager_WriteBlocks+0x36>
     e44:	8c 01       	movw	r16, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     e46:	bf ef       	ldi	r27, 0xFF	; 255
     e48:	cb 2e       	mov	r12, r27
     e4a:	b3 e0       	ldi	r27, 0x03	; 3
     e4c:	db 2e       	mov	r13, r27
     e4e:	c4 22       	and	r12, r20
     e50:	d5 22       	and	r13, r21
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
	bool     UsingSecondBuffer   = false;

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     e52:	c2 dd       	rcall	.-1148   	; 0x9d8 <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     e54:	83 e5       	ldi	r24, 0x53	; 83
     e56:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     e58:	0d b4       	in	r0, 0x2d	; 45
     e5a:	07 fe       	sbrs	r0, 7
     e5c:	fd cf       	rjmp	.-6      	; 0xe58 <DataflashManager_WriteBlocks+0x56>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
	/* Copy selected dataflash's current page contents to the Dataflash buffer */
	Dataflash_SendByte(DF_CMD_MAINMEMTOBUFF1);
	Dataflash_SendAddressBytes(CurrDFPage, 0);
     e5e:	c8 01       	movw	r24, r16
     e60:	60 e0       	ldi	r22, 0x00	; 0
     e62:	70 e0       	ldi	r23, 0x00	; 0
     e64:	e5 dd       	rcall	.-1078   	; 0xa30 <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
     e66:	d6 dd       	rcall	.-1108   	; 0xa14 <Dataflash_WaitWhileBusy>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     e68:	84 e8       	ldi	r24, 0x84	; 132
     e6a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     e6c:	0d b4       	in	r0, 0x2d	; 45
     e6e:	07 fe       	sbrs	r0, 7
     e70:	fd cf       	rjmp	.-6      	; 0xe6c <DataflashManager_WriteBlocks+0x6a>
#endif

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);
     e72:	80 e0       	ldi	r24, 0x00	; 0
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	b6 01       	movw	r22, r12
     e78:	db dd       	rcall	.-1098   	; 0xa30 <Dataflash_SendAddressBytes>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     e7a:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Endpoint_WaitUntilReady>
     e7e:	88 23       	and	r24, r24
     e80:	09 f0       	breq	.+2      	; 0xe84 <DataflashManager_WriteBlocks+0x82>
     e82:	eb c0       	rjmp	.+470    	; 0x105a <DataflashManager_WriteBlocks+0x258>
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     e84:	a4 e0       	ldi	r26, 0x04	; 4
     e86:	d6 94       	lsr	r13
     e88:	c7 94       	ror	r12
     e8a:	aa 95       	dec	r26
     e8c:	e1 f7       	brne	.-8      	; 0xe86 <DataflashManager_WriteBlocks+0x84>
     e8e:	9c 2d       	mov	r25, r12
     e90:	47 01       	movw	r8, r14
     e92:	f5 e0       	ldi	r31, 0x05	; 5
     e94:	88 0c       	add	r8, r8
     e96:	99 1c       	adc	r9, r9
     e98:	fa 95       	dec	r31
     e9a:	e1 f7       	brne	.-8      	; 0xe94 <DataflashManager_WriteBlocks+0x92>
     e9c:	dd 24       	eor	r13, r13
     e9e:	be c0       	rjmp	.+380    	; 0x101c <DataflashManager_WriteBlocks+0x21a>
     ea0:	cc 24       	eor	r12, r12
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     ea2:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently empty */
			if (!(Endpoint_IsReadWriteAllowed()))
     ea6:	85 fd       	sbrc	r24, 5
     ea8:	0c c0       	rjmp	.+24     	; 0xec2 <DataflashManager_WriteBlocks+0xc0>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     eaa:	80 91 e8 00 	lds	r24, 0x00E8
     eae:	8b 77       	andi	r24, 0x7B	; 123
     eb0:	80 93 e8 00 	sts	0x00E8, r24
			{
				/* Clear the current endpoint bank */
				Endpoint_ClearOUT();

				/* Wait until the host has sent another packet */
				if (Endpoint_WaitUntilReady())
     eb4:	99 83       	std	Y+1, r25	; 0x01
     eb6:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Endpoint_WaitUntilReady>
     eba:	99 81       	ldd	r25, Y+1	; 0x01
     ebc:	88 23       	and	r24, r24
     ebe:	09 f0       	breq	.+2      	; 0xec2 <DataflashManager_WriteBlocks+0xc0>
     ec0:	cc c0       	rjmp	.+408    	; 0x105a <DataflashManager_WriteBlocks+0x258>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     ec2:	90 34       	cpi	r25, 0x40	; 64
     ec4:	09 f0       	breq	.+2      	; 0xec8 <DataflashManager_WriteBlocks+0xc6>
     ec6:	39 c0       	rjmp	.+114    	; 0xf3a <DataflashManager_WriteBlocks+0x138>
			{
				/* Write the Dataflash buffer contents back to the Dataflash page */
				Dataflash_WaitWhileBusy();
     ec8:	a5 dd       	rcall	.-1206   	; 0xa14 <Dataflash_WaitWhileBusy>
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     eca:	dd 20       	and	r13, r13
     ecc:	11 f4       	brne	.+4      	; 0xed2 <DataflashManager_WriteBlocks+0xd0>
     ece:	83 e8       	ldi	r24, 0x83	; 131
     ed0:	01 c0       	rjmp	.+2      	; 0xed4 <DataflashManager_WriteBlocks+0xd2>
     ed2:	86 e8       	ldi	r24, 0x86	; 134
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ed4:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     ed6:	0d b4       	in	r0, 0x2d	; 45
     ed8:	07 fe       	sbrs	r0, 7
     eda:	fd cf       	rjmp	.-6      	; 0xed6 <DataflashManager_WriteBlocks+0xd4>
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     edc:	c8 01       	movw	r24, r16
     ede:	60 e0       	ldi	r22, 0x00	; 0
     ee0:	70 e0       	ldi	r23, 0x00	; 0
     ee2:	a6 dd       	rcall	.-1204   	; 0xa30 <Dataflash_SendAddressBytes>

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     ee4:	0f 5f       	subi	r16, 0xFF	; 255
     ee6:	1f 4f       	sbci	r17, 0xFF	; 255
			 *  or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     ee8:	8e b1       	in	r24, 0x0e	; 14

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
     eea:	83 70       	andi	r24, 0x03	; 3
     eec:	81 30       	cpi	r24, 0x01	; 1
     eee:	09 f4       	brne	.+2      	; 0xef2 <DataflashManager_WriteBlocks+0xf0>
				  UsingSecondBuffer = !(UsingSecondBuffer);
     ef0:	d8 26       	eor	r13, r24

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     ef2:	c8 01       	movw	r24, r16
     ef4:	71 dd       	rcall	.-1310   	; 0x9d8 <Dataflash_SelectChipFromPage>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
				/* If less than one Dataflash page remaining, copy over the existing page to preserve trailing data */
				if ((TotalBlocks * (VIRTUAL_MEMORY_BLOCK_SIZE >> 4)) < (DATAFLASH_PAGE_SIZE >> 4))
     ef6:	20 e4       	ldi	r18, 0x40	; 64
     ef8:	82 16       	cp	r8, r18
     efa:	91 04       	cpc	r9, r1
     efc:	78 f4       	brcc	.+30     	; 0xf1c <DataflashManager_WriteBlocks+0x11a>
				{
					/* Copy selected dataflash's current page contents to the Dataflash buffer */
					Dataflash_WaitWhileBusy();
     efe:	8a dd       	rcall	.-1260   	; 0xa14 <Dataflash_WaitWhileBusy>
					Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_MAINMEMTOBUFF2 : DF_CMD_MAINMEMTOBUFF1);
     f00:	dd 20       	and	r13, r13
     f02:	11 f4       	brne	.+4      	; 0xf08 <DataflashManager_WriteBlocks+0x106>
     f04:	83 e5       	ldi	r24, 0x53	; 83
     f06:	01 c0       	rjmp	.+2      	; 0xf0a <DataflashManager_WriteBlocks+0x108>
     f08:	85 e5       	ldi	r24, 0x55	; 85
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f0a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f0c:	0d b4       	in	r0, 0x2d	; 45
     f0e:	07 fe       	sbrs	r0, 7
     f10:	fd cf       	rjmp	.-6      	; 0xf0c <DataflashManager_WriteBlocks+0x10a>
					Dataflash_SendAddressBytes(CurrDFPage, 0);
     f12:	c8 01       	movw	r24, r16
     f14:	60 e0       	ldi	r22, 0x00	; 0
     f16:	70 e0       	ldi	r23, 0x00	; 0
     f18:	8b dd       	rcall	.-1258   	; 0xa30 <Dataflash_SendAddressBytes>
					Dataflash_WaitWhileBusy();
     f1a:	7c dd       	rcall	.-1288   	; 0xa14 <Dataflash_WaitWhileBusy>
				}
#endif

				/* Send the Dataflash buffer write command */
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2WRITE : DF_CMD_BUFF1WRITE);
     f1c:	dd 20       	and	r13, r13
     f1e:	11 f4       	brne	.+4      	; 0xf24 <DataflashManager_WriteBlocks+0x122>
     f20:	84 e8       	ldi	r24, 0x84	; 132
     f22:	01 c0       	rjmp	.+2      	; 0xf26 <DataflashManager_WriteBlocks+0x124>
     f24:	87 e8       	ldi	r24, 0x87	; 135
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f26:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f28:	0d b4       	in	r0, 0x2d	; 45
     f2a:	07 fe       	sbrs	r0, 7
     f2c:	fd cf       	rjmp	.-6      	; 0xf28 <DataflashManager_WriteBlocks+0x126>
				Dataflash_SendAddressBytes(0, 0);
     f2e:	80 e0       	ldi	r24, 0x00	; 0
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	60 e0       	ldi	r22, 0x00	; 0
     f34:	70 e0       	ldi	r23, 0x00	; 0
     f36:	7c dd       	rcall	.-1288   	; 0xa30 <Dataflash_SendAddressBytes>
     f38:	90 e0       	ldi	r25, 0x00	; 0
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
     f3a:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f3e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f40:	0d b4       	in	r0, 0x2d	; 45
     f42:	07 fe       	sbrs	r0, 7
     f44:	fd cf       	rjmp	.-6      	; 0xf40 <DataflashManager_WriteBlocks+0x13e>
     f46:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f4a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f4c:	0d b4       	in	r0, 0x2d	; 45
     f4e:	07 fe       	sbrs	r0, 7
     f50:	fd cf       	rjmp	.-6      	; 0xf4c <DataflashManager_WriteBlocks+0x14a>
     f52:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f56:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f58:	0d b4       	in	r0, 0x2d	; 45
     f5a:	07 fe       	sbrs	r0, 7
     f5c:	fd cf       	rjmp	.-6      	; 0xf58 <DataflashManager_WriteBlocks+0x156>
     f5e:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f62:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f64:	0d b4       	in	r0, 0x2d	; 45
     f66:	07 fe       	sbrs	r0, 7
     f68:	fd cf       	rjmp	.-6      	; 0xf64 <DataflashManager_WriteBlocks+0x162>
     f6a:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f6e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f70:	0d b4       	in	r0, 0x2d	; 45
     f72:	07 fe       	sbrs	r0, 7
     f74:	fd cf       	rjmp	.-6      	; 0xf70 <DataflashManager_WriteBlocks+0x16e>
     f76:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f7a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f7c:	0d b4       	in	r0, 0x2d	; 45
     f7e:	07 fe       	sbrs	r0, 7
     f80:	fd cf       	rjmp	.-6      	; 0xf7c <DataflashManager_WriteBlocks+0x17a>
     f82:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f86:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f88:	0d b4       	in	r0, 0x2d	; 45
     f8a:	07 fe       	sbrs	r0, 7
     f8c:	fd cf       	rjmp	.-6      	; 0xf88 <DataflashManager_WriteBlocks+0x186>
     f8e:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f92:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f94:	0d b4       	in	r0, 0x2d	; 45
     f96:	07 fe       	sbrs	r0, 7
     f98:	fd cf       	rjmp	.-6      	; 0xf94 <DataflashManager_WriteBlocks+0x192>
     f9a:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f9e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     fa0:	0d b4       	in	r0, 0x2d	; 45
     fa2:	07 fe       	sbrs	r0, 7
     fa4:	fd cf       	rjmp	.-6      	; 0xfa0 <DataflashManager_WriteBlocks+0x19e>
     fa6:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     faa:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     fac:	0d b4       	in	r0, 0x2d	; 45
     fae:	07 fe       	sbrs	r0, 7
     fb0:	fd cf       	rjmp	.-6      	; 0xfac <DataflashManager_WriteBlocks+0x1aa>
     fb2:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fb6:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     fb8:	0d b4       	in	r0, 0x2d	; 45
     fba:	07 fe       	sbrs	r0, 7
     fbc:	fd cf       	rjmp	.-6      	; 0xfb8 <DataflashManager_WriteBlocks+0x1b6>
     fbe:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fc2:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     fc4:	0d b4       	in	r0, 0x2d	; 45
     fc6:	07 fe       	sbrs	r0, 7
     fc8:	fd cf       	rjmp	.-6      	; 0xfc4 <DataflashManager_WriteBlocks+0x1c2>
     fca:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fce:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     fd0:	0d b4       	in	r0, 0x2d	; 45
     fd2:	07 fe       	sbrs	r0, 7
     fd4:	fd cf       	rjmp	.-6      	; 0xfd0 <DataflashManager_WriteBlocks+0x1ce>
     fd6:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fda:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     fdc:	0d b4       	in	r0, 0x2d	; 45
     fde:	07 fe       	sbrs	r0, 7
     fe0:	fd cf       	rjmp	.-6      	; 0xfdc <DataflashManager_WriteBlocks+0x1da>
     fe2:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fe6:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     fe8:	0d b4       	in	r0, 0x2d	; 45
     fea:	07 fe       	sbrs	r0, 7
     fec:	fd cf       	rjmp	.-6      	; 0xfe8 <DataflashManager_WriteBlocks+0x1e6>
     fee:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ff2:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     ff4:	0d b4       	in	r0, 0x2d	; 45
     ff6:	07 fe       	sbrs	r0, 7
     ff8:	fd cf       	rjmp	.-6      	; 0xff4 <DataflashManager_WriteBlocks+0x1f2>

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     ffa:	f5 01       	movw	r30, r10
     ffc:	86 a9       	ldd	r24, Z+54	; 0x36
     ffe:	88 23       	and	r24, r24
    1000:	61 f5       	brne	.+88     	; 0x105a <DataflashManager_WriteBlocks+0x258>
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
    1002:	9f 5f       	subi	r25, 0xFF	; 255

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
    1004:	c3 94       	inc	r12
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
    1006:	f0 e2       	ldi	r31, 0x20	; 32
    1008:	cf 16       	cp	r12, r31
    100a:	09 f0       	breq	.+2      	; 0x100e <DataflashManager_WriteBlocks+0x20c>
    100c:	4a cf       	rjmp	.-364    	; 0xea2 <DataflashManager_WriteBlocks+0xa0>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
    100e:	08 94       	sec
    1010:	e1 08       	sbc	r14, r1
    1012:	f1 08       	sbc	r15, r1
    1014:	20 ee       	ldi	r18, 0xE0	; 224
    1016:	3f ef       	ldi	r19, 0xFF	; 255
    1018:	82 0e       	add	r8, r18
    101a:	93 1e       	adc	r9, r19

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
    101c:	e1 14       	cp	r14, r1
    101e:	f1 04       	cpc	r15, r1
    1020:	09 f0       	breq	.+2      	; 0x1024 <DataflashManager_WriteBlocks+0x222>
    1022:	3e cf       	rjmp	.-388    	; 0xea0 <DataflashManager_WriteBlocks+0x9e>
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* Write the Dataflash buffer contents back to the Dataflash page */
	Dataflash_WaitWhileBusy();
    1024:	f7 dc       	rcall	.-1554   	; 0xa14 <Dataflash_WaitWhileBusy>
	Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
    1026:	dd 20       	and	r13, r13
    1028:	11 f4       	brne	.+4      	; 0x102e <DataflashManager_WriteBlocks+0x22c>
    102a:	83 e8       	ldi	r24, 0x83	; 131
    102c:	01 c0       	rjmp	.+2      	; 0x1030 <DataflashManager_WriteBlocks+0x22e>
    102e:	86 e8       	ldi	r24, 0x86	; 134
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
    1030:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    1032:	0d b4       	in	r0, 0x2d	; 45
    1034:	07 fe       	sbrs	r0, 7
    1036:	fd cf       	rjmp	.-6      	; 0x1032 <DataflashManager_WriteBlocks+0x230>
	Dataflash_SendAddressBytes(CurrDFPage, 0x00);
    1038:	c8 01       	movw	r24, r16
    103a:	60 e0       	ldi	r22, 0x00	; 0
    103c:	70 e0       	ldi	r23, 0x00	; 0
    103e:	f8 dc       	rcall	.-1552   	; 0xa30 <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
    1040:	e9 dc       	rcall	.-1582   	; 0xa14 <Dataflash_WaitWhileBusy>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    1042:	80 91 e8 00 	lds	r24, 0x00E8

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    1046:	85 fd       	sbrc	r24, 5
    1048:	05 c0       	rjmp	.+10     	; 0x1054 <DataflashManager_WriteBlocks+0x252>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    104a:	80 91 e8 00 	lds	r24, 0x00E8
    104e:	8b 77       	andi	r24, 0x7B	; 123
    1050:	80 93 e8 00 	sts	0x00E8, r24
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT & ~DATAFLASH_CHIPCS_MASK) | ChipMask);
    1054:	8e b1       	in	r24, 0x0e	; 14
    1056:	83 60       	ori	r24, 0x03	; 3
    1058:	8e b9       	out	0x0e, r24	; 14
	  Endpoint_ClearOUT();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
    105a:	0f 90       	pop	r0
    105c:	cf 91       	pop	r28
    105e:	df 91       	pop	r29
    1060:	1f 91       	pop	r17
    1062:	0f 91       	pop	r16
    1064:	ff 90       	pop	r15
    1066:	ef 90       	pop	r14
    1068:	df 90       	pop	r13
    106a:	cf 90       	pop	r12
    106c:	bf 90       	pop	r11
    106e:	af 90       	pop	r10
    1070:	9f 90       	pop	r9
    1072:	8f 90       	pop	r8
    1074:	08 95       	ret

00001076 <uIPManagement_UDPCallback>:
 *  to the appropriate UDP protocol application based on the connection's listen port number.
 */
void uIPManagement_UDPCallback(void)
{
	/* Call the correct UDP application based on the port number the connection is listening on */
	switch (uip_udp_conn->lport)
    1076:	e0 91 24 06 	lds	r30, 0x0624
    107a:	f0 91 25 06 	lds	r31, 0x0625
    107e:	84 81       	ldd	r24, Z+4	; 0x04
    1080:	95 81       	ldd	r25, Z+5	; 0x05
    1082:	23 e4       	ldi	r18, 0x43	; 67
    1084:	80 30       	cpi	r24, 0x00	; 0
    1086:	92 07       	cpc	r25, r18
    1088:	21 f0       	breq	.+8      	; 0x1092 <uIPManagement_UDPCallback+0x1c>
    108a:	80 50       	subi	r24, 0x00	; 0
    108c:	94 44       	sbci	r25, 0x44	; 68
    108e:	11 f4       	brne	.+4      	; 0x1094 <uIPManagement_UDPCallback+0x1e>
	{
		#if defined(ENABLE_DHCP_CLIENT)
		case HTONS(DHCP_CLIENT_PORT):
			DHCPClientApp_Callback();
    1090:	f1 c1       	rjmp	.+994    	; 0x1474 <DHCPClientApp_Callback>
			break;
		#endif
		#if defined(ENABLE_DHCP_SERVER)
		case HTONS(DHCP_SERVER_PORT):
			DHCPServerApp_Callback();
    1092:	a2 c3       	rjmp	.+1860   	; 0x17d8 <DHCPServerApp_Callback>
    1094:	08 95       	ret

00001096 <uIPManagement_TCPCallback>:
 *  to the appropriate TCP protocol application based on the connection's listen port number.
 */
void uIPManagement_TCPCallback(void)
{
	/* Call the correct TCP application based on the port number the connection is listening on */
	switch (uip_conn->lport)
    1096:	e0 91 28 06 	lds	r30, 0x0628
    109a:	f0 91 29 06 	lds	r31, 0x0629
    109e:	84 81       	ldd	r24, Z+4	; 0x04
    10a0:	95 81       	ldd	r25, Z+5	; 0x05
    10a2:	27 e1       	ldi	r18, 0x17	; 23
    10a4:	80 30       	cpi	r24, 0x00	; 0
    10a6:	92 07       	cpc	r25, r18
    10a8:	21 f0       	breq	.+8      	; 0x10b2 <uIPManagement_TCPCallback+0x1c>
    10aa:	80 50       	subi	r24, 0x00	; 0
    10ac:	90 45       	sbci	r25, 0x50	; 80
    10ae:	11 f4       	brne	.+4      	; 0x10b4 <uIPManagement_TCPCallback+0x1e>
	{
		case HTONS(HTTP_SERVER_PORT):
			HTTPServerApp_Callback();
    10b0:	0a c5       	rjmp	.+2580   	; 0x1ac6 <HTTPServerApp_Callback>
			break;
		#if defined(ENABLE_TELNET_SERVER)
		case HTONS(TELNET_SERVER_PORT):
			TELNETServerApp_Callback();
    10b2:	a9 c6       	rjmp	.+3410   	; 0x1e06 <TELNETServerApp_Callback>
    10b4:	08 95       	ret

000010b6 <uIPManagement_ManageNetwork>:

/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
    10b6:	0f 93       	push	r16
    10b8:	1f 93       	push	r17
    10ba:	cf 93       	push	r28
    10bc:	df 93       	push	r29
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    10be:	80 91 cf 03 	lds	r24, 0x03CF
    10c2:	82 30       	cpi	r24, 0x02	; 2
    10c4:	21 f4       	brne	.+8      	; 0x10ce <uIPManagement_ManageNetwork+0x18>
    10c6:	80 91 ac 0d 	lds	r24, 0x0DAC
    10ca:	8b 30       	cpi	r24, 0x0B	; 11
    10cc:	49 f0       	breq	.+18     	; 0x10e0 <uIPManagement_ManageNetwork+0x2a>
    10ce:	80 91 cf 03 	lds	r24, 0x03CF
    10d2:	81 30       	cpi	r24, 0x01	; 1
    10d4:	09 f0       	breq	.+2      	; 0x10d8 <uIPManagement_ManageNetwork+0x22>
    10d6:	bb c0       	rjmp	.+374    	; 0x124e <uIPManagement_ManageNetwork+0x198>
    10d8:	8e b3       	in	r24, 0x1e	; 30
    10da:	84 30       	cpi	r24, 0x04	; 4
    10dc:	09 f0       	breq	.+2      	; 0x10e0 <uIPManagement_ManageNetwork+0x2a>
    10de:	b7 c0       	rjmp	.+366    	; 0x124e <uIPManagement_ManageNetwork+0x198>

/** Processes Incoming packets to the server from the connected RNDIS device, creating responses as needed. */
static void uIPManagement_ProcessIncomingPacket(void)
{
	/* Determine which USB mode the system is currently initialized in */
	if (USB_CurrentMode == USB_MODE_Device)
    10e0:	80 91 cf 03 	lds	r24, 0x03CF
    10e4:	81 30       	cpi	r24, 0x01	; 1
    10e6:	a1 f4       	brne	.+40     	; 0x1110 <uIPManagement_ManageNetwork+0x5a>
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface_Device)))
    10e8:	83 e1       	ldi	r24, 0x13	; 19
    10ea:	91 e0       	ldi	r25, 0x01	; 1
    10ec:	0e 94 58 34 	call	0x68b0	; 0x68b0 <RNDIS_Device_IsPacketReceived>
    10f0:	88 23       	and	r24, r24
    10f2:	09 f4       	brne	.+2      	; 0x10f6 <uIPManagement_ManageNetwork+0x40>
    10f4:	4a c0       	rjmp	.+148    	; 0x118a <uIPManagement_ManageNetwork+0xd4>
    10f6:	8b b1       	in	r24, 0x0b	; 11
    10f8:	8f 70       	andi	r24, 0x0F	; 15
    10fa:	80 6d       	ori	r24, 0xD0	; 208
    10fc:	8b b9       	out	0x0b, r24	; 11
		  return;
	
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, &uip_len);
    10fe:	83 e1       	ldi	r24, 0x13	; 19
    1100:	91 e0       	ldi	r25, 0x01	; 1
    1102:	63 e9       	ldi	r22, 0x93	; 147
    1104:	77 e0       	ldi	r23, 0x07	; 7
    1106:	4b e1       	ldi	r20, 0x1B	; 27
    1108:	56 e0       	ldi	r21, 0x06	; 6
    110a:	0e 94 26 35 	call	0x6a4c	; 0x6a4c <RNDIS_Device_ReadPacket>
    110e:	12 c0       	rjmp	.+36     	; 0x1134 <uIPManagement_ManageNetwork+0x7e>
	}
	else
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Host_IsPacketReceived(&Ethernet_RNDIS_Interface_Host)))
    1110:	85 ee       	ldi	r24, 0xE5	; 229
    1112:	91 e0       	ldi	r25, 0x01	; 1
    1114:	0e 94 b8 38 	call	0x7170	; 0x7170 <RNDIS_Host_IsPacketReceived>
    1118:	88 23       	and	r24, r24
    111a:	b9 f1       	breq	.+110    	; 0x118a <uIPManagement_ManageNetwork+0xd4>
    111c:	8b b1       	in	r24, 0x0b	; 11
    111e:	8f 70       	andi	r24, 0x0F	; 15
    1120:	80 6d       	ori	r24, 0xD0	; 208
    1122:	8b b9       	out	0x0b, r24	; 11
		  return;
	
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Host_ReadPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, &uip_len);
    1124:	85 ee       	ldi	r24, 0xE5	; 229
    1126:	91 e0       	ldi	r25, 0x01	; 1
    1128:	63 e9       	ldi	r22, 0x93	; 147
    112a:	77 e0       	ldi	r23, 0x07	; 7
    112c:	4b e1       	ldi	r20, 0x1B	; 27
    112e:	56 e0       	ldi	r21, 0x06	; 6
    1130:	0e 94 50 39 	call	0x72a0	; 0x72a0 <RNDIS_Host_ReadPacket>
	}
	
	/* If the packet contains an Ethernet frame, process it */
	if (uip_len > 0)
    1134:	80 91 1b 06 	lds	r24, 0x061B
    1138:	90 91 1c 06 	lds	r25, 0x061C
    113c:	89 2b       	or	r24, r25
    113e:	09 f1       	breq	.+66     	; 0x1182 <uIPManagement_ManageNetwork+0xcc>
	{
		switch (((struct uip_eth_hdr*)uip_buf)->type)
    1140:	80 91 9f 07 	lds	r24, 0x079F
    1144:	90 91 a0 07 	lds	r25, 0x07A0
    1148:	88 30       	cpi	r24, 0x08	; 8
    114a:	91 05       	cpc	r25, r1
    114c:	21 f0       	breq	.+8      	; 0x1156 <uIPManagement_ManageNetwork+0xa0>
    114e:	88 50       	subi	r24, 0x08	; 8
    1150:	96 40       	sbci	r25, 0x06	; 6
    1152:	b9 f4       	brne	.+46     	; 0x1182 <uIPManagement_ManageNetwork+0xcc>
    1154:	0c c0       	rjmp	.+24     	; 0x116e <uIPManagement_ManageNetwork+0xb8>
			case HTONS(UIP_ETHTYPE_IP):
				/* Filter packet by MAC destination */
				uip_arp_ipin();

				/* Process Incoming packet */
				uip_input();
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	0e 94 2b 11 	call	0x2256	; 0x2256 <uip_process>

				/* If a response was generated, send it */
				if (uip_len > 0)
    115c:	80 91 1b 06 	lds	r24, 0x061B
    1160:	90 91 1c 06 	lds	r25, 0x061C
    1164:	89 2b       	or	r24, r25
    1166:	69 f0       	breq	.+26     	; 0x1182 <uIPManagement_ManageNetwork+0xcc>
				{
					/* Add destination MAC to outgoing packet */
					uip_arp_out();
    1168:	0e 94 cb 1a 	call	0x3596	; 0x3596 <uip_arp_out>
    116c:	08 c0       	rjmp	.+16     	; 0x117e <uIPManagement_ManageNetwork+0xc8>
				}

				break;
			case HTONS(UIP_ETHTYPE_ARP):
				/* Process ARP packet */
				uip_arp_arpin();
    116e:	0e 94 17 1a 	call	0x342e	; 0x342e <uip_arp_arpin>

				/* If a response was generated, send it */
				if (uip_len > 0)
    1172:	80 91 1b 06 	lds	r24, 0x061B
    1176:	90 91 1c 06 	lds	r25, 0x061C
    117a:	89 2b       	or	r24, r25
    117c:	11 f0       	breq	.+4      	; 0x1182 <uIPManagement_ManageNetwork+0xcc>
				  uip_split_output();
    117e:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <uip_split_output>
    1182:	8b b1       	in	r24, 0x0b	; 11
    1184:	8f 70       	andi	r24, 0x0F	; 15
    1186:	80 62       	ori	r24, 0x20	; 32
    1188:	8b b9       	out	0x0b, r24	; 11
    118a:	0a e2       	ldi	r16, 0x2A	; 42
    118c:	16 e0       	ldi	r17, 0x06	; 6
    118e:	e8 01       	movw	r28, r16
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		uip_poll_conn(&uip_conns[i]);
    1190:	d0 93 29 06 	sts	0x0629, r29
    1194:	c0 93 28 06 	sts	0x0628, r28
    1198:	83 e0       	ldi	r24, 0x03	; 3
    119a:	0e 94 2b 11 	call	0x2256	; 0x2256 <uip_process>

		/* If a response was generated, send it */
		if (uip_len > 0)
    119e:	80 91 1b 06 	lds	r24, 0x061B
    11a2:	90 91 1c 06 	lds	r25, 0x061C
    11a6:	89 2b       	or	r24, r25
    11a8:	21 f0       	breq	.+8      	; 0x11b2 <uIPManagement_ManageNetwork+0xfc>
		{
			/* Add destination MAC to outgoing packet */
			uip_arp_out();
    11aa:	0e 94 cb 1a 	call	0x3596	; 0x3596 <uip_arp_out>

			/* Split and send the outgoing packet */
			uip_split_output();
    11ae:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <uip_split_output>
    11b2:	cf 58       	subi	r28, 0x8F	; 143
    11b4:	df 4f       	sbci	r29, 0xFF	; 255

/** Manages the currently open network connections, including TCP and (if enabled) UDP. */
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    11b6:	87 e0       	ldi	r24, 0x07	; 7
    11b8:	cd 37       	cpi	r28, 0x7D	; 125
    11ba:	d8 07       	cpc	r29, r24
    11bc:	49 f7       	brne	.-46     	; 0x1190 <uIPManagement_ManageNetwork+0xda>
			uip_split_output();
		}
	}

	/* Manage open connections for timeouts */
	if (timer_expired(&ConnectionTimer))
    11be:	8c e4       	ldi	r24, 0x4C	; 76
    11c0:	93 e0       	ldi	r25, 0x03	; 3
    11c2:	0e 94 2d 1c 	call	0x385a	; 0x385a <timer_expired>
    11c6:	89 2b       	or	r24, r25
    11c8:	b1 f1       	breq	.+108    	; 0x1236 <uIPManagement_ManageNetwork+0x180>
	{
		timer_reset(&ConnectionTimer);
    11ca:	8c e4       	ldi	r24, 0x4C	; 76
    11cc:	93 e0       	ldi	r25, 0x03	; 3
    11ce:	0e 94 23 1c 	call	0x3846	; 0x3846 <timer_reset>
    11d2:	8b b1       	in	r24, 0x0b	; 11
    11d4:	8f 70       	andi	r24, 0x0F	; 15
    11d6:	80 6d       	ori	r24, 0xD0	; 208
    11d8:	8b b9       	out	0x0b, r24	; 11
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		for (uint8_t i = 0; i < UIP_CONNS; i++)
		{
			/* Run periodic connection management for each TCP connection */
			uip_periodic(i);
    11da:	10 93 29 06 	sts	0x0629, r17
    11de:	00 93 28 06 	sts	0x0628, r16
    11e2:	82 e0       	ldi	r24, 0x02	; 2
    11e4:	0e 94 2b 11 	call	0x2256	; 0x2256 <uip_process>

			/* If a response was generated, send it */
			if (uip_len > 0)
    11e8:	80 91 1b 06 	lds	r24, 0x061B
    11ec:	90 91 1c 06 	lds	r25, 0x061C
    11f0:	89 2b       	or	r24, r25
    11f2:	21 f0       	breq	.+8      	; 0x11fc <uIPManagement_ManageNetwork+0x146>
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    11f4:	0e 94 cb 1a 	call	0x3596	; 0x3596 <uip_arp_out>

				/* Split and send the outgoing packet */
				uip_split_output();
    11f8:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <uip_split_output>
    11fc:	0f 58       	subi	r16, 0x8F	; 143
    11fe:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		timer_reset(&ConnectionTimer);

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		for (uint8_t i = 0; i < UIP_CONNS; i++)
    1200:	27 e0       	ldi	r18, 0x07	; 7
    1202:	0d 37       	cpi	r16, 0x7D	; 125
    1204:	12 07       	cpc	r17, r18
    1206:	49 f7       	brne	.-46     	; 0x11da <uIPManagement_ManageNetwork+0x124>

		#if defined(ENABLE_DHCP_CLIENT)
		for (uint8_t i = 0; i < UIP_UDP_CONNS; i++)
		{
			/* Run periodic connection management for each UDP connection */
			uip_udp_periodic(i);
    1208:	81 e8       	ldi	r24, 0x81	; 129
    120a:	9d e0       	ldi	r25, 0x0D	; 13
    120c:	90 93 25 06 	sts	0x0625, r25
    1210:	80 93 24 06 	sts	0x0624, r24
    1214:	85 e0       	ldi	r24, 0x05	; 5
    1216:	0e 94 2b 11 	call	0x2256	; 0x2256 <uip_process>

			/* If a response was generated, send it */
			if (uip_len > 0)
    121a:	80 91 1b 06 	lds	r24, 0x061B
    121e:	90 91 1c 06 	lds	r25, 0x061C
    1222:	89 2b       	or	r24, r25
    1224:	21 f0       	breq	.+8      	; 0x122e <uIPManagement_ManageNetwork+0x178>
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    1226:	0e 94 cb 1a 	call	0x3596	; 0x3596 <uip_arp_out>

				/* Split and send the outgoing packet */
				uip_split_output();
    122a:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <uip_split_output>
    122e:	8b b1       	in	r24, 0x0b	; 11
    1230:	8f 70       	andi	r24, 0x0F	; 15
    1232:	80 62       	ori	r24, 0x20	; 32
    1234:	8b b9       	out	0x0b, r24	; 11

		LEDs_SetAllLEDs(LEDMASK_USB_READY);
	}

	/* Manage ARP cache refreshing */
	if (timer_expired(&ARPTimer))
    1236:	80 e5       	ldi	r24, 0x50	; 80
    1238:	93 e0       	ldi	r25, 0x03	; 3
    123a:	0e 94 2d 1c 	call	0x385a	; 0x385a <timer_expired>
    123e:	89 2b       	or	r24, r25
    1240:	31 f0       	breq	.+12     	; 0x124e <uIPManagement_ManageNetwork+0x198>
	{
		timer_reset(&ARPTimer);
    1242:	80 e5       	ldi	r24, 0x50	; 80
    1244:	93 e0       	ldi	r25, 0x03	; 3
    1246:	0e 94 23 1c 	call	0x3846	; 0x3846 <timer_reset>
		uip_arp_timer();
    124a:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <uip_arp_timer>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
	{
		uIPManagement_ProcessIncomingPacket();
		uIPManagement_ManageConnections();
	}
}
    124e:	df 91       	pop	r29
    1250:	cf 91       	pop	r28
    1252:	1f 91       	pop	r17
    1254:	0f 91       	pop	r16
    1256:	08 95       	ret

00001258 <uIPManagement_Init>:
struct uip_eth_addr MACAddress;


/** Configures the uIP stack ready for network traffic processing. */
void uIPManagement_Init(void)
{
    1258:	ef 92       	push	r14
    125a:	ff 92       	push	r15
    125c:	0f 93       	push	r16
    125e:	1f 93       	push	r17
	/* uIP Timing Initialization */
	clock_init();
    1260:	0e 94 67 1c 	call	0x38ce	; 0x38ce <clock_init>
	timer_set(&ConnectionTimer, CLOCK_SECOND / 2);
    1264:	8c e4       	ldi	r24, 0x4C	; 76
    1266:	93 e0       	ldi	r25, 0x03	; 3
    1268:	62 e3       	ldi	r22, 0x32	; 50
    126a:	70 e0       	ldi	r23, 0x00	; 0
    126c:	0e 94 43 1c 	call	0x3886	; 0x3886 <timer_set>
	timer_set(&ARPTimer, CLOCK_SECOND * 10);
    1270:	80 e5       	ldi	r24, 0x50	; 80
    1272:	93 e0       	ldi	r25, 0x03	; 3
    1274:	68 ee       	ldi	r22, 0xE8	; 232
    1276:	73 e0       	ldi	r23, 0x03	; 3
    1278:	0e 94 43 1c 	call	0x3886	; 0x3886 <timer_set>

	/* uIP Stack Initialization */
	uip_init();
    127c:	29 d7       	rcall	.+3666   	; 0x20d0 <uip_init>
	uip_arp_init();
    127e:	0e 94 0e 1c 	call	0x381c	; 0x381c <uip_arp_init>

	/* DHCP/Server IP Settings Initialization */
	if (USB_CurrentMode == USB_MODE_Device)
    1282:	80 91 cf 03 	lds	r24, 0x03CF
    1286:	81 30       	cpi	r24, 0x01	; 1
    1288:	e1 f5       	brne	.+120    	; 0x1302 <uIPManagement_Init+0xaa>
	{
		MACAddress.addr[0] = SERVER_MAC_ADDRESS[0];
    128a:	80 93 d2 03 	sts	0x03D2, r24
		MACAddress.addr[1] = SERVER_MAC_ADDRESS[1];
    128e:	10 92 d3 03 	sts	0x03D3, r1
		MACAddress.addr[2] = SERVER_MAC_ADDRESS[2];
    1292:	80 93 d4 03 	sts	0x03D4, r24
		MACAddress.addr[3] = SERVER_MAC_ADDRESS[3];
    1296:	10 92 d5 03 	sts	0x03D5, r1
		MACAddress.addr[4] = SERVER_MAC_ADDRESS[4];
    129a:	80 93 d6 03 	sts	0x03D6, r24
		MACAddress.addr[5] = SERVER_MAC_ADDRESS[5];
    129e:	10 92 d7 03 	sts	0x03D7, r1

		#if defined(ENABLE_DHCP_SERVER)
		DHCPServerApp_Init();	
    12a2:	f9 d3       	rcall	.+2034   	; 0x1a96 <DHCPServerApp_Init>
		#endif

		uip_ipaddr_t IPAddress, Netmask, GatewayIPAddress;
		uip_ipaddr(&IPAddress,        DEVICE_IP_ADDRESS[0], DEVICE_IP_ADDRESS[1], DEVICE_IP_ADDRESS[2], DEVICE_IP_ADDRESS[3]);
    12a4:	8a e0       	ldi	r24, 0x0A	; 10
    12a6:	e8 2e       	mov	r14, r24
    12a8:	f1 2c       	mov	r15, r1
    12aa:	01 2d       	mov	r16, r1
    12ac:	11 2d       	mov	r17, r1
    12ae:	ff 24       	eor	r15, r15
    12b0:	00 e0       	ldi	r16, 0x00	; 0
    12b2:	12 e0       	ldi	r17, 0x02	; 2
		uip_ipaddr(&Netmask,          DEVICE_NETMASK[0],    DEVICE_NETMASK[1],    DEVICE_NETMASK[2],    DEVICE_NETMASK[3]);
    12b4:	2f ef       	ldi	r18, 0xFF	; 255
    12b6:	30 e0       	ldi	r19, 0x00	; 0
    12b8:	40 e0       	ldi	r20, 0x00	; 0
    12ba:	50 e0       	ldi	r21, 0x00	; 0
    12bc:	3f ef       	ldi	r19, 0xFF	; 255
    12be:	4f ef       	ldi	r20, 0xFF	; 255
    12c0:	50 e0       	ldi	r21, 0x00	; 0
		uip_ipaddr(&GatewayIPAddress, DEVICE_GATEWAY[0],    DEVICE_GATEWAY[1],    DEVICE_GATEWAY[2],    DEVICE_GATEWAY[3]);
    12c2:	8a e0       	ldi	r24, 0x0A	; 10
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	a0 e0       	ldi	r26, 0x00	; 0
    12c8:	b0 e0       	ldi	r27, 0x00	; 0
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	a0 e0       	ldi	r26, 0x00	; 0
    12ce:	b1 e0       	ldi	r27, 0x01	; 1
		uip_sethostaddr(&IPAddress);
    12d0:	e0 92 8f 07 	sts	0x078F, r14
    12d4:	f0 92 90 07 	sts	0x0790, r15
    12d8:	00 93 91 07 	sts	0x0791, r16
    12dc:	10 93 92 07 	sts	0x0792, r17
		uip_setnetmask(&Netmask);
    12e0:	20 93 8b 07 	sts	0x078B, r18
    12e4:	30 93 8c 07 	sts	0x078C, r19
    12e8:	40 93 8d 07 	sts	0x078D, r20
    12ec:	50 93 8e 07 	sts	0x078E, r21
		uip_setdraddr(&GatewayIPAddress);
    12f0:	80 93 87 07 	sts	0x0787, r24
    12f4:	90 93 88 07 	sts	0x0788, r25
    12f8:	a0 93 89 07 	sts	0x0789, r26
    12fc:	b0 93 8a 07 	sts	0x078A, r27
    1300:	01 c0       	rjmp	.+2      	; 0x1304 <uIPManagement_Init+0xac>
	}
	else
	{
		#if defined(ENABLE_DHCP_CLIENT)
		DHCPClientApp_Init();	
    1302:	e6 d1       	rcall	.+972    	; 0x16d0 <DHCPClientApp_Init>
		uip_setdraddr(&GatewayIPAddress);
		#endif
	}

	/* Virtual Webserver Ethernet Address Configuration */
	uip_setethaddr(MACAddress);
    1304:	80 91 d2 03 	lds	r24, 0x03D2
    1308:	80 93 54 03 	sts	0x0354, r24
    130c:	80 91 d3 03 	lds	r24, 0x03D3
    1310:	80 93 55 03 	sts	0x0355, r24
    1314:	80 91 d4 03 	lds	r24, 0x03D4
    1318:	80 93 56 03 	sts	0x0356, r24
    131c:	80 91 d5 03 	lds	r24, 0x03D5
    1320:	80 93 57 03 	sts	0x0357, r24
    1324:	80 91 d6 03 	lds	r24, 0x03D6
    1328:	80 93 58 03 	sts	0x0358, r24
    132c:	80 91 d7 03 	lds	r24, 0x03D7
    1330:	80 93 59 03 	sts	0x0359, r24

	/* HTTP Webserver Initialization */
	HTTPServerApp_Init();
    1334:	60 d5       	rcall	.+2752   	; 0x1df6 <HTTPServerApp_Init>

	/* TELNET Server Initialization */
	#if defined(ENABLE_TELNET_SERVER)
	TELNETServerApp_Init();
    1336:	6a d6       	rcall	.+3284   	; 0x200c <TELNETServerApp_Init>
	#endif
}
    1338:	1f 91       	pop	r17
    133a:	0f 91       	pop	r16
    133c:	ff 90       	pop	r15
    133e:	ef 90       	pop	r14
    1340:	08 95       	ret

00001342 <DHCPCommon_GetOption>:
 *  \return Boolean true if the option was found in the DHCP packet's options list, false otherwise
 */
bool DHCPCommon_GetOption(const uint8_t* DHCPOptionList,
                          const uint8_t Option,
                          void* const Destination)
{
    1342:	fc 01       	movw	r30, r24
    1344:	da 01       	movw	r26, r20
    1346:	10 c0       	rjmp	.+32     	; 0x1368 <DHCPCommon_GetOption+0x26>
    1348:	41 81       	ldd	r20, Z+1	; 0x01
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
	{
		/* Check if the current DHCP option in the packet is the one requested */
		if (DHCPOptionList[0] == Option)
    134a:	26 17       	cp	r18, r22
    134c:	41 f4       	brne	.+16     	; 0x135e <DHCPCommon_GetOption+0x1c>
		{
			/* Copy request option's data to the destination buffer */
			memcpy(Destination, &DHCPOptionList[2], DHCPOptionList[1]);
    134e:	50 e0       	ldi	r21, 0x00	; 0
    1350:	32 96       	adiw	r30, 0x02	; 2
    1352:	cd 01       	movw	r24, r26
    1354:	bf 01       	movw	r22, r30
    1356:	0e 94 24 3d 	call	0x7a48	; 0x7a48 <memcpy>
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	08 95       	ret
			/* Indicate that the requested option data was successfully retrieved */
			return true;
		}

		/* Skip to next DHCP option in the options list */
		DHCPOptionList += (DHCPOptionList[1] + 2);
    135e:	84 2f       	mov	r24, r20
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	02 96       	adiw	r24, 0x02	; 2
    1364:	e8 0f       	add	r30, r24
    1366:	f9 1f       	adc	r31, r25
bool DHCPCommon_GetOption(const uint8_t* DHCPOptionList,
                          const uint8_t Option,
                          void* const Destination)
{
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1368:	20 81       	ld	r18, Z
    136a:	2f 3f       	cpi	r18, 0xFF	; 255
    136c:	69 f7       	brne	.-38     	; 0x1348 <DHCPCommon_GetOption+0x6>
    136e:	80 e0       	ldi	r24, 0x00	; 0
		DHCPOptionList += (DHCPOptionList[1] + 2);
	}

	/* Requested option not found in the incoming packet's DHCP options list */
	return false;
}
    1370:	08 95       	ret

00001372 <DHCPCommon_SetOption>:
 */
uint8_t DHCPCommon_SetOption(uint8_t* DHCPOptionList,
                             const uint8_t Option,
                             const uint8_t DataLen,
                             void* const OptionData)
{
    1372:	ef 92       	push	r14
    1374:	ff 92       	push	r15
    1376:	0f 93       	push	r16
    1378:	1f 93       	push	r17
    137a:	cf 93       	push	r28
    137c:	df 93       	push	r29
    137e:	ec 01       	movw	r28, r24
    1380:	f4 2e       	mov	r15, r20
    1382:	05 c0       	rjmp	.+10     	; 0x138e <DHCPCommon_SetOption+0x1c>
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
	  DHCPOptionList += (DHCPOptionList[1] + 2);
    1384:	89 81       	ldd	r24, Y+1	; 0x01
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	02 96       	adiw	r24, 0x02	; 2
    138a:	c8 0f       	add	r28, r24
    138c:	d9 1f       	adc	r29, r25
                             const uint8_t Option,
                             const uint8_t DataLen,
                             void* const OptionData)
{
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
    138e:	e8 80       	ld	r14, Y
    1390:	8f ef       	ldi	r24, 0xFF	; 255
    1392:	e8 16       	cp	r14, r24
    1394:	b9 f7       	brne	.-18     	; 0x1384 <DHCPCommon_SetOption+0x12>
	  DHCPOptionList += (DHCPOptionList[1] + 2);

	/* Overwrite the existing terminator with the new option, add a new terminator at the end of the list */
	DHCPOptionList[0] = Option;
    1396:	68 83       	st	Y, r22
	DHCPOptionList[1] = DataLen;
    1398:	f9 82       	std	Y+1, r15	; 0x01
	memcpy(&DHCPOptionList[2], OptionData, DataLen);
    139a:	0f 2d       	mov	r16, r15
    139c:	10 e0       	ldi	r17, 0x00	; 0
    139e:	ce 01       	movw	r24, r28
    13a0:	02 96       	adiw	r24, 0x02	; 2
    13a2:	b9 01       	movw	r22, r18
    13a4:	a8 01       	movw	r20, r16
    13a6:	0e 94 24 3d 	call	0x7a48	; 0x7a48 <memcpy>
	DHCPOptionList[2 + DataLen] = DHCP_OPTION_END;
    13aa:	0c 0f       	add	r16, r28
    13ac:	1d 1f       	adc	r17, r29
    13ae:	f8 01       	movw	r30, r16
    13b0:	e2 82       	std	Z+2, r14	; 0x02

	/* Calculate the total number of bytes added to the outgoing packet */
	return (2 + DataLen);
}
    13b2:	8f 2d       	mov	r24, r15
    13b4:	8e 5f       	subi	r24, 0xFE	; 254
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	0f 91       	pop	r16
    13be:	ff 90       	pop	r15
    13c0:	ef 90       	pop	r14
    13c2:	08 95       	ret

000013c4 <DHCPClientApp_FillDHCPHeader>:
 *  \return Size in bytes of the created DHCP packet
 */
static uint16_t DHCPClientApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             uip_udp_appstate_t* const AppState)
{
    13c4:	cf 93       	push	r28
    13c6:	df 93       	push	r29
    13c8:	ec 01       	movw	r28, r24
    13ca:	fa 01       	movw	r30, r20
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    13cc:	80 ef       	ldi	r24, 0xF0	; 240
    13ce:	de 01       	movw	r26, r28
    13d0:	1d 92       	st	X+, r1
    13d2:	8a 95       	dec	r24
    13d4:	e9 f7       	brne	.-6      	; 0x13d0 <DHCPClientApp_FillDHCPHeader+0xc>

	/* Fill out the DHCP packet header */
	DHCPHeader->Operation             = DHCP_OP_BOOTREQUEST;
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	88 83       	st	Y, r24
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    13da:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    13dc:	86 e0       	ldi	r24, 0x06	; 6
    13de:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeader->Hops                  = 0;
    13e0:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeader->TransactionID         = DHCP_TRANSACTION_ID;
    13e2:	86 e6       	ldi	r24, 0x66	; 102
    13e4:	94 e5       	ldi	r25, 0x54	; 84
    13e6:	a4 e2       	ldi	r26, 0x24	; 36
    13e8:	b3 e1       	ldi	r27, 0x13	; 19
    13ea:	8c 83       	std	Y+4, r24	; 0x04
    13ec:	9d 83       	std	Y+5, r25	; 0x05
    13ee:	ae 83       	std	Y+6, r26	; 0x06
    13f0:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    13f2:	19 86       	std	Y+9, r1	; 0x09
    13f4:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeader->Flags                 = HTONS(BOOTP_BROADCAST);
    13f6:	80 e8       	ldi	r24, 0x80	; 128
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	9b 87       	std	Y+11, r25	; 0x0b
    13fc:	8a 87       	std	Y+10, r24	; 0x0a
	memcpy(&DHCPHeader->ClientIP,     &uip_hostaddr,        sizeof(uip_ipaddr_t));
    13fe:	80 91 8f 07 	lds	r24, 0x078F
    1402:	90 91 90 07 	lds	r25, 0x0790
    1406:	a0 91 91 07 	lds	r26, 0x0791
    140a:	b0 91 92 07 	lds	r27, 0x0792
    140e:	8c 87       	std	Y+12, r24	; 0x0c
    1410:	9d 87       	std	Y+13, r25	; 0x0d
    1412:	ae 87       	std	Y+14, r26	; 0x0e
    1414:	bf 87       	std	Y+15, r27	; 0x0f
	memcpy(&DHCPHeader->YourIP,       &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, sizeof(uip_ipaddr_t));
    1416:	85 81       	ldd	r24, Z+5	; 0x05
    1418:	96 81       	ldd	r25, Z+6	; 0x06
    141a:	a7 81       	ldd	r26, Z+7	; 0x07
    141c:	b0 85       	ldd	r27, Z+8	; 0x08
    141e:	88 8b       	std	Y+16, r24	; 0x10
    1420:	99 8b       	std	Y+17, r25	; 0x11
    1422:	aa 8b       	std	Y+18, r26	; 0x12
    1424:	bb 8b       	std	Y+19, r27	; 0x13
	memcpy(&DHCPHeader->NextServerIP, &AppState->DHCPClient.DHCPOffer_Data.ServerIP,    sizeof(uip_ipaddr_t));
    1426:	81 89       	ldd	r24, Z+17	; 0x11
    1428:	92 89       	ldd	r25, Z+18	; 0x12
    142a:	a3 89       	ldd	r26, Z+19	; 0x13
    142c:	b4 89       	ldd	r27, Z+20	; 0x14
    142e:	8c 8b       	std	Y+20, r24	; 0x14
    1430:	9d 8b       	std	Y+21, r25	; 0x15
    1432:	ae 8b       	std	Y+22, r26	; 0x16
    1434:	bf 8b       	std	Y+23, r27	; 0x17
	memcpy(&DHCPHeader->ClientHardwareAddress, &MACAddress, sizeof(struct uip_eth_addr));
    1436:	de 01       	movw	r26, r28
    1438:	5c 96       	adiw	r26, 0x1c	; 28
    143a:	e2 ed       	ldi	r30, 0xD2	; 210
    143c:	f3 e0       	ldi	r31, 0x03	; 3
    143e:	86 e0       	ldi	r24, 0x06	; 6
    1440:	01 90       	ld	r0, Z+
    1442:	0d 92       	st	X+, r0
    1444:	81 50       	subi	r24, 0x01	; 1
    1446:	e1 f7       	brne	.-8      	; 0x1440 <DHCPClientApp_FillDHCPHeader+0x7c>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    1448:	c4 51       	subi	r28, 0x14	; 20
    144a:	df 4f       	sbci	r29, 0xFF	; 255
    144c:	83 e6       	ldi	r24, 0x63	; 99
    144e:	92 e8       	ldi	r25, 0x82	; 130
    1450:	a3 e5       	ldi	r26, 0x53	; 83
    1452:	b3 e6       	ldi	r27, 0x63	; 99
    1454:	89 93       	st	Y+, r24
    1456:	99 93       	st	Y+, r25
    1458:	a9 93       	st	Y+, r26
    145a:	b9 93       	st	Y+, r27

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    145c:	85 e3       	ldi	r24, 0x35	; 53
    145e:	89 93       	st	Y+, r24
	DHCPHeader->Options[1]            = 1;
    1460:	81 e0       	ldi	r24, 0x01	; 1
    1462:	89 93       	st	Y+, r24
	DHCPHeader->Options[2]            = DHCPMessageType;
    1464:	69 93       	st	Y+, r22
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    1466:	8f ef       	ldi	r24, 0xFF	; 255
    1468:	88 83       	st	Y, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    146a:	84 ef       	ldi	r24, 0xF4	; 244
    146c:	90 e0       	ldi	r25, 0x00	; 0
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	08 95       	ret

00001474 <DHCPClientApp_Callback>:

/** uIP stack application callback for the DHCP client. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPClientApp_Callback(void)
{
    1474:	af 92       	push	r10
    1476:	bf 92       	push	r11
    1478:	cf 92       	push	r12
    147a:	df 92       	push	r13
    147c:	ef 92       	push	r14
    147e:	ff 92       	push	r15
    1480:	0f 93       	push	r16
    1482:	1f 93       	push	r17
    1484:	df 93       	push	r29
    1486:	cf 93       	push	r28
    1488:	00 d0       	rcall	.+0      	; 0x148a <DHCPClientApp_Callback+0x16>
    148a:	00 d0       	rcall	.+0      	; 0x148c <DHCPClientApp_Callback+0x18>
    148c:	0f 92       	push	r0
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
	uip_udp_appstate_t* const AppState    = &uip_udp_conn->appstate;
    1492:	a0 90 24 06 	lds	r10, 0x0624
    1496:	b0 90 25 06 	lds	r11, 0x0625
    149a:	a5 01       	movw	r20, r10
    149c:	47 5f       	subi	r20, 0xF7	; 247
    149e:	5f 4f       	sbci	r21, 0xFF	; 255
	DHCP_Header_t*      const AppData     = (DHCP_Header_t*)uip_appdata;
    14a0:	00 91 26 06 	lds	r16, 0x0626
    14a4:	10 91 27 06 	lds	r17, 0x0627
	uint16_t                  AppDataSize = 0;

	switch (AppState->DHCPClient.CurrentState)
    14a8:	f5 01       	movw	r30, r10
    14aa:	81 85       	ldd	r24, Z+9	; 0x09
    14ac:	81 30       	cpi	r24, 0x01	; 1
    14ae:	09 f4       	brne	.+2      	; 0x14b2 <DHCPClientApp_Callback+0x3e>
    14b0:	47 c0       	rjmp	.+142    	; 0x1540 <DHCPClientApp_Callback+0xcc>
    14b2:	81 30       	cpi	r24, 0x01	; 1
    14b4:	38 f0       	brcs	.+14     	; 0x14c4 <DHCPClientApp_Callback+0x50>
    14b6:	82 30       	cpi	r24, 0x02	; 2
    14b8:	09 f4       	brne	.+2      	; 0x14bc <DHCPClientApp_Callback+0x48>
    14ba:	87 c0       	rjmp	.+270    	; 0x15ca <DHCPClientApp_Callback+0x156>
    14bc:	83 30       	cpi	r24, 0x03	; 3
    14be:	09 f0       	breq	.+2      	; 0x14c2 <DHCPClientApp_Callback+0x4e>
    14c0:	f7 c0       	rjmp	.+494    	; 0x16b0 <DHCPClientApp_Callback+0x23c>
    14c2:	aa c0       	rjmp	.+340    	; 0x1618 <DHCPClientApp_Callback+0x1a4>
	{
		case DHCP_STATE_SendDiscover:
			/* Clear all DHCP settings, reset client IP address */
			memset(&AppState->DHCPClient.DHCPOffer_Data, 0x00, sizeof(AppState->DHCPClient.DHCPOffer_Data));
    14c4:	8e e0       	ldi	r24, 0x0E	; 14
    14c6:	90 e0       	ldi	r25, 0x00	; 0
    14c8:	a8 0e       	add	r10, r24
    14ca:	b9 1e       	adc	r11, r25
    14cc:	80 e1       	ldi	r24, 0x10	; 16
    14ce:	f5 01       	movw	r30, r10
    14d0:	11 92       	st	Z+, r1
    14d2:	8a 95       	dec	r24
    14d4:	e9 f7       	brne	.-6      	; 0x14d0 <DHCPClientApp_Callback+0x5c>
    14d6:	82 ef       	ldi	r24, 0xF2	; 242
    14d8:	9f ef       	ldi	r25, 0xFF	; 255
    14da:	a8 0e       	add	r10, r24
    14dc:	b9 1e       	adc	r11, r25
			uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    14de:	f5 01       	movw	r30, r10
    14e0:	86 85       	ldd	r24, Z+14	; 0x0e
    14e2:	97 85       	ldd	r25, Z+15	; 0x0f
    14e4:	a0 89       	ldd	r26, Z+16	; 0x10
    14e6:	b1 89       	ldd	r27, Z+17	; 0x11
    14e8:	80 93 8f 07 	sts	0x078F, r24
    14ec:	90 93 90 07 	sts	0x0790, r25
    14f0:	a0 93 91 07 	sts	0x0791, r26
    14f4:	b0 93 92 07 	sts	0x0792, r27

			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_DISCOVER, AppState);
    14f8:	c8 01       	movw	r24, r16
    14fa:	61 e0       	ldi	r22, 0x01	; 1
    14fc:	63 df       	rcall	.-314    	; 0x13c4 <DHCPClientApp_FillDHCPHeader>
    14fe:	7c 01       	movw	r14, r24

			/* Add the required DHCP options list to the packet */
			uint8_t RequiredOptionList[] = {DHCP_OPTION_SUBNET_MASK, DHCP_OPTION_ROUTER, DHCP_OPTION_DNS_SERVER};
    1500:	de 01       	movw	r26, r28
    1502:	13 96       	adiw	r26, 0x03	; 3
    1504:	e5 e3       	ldi	r30, 0x35	; 53
    1506:	f2 e0       	ldi	r31, 0x02	; 2
    1508:	83 e0       	ldi	r24, 0x03	; 3
    150a:	01 90       	ld	r0, Z+
    150c:	0d 92       	st	X+, r0
    150e:	81 50       	subi	r24, 0x01	; 1
    1510:	e1 f7       	brne	.-8      	; 0x150a <DHCPClientApp_Callback+0x96>
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_LIST, sizeof(RequiredOptionList),
    1512:	c8 01       	movw	r24, r16
    1514:	80 51       	subi	r24, 0x10	; 16
    1516:	9f 4f       	sbci	r25, 0xFF	; 255
    1518:	67 e3       	ldi	r22, 0x37	; 55
    151a:	43 e0       	ldi	r20, 0x03	; 3
    151c:	9e 01       	movw	r18, r28
    151e:	2d 5f       	subi	r18, 0xFD	; 253
    1520:	3f 4f       	sbci	r19, 0xFF	; 255
    1522:	27 df       	rcall	.-434    	; 0x1372 <DHCPCommon_SetOption>
			                                    RequiredOptionList);

			/* Send the DHCP DISCOVER packet */
			uip_udp_send(AppDataSize);
    1524:	e8 0e       	add	r14, r24
    1526:	f1 1c       	adc	r15, r1
    1528:	80 91 26 06 	lds	r24, 0x0626
    152c:	90 91 27 06 	lds	r25, 0x0627
    1530:	b7 01       	movw	r22, r14
    1532:	76 d6       	rcall	.+3308   	; 0x2220 <uip_send>

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    1534:	c5 01       	movw	r24, r10
    1536:	0a 96       	adiw	r24, 0x0a	; 10
    1538:	0e 94 23 1c 	call	0x3846	; 0x3846 <timer_reset>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForOffer;
    153c:	81 e0       	ldi	r24, 0x01	; 1
    153e:	6a c0       	rjmp	.+212    	; 0x1614 <DHCPClientApp_Callback+0x1a0>

			break;
		case DHCP_STATE_WaitForOffer:
			if (!(uip_newdata()))
    1540:	80 91 23 06 	lds	r24, 0x0623
    1544:	81 ff       	sbrs	r24, 1
    1546:	6c c0       	rjmp	.+216    	; 0x1620 <DHCPClientApp_Callback+0x1ac>

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1548:	f8 01       	movw	r30, r16
    154a:	84 81       	ldd	r24, Z+4	; 0x04
    154c:	95 81       	ldd	r25, Z+5	; 0x05
    154e:	a6 81       	ldd	r26, Z+6	; 0x06
    1550:	b7 81       	ldd	r27, Z+7	; 0x07
    1552:	86 56       	subi	r24, 0x66	; 102
    1554:	94 45       	sbci	r25, 0x54	; 84
    1556:	a4 42       	sbci	r26, 0x24	; 36
    1558:	b3 41       	sbci	r27, 0x13	; 19
    155a:	09 f0       	breq	.+2      	; 0x155e <DHCPClientApp_Callback+0xea>
    155c:	a9 c0       	rjmp	.+338    	; 0x16b0 <DHCPClientApp_Callback+0x23c>
    155e:	80 ef       	ldi	r24, 0xF0	; 240
    1560:	e8 2e       	mov	r14, r24
    1562:	f1 2c       	mov	r15, r1
    1564:	e0 0e       	add	r14, r16
    1566:	f1 1e       	adc	r15, r17
    1568:	c7 01       	movw	r24, r14
    156a:	65 e3       	ldi	r22, 0x35	; 53
    156c:	ae 01       	movw	r20, r28
    156e:	4f 5f       	subi	r20, 0xFF	; 255
    1570:	5f 4f       	sbci	r21, 0xFF	; 255
    1572:	e7 de       	rcall	.-562    	; 0x1342 <DHCPCommon_GetOption>
    1574:	88 23       	and	r24, r24
    1576:	09 f4       	brne	.+2      	; 0x157a <DHCPClientApp_Callback+0x106>
    1578:	9b c0       	rjmp	.+310    	; 0x16b0 <DHCPClientApp_Callback+0x23c>
    157a:	c9 80       	ldd	r12, Y+1	; 0x01
    157c:	22 e0       	ldi	r18, 0x02	; 2
    157e:	c2 16       	cp	r12, r18
    1580:	09 f0       	breq	.+2      	; 0x1584 <DHCPClientApp_Callback+0x110>
    1582:	96 c0       	rjmp	.+300    	; 0x16b0 <DHCPClientApp_Callback+0x23c>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
			    (OfferResponse_MessageType == DHCP_OFFER))
			{
				/* Received a DHCP offer for an IP address, copy over values for later request */
				memcpy(&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, &AppData->YourIP, sizeof(uip_ipaddr_t));
    1584:	f8 01       	movw	r30, r16
    1586:	80 89       	ldd	r24, Z+16	; 0x10
    1588:	91 89       	ldd	r25, Z+17	; 0x11
    158a:	a2 89       	ldd	r26, Z+18	; 0x12
    158c:	b3 89       	ldd	r27, Z+19	; 0x13
    158e:	f5 01       	movw	r30, r10
    1590:	86 87       	std	Z+14, r24	; 0x0e
    1592:	97 87       	std	Z+15, r25	; 0x0f
    1594:	a0 8b       	std	Z+16, r26	; 0x10
    1596:	b1 8b       	std	Z+17, r27	; 0x11
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK, &AppState->DHCPClient.DHCPOffer_Data.Netmask);
    1598:	a5 01       	movw	r20, r10
    159a:	4e 5e       	subi	r20, 0xEE	; 238
    159c:	5f 4f       	sbci	r21, 0xFF	; 255
    159e:	c7 01       	movw	r24, r14
    15a0:	61 e0       	ldi	r22, 0x01	; 1
    15a2:	cf de       	rcall	.-610    	; 0x1342 <DHCPCommon_GetOption>
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_ROUTER,      &AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    15a4:	a5 01       	movw	r20, r10
    15a6:	4a 5e       	subi	r20, 0xEA	; 234
    15a8:	5f 4f       	sbci	r21, 0xFF	; 255
    15aa:	c7 01       	movw	r24, r14
    15ac:	63 e0       	ldi	r22, 0x03	; 3
    15ae:	c9 de       	rcall	.-622    	; 0x1342 <DHCPCommon_GetOption>
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SERVER_ID,   &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    15b0:	a5 01       	movw	r20, r10
    15b2:	46 5e       	subi	r20, 0xE6	; 230
    15b4:	5f 4f       	sbci	r21, 0xFF	; 255
    15b6:	c7 01       	movw	r24, r14
    15b8:	66 e3       	ldi	r22, 0x36	; 54
    15ba:	c3 de       	rcall	.-634    	; 0x1342 <DHCPCommon_GetOption>

				timer_reset(&AppState->DHCPClient.Timeout);
    15bc:	c5 01       	movw	r24, r10
    15be:	0a 96       	adiw	r24, 0x0a	; 10
    15c0:	0e 94 23 1c 	call	0x3846	; 0x3846 <timer_reset>
				AppState->DHCPClient.CurrentState = DHCP_STATE_SendRequest;
    15c4:	f5 01       	movw	r30, r10
    15c6:	c1 86       	std	Z+9, r12	; 0x09
    15c8:	73 c0       	rjmp	.+230    	; 0x16b0 <DHCPClientApp_Callback+0x23c>
			}

			break;
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);
    15ca:	c8 01       	movw	r24, r16
    15cc:	63 e0       	ldi	r22, 0x03	; 3
    15ce:	fa de       	rcall	.-524    	; 0x13c4 <DHCPClientApp_FillDHCPHeader>
    15d0:	6c 01       	movw	r12, r24

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    15d2:	00 51       	subi	r16, 0x10	; 16
    15d4:	1f 4f       	sbci	r17, 0xFF	; 255
    15d6:	95 01       	movw	r18, r10
    15d8:	22 5f       	subi	r18, 0xF2	; 242
    15da:	3f 4f       	sbci	r19, 0xFF	; 255
    15dc:	c8 01       	movw	r24, r16
    15de:	62 e3       	ldi	r22, 0x32	; 50
    15e0:	44 e0       	ldi	r20, 0x04	; 4
    15e2:	c7 de       	rcall	.-626    	; 0x1372 <DHCPCommon_SetOption>
    15e4:	f8 2e       	mov	r15, r24
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    15e6:	95 01       	movw	r18, r10
    15e8:	26 5e       	subi	r18, 0xE6	; 230
    15ea:	3f 4f       	sbci	r19, 0xFF	; 255
    15ec:	c8 01       	movw	r24, r16
    15ee:	66 e3       	ldi	r22, 0x36	; 54
    15f0:	44 e0       	ldi	r20, 0x04	; 4
    15f2:	bf de       	rcall	.-642    	; 0x1372 <DHCPCommon_SetOption>
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    15f4:	68 2f       	mov	r22, r24
    15f6:	70 e0       	ldi	r23, 0x00	; 0
    15f8:	6f 0d       	add	r22, r15
    15fa:	71 1d       	adc	r23, r1
			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);

			/* Send the DHCP REQUEST packet */
			uip_udp_send(AppDataSize);
    15fc:	6c 0d       	add	r22, r12
    15fe:	7d 1d       	adc	r23, r13
    1600:	80 91 26 06 	lds	r24, 0x0626
    1604:	90 91 27 06 	lds	r25, 0x0627
    1608:	0b d6       	rcall	.+3094   	; 0x2220 <uip_send>

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    160a:	c5 01       	movw	r24, r10
    160c:	0a 96       	adiw	r24, 0x0a	; 10
    160e:	0e 94 23 1c 	call	0x3846	; 0x3846 <timer_reset>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForACK;
    1612:	83 e0       	ldi	r24, 0x03	; 3
    1614:	f5 01       	movw	r30, r10
    1616:	4b c0       	rjmp	.+150    	; 0x16ae <DHCPClientApp_Callback+0x23a>

			break;
		case DHCP_STATE_WaitForACK:
			if (!(uip_newdata()))
    1618:	80 91 23 06 	lds	r24, 0x0623
    161c:	81 fd       	sbrc	r24, 1
    161e:	0a c0       	rjmp	.+20     	; 0x1634 <DHCPClientApp_Callback+0x1c0>
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    1620:	c5 01       	movw	r24, r10
    1622:	0a 96       	adiw	r24, 0x0a	; 10
    1624:	0e 94 2d 1c 	call	0x385a	; 0x385a <timer_expired>
    1628:	89 2b       	or	r24, r25
    162a:	09 f4       	brne	.+2      	; 0x162e <DHCPClientApp_Callback+0x1ba>
    162c:	41 c0       	rjmp	.+130    	; 0x16b0 <DHCPClientApp_Callback+0x23c>
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    162e:	f5 01       	movw	r30, r10
    1630:	11 86       	std	Z+9, r1	; 0x09
    1632:	3e c0       	rjmp	.+124    	; 0x16b0 <DHCPClientApp_Callback+0x23c>

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1634:	f8 01       	movw	r30, r16
    1636:	84 81       	ldd	r24, Z+4	; 0x04
    1638:	95 81       	ldd	r25, Z+5	; 0x05
    163a:	a6 81       	ldd	r26, Z+6	; 0x06
    163c:	b7 81       	ldd	r27, Z+7	; 0x07
    163e:	86 56       	subi	r24, 0x66	; 102
    1640:	94 45       	sbci	r25, 0x54	; 84
    1642:	a4 42       	sbci	r26, 0x24	; 36
    1644:	b3 41       	sbci	r27, 0x13	; 19
    1646:	a1 f5       	brne	.+104    	; 0x16b0 <DHCPClientApp_Callback+0x23c>
    1648:	c8 01       	movw	r24, r16
    164a:	80 51       	subi	r24, 0x10	; 16
    164c:	9f 4f       	sbci	r25, 0xFF	; 255
    164e:	65 e3       	ldi	r22, 0x35	; 53
    1650:	ae 01       	movw	r20, r28
    1652:	4e 5f       	subi	r20, 0xFE	; 254
    1654:	5f 4f       	sbci	r21, 0xFF	; 255
    1656:	75 de       	rcall	.-790    	; 0x1342 <DHCPCommon_GetOption>
    1658:	88 23       	and	r24, r24
    165a:	51 f1       	breq	.+84     	; 0x16b0 <DHCPClientApp_Callback+0x23c>
    165c:	8a 81       	ldd	r24, Y+2	; 0x02
    165e:	85 30       	cpi	r24, 0x05	; 5
    1660:	39 f5       	brne	.+78     	; 0x16b0 <DHCPClientApp_Callback+0x23c>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
			    (RequestResponse_MessageType == DHCP_ACK))
			{
				/* Set the new network parameters from the DHCP server */
				uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    1662:	f5 01       	movw	r30, r10
    1664:	86 85       	ldd	r24, Z+14	; 0x0e
    1666:	97 85       	ldd	r25, Z+15	; 0x0f
    1668:	a0 89       	ldd	r26, Z+16	; 0x10
    166a:	b1 89       	ldd	r27, Z+17	; 0x11
    166c:	80 93 8f 07 	sts	0x078F, r24
    1670:	90 93 90 07 	sts	0x0790, r25
    1674:	a0 93 91 07 	sts	0x0791, r26
    1678:	b0 93 92 07 	sts	0x0792, r27
				uip_setnetmask((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.Netmask);
    167c:	82 89       	ldd	r24, Z+18	; 0x12
    167e:	93 89       	ldd	r25, Z+19	; 0x13
    1680:	a4 89       	ldd	r26, Z+20	; 0x14
    1682:	b5 89       	ldd	r27, Z+21	; 0x15
    1684:	80 93 8b 07 	sts	0x078B, r24
    1688:	90 93 8c 07 	sts	0x078C, r25
    168c:	a0 93 8d 07 	sts	0x078D, r26
    1690:	b0 93 8e 07 	sts	0x078E, r27
				uip_setdraddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    1694:	86 89       	ldd	r24, Z+22	; 0x16
    1696:	97 89       	ldd	r25, Z+23	; 0x17
    1698:	a0 8d       	ldd	r26, Z+24	; 0x18
    169a:	b1 8d       	ldd	r27, Z+25	; 0x19
    169c:	80 93 87 07 	sts	0x0787, r24
    16a0:	90 93 88 07 	sts	0x0788, r25
    16a4:	a0 93 89 07 	sts	0x0789, r26
    16a8:	b0 93 8a 07 	sts	0x078A, r27

				AppState->DHCPClient.CurrentState = DHCP_STATE_AddressLeased;
    16ac:	84 e0       	ldi	r24, 0x04	; 4
    16ae:	81 87       	std	Z+9, r24	; 0x09
			}

			break;
	}
}
    16b0:	0f 90       	pop	r0
    16b2:	0f 90       	pop	r0
    16b4:	0f 90       	pop	r0
    16b6:	0f 90       	pop	r0
    16b8:	0f 90       	pop	r0
    16ba:	cf 91       	pop	r28
    16bc:	df 91       	pop	r29
    16be:	1f 91       	pop	r17
    16c0:	0f 91       	pop	r16
    16c2:	ff 90       	pop	r15
    16c4:	ef 90       	pop	r14
    16c6:	df 90       	pop	r13
    16c8:	cf 90       	pop	r12
    16ca:	bf 90       	pop	r11
    16cc:	af 90       	pop	r10
    16ce:	08 95       	ret

000016d0 <DHCPClientApp_Init>:

/** Initialization function for the DHCP client. */
void DHCPClientApp_Init(void)
{
	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* Connection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_SERVER_PORT));
    16d0:	85 e1       	ldi	r24, 0x15	; 21
    16d2:	93 e0       	ldi	r25, 0x03	; 3
    16d4:	60 e0       	ldi	r22, 0x00	; 0
    16d6:	73 e4       	ldi	r23, 0x43	; 67
    16d8:	0e 94 06 19 	call	0x320c	; 0x320c <uip_udp_new>
    16dc:	fc 01       	movw	r30, r24

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (Connection != NULL)
    16de:	00 97       	sbiw	r24, 0x00	; 0
    16e0:	59 f0       	breq	.+22     	; 0x16f8 <DHCPClientApp_Init+0x28>
	{
		uip_udp_appstate_t* const AppState = &Connection->appstate;
		uip_udp_bind(Connection, HTONS(DHCP_CLIENT_PORT));
    16e2:	80 e0       	ldi	r24, 0x00	; 0
    16e4:	94 e4       	ldi	r25, 0x44	; 68
    16e6:	95 83       	std	Z+5, r25	; 0x05
    16e8:	84 83       	std	Z+4, r24	; 0x04

		/* Set the initial client state */
		AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    16ea:	11 86       	std	Z+9, r1	; 0x09

		/* Set timeout period to half a second for a DHCP server to respond */
		timer_set(&AppState->DHCPClient.Timeout, CLOCK_SECOND / 2);
    16ec:	cf 01       	movw	r24, r30
    16ee:	0a 96       	adiw	r24, 0x0a	; 10
    16f0:	62 e3       	ldi	r22, 0x32	; 50
    16f2:	70 e0       	ldi	r23, 0x00	; 0
    16f4:	0c 94 43 1c 	jmp	0x3886	; 0x3886 <timer_set>
    16f8:	08 95       	ret

000016fa <DHCPServerApp_CheckIfIPLeased>:
 *
 *  \return Boolean true if the IP has already been leased to a client, false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    16fa:	dc 01       	movw	r26, r24
    16fc:	13 96       	adiw	r26, 0x03	; 3
    16fe:	ec 91       	ld	r30, X
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
	
	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
    1700:	ee 23       	and	r30, r30
    1702:	b1 f0       	breq	.+44     	; 0x1730 <DHCPServerApp_CheckIfIPLeased+0x36>
    1704:	80 91 92 07 	lds	r24, 0x0792
    1708:	e8 17       	cp	r30, r24
    170a:	91 f0       	breq	.+36     	; 0x1730 <DHCPServerApp_CheckIfIPLeased+0x36>
    170c:	2e 2f       	mov	r18, r30
    170e:	27 70       	andi	r18, 0x07	; 7
    1710:	81 e0       	ldi	r24, 0x01	; 1
    1712:	90 e0       	ldi	r25, 0x00	; 0
    1714:	02 c0       	rjmp	.+4      	; 0x171a <DHCPServerApp_CheckIfIPLeased+0x20>
    1716:	88 0f       	add	r24, r24
    1718:	99 1f       	adc	r25, r25
    171a:	2a 95       	dec	r18
    171c:	e2 f7       	brpl	.-8      	; 0x1716 <DHCPServerApp_CheckIfIPLeased+0x1c>
    171e:	e6 95       	lsr	r30
    1720:	e6 95       	lsr	r30
    1722:	e6 95       	lsr	r30
    1724:	f0 e0       	ldi	r31, 0x00	; 0
    1726:	e8 52       	subi	r30, 0x28	; 40
    1728:	fc 4f       	sbci	r31, 0xFC	; 252
    172a:	20 81       	ld	r18, Z
    172c:	28 23       	and	r18, r24
    172e:	09 f0       	breq	.+2      	; 0x1732 <DHCPServerApp_CheckIfIPLeased+0x38>
    1730:	21 e0       	ldi	r18, 0x01	; 1
	  return false;
	else
	  return true;
}
    1732:	82 2f       	mov	r24, r18
    1734:	08 95       	ret

00001736 <DHCPServerApp_FillDHCPHeader>:
static uint16_t DHCPServerApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             const struct uip_eth_addr* const ClientHardwareAddress,
											 const uip_ipaddr_t* const PreferredClientIP,
                                             const uint32_t TransactionID)
{
    1736:	ef 92       	push	r14
    1738:	ff 92       	push	r15
    173a:	0f 93       	push	r16
    173c:	1f 93       	push	r17
    173e:	cf 93       	push	r28
    1740:	df 93       	push	r29
    1742:	ec 01       	movw	r28, r24
    1744:	f9 01       	movw	r30, r18
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    1746:	80 ef       	ldi	r24, 0xF0	; 240
    1748:	de 01       	movw	r26, r28
    174a:	1d 92       	st	X+, r1
    174c:	8a 95       	dec	r24
    174e:	e9 f7       	brne	.-6      	; 0x174a <DHCPServerApp_FillDHCPHeader+0x14>

	DHCPHeader->Operation             = DHCPMessageType;
    1750:	68 83       	st	Y, r22
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    1756:	86 e0       	ldi	r24, 0x06	; 6
    1758:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeader->Hops                  = 0;
    175a:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeader->TransactionID         = TransactionID;
    175c:	ec 82       	std	Y+4, r14	; 0x04
    175e:	fd 82       	std	Y+5, r15	; 0x05
    1760:	0e 83       	std	Y+6, r16	; 0x06
    1762:	1f 83       	std	Y+7, r17	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    1764:	19 86       	std	Y+9, r1	; 0x09
    1766:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeader->Flags                 = 0;
    1768:	1b 86       	std	Y+11, r1	; 0x0b
    176a:	1a 86       	std	Y+10, r1	; 0x0a
	memcpy(&DHCPHeader->NextServerIP, &uip_hostaddr, sizeof(uip_ipaddr_t));
    176c:	80 91 8f 07 	lds	r24, 0x078F
    1770:	90 91 90 07 	lds	r25, 0x0790
    1774:	a0 91 91 07 	lds	r26, 0x0791
    1778:	b0 91 92 07 	lds	r27, 0x0792
    177c:	8c 8b       	std	Y+20, r24	; 0x14
    177e:	9d 8b       	std	Y+21, r25	; 0x15
    1780:	ae 8b       	std	Y+22, r26	; 0x16
    1782:	bf 8b       	std	Y+23, r27	; 0x17
	memcpy(&DHCPHeader->YourIP, PreferredClientIP, sizeof(uip_ipaddr_t));
    1784:	80 81       	ld	r24, Z
    1786:	91 81       	ldd	r25, Z+1	; 0x01
    1788:	a2 81       	ldd	r26, Z+2	; 0x02
    178a:	b3 81       	ldd	r27, Z+3	; 0x03
    178c:	88 8b       	std	Y+16, r24	; 0x10
    178e:	99 8b       	std	Y+17, r25	; 0x11
    1790:	aa 8b       	std	Y+18, r26	; 0x12
    1792:	bb 8b       	std	Y+19, r27	; 0x13
	memcpy(&DHCPHeader->ClientHardwareAddress, ClientHardwareAddress, sizeof(struct uip_eth_addr));
    1794:	de 01       	movw	r26, r28
    1796:	5c 96       	adiw	r26, 0x1c	; 28
    1798:	fa 01       	movw	r30, r20
    179a:	86 e0       	ldi	r24, 0x06	; 6
    179c:	01 90       	ld	r0, Z+
    179e:	0d 92       	st	X+, r0
    17a0:	81 50       	subi	r24, 0x01	; 1
    17a2:	e1 f7       	brne	.-8      	; 0x179c <DHCPServerApp_FillDHCPHeader+0x66>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    17a4:	c4 51       	subi	r28, 0x14	; 20
    17a6:	df 4f       	sbci	r29, 0xFF	; 255
    17a8:	83 e6       	ldi	r24, 0x63	; 99
    17aa:	92 e8       	ldi	r25, 0x82	; 130
    17ac:	a3 e5       	ldi	r26, 0x53	; 83
    17ae:	b3 e6       	ldi	r27, 0x63	; 99
    17b0:	89 93       	st	Y+, r24
    17b2:	99 93       	st	Y+, r25
    17b4:	a9 93       	st	Y+, r26
    17b6:	b9 93       	st	Y+, r27
	  
	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    17b8:	85 e3       	ldi	r24, 0x35	; 53
    17ba:	89 93       	st	Y+, r24
	DHCPHeader->Options[1]            = 1;
    17bc:	81 e0       	ldi	r24, 0x01	; 1
    17be:	89 93       	st	Y+, r24
	DHCPHeader->Options[2]            = DHCPMessageType;
    17c0:	69 93       	st	Y+, r22
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    17c2:	8f ef       	ldi	r24, 0xFF	; 255
    17c4:	88 83       	st	Y, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    17c6:	84 ef       	ldi	r24, 0xF4	; 244
    17c8:	90 e0       	ldi	r25, 0x00	; 0
    17ca:	df 91       	pop	r29
    17cc:	cf 91       	pop	r28
    17ce:	1f 91       	pop	r17
    17d0:	0f 91       	pop	r16
    17d2:	ff 90       	pop	r15
    17d4:	ef 90       	pop	r14
    17d6:	08 95       	ret

000017d8 <DHCPServerApp_Callback>:

/** uIP stack application callback for the DHCP server. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPServerApp_Callback(void)
{
    17d8:	6f 92       	push	r6
    17da:	7f 92       	push	r7
    17dc:	8f 92       	push	r8
    17de:	9f 92       	push	r9
    17e0:	af 92       	push	r10
    17e2:	bf 92       	push	r11
    17e4:	cf 92       	push	r12
    17e6:	df 92       	push	r13
    17e8:	ef 92       	push	r14
    17ea:	ff 92       	push	r15
    17ec:	0f 93       	push	r16
    17ee:	1f 93       	push	r17
    17f0:	df 93       	push	r29
    17f2:	cf 93       	push	r28
    17f4:	cd b7       	in	r28, 0x3d	; 61
    17f6:	de b7       	in	r29, 0x3e	; 62
    17f8:	63 97       	sbiw	r28, 0x13	; 19
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	de bf       	out	0x3e, r29	; 62
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	cd bf       	out	0x3d, r28	; 61
	DHCP_Header_t* const AppData     = (DHCP_Header_t*)uip_appdata;
    1804:	a0 90 26 06 	lds	r10, 0x0626
    1808:	b0 90 27 06 	lds	r11, 0x0627
	uint16_t             AppDataSize = 0;

	/* Only process when new data arrives - don't retransmit lost packets */
	if (uip_newdata())
    180c:	80 91 23 06 	lds	r24, 0x0623
    1810:	81 ff       	sbrs	r24, 1
    1812:	2c c1       	rjmp	.+600    	; 0x1a6c <DHCPServerApp_Callback+0x294>
	{
		/* Get the DHCP message type (if present), otherwise early-abort */
		uint8_t DHCPMessageType;
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &DHCPMessageType)))
    1814:	90 ef       	ldi	r25, 0xF0	; 240
    1816:	69 2e       	mov	r6, r25
    1818:	71 2c       	mov	r7, r1
    181a:	6a 0c       	add	r6, r10
    181c:	7b 1c       	adc	r7, r11
    181e:	c3 01       	movw	r24, r6
    1820:	65 e3       	ldi	r22, 0x35	; 53
    1822:	ae 01       	movw	r20, r28
    1824:	4f 5f       	subi	r20, 0xFF	; 255
    1826:	5f 4f       	sbci	r21, 0xFF	; 255
    1828:	8c dd       	rcall	.-1256   	; 0x1342 <DHCPCommon_GetOption>
    182a:	88 23       	and	r24, r24
    182c:	09 f4       	brne	.+2      	; 0x1830 <DHCPServerApp_Callback+0x58>
    182e:	1e c1       	rjmp	.+572    	; 0x1a6c <DHCPServerApp_Callback+0x294>
		uip_ipaddr_t        Netmask, GatewayIPAddress, PreferredClientIP;
		struct uip_eth_addr RemoteMACAddress;
		uint32_t            TransactionID;

		/* Get configured network mask, gateway IP and extract out DHCP transaction ID and remote IP */
		uip_getnetmask(&Netmask);
    1830:	80 91 8b 07 	lds	r24, 0x078B
    1834:	90 91 8c 07 	lds	r25, 0x078C
    1838:	a0 91 8d 07 	lds	r26, 0x078D
    183c:	b0 91 8e 07 	lds	r27, 0x078E
    1840:	8a 83       	std	Y+2, r24	; 0x02
    1842:	9b 83       	std	Y+3, r25	; 0x03
    1844:	ac 83       	std	Y+4, r26	; 0x04
    1846:	bd 83       	std	Y+5, r27	; 0x05
		uip_getdraddr(&GatewayIPAddress);
    1848:	80 91 87 07 	lds	r24, 0x0787
    184c:	90 91 88 07 	lds	r25, 0x0788
    1850:	a0 91 89 07 	lds	r26, 0x0789
    1854:	b0 91 8a 07 	lds	r27, 0x078A
    1858:	8e 83       	std	Y+6, r24	; 0x06
    185a:	9f 83       	std	Y+7, r25	; 0x07
    185c:	a8 87       	std	Y+8, r26	; 0x08
    185e:	b9 87       	std	Y+9, r27	; 0x09
		memcpy(&RemoteMACAddress, &AppData->ClientHardwareAddress, sizeof(struct uip_eth_addr));
    1860:	de 01       	movw	r26, r28
    1862:	1e 96       	adiw	r26, 0x0e	; 14
    1864:	f5 01       	movw	r30, r10
    1866:	7c 96       	adiw	r30, 0x1c	; 28
    1868:	86 e0       	ldi	r24, 0x06	; 6
    186a:	01 90       	ld	r0, Z+
    186c:	0d 92       	st	X+, r0
    186e:	81 50       	subi	r24, 0x01	; 1
    1870:	e1 f7       	brne	.-8      	; 0x186a <DHCPServerApp_Callback+0x92>
		TransactionID = AppData->TransactionID;
    1872:	f5 01       	movw	r30, r10
    1874:	c4 80       	ldd	r12, Z+4	; 0x04
    1876:	d5 80       	ldd	r13, Z+5	; 0x05
    1878:	e6 80       	ldd	r14, Z+6	; 0x06
    187a:	f7 80       	ldd	r15, Z+7	; 0x07

		/* Try to extract out the client's preferred IP address if it is indicated in the packet */
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, &PreferredClientIP)))
    187c:	c3 01       	movw	r24, r6
    187e:	62 e3       	ldi	r22, 0x32	; 50
    1880:	ae 01       	movw	r20, r28
    1882:	46 5f       	subi	r20, 0xF6	; 246
    1884:	5f 4f       	sbci	r21, 0xFF	; 255
    1886:	5d dd       	rcall	.-1350   	; 0x1342 <DHCPCommon_GetOption>
    1888:	88 23       	and	r24, r24
    188a:	61 f4       	brne	.+24     	; 0x18a4 <DHCPServerApp_Callback+0xcc>
		  memcpy(&PreferredClientIP, &uip_all_zeroes_addr, sizeof(uip_ipaddr_t));	
    188c:	80 91 19 03 	lds	r24, 0x0319
    1890:	90 91 1a 03 	lds	r25, 0x031A
    1894:	a0 91 1b 03 	lds	r26, 0x031B
    1898:	b0 91 1c 03 	lds	r27, 0x031C
    189c:	8a 87       	std	Y+10, r24	; 0x0a
    189e:	9b 87       	std	Y+11, r25	; 0x0b
    18a0:	ac 87       	std	Y+12, r26	; 0x0c
    18a2:	bd 87       	std	Y+13, r27	; 0x0d
		
		switch (DHCPMessageType)
    18a4:	89 81       	ldd	r24, Y+1	; 0x01
    18a6:	83 30       	cpi	r24, 0x03	; 3
    18a8:	09 f4       	brne	.+2      	; 0x18ac <DHCPServerApp_Callback+0xd4>
    18aa:	65 c0       	rjmp	.+202    	; 0x1976 <DHCPServerApp_Callback+0x19e>
    18ac:	87 30       	cpi	r24, 0x07	; 7
    18ae:	09 f4       	brne	.+2      	; 0x18b2 <DHCPServerApp_Callback+0xda>
    18b0:	c5 c0       	rjmp	.+394    	; 0x1a3c <DHCPServerApp_Callback+0x264>
    18b2:	81 30       	cpi	r24, 0x01	; 1
    18b4:	09 f0       	breq	.+2      	; 0x18b8 <DHCPServerApp_Callback+0xe0>
    18b6:	da c0       	rjmp	.+436    	; 0x1a6c <DHCPServerApp_Callback+0x294>
		{
			case DHCP_DISCOVER:
				/* If no preference was made or the preferred IP is already taken, find a new address */
				if (DHCPServerApp_CheckIfIPLeased(&PreferredClientIP))
    18b8:	8a e0       	ldi	r24, 0x0A	; 10
    18ba:	88 2e       	mov	r8, r24
    18bc:	91 2c       	mov	r9, r1
    18be:	8c 0e       	add	r8, r28
    18c0:	9d 1e       	adc	r9, r29
    18c2:	c4 01       	movw	r24, r8
    18c4:	1a df       	rcall	.-460    	; 0x16fa <DHCPServerApp_CheckIfIPLeased>
    18c6:	88 23       	and	r24, r24
    18c8:	a9 f0       	breq	.+42     	; 0x18f4 <DHCPServerApp_Callback+0x11c>
 *
 *  \param[out] NewIPAddress  Location where the generated IP Address should be stored
 */
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);
    18ca:	80 91 8f 07 	lds	r24, 0x078F
    18ce:	90 91 90 07 	lds	r25, 0x0790
    18d2:	a0 91 91 07 	lds	r26, 0x0791
    18d6:	b0 91 92 07 	lds	r27, 0x0792
    18da:	8a 87       	std	Y+10, r24	; 0x0a
    18dc:	9b 87       	std	Y+11, r25	; 0x0b
    18de:	ac 87       	std	Y+12, r26	; 0x0c
    18e0:	bd 87       	std	Y+13, r27	; 0x0d
    18e2:	11 e0       	ldi	r17, 0x01	; 1
	
	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
	{
		/* Update new IP address to lease with the current IP address to test */
		NewIPAddress->u8[3] = IP;
    18e4:	1d 87       	std	Y+13, r17	; 0x0d
		
		/* If we've found an unleased IP, abort with the updated IP stored for the called */
		if (!(DHCPServerApp_CheckIfIPLeased(NewIPAddress)))
    18e6:	c4 01       	movw	r24, r8
    18e8:	08 df       	rcall	.-496    	; 0x16fa <DHCPServerApp_CheckIfIPLeased>
    18ea:	88 23       	and	r24, r24
    18ec:	19 f0       	breq	.+6      	; 0x18f4 <DHCPServerApp_Callback+0x11c>
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);
	
	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    18ee:	1f 5f       	subi	r17, 0xFF	; 255
    18f0:	1e 3f       	cpi	r17, 0xFE	; 254
    18f2:	c1 f7       	brne	.-16     	; 0x18e4 <DHCPServerApp_Callback+0x10c>
				/* If no preference was made or the preferred IP is already taken, find a new address */
				if (DHCPServerApp_CheckIfIPLeased(&PreferredClientIP))
				  DHCPServerApp_GetUnleasedIP(&PreferredClientIP);

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    18f4:	c5 01       	movw	r24, r10
    18f6:	62 e0       	ldi	r22, 0x02	; 2
    18f8:	ae 01       	movw	r20, r28
    18fa:	42 5f       	subi	r20, 0xF2	; 242
    18fc:	5f 4f       	sbci	r21, 0xFF	; 255
    18fe:	9e 01       	movw	r18, r28
    1900:	26 5f       	subi	r18, 0xF6	; 246
    1902:	3f 4f       	sbci	r19, 0xFF	; 255
    1904:	87 01       	movw	r16, r14
    1906:	76 01       	movw	r14, r12
    1908:	16 df       	rcall	.-468    	; 0x1736 <DHCPServerApp_FillDHCPHeader>
    190a:	6c 01       	movw	r12, r24

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    190c:	c3 01       	movw	r24, r6
    190e:	61 e0       	ldi	r22, 0x01	; 1
    1910:	44 e0       	ldi	r20, 0x04	; 4
    1912:	9e 01       	movw	r18, r28
    1914:	2e 5f       	subi	r18, 0xFE	; 254
    1916:	3f 4f       	sbci	r19, 0xFF	; 255
    1918:	2c dd       	rcall	.-1448   	; 0x1372 <DHCPCommon_SetOption>
    191a:	f8 2e       	mov	r15, r24
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    191c:	c3 01       	movw	r24, r6
    191e:	63 e0       	ldi	r22, 0x03	; 3
    1920:	44 e0       	ldi	r20, 0x04	; 4
    1922:	9e 01       	movw	r18, r28
    1924:	2a 5f       	subi	r18, 0xFA	; 250
    1926:	3f 4f       	sbci	r19, 0xFF	; 255
    1928:	24 dd       	rcall	.-1464   	; 0x1372 <DHCPCommon_SetOption>

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    192a:	08 2f       	mov	r16, r24
    192c:	10 e0       	ldi	r17, 0x00	; 0
    192e:	0f 0d       	add	r16, r15
    1930:	11 1d       	adc	r17, r1
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
					                                sizeof(uip_ipaddr_t), &GatewayIPAddress);

				/* Send the DHCP OFFER packet */
				uip_poll_conn(BroadcastConnection);
    1932:	80 91 f7 03 	lds	r24, 0x03F7
    1936:	90 91 f8 03 	lds	r25, 0x03F8
    193a:	90 93 29 06 	sts	0x0629, r25
    193e:	80 93 28 06 	sts	0x0628, r24
    1942:	83 e0       	ldi	r24, 0x03	; 3
    1944:	88 d4       	rcall	.+2320   	; 0x2256 <uip_process>
				memcpy(&uip_udp_conn->ripaddr, &uip_broadcast_addr, sizeof(uip_ipaddr_t));
    1946:	e0 91 24 06 	lds	r30, 0x0624
    194a:	f0 91 25 06 	lds	r31, 0x0625
    194e:	80 91 15 03 	lds	r24, 0x0315
    1952:	90 91 16 03 	lds	r25, 0x0316
    1956:	a0 91 17 03 	lds	r26, 0x0317
    195a:	b0 91 18 03 	lds	r27, 0x0318
    195e:	80 83       	st	Z, r24
    1960:	91 83       	std	Z+1, r25	; 0x01
    1962:	a2 83       	std	Z+2, r26	; 0x02
    1964:	b3 83       	std	Z+3, r27	; 0x03
				uip_udp_send(AppDataSize);
    1966:	0c 0d       	add	r16, r12
    1968:	1d 1d       	adc	r17, r13
    196a:	80 91 26 06 	lds	r24, 0x0626
    196e:	90 91 27 06 	lds	r25, 0x0627
    1972:	b8 01       	movw	r22, r16
    1974:	61 c0       	rjmp	.+194    	; 0x1a38 <DHCPServerApp_Callback+0x260>

				break;
			case DHCP_REQUEST:
				/* Check to see if the requested IP address has already been leased to a client */
				if (!(DHCPServerApp_CheckIfIPLeased(&PreferredClientIP)))
    1976:	8e 01       	movw	r16, r28
    1978:	06 5f       	subi	r16, 0xF6	; 246
    197a:	1f 4f       	sbci	r17, 0xFF	; 255
    197c:	c8 01       	movw	r24, r16
    197e:	bd de       	rcall	.-646    	; 0x16fa <DHCPServerApp_CheckIfIPLeased>
    1980:	ae 01       	movw	r20, r28
    1982:	42 5f       	subi	r20, 0xF2	; 242
    1984:	5f 4f       	sbci	r21, 0xFF	; 255
    1986:	88 23       	and	r24, r24
    1988:	81 f5       	brne	.+96     	; 0x19ea <DHCPServerApp_Callback+0x212>
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */					
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    198a:	c5 01       	movw	r24, r10
    198c:	65 e0       	ldi	r22, 0x05	; 5
    198e:	98 01       	movw	r18, r16
    1990:	87 01       	movw	r16, r14
    1992:	76 01       	movw	r14, r12
    1994:	d0 de       	rcall	.-608    	; 0x1736 <DHCPServerApp_FillDHCPHeader>
    1996:	8c 01       	movw	r16, r24

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    1998:	c3 01       	movw	r24, r6
    199a:	61 e0       	ldi	r22, 0x01	; 1
    199c:	44 e0       	ldi	r20, 0x04	; 4
    199e:	9e 01       	movw	r18, r28
    19a0:	2e 5f       	subi	r18, 0xFE	; 254
    19a2:	3f 4f       	sbci	r19, 0xFF	; 255
    19a4:	e6 dc       	rcall	.-1588   	; 0x1372 <DHCPCommon_SetOption>
    19a6:	f8 2e       	mov	r15, r24
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    19a8:	c3 01       	movw	r24, r6
    19aa:	63 e0       	ldi	r22, 0x03	; 3
    19ac:	44 e0       	ldi	r20, 0x04	; 4
    19ae:	9e 01       	movw	r18, r28
    19b0:	2a 5f       	subi	r18, 0xFA	; 250
    19b2:	3f 4f       	sbci	r19, 0xFF	; 255
    19b4:	de dc       	rcall	.-1604   	; 0x1372 <DHCPCommon_SetOption>
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */					
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    19b6:	c8 2e       	mov	r12, r24
    19b8:	dd 24       	eor	r13, r13
    19ba:	cf 0c       	add	r12, r15
    19bc:	d1 1c       	adc	r13, r1
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    19be:	c0 0e       	add	r12, r16
    19c0:	d1 1e       	adc	r13, r17
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_LeaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    19c2:	2d 85       	ldd	r18, Y+13	; 0x0d
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
	
	/* Mark the IP address as leased in the allocation table */
	LeasedIPs[Byte] |= Mask;
    19c4:	e2 2f       	mov	r30, r18
    19c6:	e6 95       	lsr	r30
    19c8:	e6 95       	lsr	r30
    19ca:	e6 95       	lsr	r30
    19cc:	f0 e0       	ldi	r31, 0x00	; 0
    19ce:	e8 52       	subi	r30, 0x28	; 40
    19d0:	fc 4f       	sbci	r31, 0xFC	; 252
    19d2:	27 70       	andi	r18, 0x07	; 7
    19d4:	81 e0       	ldi	r24, 0x01	; 1
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	02 c0       	rjmp	.+4      	; 0x19de <DHCPServerApp_Callback+0x206>
    19da:	88 0f       	add	r24, r24
    19dc:	99 1f       	adc	r25, r25
    19de:	2a 95       	dec	r18
    19e0:	e2 f7       	brpl	.-8      	; 0x19da <DHCPServerApp_Callback+0x202>
    19e2:	20 81       	ld	r18, Z
    19e4:	28 2b       	or	r18, r24
    19e6:	20 83       	st	Z, r18
    19e8:	08 c0       	rjmp	.+16     	; 0x19fa <DHCPServerApp_Callback+0x222>
					DHCPServerApp_LeaseIP(&PreferredClientIP);
				}
				else
				{
					/* Create a new DHCP NAK packet to reject the requested allocation */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_NAK, &RemoteMACAddress, &uip_all_zeroes_addr, TransactionID);
    19ea:	c5 01       	movw	r24, r10
    19ec:	66 e0       	ldi	r22, 0x06	; 6
    19ee:	29 e1       	ldi	r18, 0x19	; 25
    19f0:	33 e0       	ldi	r19, 0x03	; 3
    19f2:	87 01       	movw	r16, r14
    19f4:	76 01       	movw	r14, r12
    19f6:	9f de       	rcall	.-706    	; 0x1736 <DHCPServerApp_FillDHCPHeader>
    19f8:	6c 01       	movw	r12, r24
				}
				
				/* Send the DHCP ACK or NAK packet */
				uip_poll_conn(BroadcastConnection);
    19fa:	80 91 f7 03 	lds	r24, 0x03F7
    19fe:	90 91 f8 03 	lds	r25, 0x03F8
    1a02:	90 93 29 06 	sts	0x0629, r25
    1a06:	80 93 28 06 	sts	0x0628, r24
    1a0a:	83 e0       	ldi	r24, 0x03	; 3
    1a0c:	24 d4       	rcall	.+2120   	; 0x2256 <uip_process>
				memcpy(&uip_udp_conn->ripaddr, &uip_broadcast_addr, sizeof(uip_ipaddr_t));
    1a0e:	e0 91 24 06 	lds	r30, 0x0624
    1a12:	f0 91 25 06 	lds	r31, 0x0625
    1a16:	80 91 15 03 	lds	r24, 0x0315
    1a1a:	90 91 16 03 	lds	r25, 0x0316
    1a1e:	a0 91 17 03 	lds	r26, 0x0317
    1a22:	b0 91 18 03 	lds	r27, 0x0318
    1a26:	80 83       	st	Z, r24
    1a28:	91 83       	std	Z+1, r25	; 0x01
    1a2a:	a2 83       	std	Z+2, r26	; 0x02
    1a2c:	b3 83       	std	Z+3, r27	; 0x03
				uip_udp_send(AppDataSize);
    1a2e:	80 91 26 06 	lds	r24, 0x0626
    1a32:	90 91 27 06 	lds	r25, 0x0627
    1a36:	b6 01       	movw	r22, r12
    1a38:	f3 d3       	rcall	.+2022   	; 0x2220 <uip_send>
    1a3a:	18 c0       	rjmp	.+48     	; 0x1a6c <DHCPServerApp_Callback+0x294>
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_UnleaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    1a3c:	e0 91 24 06 	lds	r30, 0x0624
    1a40:	f0 91 25 06 	lds	r31, 0x0625
    1a44:	23 81       	ldd	r18, Z+3	; 0x03
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
	
	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
    1a46:	e2 2f       	mov	r30, r18
    1a48:	e6 95       	lsr	r30
    1a4a:	e6 95       	lsr	r30
    1a4c:	e6 95       	lsr	r30
    1a4e:	f0 e0       	ldi	r31, 0x00	; 0
    1a50:	e8 52       	subi	r30, 0x28	; 40
    1a52:	fc 4f       	sbci	r31, 0xFC	; 252
    1a54:	27 70       	andi	r18, 0x07	; 7
    1a56:	81 e0       	ldi	r24, 0x01	; 1
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	02 c0       	rjmp	.+4      	; 0x1a60 <DHCPServerApp_Callback+0x288>
    1a5c:	88 0f       	add	r24, r24
    1a5e:	99 1f       	adc	r25, r25
    1a60:	2a 95       	dec	r18
    1a62:	e2 f7       	brpl	.-8      	; 0x1a5c <DHCPServerApp_Callback+0x284>
    1a64:	80 95       	com	r24
    1a66:	20 81       	ld	r18, Z
    1a68:	82 23       	and	r24, r18
    1a6a:	80 83       	st	Z, r24
				/* Mark the IP address as released in the allocation table */
				DHCPServerApp_UnleaseIP(&uip_udp_conn->ripaddr);
				break;
		}
	}
}
    1a6c:	63 96       	adiw	r28, 0x13	; 19
    1a6e:	0f b6       	in	r0, 0x3f	; 63
    1a70:	f8 94       	cli
    1a72:	de bf       	out	0x3e, r29	; 62
    1a74:	0f be       	out	0x3f, r0	; 63
    1a76:	cd bf       	out	0x3d, r28	; 61
    1a78:	cf 91       	pop	r28
    1a7a:	df 91       	pop	r29
    1a7c:	1f 91       	pop	r17
    1a7e:	0f 91       	pop	r16
    1a80:	ff 90       	pop	r15
    1a82:	ef 90       	pop	r14
    1a84:	df 90       	pop	r13
    1a86:	cf 90       	pop	r12
    1a88:	bf 90       	pop	r11
    1a8a:	af 90       	pop	r10
    1a8c:	9f 90       	pop	r9
    1a8e:	8f 90       	pop	r8
    1a90:	7f 90       	pop	r7
    1a92:	6f 90       	pop	r6
    1a94:	08 95       	ret

00001a96 <DHCPServerApp_Init>:
	
/** Initialization function for the DHCP server. */
void DHCPServerApp_Init(void)
{
	/* Listen on port 67 for DHCP server connections from hosts */
	uip_listen(HTONS(DHCP_SERVER_PORT));
    1a96:	80 e0       	ldi	r24, 0x00	; 0
    1a98:	93 e4       	ldi	r25, 0x43	; 67
    1a9a:	48 d3       	rcall	.+1680   	; 0x212c <uip_listen>
	
	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* BroadcastConnection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_CLIENT_PORT));
    1a9c:	85 e1       	ldi	r24, 0x15	; 21
    1a9e:	93 e0       	ldi	r25, 0x03	; 3
    1aa0:	60 e0       	ldi	r22, 0x00	; 0
    1aa2:	74 e4       	ldi	r23, 0x44	; 68
    1aa4:	0e 94 06 19 	call	0x320c	; 0x320c <uip_udp_new>
    1aa8:	fc 01       	movw	r30, r24

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (BroadcastConnection != NULL)
    1aaa:	00 97       	sbiw	r24, 0x00	; 0
    1aac:	21 f0       	breq	.+8      	; 0x1ab6 <DHCPServerApp_Init+0x20>
	  uip_udp_bind(BroadcastConnection, HTONS(DHCP_SERVER_PORT));
    1aae:	80 e0       	ldi	r24, 0x00	; 0
    1ab0:	93 e4       	ldi	r25, 0x43	; 67
    1ab2:	95 83       	std	Z+5, r25	; 0x05
    1ab4:	84 83       	std	Z+4, r24	; 0x04
	  
	/* Set all IP addresses as unleased */
	memset(LeasedIPs, 0x00, sizeof(LeasedIPs));
    1ab6:	8f e1       	ldi	r24, 0x1F	; 31
    1ab8:	e8 ed       	ldi	r30, 0xD8	; 216
    1aba:	f3 e0       	ldi	r31, 0x03	; 3
    1abc:	df 01       	movw	r26, r30
    1abe:	1d 92       	st	X+, r1
    1ac0:	8a 95       	dec	r24
    1ac2:	e9 f7       	brne	.-6      	; 0x1abe <DHCPServerApp_Init+0x28>
}
    1ac4:	08 95       	ret

00001ac6 <HTTPServerApp_Callback>:

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
{
    1ac6:	af 92       	push	r10
    1ac8:	bf 92       	push	r11
    1aca:	cf 92       	push	r12
    1acc:	df 92       	push	r13
    1ace:	ef 92       	push	r14
    1ad0:	ff 92       	push	r15
    1ad2:	0f 93       	push	r16
    1ad4:	1f 93       	push	r17
    1ad6:	cf 93       	push	r28
    1ad8:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState = &uip_conn->appstate;
    1ada:	c0 91 28 06 	lds	r28, 0x0628
    1ade:	d0 91 29 06 	lds	r29, 0x0629

	if (uip_aborted() || uip_timedout() || uip_closed())
    1ae2:	20 91 23 06 	lds	r18, 0x0623
    1ae6:	25 fd       	sbrc	r18, 5
    1ae8:	04 c0       	rjmp	.+8      	; 0x1af2 <HTTPServerApp_Callback+0x2c>
    1aea:	27 fd       	sbrc	r18, 7
    1aec:	02 c0       	rjmp	.+4      	; 0x1af2 <HTTPServerApp_Callback+0x2c>
    1aee:	24 ff       	sbrs	r18, 4
    1af0:	03 c0       	rjmp	.+6      	; 0x1af8 <HTTPServerApp_Callback+0x32>
	{
		/* Lock to the closed state so that no further processing will occur on the connection */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_Closing;
    1af2:	83 e0       	ldi	r24, 0x03	; 3
    1af4:	8c 8f       	std	Y+28, r24	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_Closing;
    1af6:	8d 8f       	std	Y+29, r24	; 0x1d
	}

	if (uip_connected())
    1af8:	80 91 23 06 	lds	r24, 0x0623
    1afc:	86 ff       	sbrs	r24, 6
    1afe:	0d c0       	rjmp	.+26     	; 0x1b1a <HTTPServerApp_Callback+0x54>
	{
		/* New connection - initialize connection state values */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_OpenRequestedFile;
    1b00:	1c 8e       	std	Y+28, r1	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_OpenRequestedFile;
    1b02:	1d 8e       	std	Y+29, r1	; 0x1d
		AppState->HTTPServer.FileOpen      = false;
    1b04:	c6 59       	subi	r28, 0x96	; 150
    1b06:	df 4f       	sbci	r29, 0xFF	; 255
    1b08:	19 92       	st	Y+, r1
		AppState->HTTPServer.ACKedFilePos  = 0;
    1b0a:	19 92       	st	Y+, r1
    1b0c:	19 92       	st	Y+, r1
    1b0e:	19 92       	st	Y+, r1
    1b10:	19 92       	st	Y+, r1
		AppState->HTTPServer.SentChunkSize = 0;
    1b12:	19 82       	std	Y+1, r1	; 0x01
    1b14:	18 82       	st	Y, r1
    1b16:	cf 56       	subi	r28, 0x6F	; 111
    1b18:	d0 40       	sbci	r29, 0x00	; 0
	}

	if (uip_acked())
    1b1a:	80 91 23 06 	lds	r24, 0x0623
    1b1e:	80 ff       	sbrs	r24, 0
    1b20:	19 c0       	rjmp	.+50     	; 0x1b54 <HTTPServerApp_Callback+0x8e>
	{
		/* Add the amount of ACKed file data to the total sent file bytes counter */
		AppState->HTTPServer.ACKedFilePos += AppState->HTTPServer.SentChunkSize;
    1b22:	fe 01       	movw	r30, r28
    1b24:	e5 59       	subi	r30, 0x95	; 149
    1b26:	ff 4f       	sbci	r31, 0xFF	; 255
    1b28:	c1 59       	subi	r28, 0x91	; 145
    1b2a:	df 4f       	sbci	r29, 0xFF	; 255
    1b2c:	88 81       	ld	r24, Y
    1b2e:	99 81       	ldd	r25, Y+1	; 0x01
    1b30:	cf 56       	subi	r28, 0x6F	; 111
    1b32:	d0 40       	sbci	r29, 0x00	; 0
    1b34:	a0 e0       	ldi	r26, 0x00	; 0
    1b36:	b0 e0       	ldi	r27, 0x00	; 0
    1b38:	20 81       	ld	r18, Z
    1b3a:	31 81       	ldd	r19, Z+1	; 0x01
    1b3c:	42 81       	ldd	r20, Z+2	; 0x02
    1b3e:	53 81       	ldd	r21, Z+3	; 0x03
    1b40:	82 0f       	add	r24, r18
    1b42:	93 1f       	adc	r25, r19
    1b44:	a4 1f       	adc	r26, r20
    1b46:	b5 1f       	adc	r27, r21
    1b48:	80 83       	st	Z, r24
    1b4a:	91 83       	std	Z+1, r25	; 0x01
    1b4c:	a2 83       	std	Z+2, r26	; 0x02
    1b4e:	b3 83       	std	Z+3, r27	; 0x03

		/* Progress to the next state once the current state's data has been ACKed */
		AppState->HTTPServer.CurrentState = AppState->HTTPServer.NextState;
    1b50:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1b52:	8c 8f       	std	Y+28, r24	; 0x1c
	}

	if (uip_rexmit())
    1b54:	80 91 23 06 	lds	r24, 0x0623
    1b58:	82 ff       	sbrs	r24, 2
    1b5a:	0d c0       	rjmp	.+26     	; 0x1b76 <HTTPServerApp_Callback+0xb0>
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
    1b5c:	c5 59       	subi	r28, 0x95	; 149
    1b5e:	df 4f       	sbci	r29, 0xFF	; 255
    1b60:	48 81       	ld	r20, Y
    1b62:	59 81       	ldd	r21, Y+1	; 0x01
    1b64:	6a 81       	ldd	r22, Y+2	; 0x02
    1b66:	7b 81       	ldd	r23, Y+3	; 0x03
    1b68:	cb 56       	subi	r28, 0x6B	; 107
    1b6a:	d0 40       	sbci	r29, 0x00	; 0
    1b6c:	ce 01       	movw	r24, r28
    1b6e:	80 5b       	subi	r24, 0xB0	; 176
    1b70:	9f 4f       	sbci	r25, 0xFF	; 255
    1b72:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <f_lseek>
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1b76:	80 91 23 06 	lds	r24, 0x0623
    1b7a:	28 2f       	mov	r18, r24
    1b7c:	30 e0       	ldi	r19, 0x00	; 0
    1b7e:	82 fd       	sbrc	r24, 2
    1b80:	0b c0       	rjmp	.+22     	; 0x1b98 <HTTPServerApp_Callback+0xd2>
    1b82:	c9 01       	movw	r24, r18
    1b84:	83 70       	andi	r24, 0x03	; 3
    1b86:	90 70       	andi	r25, 0x00	; 0
    1b88:	89 2b       	or	r24, r25
    1b8a:	31 f4       	brne	.+12     	; 0x1b98 <HTTPServerApp_Callback+0xd2>
    1b8c:	c9 01       	movw	r24, r18
    1b8e:	88 74       	andi	r24, 0x48	; 72
    1b90:	90 70       	andi	r25, 0x00	; 0
    1b92:	89 2b       	or	r24, r25
    1b94:	09 f4       	brne	.+2      	; 0x1b98 <HTTPServerApp_Callback+0xd2>
    1b96:	24 c1       	rjmp	.+584    	; 0x1de0 <HTTPServerApp_Callback+0x31a>
	{
		switch (AppState->HTTPServer.CurrentState)
    1b98:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1b9a:	81 30       	cpi	r24, 0x01	; 1
    1b9c:	09 f4       	brne	.+2      	; 0x1ba0 <HTTPServerApp_Callback+0xda>
    1b9e:	64 c0       	rjmp	.+200    	; 0x1c68 <HTTPServerApp_Callback+0x1a2>
    1ba0:	81 30       	cpi	r24, 0x01	; 1
    1ba2:	38 f0       	brcs	.+14     	; 0x1bb2 <HTTPServerApp_Callback+0xec>
    1ba4:	82 30       	cpi	r24, 0x02	; 2
    1ba6:	09 f4       	brne	.+2      	; 0x1baa <HTTPServerApp_Callback+0xe4>
    1ba8:	e9 c0       	rjmp	.+466    	; 0x1d7c <HTTPServerApp_Callback+0x2b6>
    1baa:	83 30       	cpi	r24, 0x03	; 3
    1bac:	09 f0       	breq	.+2      	; 0x1bb0 <HTTPServerApp_Callback+0xea>
    1bae:	18 c1       	rjmp	.+560    	; 0x1de0 <HTTPServerApp_Callback+0x31a>
    1bb0:	07 c1       	rjmp	.+526    	; 0x1dc0 <HTTPServerApp_Callback+0x2fa>
/** HTTP Server State handler for the Request Process state. This state manages the processing of incoming HTTP
 *  GET requests to the server from the receiving HTTP client.
 */
static void HTTPServerApp_OpenRequestedFile(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1bb2:	e0 90 28 06 	lds	r14, 0x0628
    1bb6:	f0 90 29 06 	lds	r15, 0x0629
	char*               const AppData     = (char*)uip_appdata;
    1bba:	80 91 26 06 	lds	r24, 0x0626
    1bbe:	90 91 27 06 	lds	r25, 0x0627

	/* No HTTP header received from the client, abort processing */
	if (!(uip_newdata()))
    1bc2:	21 ff       	sbrs	r18, 1
    1bc4:	0d c1       	rjmp	.+538    	; 0x1de0 <HTTPServerApp_Callback+0x31a>
	  return;

	char* RequestToken      = strtok(AppData, " ");
    1bc6:	68 e3       	ldi	r22, 0x38	; 56
    1bc8:	72 e0       	ldi	r23, 0x02	; 2
    1bca:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <strtok>
    1bce:	8c 01       	movw	r16, r24
	char* RequestedFileName = strtok(NULL, " ");
    1bd0:	80 e0       	ldi	r24, 0x00	; 0
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	68 e3       	ldi	r22, 0x38	; 56
    1bd6:	72 e0       	ldi	r23, 0x02	; 2
    1bd8:	0e 94 21 3d 	call	0x7a42	; 0x7a42 <strtok>
    1bdc:	ec 01       	movw	r28, r24

	/* Must be a GET request, abort otherwise */
	if (strcmp_P(RequestToken, PSTR("GET")) != 0)
    1bde:	c8 01       	movw	r24, r16
    1be0:	61 e4       	ldi	r22, 0x41	; 65
    1be2:	72 e0       	ldi	r23, 0x02	; 2
    1be4:	0e 94 fd 3c 	call	0x79fa	; 0x79fa <strcmp_P>
    1be8:	89 2b       	or	r24, r25
    1bea:	21 f0       	breq	.+8      	; 0x1bf4 <HTTPServerApp_Callback+0x12e>
	{
		uip_abort();
    1bec:	80 e2       	ldi	r24, 0x20	; 32
    1bee:	80 93 23 06 	sts	0x0623, r24
    1bf2:	f6 c0       	rjmp	.+492    	; 0x1de0 <HTTPServerApp_Callback+0x31a>
		return;
	}

	/* Copy over the requested filename */
	strlcpy(AppState->HTTPServer.FileName, &RequestedFileName[1], sizeof(AppState->HTTPServer.FileName));
    1bf4:	87 01       	movw	r16, r14
    1bf6:	02 5e       	subi	r16, 0xE2	; 226
    1bf8:	1f 4f       	sbci	r17, 0xFF	; 255
    1bfa:	21 96       	adiw	r28, 0x01	; 1
    1bfc:	c8 01       	movw	r24, r16
    1bfe:	be 01       	movw	r22, r28
    1c00:	42 e3       	ldi	r20, 0x32	; 50
    1c02:	50 e0       	ldi	r21, 0x00	; 0
    1c04:	0e 94 4f 3d 	call	0x7a9e	; 0x7a9e <strlcpy>

	/* Determine the length of the URI so that it can be checked to see if it is a directory */
	uint8_t FileNameLen = strlen(AppState->HTTPServer.FileName);
    1c08:	d8 01       	movw	r26, r16
    1c0a:	0d 90       	ld	r0, X+
    1c0c:	00 20       	and	r0, r0
    1c0e:	e9 f7       	brne	.-6      	; 0x1c0a <HTTPServerApp_Callback+0x144>
    1c10:	11 97       	sbiw	r26, 0x01	; 1
    1c12:	a0 1b       	sub	r26, r16
    1c14:	b1 0b       	sbc	r27, r17
    1c16:	9a 2f       	mov	r25, r26

	/* If the URI is a directory, append the default filename */
	if ((AppState->HTTPServer.FileName[FileNameLen - 1] == '/') || !(FileNameLen))
    1c18:	f7 01       	movw	r30, r14
    1c1a:	ea 0f       	add	r30, r26
    1c1c:	f1 1d       	adc	r31, r1
    1c1e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c20:	8f 32       	cpi	r24, 0x2F	; 47
    1c22:	11 f0       	breq	.+4      	; 0x1c28 <HTTPServerApp_Callback+0x162>
    1c24:	aa 23       	and	r26, r26
    1c26:	69 f4       	brne	.+26     	; 0x1c42 <HTTPServerApp_Callback+0x17c>
	{
		strlcpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
    1c28:	89 2f       	mov	r24, r25
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	42 e3       	ldi	r20, 0x32	; 50
    1c2e:	50 e0       	ldi	r21, 0x00	; 0
    1c30:	48 1b       	sub	r20, r24
    1c32:	59 0b       	sbc	r21, r25
    1c34:	4e 96       	adiw	r24, 0x1e	; 30
    1c36:	8e 0d       	add	r24, r14
    1c38:	9f 1d       	adc	r25, r15
    1c3a:	6c e2       	ldi	r22, 0x2C	; 44
    1c3c:	72 e0       	ldi	r23, 0x02	; 2
    1c3e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <strlcpy_P>
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    1c42:	c7 01       	movw	r24, r14
    1c44:	80 5b       	subi	r24, 0xB0	; 176
    1c46:	9f 4f       	sbci	r25, 0xFF	; 255
    1c48:	b8 01       	movw	r22, r16
    1c4a:	41 e0       	ldi	r20, 0x01	; 1
    1c4c:	0e 94 35 22 	call	0x446a	; 0x446a <f_open>
    1c50:	f7 01       	movw	r30, r14
    1c52:	e6 59       	subi	r30, 0x96	; 150
    1c54:	ff 4f       	sbci	r31, 0xFF	; 255
    1c56:	10 82       	st	Z, r1
    1c58:	88 23       	and	r24, r24
    1c5a:	11 f4       	brne	.+4      	; 0x1c60 <HTTPServerApp_Callback+0x19a>
    1c5c:	81 e0       	ldi	r24, 0x01	; 1
    1c5e:	80 83       	st	Z, r24
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);

	/* Lock to the SendResponseHeader state until connection terminated */
	AppState->HTTPServer.CurrentState = WEBSERVER_STATE_SendResponseHeader;
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	f7 01       	movw	r30, r14
    1c64:	84 8f       	std	Z+28, r24	; 0x1c
    1c66:	88 c0       	rjmp	.+272    	; 0x1d78 <HTTPServerApp_Callback+0x2b2>
/** HTTP Server State handler for the HTTP Response Header Send state. This state manages the transmission of
 *  the HTTP response header to the receiving HTTP client.
 */
static void HTTPServerApp_SendResponseHeader(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1c68:	c0 90 28 06 	lds	r12, 0x0628
    1c6c:	d0 90 29 06 	lds	r13, 0x0629
	char*               const AppData     = (char*)uip_appdata;
    1c70:	00 91 26 06 	lds	r16, 0x0626
    1c74:	10 91 27 06 	lds	r17, 0x0627

	char* Extension     = strpbrk(AppState->HTTPServer.FileName, ".");
    1c78:	e6 01       	movw	r28, r12
    1c7a:	6e 96       	adiw	r28, 0x1e	; 30
    1c7c:	ce 01       	movw	r24, r28
    1c7e:	6e e2       	ldi	r22, 0x2E	; 46
    1c80:	70 e0       	ldi	r23, 0x00	; 0
    1c82:	0e 94 34 3d 	call	0x7a68	; 0x7a68 <strchr>
    1c86:	5c 01       	movw	r10, r24
	bool  FoundMIMEType = false;

	/* If the file isn't already open, it wasn't found - send back a 404 error response and abort */
	if (!(AppState->HTTPServer.FileOpen))
    1c88:	2a e6       	ldi	r18, 0x6A	; 106
    1c8a:	30 e0       	ldi	r19, 0x00	; 0
    1c8c:	c2 0e       	add	r12, r18
    1c8e:	d3 1e       	adc	r13, r19
    1c90:	f6 01       	movw	r30, r12
    1c92:	80 81       	ld	r24, Z
    1c94:	26 e9       	ldi	r18, 0x96	; 150
    1c96:	3f ef       	ldi	r19, 0xFF	; 255
    1c98:	c2 0e       	add	r12, r18
    1c9a:	d3 1e       	adc	r13, r19
    1c9c:	88 23       	and	r24, r24
    1c9e:	d1 f4       	brne	.+52     	; 0x1cd4 <HTTPServerApp_Callback+0x20e>
	{
		/* Copy over the HTTP 404 response header and send it to the receiving client */
		strcpy_P(AppData, HTTP404Header);
    1ca0:	c8 01       	movw	r24, r16
    1ca2:	60 ea       	ldi	r22, 0xA0	; 160
    1ca4:	71 e0       	ldi	r23, 0x01	; 1
    1ca6:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <strcpy_P>
		strcpy(&AppData[strlen(AppData)], AppState->HTTPServer.FileName);
    1caa:	f8 01       	movw	r30, r16
    1cac:	01 90       	ld	r0, Z+
    1cae:	00 20       	and	r0, r0
    1cb0:	e9 f7       	brne	.-6      	; 0x1cac <HTTPServerApp_Callback+0x1e6>
    1cb2:	cf 01       	movw	r24, r30
    1cb4:	01 97       	sbiw	r24, 0x01	; 1
    1cb6:	be 01       	movw	r22, r28
    1cb8:	0e 94 48 3d 	call	0x7a90	; 0x7a90 <strcpy>
		uip_send(AppData, strlen(AppData));
    1cbc:	f8 01       	movw	r30, r16
    1cbe:	01 90       	ld	r0, Z+
    1cc0:	00 20       	and	r0, r0
    1cc2:	e9 f7       	brne	.-6      	; 0x1cbe <HTTPServerApp_Callback+0x1f8>
    1cc4:	31 97       	sbiw	r30, 0x01	; 1
    1cc6:	e0 1b       	sub	r30, r16
    1cc8:	f1 0b       	sbc	r31, r17
    1cca:	c8 01       	movw	r24, r16
    1ccc:	bf 01       	movw	r22, r30
    1cce:	a8 d2       	rcall	.+1360   	; 0x2220 <uip_send>

		AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1cd0:	83 e0       	ldi	r24, 0x03	; 3
    1cd2:	51 c0       	rjmp	.+162    	; 0x1d76 <HTTPServerApp_Callback+0x2b0>
		return;
	}

	/* Copy over the HTTP 200 response header and send it to the receiving client */
	strcpy_P(AppData, HTTP200Header);
    1cd4:	c8 01       	movw	r24, r16
    1cd6:	65 e4       	ldi	r22, 0x45	; 69
    1cd8:	71 e0       	ldi	r23, 0x01	; 1
    1cda:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <strcpy_P>

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
    1cde:	a1 14       	cp	r10, r1
    1ce0:	b1 04       	cpc	r11, r1
    1ce2:	51 f1       	breq	.+84     	; 0x1d38 <HTTPServerApp_Callback+0x272>
    1ce4:	9d ee       	ldi	r25, 0xED	; 237
    1ce6:	e9 2e       	mov	r14, r25
    1ce8:	92 e0       	ldi	r25, 0x02	; 2
    1cea:	f9 2e       	mov	r15, r25
    1cec:	c0 e0       	ldi	r28, 0x00	; 0
    1cee:	d0 e0       	ldi	r29, 0x00	; 0
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
		{
			if (strcmp(&Extension[1], MIMETypes[i].Extension) == 0)
    1cf0:	08 94       	sec
    1cf2:	a1 1c       	adc	r10, r1
    1cf4:	b1 1c       	adc	r11, r1
    1cf6:	f7 01       	movw	r30, r14
    1cf8:	60 81       	ld	r22, Z
    1cfa:	71 81       	ldd	r23, Z+1	; 0x01
    1cfc:	c5 01       	movw	r24, r10
    1cfe:	0e 94 3f 3d 	call	0x7a7e	; 0x7a7e <strcmp>
    1d02:	89 2b       	or	r24, r25
    1d04:	89 f4       	brne	.+34     	; 0x1d28 <HTTPServerApp_Callback+0x262>
			{
				strcpy(&AppData[strlen(AppData)], MIMETypes[i].MIMEType);
    1d06:	f8 01       	movw	r30, r16
    1d08:	01 90       	ld	r0, Z+
    1d0a:	00 20       	and	r0, r0
    1d0c:	e9 f7       	brne	.-6      	; 0x1d08 <HTTPServerApp_Callback+0x242>
    1d0e:	cc 0f       	add	r28, r28
    1d10:	dd 1f       	adc	r29, r29
    1d12:	cc 0f       	add	r28, r28
    1d14:	dd 1f       	adc	r29, r29
    1d16:	c1 51       	subi	r28, 0x11	; 17
    1d18:	dd 4f       	sbci	r29, 0xFD	; 253
    1d1a:	68 81       	ld	r22, Y
    1d1c:	79 81       	ldd	r23, Y+1	; 0x01
    1d1e:	cf 01       	movw	r24, r30
    1d20:	01 97       	sbiw	r24, 0x01	; 1
    1d22:	0e 94 48 3d 	call	0x7a90	; 0x7a90 <strcpy>
    1d26:	12 c0       	rjmp	.+36     	; 0x1d4c <HTTPServerApp_Callback+0x286>
    1d28:	21 96       	adiw	r28, 0x01	; 1
    1d2a:	24 e0       	ldi	r18, 0x04	; 4
    1d2c:	30 e0       	ldi	r19, 0x00	; 0
    1d2e:	e2 0e       	add	r14, r18
    1d30:	f3 1e       	adc	r15, r19

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
    1d32:	ca 30       	cpi	r28, 0x0A	; 10
    1d34:	d1 05       	cpc	r29, r1
    1d36:	f9 f6       	brne	.-66     	; 0x1cf6 <HTTPServerApp_Callback+0x230>

	/* Check if a MIME type was found and copied to the output buffer */
	if (!(FoundMIMEType))
	{
		/* MIME type not found - copy over the default MIME type */
		strcpy_P(&AppData[strlen(AppData)], DefaultMIMEType);
    1d38:	f8 01       	movw	r30, r16
    1d3a:	01 90       	ld	r0, Z+
    1d3c:	00 20       	and	r0, r0
    1d3e:	e9 f7       	brne	.-6      	; 0x1d3a <HTTPServerApp_Callback+0x274>
    1d40:	cf 01       	movw	r24, r30
    1d42:	01 97       	sbiw	r24, 0x01	; 1
    1d44:	66 e3       	ldi	r22, 0x36	; 54
    1d46:	72 e0       	ldi	r23, 0x02	; 2
    1d48:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <strcpy_P>
	}

	/* Add the end-of-line terminator and end-of-headers terminator after the MIME type */
	strcpy_P(&AppData[strlen(AppData)], PSTR("\r\n\r\n"));
    1d4c:	f8 01       	movw	r30, r16
    1d4e:	01 90       	ld	r0, Z+
    1d50:	00 20       	and	r0, r0
    1d52:	e9 f7       	brne	.-6      	; 0x1d4e <HTTPServerApp_Callback+0x288>
    1d54:	cf 01       	movw	r24, r30
    1d56:	01 97       	sbiw	r24, 0x01	; 1
    1d58:	65 e4       	ldi	r22, 0x45	; 69
    1d5a:	72 e0       	ldi	r23, 0x02	; 2
    1d5c:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <strcpy_P>

	/* Send the MIME header to the receiving client */
	uip_send(AppData, strlen(AppData));
    1d60:	f8 01       	movw	r30, r16
    1d62:	01 90       	ld	r0, Z+
    1d64:	00 20       	and	r0, r0
    1d66:	e9 f7       	brne	.-6      	; 0x1d62 <HTTPServerApp_Callback+0x29c>
    1d68:	31 97       	sbiw	r30, 0x01	; 1
    1d6a:	e0 1b       	sub	r30, r16
    1d6c:	f1 0b       	sbc	r31, r17
    1d6e:	c8 01       	movw	r24, r16
    1d70:	bf 01       	movw	r22, r30
    1d72:	56 d2       	rcall	.+1196   	; 0x2220 <uip_send>

	/* When the MIME header is ACKed, progress to the data send stage */
	AppState->HTTPServer.NextState = WEBSERVER_STATE_SendData;
    1d74:	82 e0       	ldi	r24, 0x02	; 2
    1d76:	f6 01       	movw	r30, r12
    1d78:	85 8f       	std	Z+29, r24	; 0x1d
    1d7a:	32 c0       	rjmp	.+100    	; 0x1de0 <HTTPServerApp_Callback+0x31a>
/** HTTP Server State handler for the Data Send state. This state manages the transmission of file chunks
 *  to the receiving HTTP client.
 */
static void HTTPServerApp_SendData(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1d7c:	c0 91 28 06 	lds	r28, 0x0628
    1d80:	d0 91 29 06 	lds	r29, 0x0629
	char*               const AppData     = (char*)uip_appdata;
    1d84:	e0 90 26 06 	lds	r14, 0x0626
    1d88:	f0 90 27 06 	lds	r15, 0x0627

	/* Get the maximum segment size for the current packet */
	uint16_t MaxChunkSize = uip_mss();
    1d8c:	ca 88       	ldd	r12, Y+18	; 0x12
    1d8e:	db 88       	ldd	r13, Y+19	; 0x13

	/* Read the next chunk of data from the open file */
	f_read(&AppState->HTTPServer.FileHandle, AppData, MaxChunkSize, &AppState->HTTPServer.SentChunkSize);
    1d90:	8e 01       	movw	r16, r28
    1d92:	01 59       	subi	r16, 0x91	; 145
    1d94:	1f 4f       	sbci	r17, 0xFF	; 255
    1d96:	ce 01       	movw	r24, r28
    1d98:	80 5b       	subi	r24, 0xB0	; 176
    1d9a:	9f 4f       	sbci	r25, 0xFF	; 255
    1d9c:	b7 01       	movw	r22, r14
    1d9e:	a6 01       	movw	r20, r12
    1da0:	98 01       	movw	r18, r16
    1da2:	0e 94 c5 20 	call	0x418a	; 0x418a <f_read>

	/* Send the next file chunk to the receiving client */
	uip_send(AppData, AppState->HTTPServer.SentChunkSize);
    1da6:	f8 01       	movw	r30, r16
    1da8:	60 81       	ld	r22, Z
    1daa:	71 81       	ldd	r23, Z+1	; 0x01
    1dac:	c7 01       	movw	r24, r14
    1dae:	38 d2       	rcall	.+1136   	; 0x2220 <uip_send>

	/* Check if we are at the last chunk of the file, if so next ACK should close the connection */
	if (MaxChunkSize != AppState->HTTPServer.SentChunkSize)
    1db0:	f8 01       	movw	r30, r16
    1db2:	80 81       	ld	r24, Z
    1db4:	91 81       	ldd	r25, Z+1	; 0x01
    1db6:	c8 16       	cp	r12, r24
    1db8:	d9 06       	cpc	r13, r25
    1dba:	91 f0       	breq	.+36     	; 0x1de0 <HTTPServerApp_Callback+0x31a>
	  AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1dbc:	83 e0       	ldi	r24, 0x03	; 3
    1dbe:	0f c0       	rjmp	.+30     	; 0x1dde <HTTPServerApp_Callback+0x318>
			case WEBSERVER_STATE_SendData:
				HTTPServerApp_SendData();
				break;
			case WEBSERVER_STATE_Closing:
				/* Connection is being terminated for some reason - close file handle */
				f_close(&AppState->HTTPServer.FileHandle);
    1dc0:	ce 01       	movw	r24, r28
    1dc2:	80 5b       	subi	r24, 0xB0	; 176
    1dc4:	9f 4f       	sbci	r25, 0xFF	; 255
    1dc6:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <f_close>
				AppState->HTTPServer.FileOpen = false;
    1dca:	c6 59       	subi	r28, 0x96	; 150
    1dcc:	df 4f       	sbci	r29, 0xFF	; 255
    1dce:	18 82       	st	Y, r1
    1dd0:	ca 56       	subi	r28, 0x6A	; 106
    1dd2:	d0 40       	sbci	r29, 0x00	; 0

				/* If connection is not already closed, close it */
				uip_close();
    1dd4:	80 e1       	ldi	r24, 0x10	; 16
    1dd6:	80 93 23 06 	sts	0x0623, r24

				AppState->HTTPServer.CurrentState = WEBSERVER_STATE_Closed;
    1dda:	84 e0       	ldi	r24, 0x04	; 4
    1ddc:	8c 8f       	std	Y+28, r24	; 0x1c
				AppState->HTTPServer.NextState    = WEBSERVER_STATE_Closed;
    1dde:	8d 8f       	std	Y+29, r24	; 0x1d
				break;
		}
	}
}
    1de0:	df 91       	pop	r29
    1de2:	cf 91       	pop	r28
    1de4:	1f 91       	pop	r17
    1de6:	0f 91       	pop	r16
    1de8:	ff 90       	pop	r15
    1dea:	ef 90       	pop	r14
    1dec:	df 90       	pop	r13
    1dee:	cf 90       	pop	r12
    1df0:	bf 90       	pop	r11
    1df2:	af 90       	pop	r10
    1df4:	08 95       	ret

00001df6 <HTTPServerApp_Init>:

/** Initialization function for the simple HTTP webserver. */
void HTTPServerApp_Init(void)
{
	/* Listen on port 80 for HTTP connections from hosts */
	uip_listen(HTONS(HTTP_SERVER_PORT));
    1df6:	80 e0       	ldi	r24, 0x00	; 0
    1df8:	90 e5       	ldi	r25, 0x50	; 80
    1dfa:	98 d1       	rcall	.+816    	; 0x212c <uip_listen>

	/* Mount the Dataflash disk via FatFS */
	f_mount(0, &DiskFATState);
    1dfc:	80 e0       	ldi	r24, 0x00	; 0
    1dfe:	69 ef       	ldi	r22, 0xF9	; 249
    1e00:	73 e0       	ldi	r23, 0x03	; 3
    1e02:	0c 94 74 1d 	jmp	0x3ae8	; 0x3ae8 <f_mount>

00001e06 <TELNETServerApp_Callback>:

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
{
    1e06:	4f 92       	push	r4
    1e08:	5f 92       	push	r5
    1e0a:	7f 92       	push	r7
    1e0c:	8f 92       	push	r8
    1e0e:	9f 92       	push	r9
    1e10:	af 92       	push	r10
    1e12:	bf 92       	push	r11
    1e14:	cf 92       	push	r12
    1e16:	df 92       	push	r13
    1e18:	ef 92       	push	r14
    1e1a:	ff 92       	push	r15
    1e1c:	0f 93       	push	r16
    1e1e:	1f 93       	push	r17
    1e20:	cf 93       	push	r28
    1e22:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState   = &uip_conn->appstate;
    1e24:	a0 90 28 06 	lds	r10, 0x0628
    1e28:	b0 90 29 06 	lds	r11, 0x0629
	char*               const AppData    = (char*)uip_appdata;
    1e2c:	c0 91 26 06 	lds	r28, 0x0626
    1e30:	d0 91 27 06 	lds	r29, 0x0627

	if (uip_connected())
    1e34:	80 91 23 06 	lds	r24, 0x0623
    1e38:	86 ff       	sbrs	r24, 6
    1e3a:	03 c0       	rjmp	.+6      	; 0x1e42 <TELNETServerApp_Callback+0x3c>
	{
		/* New connection - initialize connection state values */
		AppState->TELNETServer.CurrentState = TELNET_STATE_SendHeader;
    1e3c:	d5 01       	movw	r26, r10
    1e3e:	5c 96       	adiw	r26, 0x1c	; 28
    1e40:	1c 92       	st	X, r1
	}

	if (uip_acked())
    1e42:	80 91 23 06 	lds	r24, 0x0623
    1e46:	80 ff       	sbrs	r24, 0
    1e48:	03 c0       	rjmp	.+6      	; 0x1e50 <TELNETServerApp_Callback+0x4a>
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
    1e4a:	f5 01       	movw	r30, r10
    1e4c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e4e:	84 8f       	std	Z+28, r24	; 0x1c
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1e50:	80 91 23 06 	lds	r24, 0x0623
    1e54:	28 2f       	mov	r18, r24
    1e56:	30 e0       	ldi	r19, 0x00	; 0
    1e58:	82 fd       	sbrc	r24, 2
    1e5a:	0a c0       	rjmp	.+20     	; 0x1e70 <TELNETServerApp_Callback+0x6a>
    1e5c:	c9 01       	movw	r24, r18
    1e5e:	83 70       	andi	r24, 0x03	; 3
    1e60:	90 70       	andi	r25, 0x00	; 0
    1e62:	89 2b       	or	r24, r25
    1e64:	29 f4       	brne	.+10     	; 0x1e70 <TELNETServerApp_Callback+0x6a>
    1e66:	28 74       	andi	r18, 0x48	; 72
    1e68:	30 70       	andi	r19, 0x00	; 0
    1e6a:	23 2b       	or	r18, r19
    1e6c:	09 f4       	brne	.+2      	; 0x1e70 <TELNETServerApp_Callback+0x6a>
    1e6e:	be c0       	rjmp	.+380    	; 0x1fec <TELNETServerApp_Callback+0x1e6>
	{
		switch (AppState->TELNETServer.CurrentState)
    1e70:	d5 01       	movw	r26, r10
    1e72:	5c 96       	adiw	r26, 0x1c	; 28
    1e74:	8c 91       	ld	r24, X
    1e76:	81 30       	cpi	r24, 0x01	; 1
    1e78:	d9 f0       	breq	.+54     	; 0x1eb0 <TELNETServerApp_Callback+0xaa>
    1e7a:	81 30       	cpi	r24, 0x01	; 1
    1e7c:	30 f0       	brcs	.+12     	; 0x1e8a <TELNETServerApp_Callback+0x84>
    1e7e:	82 30       	cpi	r24, 0x02	; 2
    1e80:	41 f1       	breq	.+80     	; 0x1ed2 <TELNETServerApp_Callback+0xcc>
    1e82:	83 30       	cpi	r24, 0x03	; 3
    1e84:	09 f0       	breq	.+2      	; 0x1e88 <TELNETServerApp_Callback+0x82>
    1e86:	b2 c0       	rjmp	.+356    	; 0x1fec <TELNETServerApp_Callback+0x1e6>
    1e88:	31 c0       	rjmp	.+98     	; 0x1eec <TELNETServerApp_Callback+0xe6>
		{
			case TELNET_STATE_SendHeader:
				/* Copy over and send the TELNET welcome message upon first connection */
				strcpy_P(AppData, WelcomeHeader);
    1e8a:	ce 01       	movw	r24, r28
    1e8c:	6a e4       	ldi	r22, 0x4A	; 74
    1e8e:	72 e0       	ldi	r23, 0x02	; 2
    1e90:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1e94:	fe 01       	movw	r30, r28
    1e96:	01 90       	ld	r0, Z+
    1e98:	00 20       	and	r0, r0
    1e9a:	e9 f7       	brne	.-6      	; 0x1e96 <TELNETServerApp_Callback+0x90>
    1e9c:	31 97       	sbiw	r30, 0x01	; 1
    1e9e:	ec 1b       	sub	r30, r28
    1ea0:	fd 0b       	sbc	r31, r29
    1ea2:	ce 01       	movw	r24, r28
    1ea4:	bf 01       	movw	r22, r30
    1ea6:	bc d1       	rcall	.+888    	; 0x2220 <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1ea8:	81 e0       	ldi	r24, 0x01	; 1
    1eaa:	f5 01       	movw	r30, r10
    1eac:	85 8f       	std	Z+29, r24	; 0x1d
    1eae:	9e c0       	rjmp	.+316    	; 0x1fec <TELNETServerApp_Callback+0x1e6>
				break;
			case TELNET_STATE_SendMenu:
				/* Copy over and send the TELNET menu to the client */
				strcpy_P(AppData, TELNETMenu);
    1eb0:	ce 01       	movw	r24, r28
    1eb2:	65 ed       	ldi	r22, 0xD5	; 213
    1eb4:	72 e0       	ldi	r23, 0x02	; 2
    1eb6:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1eba:	fe 01       	movw	r30, r28
    1ebc:	01 90       	ld	r0, Z+
    1ebe:	00 20       	and	r0, r0
    1ec0:	e9 f7       	brne	.-6      	; 0x1ebc <TELNETServerApp_Callback+0xb6>
    1ec2:	31 97       	sbiw	r30, 0x01	; 1
    1ec4:	ec 1b       	sub	r30, r28
    1ec6:	fd 0b       	sbc	r31, r29
    1ec8:	ce 01       	movw	r24, r28
    1eca:	bf 01       	movw	r22, r30
    1ecc:	a9 d1       	rcall	.+850    	; 0x2220 <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_GetCommand;
    1ece:	82 e0       	ldi	r24, 0x02	; 2
    1ed0:	8a c0       	rjmp	.+276    	; 0x1fe6 <TELNETServerApp_Callback+0x1e0>
				break;
			case TELNET_STATE_GetCommand:
				if (!(uip_datalen()))
    1ed2:	80 91 1b 06 	lds	r24, 0x061B
    1ed6:	90 91 1c 06 	lds	r25, 0x061C
    1eda:	89 2b       	or	r24, r25
    1edc:	09 f4       	brne	.+2      	; 0x1ee0 <TELNETServerApp_Callback+0xda>
    1ede:	86 c0       	rjmp	.+268    	; 0x1fec <TELNETServerApp_Callback+0x1e6>
				  break;

				/* Save the issued command for later processing */
				AppState->TELNETServer.IssuedCommand = AppData[0];
    1ee0:	88 81       	ld	r24, Y
    1ee2:	f5 01       	movw	r30, r10
    1ee4:	86 8f       	std	Z+30, r24	; 0x1e

				AppState->TELNETServer.CurrentState  = TELNET_STATE_SendResponse;
    1ee6:	83 e0       	ldi	r24, 0x03	; 3
    1ee8:	84 8f       	std	Z+28, r24	; 0x1c
    1eea:	80 c0       	rjmp	.+256    	; 0x1fec <TELNETServerApp_Callback+0x1e6>
				break;
			case TELNET_STATE_SendResponse:
				/* Determine which command was issued, perform command processing */
				switch (AppState->TELNETServer.IssuedCommand)
    1eec:	d5 01       	movw	r26, r10
    1eee:	5e 96       	adiw	r26, 0x1e	; 30
    1ef0:	8c 91       	ld	r24, X
    1ef2:	83 36       	cpi	r24, 0x63	; 99
    1ef4:	09 f0       	breq	.+2      	; 0x1ef8 <TELNETServerApp_Callback+0xf2>
    1ef6:	67 c0       	rjmp	.+206    	; 0x1fc6 <TELNETServerApp_Callback+0x1c0>
}

/** Sends a list of active TCP connections to the TELNET client. */
static void TELNETServerApp_DisplayTCPConnections(void)
{
	char* const AppData    = (char*)uip_appdata;
    1ef8:	80 90 26 06 	lds	r8, 0x0626
    1efc:	90 90 27 06 	lds	r9, 0x0627

	strcpy_P(AppData, CurrentConnectionsHeader);
    1f00:	c4 01       	movw	r24, r8
    1f02:	6a e3       	ldi	r22, 0x3A	; 58
    1f04:	73 e0       	ldi	r23, 0x03	; 3
    1f06:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <strcpy_P>

	uint16_t ResponseLen     = strlen(AppData);
    1f0a:	f4 01       	movw	r30, r8
    1f0c:	01 90       	ld	r0, Z+
    1f0e:	00 20       	and	r0, r0
    1f10:	e9 f7       	brne	.-6      	; 0x1f0c <TELNETServerApp_Callback+0x106>
    1f12:	6f 01       	movw	r12, r30
    1f14:	08 94       	sec
    1f16:	c1 08       	sbc	r12, r1
    1f18:	d1 08       	sbc	r13, r1
    1f1a:	c8 18       	sub	r12, r8
    1f1c:	d9 08       	sbc	r13, r9
    1f1e:	ca e2       	ldi	r28, 0x2A	; 42
    1f20:	d6 e0       	ldi	r29, 0x06	; 6
    1f22:	77 24       	eor	r7, r7

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1f24:	8e e6       	ldi	r24, 0x6E	; 110
    1f26:	48 2e       	mov	r4, r24
    1f28:	83 e0       	ldi	r24, 0x03	; 3
    1f2a:	58 2e       	mov	r5, r24
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		struct uip_conn* CurrConnection = &uip_conns[i];

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
    1f2c:	89 8d       	ldd	r24, Y+25	; 0x19
    1f2e:	88 23       	and	r24, r24
    1f30:	09 f4       	brne	.+2      	; 0x1f34 <TELNETServerApp_Callback+0x12e>
    1f32:	3f c0       	rjmp	.+126    	; 0x1fb2 <TELNETServerApp_Callback+0x1ac>
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1f34:	73 94       	inc	r7
    1f36:	8d b7       	in	r24, 0x3d	; 61
    1f38:	9e b7       	in	r25, 0x3e	; 62
    1f3a:	42 97       	sbiw	r24, 0x12	; 18
    1f3c:	0f b6       	in	r0, 0x3f	; 63
    1f3e:	f8 94       	cli
    1f40:	9e bf       	out	0x3e, r25	; 62
    1f42:	0f be       	out	0x3f, r0	; 63
    1f44:	8d bf       	out	0x3d, r24	; 61
    1f46:	ed b7       	in	r30, 0x3d	; 61
    1f48:	fe b7       	in	r31, 0x3e	; 62
    1f4a:	31 96       	adiw	r30, 0x01	; 1
    1f4c:	c4 01       	movw	r24, r8
    1f4e:	8c 0d       	add	r24, r12
    1f50:	9d 1d       	adc	r25, r13
    1f52:	ad b7       	in	r26, 0x3d	; 61
    1f54:	be b7       	in	r27, 0x3e	; 62
    1f56:	12 96       	adiw	r26, 0x02	; 2
    1f58:	9c 93       	st	X, r25
    1f5a:	8e 93       	st	-X, r24
    1f5c:	11 97       	sbiw	r26, 0x01	; 1
    1f5e:	53 82       	std	Z+3, r5	; 0x03
    1f60:	42 82       	std	Z+2, r4	; 0x02
    1f62:	87 2d       	mov	r24, r7
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	95 83       	std	Z+5, r25	; 0x05
    1f68:	84 83       	std	Z+4, r24	; 0x04
    1f6a:	88 81       	ld	r24, Y
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	97 83       	std	Z+7, r25	; 0x07
    1f70:	86 83       	std	Z+6, r24	; 0x06
    1f72:	89 81       	ldd	r24, Y+1	; 0x01
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	91 87       	std	Z+9, r25	; 0x09
    1f78:	80 87       	std	Z+8, r24	; 0x08
    1f7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f7c:	90 e0       	ldi	r25, 0x00	; 0
    1f7e:	93 87       	std	Z+11, r25	; 0x0b
    1f80:	82 87       	std	Z+10, r24	; 0x0a
    1f82:	8b 81       	ldd	r24, Y+3	; 0x03
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	95 87       	std	Z+13, r25	; 0x0d
    1f88:	84 87       	std	Z+12, r24	; 0x0c
    1f8a:	fc 80       	ldd	r15, Y+4	; 0x04
    1f8c:	ed 80       	ldd	r14, Y+5	; 0x05
    1f8e:	f7 86       	std	Z+15, r15	; 0x0f
    1f90:	e6 86       	std	Z+14, r14	; 0x0e
    1f92:	1e 81       	ldd	r17, Y+6	; 0x06
    1f94:	0f 81       	ldd	r16, Y+7	; 0x07
    1f96:	11 8b       	std	Z+17, r17	; 0x11
    1f98:	00 8b       	std	Z+16, r16	; 0x10
    1f9a:	0e 94 8a 3d 	call	0x7b14	; 0x7b14 <sprintf_P>
    1f9e:	c8 0e       	add	r12, r24
    1fa0:	d9 1e       	adc	r13, r25
    1fa2:	ed b7       	in	r30, 0x3d	; 61
    1fa4:	fe b7       	in	r31, 0x3e	; 62
    1fa6:	72 96       	adiw	r30, 0x12	; 18
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	fe bf       	out	0x3e, r31	; 62
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	ed bf       	out	0x3d, r30	; 61
    1fb2:	cf 58       	subi	r28, 0x8F	; 143
    1fb4:	df 4f       	sbci	r29, 0xFF	; 255

	uint16_t ResponseLen     = strlen(AppData);
	uint8_t  ActiveConnCount = 0;

	/* Loop through the complete uIP TCP connections list, looking for active connections */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    1fb6:	f7 e0       	ldi	r31, 0x07	; 7
    1fb8:	cd 37       	cpi	r28, 0x7D	; 125
    1fba:	df 07       	cpc	r29, r31
    1fbc:	09 f0       	breq	.+2      	; 0x1fc0 <TELNETServerApp_Callback+0x1ba>
    1fbe:	b6 cf       	rjmp	.-148    	; 0x1f2c <TELNETServerApp_Callback+0x126>
			                         CurrConnection->ripaddr.u8[3],
			                         HTONS(CurrConnection->lport), HTONS(CurrConnection->rport));
		}
	}

	uip_send(AppData, ResponseLen);
    1fc0:	c4 01       	movw	r24, r8
    1fc2:	b6 01       	movw	r22, r12
    1fc4:	0e c0       	rjmp	.+28     	; 0x1fe2 <TELNETServerApp_Callback+0x1dc>
				{
					case 'c':
						TELNETServerApp_DisplayTCPConnections();
						break;
					default:
						strcpy_P(AppData, PSTR("Invalid Command.\r\n"));
    1fc6:	ce 01       	movw	r24, r28
    1fc8:	6b e5       	ldi	r22, 0x5B	; 91
    1fca:	73 e0       	ldi	r23, 0x03	; 3
    1fcc:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <strcpy_P>
						uip_send(AppData, strlen(AppData));
    1fd0:	fe 01       	movw	r30, r28
    1fd2:	01 90       	ld	r0, Z+
    1fd4:	00 20       	and	r0, r0
    1fd6:	e9 f7       	brne	.-6      	; 0x1fd2 <TELNETServerApp_Callback+0x1cc>
    1fd8:	31 97       	sbiw	r30, 0x01	; 1
    1fda:	ec 1b       	sub	r30, r28
    1fdc:	fd 0b       	sbc	r31, r29
    1fde:	ce 01       	movw	r24, r28
    1fe0:	bf 01       	movw	r22, r30
    1fe2:	1e d1       	rcall	.+572    	; 0x2220 <uip_send>
						break;
				}

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	d5 01       	movw	r26, r10
    1fe8:	5d 96       	adiw	r26, 0x1d	; 29
    1fea:	8c 93       	st	X, r24
				break;
		}
	}
}
    1fec:	df 91       	pop	r29
    1fee:	cf 91       	pop	r28
    1ff0:	1f 91       	pop	r17
    1ff2:	0f 91       	pop	r16
    1ff4:	ff 90       	pop	r15
    1ff6:	ef 90       	pop	r14
    1ff8:	df 90       	pop	r13
    1ffa:	cf 90       	pop	r12
    1ffc:	bf 90       	pop	r11
    1ffe:	af 90       	pop	r10
    2000:	9f 90       	pop	r9
    2002:	8f 90       	pop	r8
    2004:	7f 90       	pop	r7
    2006:	5f 90       	pop	r5
    2008:	4f 90       	pop	r4
    200a:	08 95       	ret

0000200c <TELNETServerApp_Init>:

/** Initialization function for the simple TELNET webserver. */
void TELNETServerApp_Init(void)
{
	/* Listen on port 23 for TELNET connections from hosts */
	uip_listen(HTONS(TELNET_SERVER_PORT));
    200c:	80 e0       	ldi	r24, 0x00	; 0
    200e:	97 e1       	ldi	r25, 0x17	; 23
}
    2010:	8d c0       	rjmp	.+282    	; 0x212c <uip_listen>

00002012 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    2012:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    2014:	53 81       	ldd	r21, Z+3	; 0x03
    2016:	56 0f       	add	r21, r22
    2018:	50 93 22 06 	sts	0x0622, r21
  uip_acc32[2] = op32[2] + (op16 >> 8);
    201c:	27 2f       	mov	r18, r23
    201e:	33 27       	eor	r19, r19
    2020:	42 81       	ldd	r20, Z+2	; 0x02
    2022:	42 0f       	add	r20, r18
    2024:	40 93 21 06 	sts	0x0621, r20
  uip_acc32[1] = op32[1];
    2028:	a1 81       	ldd	r26, Z+1	; 0x01
    202a:	a0 93 20 06 	sts	0x0620, r26
  uip_acc32[0] = op32[0];
    202e:	e0 81       	ld	r30, Z
    2030:	e0 93 1f 06 	sts	0x061F, r30

  if(uip_acc32[2] < (op16 >> 8)) {
    2034:	84 2f       	mov	r24, r20
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	82 17       	cp	r24, r18
    203a:	93 07       	cpc	r25, r19
    203c:	48 f4       	brcc	.+18     	; 0x2050 <uip_add32+0x3e>
    ++uip_acc32[1];
    203e:	8a 2f       	mov	r24, r26
    2040:	8f 5f       	subi	r24, 0xFF	; 255
    2042:	80 93 20 06 	sts	0x0620, r24
    if(uip_acc32[1] == 0) {
    2046:	88 23       	and	r24, r24
    2048:	19 f4       	brne	.+6      	; 0x2050 <uip_add32+0x3e>
      ++uip_acc32[0];
    204a:	ef 5f       	subi	r30, 0xFF	; 255
    204c:	e0 93 1f 06 	sts	0x061F, r30
    }
  }


  if(uip_acc32[3] < (op16 & 0xff)) {
    2050:	85 2f       	mov	r24, r21
    2052:	90 e0       	ldi	r25, 0x00	; 0
    2054:	70 70       	andi	r23, 0x00	; 0
    2056:	86 17       	cp	r24, r22
    2058:	97 07       	cpc	r25, r23
    205a:	90 f4       	brcc	.+36     	; 0x2080 <uip_add32+0x6e>
    ++uip_acc32[2];
    205c:	84 2f       	mov	r24, r20
    205e:	8f 5f       	subi	r24, 0xFF	; 255
    2060:	80 93 21 06 	sts	0x0621, r24
    if(uip_acc32[2] == 0) {
    2064:	88 23       	and	r24, r24
    2066:	61 f4       	brne	.+24     	; 0x2080 <uip_add32+0x6e>
      ++uip_acc32[1];
    2068:	80 91 20 06 	lds	r24, 0x0620
    206c:	8f 5f       	subi	r24, 0xFF	; 255
    206e:	80 93 20 06 	sts	0x0620, r24
      if(uip_acc32[1] == 0) {
    2072:	88 23       	and	r24, r24
    2074:	29 f4       	brne	.+10     	; 0x2080 <uip_add32+0x6e>
	++uip_acc32[0];
    2076:	80 91 1f 06 	lds	r24, 0x061F
    207a:	8f 5f       	subi	r24, 0xFF	; 255
    207c:	80 93 1f 06 	sts	0x061F, r24
    2080:	08 95       	ret

00002082 <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    2082:	dc 01       	movw	r26, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    2084:	41 50       	subi	r20, 0x01	; 1
    2086:	50 40       	sbci	r21, 0x00	; 0
    2088:	46 0f       	add	r20, r22
    208a:	57 1f       	adc	r21, r23
    208c:	fb 01       	movw	r30, r22
    208e:	0e c0       	rjmp	.+28     	; 0x20ac <chksum+0x2a>

  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    2090:	80 81       	ld	r24, Z
    2092:	90 e0       	ldi	r25, 0x00	; 0
    2094:	98 2f       	mov	r25, r24
    2096:	88 27       	eor	r24, r24
    2098:	21 81       	ldd	r18, Z+1	; 0x01
    209a:	82 0f       	add	r24, r18
    209c:	91 1d       	adc	r25, r1
    sum += t;
    209e:	a8 0f       	add	r26, r24
    20a0:	b9 1f       	adc	r27, r25
    if(sum < t) {
    20a2:	a8 17       	cp	r26, r24
    20a4:	b9 07       	cpc	r27, r25
    20a6:	08 f4       	brcc	.+2      	; 0x20aa <chksum+0x28>
      sum++;		/* carry */
    20a8:	11 96       	adiw	r26, 0x01	; 1
    }
    dataptr += 2;
    20aa:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;

  while(dataptr < last_byte) {	/* At least two more bytes */
    20ac:	e4 17       	cp	r30, r20
    20ae:	f5 07       	cpc	r31, r21
    20b0:	78 f3       	brcs	.-34     	; 0x2090 <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }

  if(dataptr == last_byte) {
    20b2:	e4 17       	cp	r30, r20
    20b4:	f5 07       	cpc	r31, r21
    20b6:	51 f4       	brne	.+20     	; 0x20cc <chksum+0x4a>
    t = (dataptr[0] << 8) + 0;
    20b8:	80 81       	ld	r24, Z
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	98 2f       	mov	r25, r24
    20be:	88 27       	eor	r24, r24
    sum += t;
    20c0:	a8 0f       	add	r26, r24
    20c2:	b9 1f       	adc	r27, r25
    if(sum < t) {
    20c4:	a8 17       	cp	r26, r24
    20c6:	b9 07       	cpc	r27, r25
    20c8:	08 f4       	brcc	.+2      	; 0x20cc <chksum+0x4a>
      sum++;		/* carry */
    20ca:	11 96       	adiw	r26, 0x01	; 1
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    20cc:	cd 01       	movw	r24, r26
    20ce:	08 95       	ret

000020d0 <uip_init>:
#endif /* UIP_UDP_CHECKSUMS */
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
    20d0:	80 e0       	ldi	r24, 0x00	; 0
    20d2:	09 c0       	rjmp	.+18     	; 0x20e6 <uip_init+0x16>
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
    20d4:	e8 2f       	mov	r30, r24
    20d6:	f0 e0       	ldi	r31, 0x00	; 0
    20d8:	ee 0f       	add	r30, r30
    20da:	ff 1f       	adc	r31, r31
    20dc:	e3 58       	subi	r30, 0x83	; 131
    20de:	f8 4f       	sbci	r31, 0xF8	; 248
    20e0:	11 82       	std	Z+1, r1	; 0x01
    20e2:	10 82       	st	Z, r1
    20e4:	8f 5f       	subi	r24, 0xFF	; 255
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    20e6:	85 30       	cpi	r24, 0x05	; 5
    20e8:	a8 f3       	brcs	.-22     	; 0x20d4 <uip_init+0x4>
    20ea:	20 e0       	ldi	r18, 0x00	; 0
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    20ec:	41 e7       	ldi	r20, 0x71	; 113
    20ee:	50 e0       	ldi	r21, 0x00	; 0
    20f0:	0d c0       	rjmp	.+26     	; 0x210c <__stack+0xd>
    20f2:	82 2f       	mov	r24, r18
    20f4:	90 e0       	ldi	r25, 0x00	; 0
    20f6:	84 9f       	mul	r24, r20
    20f8:	f0 01       	movw	r30, r0
    20fa:	85 9f       	mul	r24, r21
    20fc:	f0 0d       	add	r31, r0
    20fe:	94 9f       	mul	r25, r20
    2100:	f0 0d       	add	r31, r0
    2102:	11 24       	eor	r1, r1
    2104:	e6 5d       	subi	r30, 0xD6	; 214
    2106:	f9 4f       	sbci	r31, 0xF9	; 249
    2108:	11 8e       	std	Z+25, r1	; 0x19
    210a:	2f 5f       	subi	r18, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    210c:	23 30       	cpi	r18, 0x03	; 3
    210e:	88 f3       	brcs	.-30     	; 0x20f2 <uip_init+0x22>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    2110:	80 e0       	ldi	r24, 0x00	; 0
    2112:	94 e0       	ldi	r25, 0x04	; 4
    2114:	90 93 61 03 	sts	0x0361, r25
    2118:	80 93 60 03 	sts	0x0360, r24
#endif /* UIP_ACTIVE_OPEN */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    211c:	10 92 86 0d 	sts	0x0D86, r1
    2120:	10 92 85 0d 	sts	0x0D85, r1
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	80 93 62 03 	sts	0x0362, r24
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    212a:	08 95       	ret

0000212c <uip_listen>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
    212c:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    212e:	10 92 62 03 	sts	0x0362, r1
    2132:	20 e0       	ldi	r18, 0x00	; 0
    2134:	12 c0       	rjmp	.+36     	; 0x215a <uip_listen+0x2e>
    if(uip_listenports[c] == 0) {
    2136:	e2 2f       	mov	r30, r18
    2138:	f0 e0       	ldi	r31, 0x00	; 0
    213a:	32 2f       	mov	r19, r18
    213c:	3f 5f       	subi	r19, 0xFF	; 255
    213e:	ee 0f       	add	r30, r30
    2140:	ff 1f       	adc	r31, r31
    2142:	e3 58       	subi	r30, 0x83	; 131
    2144:	f8 4f       	sbci	r31, 0xF8	; 248
    2146:	80 81       	ld	r24, Z
    2148:	91 81       	ldd	r25, Z+1	; 0x01
    214a:	89 2b       	or	r24, r25
    214c:	29 f4       	brne	.+10     	; 0x2158 <uip_listen+0x2c>
    214e:	20 93 62 03 	sts	0x0362, r18
      uip_listenports[c] = port;
    2152:	51 83       	std	Z+1, r21	; 0x01
    2154:	40 83       	st	Z, r20
    2156:	08 95       	ret
      return;
    2158:	23 2f       	mov	r18, r19
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    215a:	25 30       	cpi	r18, 0x05	; 5
    215c:	60 f3       	brcs	.-40     	; 0x2136 <uip_listen+0xa>
    215e:	20 93 62 03 	sts	0x0362, r18
    2162:	08 95       	ret

00002164 <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    2164:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    2166:	80 91 28 06 	lds	r24, 0x0628
    216a:	90 91 29 06 	lds	r25, 0x0629
    216e:	08 96       	adiw	r24, 0x08	; 8
    2170:	50 df       	rcall	.-352    	; 0x2012 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    2172:	e0 91 28 06 	lds	r30, 0x0628
    2176:	f0 91 29 06 	lds	r31, 0x0629
    217a:	80 91 1f 06 	lds	r24, 0x061F
    217e:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    2180:	e0 91 28 06 	lds	r30, 0x0628
    2184:	f0 91 29 06 	lds	r31, 0x0629
    2188:	80 91 20 06 	lds	r24, 0x0620
    218c:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    218e:	e0 91 28 06 	lds	r30, 0x0628
    2192:	f0 91 29 06 	lds	r31, 0x0629
    2196:	80 91 21 06 	lds	r24, 0x0621
    219a:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    219c:	e0 91 28 06 	lds	r30, 0x0628
    21a0:	f0 91 29 06 	lds	r31, 0x0629
    21a4:	80 91 22 06 	lds	r24, 0x0622
    21a8:	83 87       	std	Z+11, r24	; 0x0b
}
    21aa:	08 95       	ret

000021ac <htons>:
  return;
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
    21ac:	9c 01       	movw	r18, r24
    21ae:	92 2f       	mov	r25, r18
    21b0:	83 2f       	mov	r24, r19
  return HTONS(val);
}
    21b2:	08 95       	ret

000021b4 <uip_tcpchksum>:
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
    21b4:	0f 93       	push	r16
    21b6:	1f 93       	push	r17
  u16_t sum;

#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    21b8:	00 91 a4 07 	lds	r16, 0x07A4
    21bc:	10 e0       	ldi	r17, 0x00	; 0
    21be:	04 51       	subi	r16, 0x14	; 20
    21c0:	10 40       	sbci	r17, 0x00	; 0
    21c2:	80 91 a3 07 	lds	r24, 0x07A3
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	98 2f       	mov	r25, r24
    21ca:	88 27       	eor	r24, r24
    21cc:	08 0f       	add	r16, r24
    21ce:	19 1f       	adc	r17, r25
  /* First sum pseudoheader. */

  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
    21d0:	c8 01       	movw	r24, r16
    21d2:	06 96       	adiw	r24, 0x06	; 6
    21d4:	6d ea       	ldi	r22, 0xAD	; 173
    21d6:	77 e0       	ldi	r23, 0x07	; 7
    21d8:	48 e0       	ldi	r20, 0x08	; 8
    21da:	50 e0       	ldi	r21, 0x00	; 0
    21dc:	52 df       	rcall	.-348    	; 0x2082 <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    21de:	65 eb       	ldi	r22, 0xB5	; 181
    21e0:	77 e0       	ldi	r23, 0x07	; 7
    21e2:	a8 01       	movw	r20, r16
    21e4:	4e df       	rcall	.-356    	; 0x2082 <chksum>
	       upper_layer_len);

  return (sum == 0) ? 0xffff : htons(sum);
    21e6:	00 97       	sbiw	r24, 0x00	; 0
    21e8:	19 f4       	brne	.+6      	; 0x21f0 <uip_tcpchksum+0x3c>
    21ea:	8f ef       	ldi	r24, 0xFF	; 255
    21ec:	9f ef       	ldi	r25, 0xFF	; 255
    21ee:	01 c0       	rjmp	.+2      	; 0x21f2 <uip_tcpchksum+0x3e>
    21f0:	dd df       	rcall	.-70     	; 0x21ac <htons>
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
}
    21f2:	1f 91       	pop	r17
    21f4:	0f 91       	pop	r16
    21f6:	08 95       	ret

000021f8 <uip_ipchksum>:
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    21f8:	80 e0       	ldi	r24, 0x00	; 0
    21fa:	90 e0       	ldi	r25, 0x00	; 0
    21fc:	61 ea       	ldi	r22, 0xA1	; 161
    21fe:	77 e0       	ldi	r23, 0x07	; 7
    2200:	44 e1       	ldi	r20, 0x14	; 20
    2202:	50 e0       	ldi	r21, 0x00	; 0
    2204:	3e df       	rcall	.-388    	; 0x2082 <chksum>
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    2206:	00 97       	sbiw	r24, 0x00	; 0
    2208:	19 f4       	brne	.+6      	; 0x2210 <uip_ipchksum+0x18>
    220a:	8f ef       	ldi	r24, 0xFF	; 255
    220c:	9f ef       	ldi	r25, 0xFF	; 255
    220e:	08 95       	ret
}
    2210:	cd cf       	rjmp	.-102    	; 0x21ac <htons>

00002212 <uip_chksum>:
  return sum;
}
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
    2212:	9c 01       	movw	r18, r24
    2214:	ab 01       	movw	r20, r22
  return htons(chksum(0, (u8_t *)data, len));
    2216:	80 e0       	ldi	r24, 0x00	; 0
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	b9 01       	movw	r22, r18
    221c:	32 df       	rcall	.-412    	; 0x2082 <chksum>
}
    221e:	c6 cf       	rjmp	.-116    	; 0x21ac <htons>

00002220 <uip_send>:
  return HTONL(val);
}
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    2220:	9c 01       	movw	r18, r24
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
    2222:	80 91 1d 06 	lds	r24, 0x061D
    2226:	90 91 1e 06 	lds	r25, 0x061E
    222a:	4d e7       	ldi	r20, 0x7D	; 125
    222c:	5d e0       	ldi	r21, 0x0D	; 13
    222e:	48 1b       	sub	r20, r24
    2230:	59 0b       	sbc	r21, r25
    2232:	64 17       	cp	r22, r20
    2234:	75 07       	cpc	r23, r21
    2236:	0c f4       	brge	.+2      	; 0x223a <uip_send+0x1a>
    2238:	ab 01       	movw	r20, r22
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
    223a:	14 16       	cp	r1, r20
    223c:	15 06       	cpc	r1, r21
    223e:	54 f4       	brge	.+20     	; 0x2254 <uip_send+0x34>
    uip_slen = copylen;
    2240:	50 93 80 0d 	sts	0x0D80, r21
    2244:	40 93 7f 0d 	sts	0x0D7F, r20
    if(data != uip_sappdata) {
    2248:	28 17       	cp	r18, r24
    224a:	39 07       	cpc	r19, r25
    224c:	19 f0       	breq	.+6      	; 0x2254 <uip_send+0x34>
      memcpy(uip_sappdata, (data), uip_slen);
    224e:	b9 01       	movw	r22, r18
    2250:	0c 94 24 3d 	jmp	0x7a48	; 0x7a48 <memcpy>
    2254:	08 95       	ret

00002256 <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    2256:	0f 93       	push	r16
    2258:	1f 93       	push	r17
    225a:	cf 93       	push	r28
    225c:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    225e:	c0 91 28 06 	lds	r28, 0x0628
    2262:	d0 91 29 06 	lds	r29, 0x0629

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    2266:	84 30       	cpi	r24, 0x04	; 4
    2268:	09 f4       	brne	.+2      	; 0x226c <uip_process+0x16>
    226a:	73 c2       	rjmp	.+1254   	; 0x2752 <uip_process+0x4fc>
    goto udp_send;
  }
#endif /* UIP_UDP */

  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    226c:	29 ec       	ldi	r18, 0xC9	; 201
    226e:	37 e0       	ldi	r19, 0x07	; 7
    2270:	30 93 27 06 	sts	0x0627, r19
    2274:	20 93 26 06 	sts	0x0626, r18
    2278:	30 93 1e 06 	sts	0x061E, r19
    227c:	20 93 1d 06 	sts	0x061D, r18

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    2280:	83 30       	cpi	r24, 0x03	; 3
    2282:	59 f4       	brne	.+22     	; 0x229a <uip_process+0x44>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    2284:	89 8d       	ldd	r24, Y+25	; 0x19
    2286:	8f 70       	andi	r24, 0x0F	; 15
    2288:	83 30       	cpi	r24, 0x03	; 3
    228a:	09 f0       	breq	.+2      	; 0x228e <uip_process+0x38>
    228c:	b4 c7       	rjmp	.+3944   	; 0x31f6 <uip_process+0xfa0>
    228e:	88 89       	ldd	r24, Y+16	; 0x10
    2290:	99 89       	ldd	r25, Y+17	; 0x11
    2292:	89 2b       	or	r24, r25
    2294:	09 f0       	breq	.+2      	; 0x2298 <uip_process+0x42>
    2296:	af c7       	rjmp	.+3934   	; 0x31f6 <uip_process+0xfa0>
    2298:	89 c0       	rjmp	.+274    	; 0x23ac <uip_process+0x156>
	goto appsend;
    }
    goto drop;

    /* Check if we were invoked because of the periodic timer firing. */
  } else if(flag == UIP_TIMER) {
    229a:	82 30       	cpi	r24, 0x02	; 2
    229c:	09 f0       	breq	.+2      	; 0x22a0 <uip_process+0x4a>
    229e:	92 c0       	rjmp	.+292    	; 0x23c4 <uip_process+0x16e>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    22a0:	80 91 5f 03 	lds	r24, 0x035F
    22a4:	8f 5f       	subi	r24, 0xFF	; 255
    22a6:	80 93 5f 03 	sts	0x035F, r24
    22aa:	88 23       	and	r24, r24
    22ac:	99 f4       	brne	.+38     	; 0x22d4 <uip_process+0x7e>
      if(++iss[2] == 0) {
    22ae:	80 91 5e 03 	lds	r24, 0x035E
    22b2:	8f 5f       	subi	r24, 0xFF	; 255
    22b4:	80 93 5e 03 	sts	0x035E, r24
    22b8:	88 23       	and	r24, r24
    22ba:	61 f4       	brne	.+24     	; 0x22d4 <uip_process+0x7e>
	if(++iss[1] == 0) {
    22bc:	80 91 5d 03 	lds	r24, 0x035D
    22c0:	8f 5f       	subi	r24, 0xFF	; 255
    22c2:	80 93 5d 03 	sts	0x035D, r24
    22c6:	88 23       	and	r24, r24
    22c8:	29 f4       	brne	.+10     	; 0x22d4 <uip_process+0x7e>
	  ++iss[0];
    22ca:	80 91 5c 03 	lds	r24, 0x035C
    22ce:	8f 5f       	subi	r24, 0xFF	; 255
    22d0:	80 93 5c 03 	sts	0x035C, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    22d4:	10 92 1c 06 	sts	0x061C, r1
    22d8:	10 92 1b 06 	sts	0x061B, r1
    uip_slen = 0;
    22dc:	10 92 80 0d 	sts	0x0D80, r1
    22e0:	10 92 7f 0d 	sts	0x0D7F, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    22e4:	29 8d       	ldd	r18, Y+25	; 0x19
    22e6:	27 30       	cpi	r18, 0x07	; 7
    22e8:	11 f0       	breq	.+4      	; 0x22ee <uip_process+0x98>
    22ea:	25 30       	cpi	r18, 0x05	; 5
    22ec:	41 f4       	brne	.+16     	; 0x22fe <uip_process+0xa8>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    22ee:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22f0:	8f 5f       	subi	r24, 0xFF	; 255
    22f2:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    22f4:	88 37       	cpi	r24, 0x78	; 120
    22f6:	09 f0       	breq	.+2      	; 0x22fa <uip_process+0xa4>
    22f8:	7e c7       	rjmp	.+3836   	; 0x31f6 <uip_process+0xfa0>
	uip_connr->tcpstateflags = UIP_CLOSED;
    22fa:	19 8e       	std	Y+25, r1	; 0x19
    22fc:	7c c7       	rjmp	.+3832   	; 0x31f6 <uip_process+0xfa0>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    22fe:	22 23       	and	r18, r18
    2300:	09 f4       	brne	.+2      	; 0x2304 <uip_process+0xae>
    2302:	79 c7       	rjmp	.+3826   	; 0x31f6 <uip_process+0xfa0>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    2304:	88 89       	ldd	r24, Y+16	; 0x10
    2306:	99 89       	ldd	r25, Y+17	; 0x11
    2308:	89 2b       	or	r24, r25
    230a:	09 f4       	brne	.+2      	; 0x230e <uip_process+0xb8>
    230c:	4b c0       	rjmp	.+150    	; 0x23a4 <uip_process+0x14e>
	if(uip_connr->timer-- == 0) {
    230e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2310:	81 50       	subi	r24, 0x01	; 1
    2312:	8a 8f       	std	Y+26, r24	; 0x1a
    2314:	8f 5f       	subi	r24, 0xFF	; 255
    2316:	09 f0       	breq	.+2      	; 0x231a <uip_process+0xc4>
    2318:	6e c7       	rjmp	.+3804   	; 0x31f6 <uip_process+0xfa0>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    231a:	3b 8d       	ldd	r19, Y+27	; 0x1b
    231c:	38 30       	cpi	r19, 0x08	; 8
    231e:	29 f0       	breq	.+10     	; 0x232a <uip_process+0xd4>
    2320:	21 50       	subi	r18, 0x01	; 1
    2322:	22 30       	cpi	r18, 0x02	; 2
    2324:	48 f4       	brcc	.+18     	; 0x2338 <uip_process+0xe2>
    2326:	35 30       	cpi	r19, 0x05	; 5
    2328:	39 f4       	brne	.+14     	; 0x2338 <uip_process+0xe2>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    232a:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    232c:	80 e8       	ldi	r24, 0x80	; 128
    232e:	80 93 23 06 	sts	0x0623, r24
	    UIP_APPCALL();
    2332:	0e 94 4b 08 	call	0x1096	; 0x1096 <uIPManagement_TCPCallback>
    2336:	14 c6       	rjmp	.+3112   	; 0x2f60 <uip_process+0xd0a>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential back-off. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    2338:	35 30       	cpi	r19, 0x05	; 5
    233a:	10 f0       	brcs	.+4      	; 0x2340 <uip_process+0xea>
    233c:	80 e3       	ldi	r24, 0x30	; 48
    233e:	07 c0       	rjmp	.+14     	; 0x234e <uip_process+0xf8>
    2340:	83 e0       	ldi	r24, 0x03	; 3
    2342:	90 e0       	ldi	r25, 0x00	; 0
    2344:	02 c0       	rjmp	.+4      	; 0x234a <uip_process+0xf4>
    2346:	88 0f       	add	r24, r24
    2348:	99 1f       	adc	r25, r25
    234a:	3a 95       	dec	r19
    234c:	e2 f7       	brpl	.-8      	; 0x2346 <uip_process+0xf0>
    234e:	8a 8f       	std	Y+26, r24	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    2350:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2352:	8f 5f       	subi	r24, 0xFF	; 255
    2354:	8b 8f       	std	Y+27, r24	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    2356:	89 8d       	ldd	r24, Y+25	; 0x19
    2358:	90 e0       	ldi	r25, 0x00	; 0
    235a:	8f 70       	andi	r24, 0x0F	; 15
    235c:	90 70       	andi	r25, 0x00	; 0
    235e:	83 30       	cpi	r24, 0x03	; 3
    2360:	91 05       	cpc	r25, r1
    2362:	d1 f0       	breq	.+52     	; 0x2398 <uip_process+0x142>
    2364:	84 30       	cpi	r24, 0x04	; 4
    2366:	91 05       	cpc	r25, r1
    2368:	44 f4       	brge	.+16     	; 0x237a <uip_process+0x124>
    236a:	81 30       	cpi	r24, 0x01	; 1
    236c:	91 05       	cpc	r25, r1
    236e:	09 f4       	brne	.+2      	; 0x2372 <uip_process+0x11c>
    2370:	de c3       	rjmp	.+1980   	; 0x2b2e <uip_process+0x8d8>
    2372:	02 97       	sbiw	r24, 0x02	; 2
    2374:	09 f0       	breq	.+2      	; 0x2378 <uip_process+0x122>
    2376:	3f c7       	rjmp	.+3710   	; 0x31f6 <uip_process+0xfa0>
    2378:	0c c0       	rjmp	.+24     	; 0x2392 <uip_process+0x13c>
    237a:	86 30       	cpi	r24, 0x06	; 6
    237c:	91 05       	cpc	r25, r1
    237e:	09 f4       	brne	.+2      	; 0x2382 <uip_process+0x12c>
    2380:	84 c5       	rjmp	.+2824   	; 0x2e8a <uip_process+0xc34>
    2382:	88 30       	cpi	r24, 0x08	; 8
    2384:	91 05       	cpc	r25, r1
    2386:	09 f4       	brne	.+2      	; 0x238a <uip_process+0x134>
    2388:	80 c5       	rjmp	.+2816   	; 0x2e8a <uip_process+0xc34>
    238a:	04 97       	sbiw	r24, 0x04	; 4
    238c:	09 f0       	breq	.+2      	; 0x2390 <uip_process+0x13a>
    238e:	33 c7       	rjmp	.+3686   	; 0x31f6 <uip_process+0xfa0>
    2390:	7c c5       	rjmp	.+2808   	; 0x2e8a <uip_process+0xc34>
	    goto tcp_send_synack;

#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    2392:	10 92 c2 07 	sts	0x07C2, r1
    2396:	ce c3       	rjmp	.+1948   	; 0x2b34 <uip_process+0x8de>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    2398:	84 e0       	ldi	r24, 0x04	; 4
    239a:	80 93 23 06 	sts	0x0623, r24
	    UIP_APPCALL();
    239e:	0e 94 4b 08 	call	0x1096	; 0x1096 <uIPManagement_TCPCallback>
    23a2:	13 c6       	rjmp	.+3110   	; 0x2fca <uip_process+0xd74>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;

	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    23a4:	2f 70       	andi	r18, 0x0F	; 15
    23a6:	23 30       	cpi	r18, 0x03	; 3
    23a8:	09 f0       	breq	.+2      	; 0x23ac <uip_process+0x156>
    23aa:	25 c7       	rjmp	.+3658   	; 0x31f6 <uip_process+0xfa0>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_len = uip_slen = 0;
    23ac:	10 92 80 0d 	sts	0x0D80, r1
    23b0:	10 92 7f 0d 	sts	0x0D7F, r1
    23b4:	10 92 1c 06 	sts	0x061C, r1
    23b8:	10 92 1b 06 	sts	0x061B, r1
	uip_flags = UIP_POLL;
    23bc:	88 e0       	ldi	r24, 0x08	; 8
    23be:	80 93 23 06 	sts	0x0623, r24
    23c2:	c2 c5       	rjmp	.+2948   	; 0x2f48 <uip_process+0xcf2>
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    23c4:	85 30       	cpi	r24, 0x05	; 5
    23c6:	19 f5       	brne	.+70     	; 0x240e <uip_process+0x1b8>
    if(uip_udp_conn->lport != 0) {
    23c8:	e0 91 24 06 	lds	r30, 0x0624
    23cc:	f0 91 25 06 	lds	r31, 0x0625
    23d0:	84 81       	ldd	r24, Z+4	; 0x04
    23d2:	95 81       	ldd	r25, Z+5	; 0x05
    23d4:	89 2b       	or	r24, r25
    23d6:	09 f4       	brne	.+2      	; 0x23da <uip_process+0x184>
    23d8:	0e c7       	rjmp	.+3612   	; 0x31f6 <uip_process+0xfa0>
      uip_conn = NULL;
    23da:	10 92 29 06 	sts	0x0629, r1
    23de:	10 92 28 06 	sts	0x0628, r1
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    23e2:	c9 01       	movw	r24, r18
    23e4:	0c 97       	sbiw	r24, 0x0c	; 12
    23e6:	90 93 27 06 	sts	0x0627, r25
    23ea:	80 93 26 06 	sts	0x0626, r24
    23ee:	90 93 1e 06 	sts	0x061E, r25
    23f2:	80 93 1d 06 	sts	0x061D, r24
      uip_len = uip_slen = 0;
    23f6:	10 92 80 0d 	sts	0x0D80, r1
    23fa:	10 92 7f 0d 	sts	0x0D7F, r1
    23fe:	10 92 1c 06 	sts	0x061C, r1
    2402:	10 92 1b 06 	sts	0x061B, r1
      uip_flags = UIP_POLL;
    2406:	88 e0       	ldi	r24, 0x08	; 8
    2408:	80 93 23 06 	sts	0x0623, r24
    240c:	a0 c1       	rjmp	.+832    	; 0x274e <uip_process+0x4f8>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    240e:	89 01       	movw	r16, r18
    2410:	08 52       	subi	r16, 0x28	; 40
    2412:	10 40       	sbci	r17, 0x00	; 0
    2414:	80 91 a1 07 	lds	r24, 0x07A1
    2418:	85 34       	cpi	r24, 0x45	; 69
    241a:	09 f0       	breq	.+2      	; 0x241e <uip_process+0x1c8>
    241c:	ec c6       	rjmp	.+3544   	; 0x31f6 <uip_process+0xfa0>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    241e:	80 91 a3 07 	lds	r24, 0x07A3
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	38 2f       	mov	r19, r24
    2426:	22 27       	eor	r18, r18
    2428:	80 91 a4 07 	lds	r24, 0x07A4
    242c:	28 0f       	add	r18, r24
    242e:	31 1d       	adc	r19, r1
    2430:	80 91 1b 06 	lds	r24, 0x061B
    2434:	90 91 1c 06 	lds	r25, 0x061C
    2438:	82 17       	cp	r24, r18
    243a:	93 07       	cpc	r25, r19
    243c:	08 f4       	brcc	.+2      	; 0x2440 <uip_process+0x1ea>
    243e:	db c6       	rjmp	.+3510   	; 0x31f6 <uip_process+0xfa0>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    2440:	30 93 1c 06 	sts	0x061C, r19
    2444:	20 93 1b 06 	sts	0x061B, r18
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    2448:	80 91 a7 07 	lds	r24, 0x07A7
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	8f 73       	andi	r24, 0x3F	; 63
    2450:	90 70       	andi	r25, 0x00	; 0
    2452:	89 2b       	or	r24, r25
    2454:	09 f0       	breq	.+2      	; 0x2458 <uip_process+0x202>
    2456:	cf c6       	rjmp	.+3486   	; 0x31f6 <uip_process+0xfa0>
    2458:	80 91 a8 07 	lds	r24, 0x07A8
    245c:	88 23       	and	r24, r24
    245e:	09 f0       	breq	.+2      	; 0x2462 <uip_process+0x20c>
    2460:	ca c6       	rjmp	.+3476   	; 0x31f6 <uip_process+0xfa0>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    2462:	40 91 8f 07 	lds	r20, 0x078F
    2466:	50 91 90 07 	lds	r21, 0x0790
    246a:	c0 91 19 03 	lds	r28, 0x0319
    246e:	d0 91 1a 03 	lds	r29, 0x031A
    2472:	4c 17       	cp	r20, r28
    2474:	5d 07       	cpc	r21, r29
    2476:	61 f4       	brne	.+24     	; 0x2490 <uip_process+0x23a>
    2478:	20 91 91 07 	lds	r18, 0x0791
    247c:	30 91 92 07 	lds	r19, 0x0792
    2480:	80 91 1b 03 	lds	r24, 0x031B
    2484:	90 91 1c 03 	lds	r25, 0x031C
    2488:	28 17       	cp	r18, r24
    248a:	39 07       	cpc	r19, r25
    248c:	09 f4       	brne	.+2      	; 0x2490 <uip_process+0x23a>
    248e:	4c c0       	rjmp	.+152    	; 0x2528 <uip_process+0x2d2>
  } else {
    /* If IP broadcast support is configured, we check for a broadcast
       UDP packet, which may be destined to us. */
#if UIP_BROADCAST
    DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
    if(BUF->proto == UIP_PROTO_UDP &&
    2490:	80 91 aa 07 	lds	r24, 0x07AA
    2494:	81 31       	cpi	r24, 0x11	; 17
    2496:	a1 f5       	brne	.+104    	; 0x2500 <uip_process+0x2aa>
    2498:	20 91 b1 07 	lds	r18, 0x07B1
    249c:	30 91 b2 07 	lds	r19, 0x07B2
    24a0:	80 91 15 03 	lds	r24, 0x0315
    24a4:	90 91 16 03 	lds	r25, 0x0316
    24a8:	28 17       	cp	r18, r24
    24aa:	39 07       	cpc	r19, r25
    24ac:	49 f5       	brne	.+82     	; 0x2500 <uip_process+0x2aa>
    24ae:	20 91 b3 07 	lds	r18, 0x07B3
    24b2:	30 91 b4 07 	lds	r19, 0x07B4
    24b6:	80 91 17 03 	lds	r24, 0x0317
    24ba:	90 91 18 03 	lds	r25, 0x0318
    24be:	28 17       	cp	r18, r24
    24c0:	39 07       	cpc	r19, r25
    24c2:	f1 f4       	brne	.+60     	; 0x2500 <uip_process+0x2aa>
       uip_ipaddr_cmp(&BUF->destipaddr, &uip_broadcast_addr))
	{
		if (uip_ipaddr_cmp(&BUF->srcipaddr, &uip_all_zeroes_addr))
    24c4:	80 91 ad 07 	lds	r24, 0x07AD
    24c8:	90 91 ae 07 	lds	r25, 0x07AE
    24cc:	8c 17       	cp	r24, r28
    24ce:	9d 07       	cpc	r25, r29
    24d0:	09 f0       	breq	.+2      	; 0x24d4 <uip_process+0x27e>
    24d2:	73 c0       	rjmp	.+230    	; 0x25ba <uip_process+0x364>
    24d4:	20 91 af 07 	lds	r18, 0x07AF
    24d8:	30 91 b0 07 	lds	r19, 0x07B0
    24dc:	80 91 1b 03 	lds	r24, 0x031B
    24e0:	90 91 1c 03 	lds	r25, 0x031C
    24e4:	28 17       	cp	r18, r24
    24e6:	39 07       	cpc	r19, r25
    24e8:	09 f0       	breq	.+2      	; 0x24ec <uip_process+0x296>
    24ea:	67 c0       	rjmp	.+206    	; 0x25ba <uip_process+0x364>
		  uip_ipaddr_copy(&BUF->srcipaddr, &uip_broadcast_addr);
    24ec:	8f ef       	ldi	r24, 0xFF	; 255
    24ee:	80 93 ad 07 	sts	0x07AD, r24
    24f2:	80 93 ae 07 	sts	0x07AE, r24
    24f6:	80 93 af 07 	sts	0x07AF, r24
    24fa:	80 93 b0 07 	sts	0x07B0, r24
    24fe:	5d c0       	rjmp	.+186    	; 0x25ba <uip_process+0x364>
    }
#endif /* UIP_BROADCAST */

    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
    2500:	80 91 b1 07 	lds	r24, 0x07B1
    2504:	90 91 b2 07 	lds	r25, 0x07B2
    2508:	84 17       	cp	r24, r20
    250a:	95 07       	cpc	r25, r21
    250c:	09 f0       	breq	.+2      	; 0x2510 <uip_process+0x2ba>
    250e:	73 c6       	rjmp	.+3302   	; 0x31f6 <uip_process+0xfa0>
    2510:	20 91 b3 07 	lds	r18, 0x07B3
    2514:	30 91 b4 07 	lds	r19, 0x07B4
    2518:	80 91 91 07 	lds	r24, 0x0791
    251c:	90 91 92 07 	lds	r25, 0x0792
    2520:	28 17       	cp	r18, r24
    2522:	39 07       	cpc	r19, r25
    2524:	09 f0       	breq	.+2      	; 0x2528 <uip_process+0x2d2>
    2526:	67 c6       	rjmp	.+3278   	; 0x31f6 <uip_process+0xfa0>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    2528:	67 de       	rcall	.-818    	; 0x21f8 <uip_ipchksum>
    252a:	8f 5f       	subi	r24, 0xFF	; 255
    252c:	9f 4f       	sbci	r25, 0xFF	; 255
    252e:	09 f0       	breq	.+2      	; 0x2532 <uip_process+0x2dc>
    2530:	62 c6       	rjmp	.+3268   	; 0x31f6 <uip_process+0xfa0>
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    2532:	80 91 aa 07 	lds	r24, 0x07AA
    2536:	86 30       	cpi	r24, 0x06	; 6
    2538:	09 f4       	brne	.+2      	; 0x253c <uip_process+0x2e6>
    253a:	65 c1       	rjmp	.+714    	; 0x2806 <uip_process+0x5b0>
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    253c:	81 31       	cpi	r24, 0x11	; 17
    253e:	e9 f1       	breq	.+122    	; 0x25ba <uip_process+0x364>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    2540:	81 30       	cpi	r24, 0x01	; 1
    2542:	09 f0       	breq	.+2      	; 0x2546 <uip_process+0x2f0>
    2544:	58 c6       	rjmp	.+3248   	; 0x31f6 <uip_process+0xfa0>
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    2546:	80 91 b5 07 	lds	r24, 0x07B5
    254a:	88 30       	cpi	r24, 0x08	; 8
    254c:	09 f0       	breq	.+2      	; 0x2550 <uip_process+0x2fa>
    254e:	53 c6       	rjmp	.+3238   	; 0x31f6 <uip_process+0xfa0>
  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    uip_hostaddr = BUF->destipaddr;
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    2550:	10 92 b5 07 	sts	0x07B5, r1

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    2554:	80 91 b7 07 	lds	r24, 0x07B7
    2558:	90 91 b8 07 	lds	r25, 0x07B8
    255c:	ef ef       	ldi	r30, 0xFF	; 255
    255e:	87 3f       	cpi	r24, 0xF7	; 247
    2560:	9e 07       	cpc	r25, r30
    2562:	10 f0       	brcs	.+4      	; 0x2568 <uip_process+0x312>
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    2564:	09 96       	adiw	r24, 0x09	; 9
    2566:	01 c0       	rjmp	.+2      	; 0x256a <uip_process+0x314>
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    2568:	08 96       	adiw	r24, 0x08	; 8
    256a:	90 93 b8 07 	sts	0x07B8, r25
    256e:	80 93 b7 07 	sts	0x07B7, r24
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    2572:	80 91 ad 07 	lds	r24, 0x07AD
    2576:	90 91 ae 07 	lds	r25, 0x07AE
    257a:	a0 91 af 07 	lds	r26, 0x07AF
    257e:	b0 91 b0 07 	lds	r27, 0x07B0
    2582:	80 93 b1 07 	sts	0x07B1, r24
    2586:	90 93 b2 07 	sts	0x07B2, r25
    258a:	a0 93 b3 07 	sts	0x07B3, r26
    258e:	b0 93 b4 07 	sts	0x07B4, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2592:	80 91 8f 07 	lds	r24, 0x078F
    2596:	90 91 90 07 	lds	r25, 0x0790
    259a:	a0 91 91 07 	lds	r26, 0x0791
    259e:	b0 91 92 07 	lds	r27, 0x0792
    25a2:	80 93 ad 07 	sts	0x07AD, r24
    25a6:	90 93 ae 07 	sts	0x07AE, r25
    25aa:	a0 93 af 07 	sts	0x07AF, r26
    25ae:	b0 93 b0 07 	sts	0x07B0, r27

  UIP_STAT(++uip_stat.icmp.sent);
  BUF->ttl = UIP_TTL;
    25b2:	80 e4       	ldi	r24, 0x40	; 64
    25b4:	f8 01       	movw	r30, r16
    25b6:	80 87       	std	Z+8, r24	; 0x08
    25b8:	fa c5       	rjmp	.+3060   	; 0x31ae <uip_process+0xf58>
    UIP_STAT(++uip_stat.udp.chkerr);
    UIP_LOG("udp: bad checksum.");
    goto drop;
  }
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
    25ba:	80 91 1b 06 	lds	r24, 0x061B
    25be:	90 91 1c 06 	lds	r25, 0x061C
    25c2:	4c 97       	sbiw	r24, 0x1c	; 28
    25c4:	90 93 1c 06 	sts	0x061C, r25
    25c8:	80 93 1b 06 	sts	0x061B, r24
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    25cc:	81 e8       	ldi	r24, 0x81	; 129
    25ce:	9d e0       	ldi	r25, 0x0D	; 13
    25d0:	90 93 25 06 	sts	0x0625, r25
    25d4:	80 93 24 06 	sts	0x0624, r24
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    25d8:	a0 91 1b 03 	lds	r26, 0x031B
    25dc:	b0 91 1c 03 	lds	r27, 0x031C
    25e0:	60 91 15 03 	lds	r22, 0x0315
    25e4:	70 91 16 03 	lds	r23, 0x0316
    25e8:	40 91 17 03 	lds	r20, 0x0317
    25ec:	50 91 18 03 	lds	r21, 0x0318
    25f0:	42 c0       	rjmp	.+132    	; 0x2676 <uip_process+0x420>
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    25f2:	24 81       	ldd	r18, Z+4	; 0x04
    25f4:	35 81       	ldd	r19, Z+5	; 0x05
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    25f6:	21 15       	cp	r18, r1
    25f8:	31 05       	cpc	r19, r1
    25fa:	c1 f1       	breq	.+112    	; 0x266c <uip_process+0x416>
    25fc:	80 91 b7 07 	lds	r24, 0x07B7
    2600:	90 91 b8 07 	lds	r25, 0x07B8
    2604:	82 17       	cp	r24, r18
    2606:	93 07       	cpc	r25, r19
    2608:	89 f5       	brne	.+98     	; 0x266c <uip_process+0x416>
    260a:	26 81       	ldd	r18, Z+6	; 0x06
    260c:	37 81       	ldd	r19, Z+7	; 0x07
    260e:	21 15       	cp	r18, r1
    2610:	31 05       	cpc	r19, r1
    2612:	39 f0       	breq	.+14     	; 0x2622 <uip_process+0x3cc>
    2614:	80 91 b5 07 	lds	r24, 0x07B5
    2618:	90 91 b6 07 	lds	r25, 0x07B6
    261c:	82 17       	cp	r24, r18
    261e:	93 07       	cpc	r25, r19
    2620:	29 f5       	brne	.+74     	; 0x266c <uip_process+0x416>
    2622:	20 81       	ld	r18, Z
    2624:	31 81       	ldd	r19, Z+1	; 0x01
    2626:	2c 17       	cp	r18, r28
    2628:	3d 07       	cpc	r19, r29
    262a:	31 f4       	brne	.+12     	; 0x2638 <uip_process+0x3e2>
    262c:	82 81       	ldd	r24, Z+2	; 0x02
    262e:	93 81       	ldd	r25, Z+3	; 0x03
    2630:	8a 17       	cp	r24, r26
    2632:	9b 07       	cpc	r25, r27
    2634:	09 f4       	brne	.+2      	; 0x2638 <uip_process+0x3e2>
    2636:	76 c0       	rjmp	.+236    	; 0x2724 <uip_process+0x4ce>
    2638:	26 17       	cp	r18, r22
    263a:	37 07       	cpc	r19, r23
    263c:	31 f4       	brne	.+12     	; 0x264a <uip_process+0x3f4>
    263e:	82 81       	ldd	r24, Z+2	; 0x02
    2640:	93 81       	ldd	r25, Z+3	; 0x03
    2642:	84 17       	cp	r24, r20
    2644:	95 07       	cpc	r25, r21
    2646:	09 f4       	brne	.+2      	; 0x264a <uip_process+0x3f4>
    2648:	6d c0       	rjmp	.+218    	; 0x2724 <uip_process+0x4ce>
    264a:	80 91 ad 07 	lds	r24, 0x07AD
    264e:	90 91 ae 07 	lds	r25, 0x07AE
    2652:	82 17       	cp	r24, r18
    2654:	93 07       	cpc	r25, r19
    2656:	51 f4       	brne	.+20     	; 0x266c <uip_process+0x416>
    2658:	20 91 af 07 	lds	r18, 0x07AF
    265c:	30 91 b0 07 	lds	r19, 0x07B0
    2660:	82 81       	ldd	r24, Z+2	; 0x02
    2662:	93 81       	ldd	r25, Z+3	; 0x03
    2664:	28 17       	cp	r18, r24
    2666:	39 07       	cpc	r19, r25
    2668:	09 f4       	brne	.+2      	; 0x266c <uip_process+0x416>
    266a:	5c c0       	rjmp	.+184    	; 0x2724 <uip_process+0x4ce>
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    266c:	7e 96       	adiw	r30, 0x1e	; 30
    266e:	f0 93 25 06 	sts	0x0625, r31
    2672:	e0 93 24 06 	sts	0x0624, r30
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    2676:	e0 91 24 06 	lds	r30, 0x0624
    267a:	f0 91 25 06 	lds	r31, 0x0625
    267e:	2d e0       	ldi	r18, 0x0D	; 13
    2680:	ef 39       	cpi	r30, 0x9F	; 159
    2682:	f2 07       	cpc	r31, r18
    2684:	08 f4       	brcc	.+2      	; 0x2688 <uip_process+0x432>
    2686:	b5 cf       	rjmp	.-150    	; 0x25f2 <uip_process+0x39c>
    }
  }
  UIP_LOG("udp: no matching connection found");
#if UIP_CONF_ICMP_DEST_UNREACH && !UIP_CONF_IPV6
  /* Copy fields from packet header into payload of this ICMP packet. */
  memcpy(&(ICMPBUF->payload[0]), ICMPBUF, UIP_IPH_LEN + 8);
    2688:	ed eb       	ldi	r30, 0xBD	; 189
    268a:	f7 e0       	ldi	r31, 0x07	; 7
    268c:	df 01       	movw	r26, r30
    268e:	5c 97       	sbiw	r26, 0x1c	; 28
    2690:	8c e1       	ldi	r24, 0x1C	; 28
    2692:	0d 90       	ld	r0, X+
    2694:	01 92       	st	Z+, r0
    2696:	81 50       	subi	r24, 0x01	; 1
    2698:	e1 f7       	brne	.-8      	; 0x2692 <uip_process+0x43c>

  /* Set the ICMP type and code. */
  ICMPBUF->type = ICMP_DEST_UNREACHABLE;
    269a:	83 e0       	ldi	r24, 0x03	; 3
    269c:	80 93 b5 07 	sts	0x07B5, r24
  ICMPBUF->icode = ICMP_PORT_UNREACHABLE;
    26a0:	80 93 b6 07 	sts	0x07B6, r24

  /* Calculate the ICMP checksum. */
  ICMPBUF->icmpchksum = 0;
    26a4:	10 92 b8 07 	sts	0x07B8, r1
    26a8:	10 92 b7 07 	sts	0x07B7, r1
  ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
    26ac:	85 eb       	ldi	r24, 0xB5	; 181
    26ae:	97 e0       	ldi	r25, 0x07	; 7
    26b0:	64 e2       	ldi	r22, 0x24	; 36
    26b2:	70 e0       	ldi	r23, 0x00	; 0
    26b4:	ae dd       	rcall	.-1188   	; 0x2212 <uip_chksum>
    26b6:	80 95       	com	r24
    26b8:	90 95       	com	r25
    26ba:	90 93 b8 07 	sts	0x07B8, r25
    26be:	80 93 b7 07 	sts	0x07B7, r24

  /* Set the IP destination address to be the source address of the
     original packet. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    26c2:	80 91 ad 07 	lds	r24, 0x07AD
    26c6:	90 91 ae 07 	lds	r25, 0x07AE
    26ca:	a0 91 af 07 	lds	r26, 0x07AF
    26ce:	b0 91 b0 07 	lds	r27, 0x07B0
    26d2:	80 93 b1 07 	sts	0x07B1, r24
    26d6:	90 93 b2 07 	sts	0x07B2, r25
    26da:	a0 93 b3 07 	sts	0x07B3, r26
    26de:	b0 93 b4 07 	sts	0x07B4, r27

  /* Set our IP address as the source address. */
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    26e2:	80 91 8f 07 	lds	r24, 0x078F
    26e6:	90 91 90 07 	lds	r25, 0x0790
    26ea:	a0 91 91 07 	lds	r26, 0x0791
    26ee:	b0 91 92 07 	lds	r27, 0x0792
    26f2:	80 93 ad 07 	sts	0x07AD, r24
    26f6:	90 93 ae 07 	sts	0x07AE, r25
    26fa:	a0 93 af 07 	sts	0x07AF, r26
    26fe:	b0 93 b0 07 	sts	0x07B0, r27

  /* The size of the ICMP destination unreachable packet is 36 + the
     size of the IP header (20) = 56. */
  uip_len = 36 + UIP_IPH_LEN;
    2702:	88 e3       	ldi	r24, 0x38	; 56
    2704:	90 e0       	ldi	r25, 0x00	; 0
    2706:	90 93 1c 06 	sts	0x061C, r25
    270a:	80 93 1b 06 	sts	0x061B, r24
  ICMPBUF->len[0] = 0;
    270e:	10 92 a3 07 	sts	0x07A3, r1
  ICMPBUF->len[1] = (u8_t)uip_len;
    2712:	80 93 a4 07 	sts	0x07A4, r24
  ICMPBUF->ttl = UIP_TTL;
    2716:	80 e4       	ldi	r24, 0x40	; 64
    2718:	80 93 a9 07 	sts	0x07A9, r24
  ICMPBUF->proto = UIP_PROTO_ICMP;
    271c:	81 e0       	ldi	r24, 0x01	; 1
    271e:	80 93 aa 07 	sts	0x07AA, r24
    2722:	45 c5       	rjmp	.+2698   	; 0x31ae <uip_process+0xf58>
#else /* UIP_CONF_ICMP_DEST_UNREACH */
  goto drop;
#endif /* UIP_CONF_ICMP_DEST_UNREACH */

 udp_found:
  uip_conn = NULL;
    2724:	10 92 29 06 	sts	0x0629, r1
    2728:	10 92 28 06 	sts	0x0628, r1
  uip_flags = UIP_NEWDATA;
    272c:	82 e0       	ldi	r24, 0x02	; 2
    272e:	80 93 23 06 	sts	0x0623, r24
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    2732:	8d eb       	ldi	r24, 0xBD	; 189
    2734:	97 e0       	ldi	r25, 0x07	; 7
    2736:	90 93 27 06 	sts	0x0627, r25
    273a:	80 93 26 06 	sts	0x0626, r24
    273e:	90 93 1e 06 	sts	0x061E, r25
    2742:	80 93 1d 06 	sts	0x061D, r24
  uip_slen = 0;
    2746:	10 92 80 0d 	sts	0x0D80, r1
    274a:	10 92 7f 0d 	sts	0x0D7F, r1
  UIP_UDP_APPCALL();
    274e:	0e 94 3b 08 	call	0x1076	; 0x1076 <uIPManagement_UDPCallback>

 udp_send:
  if(uip_slen == 0) {
    2752:	40 91 7f 0d 	lds	r20, 0x0D7F
    2756:	50 91 80 0d 	lds	r21, 0x0D80
    275a:	41 15       	cp	r20, r1
    275c:	51 05       	cpc	r21, r1
    275e:	09 f4       	brne	.+2      	; 0x2762 <uip_process+0x50c>
    2760:	4a c5       	rjmp	.+2708   	; 0x31f6 <uip_process+0xfa0>
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
    2762:	ca 01       	movw	r24, r20
    2764:	4c 96       	adiw	r24, 0x1c	; 28
    2766:	90 93 1c 06 	sts	0x061C, r25
    276a:	80 93 1b 06 	sts	0x061B, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    276e:	29 2f       	mov	r18, r25
    2770:	33 27       	eor	r19, r19
    2772:	20 93 a3 07 	sts	0x07A3, r18
  BUF->len[1] = (uip_len & 0xff);
    2776:	80 93 a4 07 	sts	0x07A4, r24
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
    277a:	e0 91 24 06 	lds	r30, 0x0624
    277e:	f0 91 25 06 	lds	r31, 0x0625
    2782:	80 85       	ldd	r24, Z+8	; 0x08
    2784:	80 93 a9 07 	sts	0x07A9, r24
  BUF->proto = UIP_PROTO_UDP;
    2788:	81 e1       	ldi	r24, 0x11	; 17
    278a:	80 93 aa 07 	sts	0x07AA, r24

  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
    278e:	9a 01       	movw	r18, r20
    2790:	28 5f       	subi	r18, 0xF8	; 248
    2792:	3f 4f       	sbci	r19, 0xFF	; 255
    2794:	92 2f       	mov	r25, r18
    2796:	83 2f       	mov	r24, r19
    2798:	90 93 ba 07 	sts	0x07BA, r25
    279c:	80 93 b9 07 	sts	0x07B9, r24
  UDPBUF->udpchksum = 0;
    27a0:	10 92 bc 07 	sts	0x07BC, r1
    27a4:	10 92 bb 07 	sts	0x07BB, r1

  BUF->srcport  = uip_udp_conn->lport;
    27a8:	84 81       	ldd	r24, Z+4	; 0x04
    27aa:	95 81       	ldd	r25, Z+5	; 0x05
    27ac:	90 93 b6 07 	sts	0x07B6, r25
    27b0:	80 93 b5 07 	sts	0x07B5, r24
  BUF->destport = uip_udp_conn->rport;
    27b4:	86 81       	ldd	r24, Z+6	; 0x06
    27b6:	97 81       	ldd	r25, Z+7	; 0x07
    27b8:	90 93 b8 07 	sts	0x07B8, r25
    27bc:	80 93 b7 07 	sts	0x07B7, r24

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    27c0:	80 91 8f 07 	lds	r24, 0x078F
    27c4:	90 91 90 07 	lds	r25, 0x0790
    27c8:	a0 91 91 07 	lds	r26, 0x0791
    27cc:	b0 91 92 07 	lds	r27, 0x0792
    27d0:	80 93 ad 07 	sts	0x07AD, r24
    27d4:	90 93 ae 07 	sts	0x07AE, r25
    27d8:	a0 93 af 07 	sts	0x07AF, r26
    27dc:	b0 93 b0 07 	sts	0x07B0, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
    27e0:	80 81       	ld	r24, Z
    27e2:	91 81       	ldd	r25, Z+1	; 0x01
    27e4:	a2 81       	ldd	r26, Z+2	; 0x02
    27e6:	b3 81       	ldd	r27, Z+3	; 0x03
    27e8:	80 93 b1 07 	sts	0x07B1, r24
    27ec:	90 93 b2 07 	sts	0x07B2, r25
    27f0:	a0 93 b3 07 	sts	0x07B3, r26
    27f4:	b0 93 b4 07 	sts	0x07B4, r27

  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
    27f8:	89 ec       	ldi	r24, 0xC9	; 201
    27fa:	97 e0       	ldi	r25, 0x07	; 7
    27fc:	90 93 27 06 	sts	0x0627, r25
    2800:	80 93 26 06 	sts	0x0626, r24
    2804:	d4 c4       	rjmp	.+2472   	; 0x31ae <uip_process+0xf58>
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */

  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    2806:	d6 dc       	rcall	.-1620   	; 0x21b4 <uip_tcpchksum>
    2808:	8f 5f       	subi	r24, 0xFF	; 255
    280a:	9f 4f       	sbci	r25, 0xFF	; 255
    280c:	09 f0       	breq	.+2      	; 0x2810 <uip_process+0x5ba>
    280e:	f3 c4       	rjmp	.+2534   	; 0x31f6 <uip_process+0xfa0>
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    UIP_STAT(++uip_stat.tcp.chkerr);
    UIP_LOG("tcp: bad checksum.");
    goto drop;
    2810:	ca e2       	ldi	r28, 0x2A	; 42
    2812:	d6 e0       	ldi	r29, 0x06	; 6

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    2814:	89 8d       	ldd	r24, Y+25	; 0x19
    2816:	88 23       	and	r24, r24
    2818:	29 f1       	breq	.+74     	; 0x2864 <uip_process+0x60e>
    281a:	20 91 b7 07 	lds	r18, 0x07B7
    281e:	30 91 b8 07 	lds	r19, 0x07B8
    2822:	8c 81       	ldd	r24, Y+4	; 0x04
    2824:	9d 81       	ldd	r25, Y+5	; 0x05
    2826:	28 17       	cp	r18, r24
    2828:	39 07       	cpc	r19, r25
    282a:	e1 f4       	brne	.+56     	; 0x2864 <uip_process+0x60e>
    282c:	20 91 b5 07 	lds	r18, 0x07B5
    2830:	30 91 b6 07 	lds	r19, 0x07B6
    2834:	8e 81       	ldd	r24, Y+6	; 0x06
    2836:	9f 81       	ldd	r25, Y+7	; 0x07
    2838:	28 17       	cp	r18, r24
    283a:	39 07       	cpc	r19, r25
    283c:	99 f4       	brne	.+38     	; 0x2864 <uip_process+0x60e>
    283e:	20 91 ad 07 	lds	r18, 0x07AD
    2842:	30 91 ae 07 	lds	r19, 0x07AE
    2846:	88 81       	ld	r24, Y
    2848:	99 81       	ldd	r25, Y+1	; 0x01
    284a:	28 17       	cp	r18, r24
    284c:	39 07       	cpc	r19, r25
    284e:	51 f4       	brne	.+20     	; 0x2864 <uip_process+0x60e>
    2850:	20 91 af 07 	lds	r18, 0x07AF
    2854:	30 91 b0 07 	lds	r19, 0x07B0
    2858:	8a 81       	ldd	r24, Y+2	; 0x02
    285a:	9b 81       	ldd	r25, Y+3	; 0x03
    285c:	28 17       	cp	r18, r24
    285e:	39 07       	cpc	r19, r25
    2860:	09 f4       	brne	.+2      	; 0x2864 <uip_process+0x60e>
    2862:	81 c1       	rjmp	.+770    	; 0x2b66 <uip_process+0x910>
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    2864:	cf 58       	subi	r28, 0x8F	; 143
    2866:	df 4f       	sbci	r29, 0xFF	; 255
    goto drop;
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    2868:	f7 e0       	ldi	r31, 0x07	; 7
    286a:	cc 30       	cpi	r28, 0x0C	; 12
    286c:	df 07       	cpc	r29, r31
    286e:	91 f2       	breq	.-92     	; 0x2814 <uip_process+0x5be>
    2870:	88 f2       	brcs	.-94     	; 0x2814 <uip_process+0x5be>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    2872:	80 91 c2 07 	lds	r24, 0x07C2
    2876:	8f 73       	andi	r24, 0x3F	; 63
    2878:	82 30       	cpi	r24, 0x02	; 2
    287a:	11 f5       	brne	.+68     	; 0x28c0 <uip_process+0x66a>
    goto reset;
  }

  tmp16 = BUF->destport;
    287c:	80 91 b7 07 	lds	r24, 0x07B7
    2880:	90 91 b8 07 	lds	r25, 0x07B8
    2884:	90 93 65 03 	sts	0x0365, r25
    2888:	80 93 64 03 	sts	0x0364, r24
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    288c:	10 92 62 03 	sts	0x0362, r1
    2890:	13 c0       	rjmp	.+38     	; 0x28b8 <uip_process+0x662>
    if(tmp16 == uip_listenports[c]) {
    2892:	e4 2f       	mov	r30, r20
    2894:	f0 e0       	ldi	r31, 0x00	; 0
    2896:	ee 0f       	add	r30, r30
    2898:	ff 1f       	adc	r31, r31
    289a:	e3 58       	subi	r30, 0x83	; 131
    289c:	f8 4f       	sbci	r31, 0xF8	; 248
    289e:	20 91 64 03 	lds	r18, 0x0364
    28a2:	30 91 65 03 	lds	r19, 0x0365
    28a6:	80 81       	ld	r24, Z
    28a8:	91 81       	ldd	r25, Z+1	; 0x01
    28aa:	28 17       	cp	r18, r24
    28ac:	39 07       	cpc	r19, r25
    28ae:	09 f4       	brne	.+2      	; 0x28b2 <uip_process+0x65c>
    28b0:	71 c0       	rjmp	.+226    	; 0x2994 <uip_process+0x73e>
    goto reset;
  }

  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    28b2:	4f 5f       	subi	r20, 0xFF	; 255
    28b4:	40 93 62 03 	sts	0x0362, r20
    28b8:	40 91 62 03 	lds	r20, 0x0362
    28bc:	45 30       	cpi	r20, 0x05	; 5
    28be:	48 f3       	brcs	.-46     	; 0x2892 <uip_process+0x63c>
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    28c0:	80 91 c2 07 	lds	r24, 0x07C2
    28c4:	82 fd       	sbrc	r24, 2
    28c6:	97 c4       	rjmp	.+2350   	; 0x31f6 <uip_process+0xfa0>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);

  BUF->flags = TCP_RST | TCP_ACK;
    28c8:	84 e1       	ldi	r24, 0x14	; 20
    28ca:	f8 01       	movw	r30, r16
    28cc:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    28ce:	88 e2       	ldi	r24, 0x28	; 40
    28d0:	90 e0       	ldi	r25, 0x00	; 0
    28d2:	90 93 1c 06 	sts	0x061C, r25
    28d6:	80 93 1b 06 	sts	0x061B, r24
  BUF->tcpoffset = 5 << 4;
    28da:	80 e5       	ldi	r24, 0x50	; 80
    28dc:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    28de:	90 91 bc 07 	lds	r25, 0x07BC
  BUF->seqno[3] = BUF->ackno[3];
    28e2:	80 91 c0 07 	lds	r24, 0x07C0
    28e6:	83 8f       	std	Z+27, r24	; 0x1b
  BUF->ackno[3] = c;

  c = BUF->seqno[2];
    28e8:	30 91 bb 07 	lds	r19, 0x07BB
  BUF->seqno[2] = BUF->ackno[2];
    28ec:	80 91 bf 07 	lds	r24, 0x07BF
    28f0:	82 8f       	std	Z+26, r24	; 0x1a
  BUF->ackno[2] = c;
    28f2:	36 8f       	std	Z+30, r19	; 0x1e

  c = BUF->seqno[1];
    28f4:	40 91 ba 07 	lds	r20, 0x07BA
  BUF->seqno[1] = BUF->ackno[1];
    28f8:	80 91 be 07 	lds	r24, 0x07BE
    28fc:	81 8f       	std	Z+25, r24	; 0x19
  BUF->ackno[1] = c;
    28fe:	45 8f       	std	Z+29, r20	; 0x1d

  c = BUF->seqno[0];
    2900:	20 91 b9 07 	lds	r18, 0x07B9
    2904:	20 93 62 03 	sts	0x0362, r18
  BUF->seqno[0] = BUF->ackno[0];
    2908:	80 91 bd 07 	lds	r24, 0x07BD
    290c:	80 8f       	std	Z+24, r24	; 0x18
  BUF->ackno[0] = c;
    290e:	24 8f       	std	Z+28, r18	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    2910:	9f 5f       	subi	r25, 0xFF	; 255
    2912:	97 8f       	std	Z+31, r25	; 0x1f
    2914:	99 23       	and	r25, r25
    2916:	61 f4       	brne	.+24     	; 0x2930 <uip_process+0x6da>
    if(++BUF->ackno[2] == 0) {
    2918:	83 2f       	mov	r24, r19
    291a:	8f 5f       	subi	r24, 0xFF	; 255
    291c:	86 8f       	std	Z+30, r24	; 0x1e
    291e:	88 23       	and	r24, r24
    2920:	39 f4       	brne	.+14     	; 0x2930 <uip_process+0x6da>
      if(++BUF->ackno[1] == 0) {
    2922:	84 2f       	mov	r24, r20
    2924:	8f 5f       	subi	r24, 0xFF	; 255
    2926:	85 8f       	std	Z+29, r24	; 0x1d
    2928:	88 23       	and	r24, r24
    292a:	11 f4       	brne	.+4      	; 0x2930 <uip_process+0x6da>
	++BUF->ackno[0];
    292c:	2f 5f       	subi	r18, 0xFF	; 255
    292e:	24 8f       	std	Z+28, r18	; 0x1c
      }
    }
  }

  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    2930:	20 91 b5 07 	lds	r18, 0x07B5
    2934:	30 91 b6 07 	lds	r19, 0x07B6
    2938:	30 93 65 03 	sts	0x0365, r19
    293c:	20 93 64 03 	sts	0x0364, r18
  BUF->srcport = BUF->destport;
    2940:	80 91 b7 07 	lds	r24, 0x07B7
    2944:	90 91 b8 07 	lds	r25, 0x07B8
    2948:	f8 01       	movw	r30, r16
    294a:	95 8b       	std	Z+21, r25	; 0x15
    294c:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = tmp16;
    294e:	37 8b       	std	Z+23, r19	; 0x17
    2950:	26 8b       	std	Z+22, r18	; 0x16

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    2952:	80 91 ad 07 	lds	r24, 0x07AD
    2956:	90 91 ae 07 	lds	r25, 0x07AE
    295a:	a0 91 af 07 	lds	r26, 0x07AF
    295e:	b0 91 b0 07 	lds	r27, 0x07B0
    2962:	80 93 b1 07 	sts	0x07B1, r24
    2966:	90 93 b2 07 	sts	0x07B2, r25
    296a:	a0 93 b3 07 	sts	0x07B3, r26
    296e:	b0 93 b4 07 	sts	0x07B4, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2972:	80 91 8f 07 	lds	r24, 0x078F
    2976:	90 91 90 07 	lds	r25, 0x0790
    297a:	a0 91 91 07 	lds	r26, 0x0791
    297e:	b0 91 92 07 	lds	r27, 0x0792
    2982:	80 93 ad 07 	sts	0x07AD, r24
    2986:	90 93 ae 07 	sts	0x07AE, r25
    298a:	a0 93 af 07 	sts	0x07AF, r26
    298e:	b0 93 b0 07 	sts	0x07B0, r27
    2992:	ef c3       	rjmp	.+2014   	; 0x3172 <uip_process+0xf1c>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    2994:	10 92 62 03 	sts	0x0362, r1
    2998:	c0 e0       	ldi	r28, 0x00	; 0
    299a:	d0 e0       	ldi	r29, 0x00	; 0
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    299c:	41 e7       	ldi	r20, 0x71	; 113
    299e:	50 e0       	ldi	r21, 0x00	; 0
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
      if(uip_connr == 0 ||
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    29a0:	31 e7       	ldi	r19, 0x71	; 113
    29a2:	25 c0       	rjmp	.+74     	; 0x29ee <uip_process+0x798>
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    29a4:	82 2f       	mov	r24, r18
    29a6:	90 e0       	ldi	r25, 0x00	; 0
    29a8:	84 9f       	mul	r24, r20
    29aa:	f0 01       	movw	r30, r0
    29ac:	85 9f       	mul	r24, r21
    29ae:	f0 0d       	add	r31, r0
    29b0:	94 9f       	mul	r25, r20
    29b2:	f0 0d       	add	r31, r0
    29b4:	11 24       	eor	r1, r1
    29b6:	e6 5d       	subi	r30, 0xD6	; 214
    29b8:	f9 4f       	sbci	r31, 0xF9	; 249
    29ba:	81 8d       	ldd	r24, Z+25	; 0x19
    29bc:	88 23       	and	r24, r24
    29be:	39 f4       	brne	.+14     	; 0x29ce <uip_process+0x778>
      uip_connr = &uip_conns[c];
    29c0:	81 e7       	ldi	r24, 0x71	; 113
    29c2:	28 9f       	mul	r18, r24
    29c4:	e0 01       	movw	r28, r0
    29c6:	11 24       	eor	r1, r1
    29c8:	c6 5d       	subi	r28, 0xD6	; 214
    29ca:	d9 4f       	sbci	r29, 0xF9	; 249
    29cc:	14 c0       	rjmp	.+40     	; 0x29f6 <uip_process+0x7a0>
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    29ce:	87 30       	cpi	r24, 0x07	; 7
    29d0:	59 f4       	brne	.+22     	; 0x29e8 <uip_process+0x792>
      if(uip_connr == 0 ||
    29d2:	20 97       	sbiw	r28, 0x00	; 0
    29d4:	21 f0       	breq	.+8      	; 0x29de <uip_process+0x788>
    29d6:	92 8d       	ldd	r25, Z+26	; 0x1a
    29d8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29da:	89 17       	cp	r24, r25
    29dc:	28 f4       	brcc	.+10     	; 0x29e8 <uip_process+0x792>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    29de:	23 9f       	mul	r18, r19
    29e0:	e0 01       	movw	r28, r0
    29e2:	11 24       	eor	r1, r1
    29e4:	c6 5d       	subi	r28, 0xD6	; 214
    29e6:	d9 4f       	sbci	r29, 0xF9	; 249
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    29e8:	2f 5f       	subi	r18, 0xFF	; 255
    29ea:	20 93 62 03 	sts	0x0362, r18
    29ee:	20 91 62 03 	lds	r18, 0x0362
    29f2:	23 30       	cpi	r18, 0x03	; 3
    29f4:	b8 f2       	brcs	.-82     	; 0x29a4 <uip_process+0x74e>
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    29f6:	20 97       	sbiw	r28, 0x00	; 0
    29f8:	09 f4       	brne	.+2      	; 0x29fc <uip_process+0x7a6>
    29fa:	fd c3       	rjmp	.+2042   	; 0x31f6 <uip_process+0xfa0>
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    29fc:	d0 93 29 06 	sts	0x0629, r29
    2a00:	c0 93 28 06 	sts	0x0628, r28

  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    2a04:	83 e0       	ldi	r24, 0x03	; 3
    2a06:	8a 8f       	std	Y+26, r24	; 0x1a
    2a08:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    2a0a:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    2a0c:	84 e0       	ldi	r24, 0x04	; 4
    2a0e:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    2a10:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    2a12:	80 91 b7 07 	lds	r24, 0x07B7
    2a16:	90 91 b8 07 	lds	r25, 0x07B8
    2a1a:	9d 83       	std	Y+5, r25	; 0x05
    2a1c:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    2a1e:	80 91 b5 07 	lds	r24, 0x07B5
    2a22:	90 91 b6 07 	lds	r25, 0x07B6
    2a26:	9f 83       	std	Y+7, r25	; 0x07
    2a28:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
    2a2a:	80 91 ad 07 	lds	r24, 0x07AD
    2a2e:	90 91 ae 07 	lds	r25, 0x07AE
    2a32:	a0 91 af 07 	lds	r26, 0x07AF
    2a36:	b0 91 b0 07 	lds	r27, 0x07B0
    2a3a:	88 83       	st	Y, r24
    2a3c:	99 83       	std	Y+1, r25	; 0x01
    2a3e:	aa 83       	std	Y+2, r26	; 0x02
    2a40:	bb 83       	std	Y+3, r27	; 0x03
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    2a42:	81 e0       	ldi	r24, 0x01	; 1
    2a44:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    2a46:	80 91 5c 03 	lds	r24, 0x035C
    2a4a:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    2a4c:	80 91 5d 03 	lds	r24, 0x035D
    2a50:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    2a52:	80 91 5e 03 	lds	r24, 0x035E
    2a56:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    2a58:	80 91 5f 03 	lds	r24, 0x035F
    2a5c:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    2a5e:	81 e0       	ldi	r24, 0x01	; 1
    2a60:	90 e0       	ldi	r25, 0x00	; 0
    2a62:	99 8b       	std	Y+17, r25	; 0x11
    2a64:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2a66:	80 91 bc 07 	lds	r24, 0x07BC
    2a6a:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2a6c:	80 91 bb 07 	lds	r24, 0x07BB
    2a70:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    2a72:	80 91 ba 07 	lds	r24, 0x07BA
    2a76:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2a78:	80 91 b9 07 	lds	r24, 0x07B9
    2a7c:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    2a7e:	81 e0       	ldi	r24, 0x01	; 1
    2a80:	90 e0       	ldi	r25, 0x00	; 0
    2a82:	70 db       	rcall	.-2336   	; 0x2164 <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    2a84:	80 91 c1 07 	lds	r24, 0x07C1
    2a88:	90 e0       	ldi	r25, 0x00	; 0
    2a8a:	80 7f       	andi	r24, 0xF0	; 240
    2a8c:	90 70       	andi	r25, 0x00	; 0
    2a8e:	81 35       	cpi	r24, 0x51	; 81
    2a90:	91 05       	cpc	r25, r1
    2a92:	0c f4       	brge	.+2      	; 0x2a96 <uip_process+0x840>
    2a94:	4c c0       	rjmp	.+152    	; 0x2b2e <uip_process+0x8d8>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2a96:	10 92 62 03 	sts	0x0362, r1
    2a9a:	37 c0       	rjmp	.+110    	; 0x2b0a <uip_process+0x8b4>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    2a9c:	f9 01       	movw	r30, r18
    2a9e:	ed 56       	subi	r30, 0x6D	; 109
    2aa0:	f8 4f       	sbci	r31, 0xF8	; 248
    2aa2:	86 a9       	ldd	r24, Z+54	; 0x36
    2aa4:	80 93 63 03 	sts	0x0363, r24
      if(opt == TCP_OPT_END) {
    2aa8:	88 23       	and	r24, r24
    2aaa:	09 f4       	brne	.+2      	; 0x2aae <uip_process+0x858>
    2aac:	40 c0       	rjmp	.+128    	; 0x2b2e <uip_process+0x8d8>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    2aae:	81 30       	cpi	r24, 0x01	; 1
    2ab0:	21 f4       	brne	.+8      	; 0x2aba <uip_process+0x864>
	++c;
    2ab2:	4f 5f       	subi	r20, 0xFF	; 255
    2ab4:	40 93 62 03 	sts	0x0362, r20
    2ab8:	28 c0       	rjmp	.+80     	; 0x2b0a <uip_process+0x8b4>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    2aba:	82 30       	cpi	r24, 0x02	; 2
    2abc:	d1 f4       	brne	.+52     	; 0x2af2 <uip_process+0x89c>
    2abe:	87 a9       	ldd	r24, Z+55	; 0x37
    2ac0:	84 30       	cpi	r24, 0x04	; 4
    2ac2:	b9 f4       	brne	.+46     	; 0x2af2 <uip_process+0x89c>
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2ac4:	20 ad       	ldd	r18, Z+56	; 0x38
    2ac6:	30 e0       	ldi	r19, 0x00	; 0
    2ac8:	32 2f       	mov	r19, r18
    2aca:	22 27       	eor	r18, r18
    2acc:	81 ad       	ldd	r24, Z+57	; 0x39
    2ace:	90 e0       	ldi	r25, 0x00	; 0
    2ad0:	28 2b       	or	r18, r24
    2ad2:	39 2b       	or	r19, r25
    2ad4:	30 93 65 03 	sts	0x0365, r19
    2ad8:	20 93 64 03 	sts	0x0364, r18
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    2adc:	f5 e0       	ldi	r31, 0x05	; 5
    2ade:	25 3b       	cpi	r18, 0xB5	; 181
    2ae0:	3f 07       	cpc	r19, r31
    2ae2:	10 f0       	brcs	.+4      	; 0x2ae8 <uip_process+0x892>
    2ae4:	24 eb       	ldi	r18, 0xB4	; 180
    2ae6:	35 e0       	ldi	r19, 0x05	; 5
    2ae8:	3b 8b       	std	Y+19, r19	; 0x13
    2aea:	2a 8b       	std	Y+18, r18	; 0x12
    2aec:	3d 8b       	std	Y+21, r19	; 0x15
    2aee:	2c 8b       	std	Y+20, r18	; 0x14
    2af0:	1e c0       	rjmp	.+60     	; 0x2b2e <uip_process+0x8d8>
	/* And we are done processing options. */
	break;
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2af2:	90 91 62 03 	lds	r25, 0x0362
    2af6:	e9 2f       	mov	r30, r25
    2af8:	f0 e0       	ldi	r31, 0x00	; 0
    2afa:	ed 56       	subi	r30, 0x6D	; 109
    2afc:	f8 4f       	sbci	r31, 0xF8	; 248
    2afe:	87 a9       	ldd	r24, Z+55	; 0x37
    2b00:	88 23       	and	r24, r24
    2b02:	a9 f0       	breq	.+42     	; 0x2b2e <uip_process+0x8d8>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2b04:	89 0f       	add	r24, r25
    2b06:	80 93 62 03 	sts	0x0362, r24
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2b0a:	40 91 62 03 	lds	r20, 0x0362
    2b0e:	24 2f       	mov	r18, r20
    2b10:	30 e0       	ldi	r19, 0x00	; 0
    2b12:	80 91 c1 07 	lds	r24, 0x07C1
    2b16:	82 95       	swap	r24
    2b18:	8f 70       	andi	r24, 0x0F	; 15
    2b1a:	90 e0       	ldi	r25, 0x00	; 0
    2b1c:	05 97       	sbiw	r24, 0x05	; 5
    2b1e:	88 0f       	add	r24, r24
    2b20:	99 1f       	adc	r25, r25
    2b22:	88 0f       	add	r24, r24
    2b24:	99 1f       	adc	r25, r25
    2b26:	28 17       	cp	r18, r24
    2b28:	39 07       	cpc	r19, r25
    2b2a:	0c f4       	brge	.+2      	; 0x2b2e <uip_process+0x8d8>
    2b2c:	b7 cf       	rjmp	.-146    	; 0x2a9c <uip_process+0x846>
  }

  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    2b2e:	80 e1       	ldi	r24, 0x10	; 16
    2b30:	80 93 c2 07 	sts	0x07C2, r24

 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    2b34:	80 91 c2 07 	lds	r24, 0x07C2
    2b38:	82 60       	ori	r24, 0x02	; 2
    2b3a:	80 93 c2 07 	sts	0x07C2, r24
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */

  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    2b3e:	82 e0       	ldi	r24, 0x02	; 2
    2b40:	80 93 c9 07 	sts	0x07C9, r24
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    2b44:	84 e0       	ldi	r24, 0x04	; 4
    2b46:	80 93 ca 07 	sts	0x07CA, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    2b4a:	85 e0       	ldi	r24, 0x05	; 5
    2b4c:	80 93 cb 07 	sts	0x07CB, r24
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    2b50:	84 eb       	ldi	r24, 0xB4	; 180
    2b52:	80 93 cc 07 	sts	0x07CC, r24
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    2b56:	8c e2       	ldi	r24, 0x2C	; 44
    2b58:	90 e0       	ldi	r25, 0x00	; 0
    2b5a:	90 93 1c 06 	sts	0x061C, r25
    2b5e:	80 93 1b 06 	sts	0x061B, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    2b62:	80 e6       	ldi	r24, 0x60	; 96
    2b64:	b3 c2       	rjmp	.+1382   	; 0x30cc <uip_process+0xe76>
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    2b66:	d0 93 29 06 	sts	0x0629, r29
    2b6a:	c0 93 28 06 	sts	0x0628, r28
  uip_flags = 0;
    2b6e:	10 92 23 06 	sts	0x0623, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is within our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    2b72:	80 91 c2 07 	lds	r24, 0x07C2
    2b76:	48 2f       	mov	r20, r24
    2b78:	50 e0       	ldi	r21, 0x00	; 0
    2b7a:	82 ff       	sbrs	r24, 2
    2b7c:	03 c0       	rjmp	.+6      	; 0x2b84 <uip_process+0x92e>
    uip_connr->tcpstateflags = UIP_CLOSED;
    2b7e:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    2b80:	80 e2       	ldi	r24, 0x20	; 32
    2b82:	50 c2       	rjmp	.+1184   	; 0x3024 <uip_process+0xdce>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculate the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    2b84:	80 91 c1 07 	lds	r24, 0x07C1
    2b88:	82 95       	swap	r24
    2b8a:	8f 70       	andi	r24, 0x0F	; 15
    2b8c:	88 0f       	add	r24, r24
    2b8e:	88 0f       	add	r24, r24
    2b90:	80 93 62 03 	sts	0x0362, r24
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    2b94:	20 91 1b 06 	lds	r18, 0x061B
    2b98:	30 91 1c 06 	lds	r19, 0x061C
    2b9c:	24 51       	subi	r18, 0x14	; 20
    2b9e:	30 40       	sbci	r19, 0x00	; 0
    2ba0:	28 1b       	sub	r18, r24
    2ba2:	31 09       	sbc	r19, r1
    2ba4:	30 93 1c 06 	sts	0x061C, r19
    2ba8:	20 93 1b 06 	sts	0x061B, r18

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2bac:	89 8d       	ldd	r24, Y+25	; 0x19
    2bae:	8f 70       	andi	r24, 0x0F	; 15
    2bb0:	82 30       	cpi	r24, 0x02	; 2
    2bb2:	29 f4       	brne	.+10     	; 0x2bbe <uip_process+0x968>
    2bb4:	4f 73       	andi	r20, 0x3F	; 63
    2bb6:	50 70       	andi	r21, 0x00	; 0
    2bb8:	42 31       	cpi	r20, 0x12	; 18
    2bba:	51 05       	cpc	r21, r1
    2bbc:	09 f1       	breq	.+66     	; 0x2c00 <uip_process+0x9aa>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    2bbe:	23 2b       	or	r18, r19
    2bc0:	39 f4       	brne	.+14     	; 0x2bd0 <uip_process+0x97a>
    2bc2:	80 91 c2 07 	lds	r24, 0x07C2
    2bc6:	90 e0       	ldi	r25, 0x00	; 0
    2bc8:	83 70       	andi	r24, 0x03	; 3
    2bca:	90 70       	andi	r25, 0x00	; 0
    2bcc:	89 2b       	or	r24, r25
    2bce:	c1 f0       	breq	.+48     	; 0x2c00 <uip_process+0x9aa>
    2bd0:	90 91 b9 07 	lds	r25, 0x07B9
    2bd4:	88 85       	ldd	r24, Y+8	; 0x08
    2bd6:	98 17       	cp	r25, r24
    2bd8:	09 f0       	breq	.+2      	; 0x2bdc <uip_process+0x986>
    2bda:	6e c2       	rjmp	.+1244   	; 0x30b8 <uip_process+0xe62>
    2bdc:	90 91 ba 07 	lds	r25, 0x07BA
    2be0:	89 85       	ldd	r24, Y+9	; 0x09
    2be2:	98 17       	cp	r25, r24
    2be4:	09 f0       	breq	.+2      	; 0x2be8 <uip_process+0x992>
    2be6:	68 c2       	rjmp	.+1232   	; 0x30b8 <uip_process+0xe62>
    2be8:	90 91 bb 07 	lds	r25, 0x07BB
    2bec:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bee:	98 17       	cp	r25, r24
    2bf0:	09 f0       	breq	.+2      	; 0x2bf4 <uip_process+0x99e>
    2bf2:	62 c2       	rjmp	.+1220   	; 0x30b8 <uip_process+0xe62>
    2bf4:	90 91 bc 07 	lds	r25, 0x07BC
    2bf8:	8b 85       	ldd	r24, Y+11	; 0x0b
    2bfa:	98 17       	cp	r25, r24
    2bfc:	09 f0       	breq	.+2      	; 0x2c00 <uip_process+0x9aa>
    2bfe:	5c c2       	rjmp	.+1208   	; 0x30b8 <uip_process+0xe62>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    2c00:	80 91 c2 07 	lds	r24, 0x07C2
    2c04:	84 ff       	sbrs	r24, 4
    2c06:	50 c0       	rjmp	.+160    	; 0x2ca8 <uip_process+0xa52>
    2c08:	68 89       	ldd	r22, Y+16	; 0x10
    2c0a:	79 89       	ldd	r23, Y+17	; 0x11
    2c0c:	61 15       	cp	r22, r1
    2c0e:	71 05       	cpc	r23, r1
    2c10:	09 f4       	brne	.+2      	; 0x2c14 <uip_process+0x9be>
    2c12:	4a c0       	rjmp	.+148    	; 0x2ca8 <uip_process+0xa52>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    2c14:	ce 01       	movw	r24, r28
    2c16:	0c 96       	adiw	r24, 0x0c	; 12
    2c18:	fc d9       	rcall	.-3080   	; 0x2012 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    2c1a:	20 91 bd 07 	lds	r18, 0x07BD
    2c1e:	80 91 1f 06 	lds	r24, 0x061F
    2c22:	28 17       	cp	r18, r24
    2c24:	09 f0       	breq	.+2      	; 0x2c28 <uip_process+0x9d2>
    2c26:	40 c0       	rjmp	.+128    	; 0x2ca8 <uip_process+0xa52>
    2c28:	90 91 be 07 	lds	r25, 0x07BE
    2c2c:	80 91 20 06 	lds	r24, 0x0620
    2c30:	98 17       	cp	r25, r24
    2c32:	d1 f5       	brne	.+116    	; 0x2ca8 <uip_process+0xa52>
    2c34:	90 91 bf 07 	lds	r25, 0x07BF
    2c38:	80 91 21 06 	lds	r24, 0x0621
    2c3c:	98 17       	cp	r25, r24
    2c3e:	a1 f5       	brne	.+104    	; 0x2ca8 <uip_process+0xa52>
    2c40:	90 91 c0 07 	lds	r25, 0x07C0
    2c44:	80 91 22 06 	lds	r24, 0x0622
    2c48:	98 17       	cp	r25, r24
    2c4a:	71 f5       	brne	.+92     	; 0x2ca8 <uip_process+0xa52>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    2c4c:	2c 87       	std	Y+12, r18	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    2c4e:	80 91 20 06 	lds	r24, 0x0620
    2c52:	8d 87       	std	Y+13, r24	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    2c54:	80 91 21 06 	lds	r24, 0x0621
    2c58:	8e 87       	std	Y+14, r24	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    2c5a:	80 91 22 06 	lds	r24, 0x0622
    2c5e:	8f 87       	std	Y+15, r24	; 0x0f

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    2c60:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2c62:	88 23       	and	r24, r24
    2c64:	d1 f4       	brne	.+52     	; 0x2c9a <uip_process+0xa44>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    2c66:	2e 89       	ldd	r18, Y+22	; 0x16
    2c68:	98 8d       	ldd	r25, Y+24	; 0x18
    2c6a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2c6c:	98 1b       	sub	r25, r24
    2c6e:	82 2f       	mov	r24, r18
    2c70:	86 95       	lsr	r24
    2c72:	86 95       	lsr	r24
    2c74:	86 95       	lsr	r24
    2c76:	98 1b       	sub	r25, r24
	uip_connr->sa += m;
    2c78:	39 2f       	mov	r19, r25
    2c7a:	32 0f       	add	r19, r18
    2c7c:	3e 8b       	std	Y+22, r19	; 0x16
	if(m < 0) {
	  m = -m;
	}
	m = m - (uip_connr->sv >> 2);
    2c7e:	8f 89       	ldd	r24, Y+23	; 0x17
	uip_connr->sv += m;
    2c80:	28 2f       	mov	r18, r24
    2c82:	26 95       	lsr	r18
    2c84:	26 95       	lsr	r18
    2c86:	82 1b       	sub	r24, r18
    2c88:	97 fd       	sbrc	r25, 7
    2c8a:	91 95       	neg	r25
    2c8c:	89 0f       	add	r24, r25
    2c8e:	8f 8b       	std	Y+23, r24	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    2c90:	36 95       	lsr	r19
    2c92:	36 95       	lsr	r19
    2c94:	36 95       	lsr	r19
    2c96:	83 0f       	add	r24, r19
    2c98:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    2c9a:	81 e0       	ldi	r24, 0x01	; 1
    2c9c:	80 93 23 06 	sts	0x0623, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    2ca0:	88 8d       	ldd	r24, Y+24	; 0x18
    2ca2:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    2ca4:	19 8a       	std	Y+17, r1	; 0x11
    2ca6:	18 8a       	std	Y+16, r1	; 0x10
    }

  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    2ca8:	89 8d       	ldd	r24, Y+25	; 0x19
    2caa:	28 2f       	mov	r18, r24
    2cac:	30 e0       	ldi	r19, 0x00	; 0
    2cae:	c9 01       	movw	r24, r18
    2cb0:	8f 70       	andi	r24, 0x0F	; 15
    2cb2:	90 70       	andi	r25, 0x00	; 0
    2cb4:	84 30       	cpi	r24, 0x04	; 4
    2cb6:	91 05       	cpc	r25, r1
    2cb8:	09 f4       	brne	.+2      	; 0x2cbc <uip_process+0xa66>
    2cba:	b9 c1       	rjmp	.+882    	; 0x302e <uip_process+0xdd8>
    2cbc:	85 30       	cpi	r24, 0x05	; 5
    2cbe:	91 05       	cpc	r25, r1
    2cc0:	5c f4       	brge	.+22     	; 0x2cd8 <uip_process+0xa82>
    2cc2:	82 30       	cpi	r24, 0x02	; 2
    2cc4:	91 05       	cpc	r25, r1
    2cc6:	99 f1       	breq	.+102    	; 0x2d2e <uip_process+0xad8>
    2cc8:	83 30       	cpi	r24, 0x03	; 3
    2cca:	91 05       	cpc	r25, r1
    2ccc:	0c f0       	brlt	.+2      	; 0x2cd0 <uip_process+0xa7a>
    2cce:	b4 c0       	rjmp	.+360    	; 0x2e38 <uip_process+0xbe2>
    2cd0:	01 97       	sbiw	r24, 0x01	; 1
    2cd2:	09 f0       	breq	.+2      	; 0x2cd6 <uip_process+0xa80>
    2cd4:	90 c2       	rjmp	.+1312   	; 0x31f6 <uip_process+0xfa0>
    2cd6:	10 c0       	rjmp	.+32     	; 0x2cf8 <uip_process+0xaa2>
    2cd8:	86 30       	cpi	r24, 0x06	; 6
    2cda:	91 05       	cpc	r25, r1
    2cdc:	09 f4       	brne	.+2      	; 0x2ce0 <uip_process+0xa8a>
    2cde:	e4 c1       	rjmp	.+968    	; 0x30a8 <uip_process+0xe52>
    2ce0:	86 30       	cpi	r24, 0x06	; 6
    2ce2:	91 05       	cpc	r25, r1
    2ce4:	0c f4       	brge	.+2      	; 0x2ce8 <uip_process+0xa92>
    2ce6:	c2 c1       	rjmp	.+900    	; 0x306c <uip_process+0xe16>
    2ce8:	87 30       	cpi	r24, 0x07	; 7
    2cea:	91 05       	cpc	r25, r1
    2cec:	09 f4       	brne	.+2      	; 0x2cf0 <uip_process+0xa9a>
    2cee:	e4 c1       	rjmp	.+968    	; 0x30b8 <uip_process+0xe62>
    2cf0:	08 97       	sbiw	r24, 0x08	; 8
    2cf2:	09 f0       	breq	.+2      	; 0x2cf6 <uip_process+0xaa0>
    2cf4:	80 c2       	rjmp	.+1280   	; 0x31f6 <uip_process+0xfa0>
    2cf6:	90 c1       	rjmp	.+800    	; 0x3018 <uip_process+0xdc2>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    2cf8:	80 91 23 06 	lds	r24, 0x0623
    2cfc:	80 ff       	sbrs	r24, 0
    2cfe:	7b c2       	rjmp	.+1270   	; 0x31f6 <uip_process+0xfa0>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2d00:	83 e0       	ldi	r24, 0x03	; 3
    2d02:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    2d04:	80 e4       	ldi	r24, 0x40	; 64
    2d06:	80 93 23 06 	sts	0x0623, r24
      uip_connr->len = 0;
    2d0a:	19 8a       	std	Y+17, r1	; 0x11
    2d0c:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    2d0e:	20 91 1b 06 	lds	r18, 0x061B
    2d12:	30 91 1c 06 	lds	r19, 0x061C
    2d16:	21 15       	cp	r18, r1
    2d18:	31 05       	cpc	r19, r1
    2d1a:	09 f4       	brne	.+2      	; 0x2d1e <uip_process+0xac8>
    2d1c:	11 c1       	rjmp	.+546    	; 0x2f40 <uip_process+0xcea>
        uip_flags |= UIP_NEWDATA;
    2d1e:	80 91 23 06 	lds	r24, 0x0623
    2d22:	82 60       	ori	r24, 0x02	; 2
    2d24:	80 93 23 06 	sts	0x0623, r24
        uip_add_rcv_nxt(uip_len);
    2d28:	c9 01       	movw	r24, r18
    2d2a:	1c da       	rcall	.-3016   	; 0x2164 <uip_add_rcv_nxt>
    2d2c:	09 c1       	rjmp	.+530    	; 0x2f40 <uip_process+0xcea>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    2d2e:	80 91 23 06 	lds	r24, 0x0623
    2d32:	80 ff       	sbrs	r24, 0
    2d34:	76 c0       	rjmp	.+236    	; 0x2e22 <uip_process+0xbcc>
    2d36:	80 91 c2 07 	lds	r24, 0x07C2
    2d3a:	8f 73       	andi	r24, 0x3F	; 63
    2d3c:	82 31       	cpi	r24, 0x12	; 18
    2d3e:	09 f0       	breq	.+2      	; 0x2d42 <uip_process+0xaec>
    2d40:	70 c0       	rjmp	.+224    	; 0x2e22 <uip_process+0xbcc>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    2d42:	80 91 c1 07 	lds	r24, 0x07C1
    2d46:	90 e0       	ldi	r25, 0x00	; 0
    2d48:	80 7f       	andi	r24, 0xF0	; 240
    2d4a:	90 70       	andi	r25, 0x00	; 0
    2d4c:	81 35       	cpi	r24, 0x51	; 81
    2d4e:	91 05       	cpc	r25, r1
    2d50:	0c f4       	brge	.+2      	; 0x2d54 <uip_process+0xafe>
    2d52:	4c c0       	rjmp	.+152    	; 0x2dec <uip_process+0xb96>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2d54:	10 92 62 03 	sts	0x0362, r1
    2d58:	37 c0       	rjmp	.+110    	; 0x2dc8 <uip_process+0xb72>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    2d5a:	f9 01       	movw	r30, r18
    2d5c:	ed 56       	subi	r30, 0x6D	; 109
    2d5e:	f8 4f       	sbci	r31, 0xF8	; 248
    2d60:	86 a9       	ldd	r24, Z+54	; 0x36
    2d62:	80 93 63 03 	sts	0x0363, r24
	  if(opt == TCP_OPT_END) {
    2d66:	88 23       	and	r24, r24
    2d68:	09 f4       	brne	.+2      	; 0x2d6c <uip_process+0xb16>
    2d6a:	40 c0       	rjmp	.+128    	; 0x2dec <uip_process+0xb96>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    2d6c:	81 30       	cpi	r24, 0x01	; 1
    2d6e:	21 f4       	brne	.+8      	; 0x2d78 <uip_process+0xb22>
	    ++c;
    2d70:	4f 5f       	subi	r20, 0xFF	; 255
    2d72:	40 93 62 03 	sts	0x0362, r20
    2d76:	28 c0       	rjmp	.+80     	; 0x2dc8 <uip_process+0xb72>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    2d78:	82 30       	cpi	r24, 0x02	; 2
    2d7a:	d1 f4       	brne	.+52     	; 0x2db0 <uip_process+0xb5a>
    2d7c:	87 a9       	ldd	r24, Z+55	; 0x37
    2d7e:	84 30       	cpi	r24, 0x04	; 4
    2d80:	b9 f4       	brne	.+46     	; 0x2db0 <uip_process+0xb5a>
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2d82:	20 ad       	ldd	r18, Z+56	; 0x38
    2d84:	30 e0       	ldi	r19, 0x00	; 0
    2d86:	32 2f       	mov	r19, r18
    2d88:	22 27       	eor	r18, r18
    2d8a:	81 ad       	ldd	r24, Z+57	; 0x39
    2d8c:	90 e0       	ldi	r25, 0x00	; 0
    2d8e:	28 2b       	or	r18, r24
    2d90:	39 2b       	or	r19, r25
    2d92:	30 93 65 03 	sts	0x0365, r19
    2d96:	20 93 64 03 	sts	0x0364, r18
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    2d9a:	85 e0       	ldi	r24, 0x05	; 5
    2d9c:	25 3b       	cpi	r18, 0xB5	; 181
    2d9e:	38 07       	cpc	r19, r24
    2da0:	10 f0       	brcs	.+4      	; 0x2da6 <uip_process+0xb50>
    2da2:	24 eb       	ldi	r18, 0xB4	; 180
    2da4:	35 e0       	ldi	r19, 0x05	; 5
    2da6:	3b 8b       	std	Y+19, r19	; 0x13
    2da8:	2a 8b       	std	Y+18, r18	; 0x12
    2daa:	3d 8b       	std	Y+21, r19	; 0x15
    2dac:	2c 8b       	std	Y+20, r18	; 0x14
    2dae:	1e c0       	rjmp	.+60     	; 0x2dec <uip_process+0xb96>
	    /* And we are done processing options. */
	    break;
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2db0:	90 91 62 03 	lds	r25, 0x0362
    2db4:	e9 2f       	mov	r30, r25
    2db6:	f0 e0       	ldi	r31, 0x00	; 0
    2db8:	ed 56       	subi	r30, 0x6D	; 109
    2dba:	f8 4f       	sbci	r31, 0xF8	; 248
    2dbc:	87 a9       	ldd	r24, Z+55	; 0x37
    2dbe:	88 23       	and	r24, r24
    2dc0:	a9 f0       	breq	.+42     	; 0x2dec <uip_process+0xb96>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2dc2:	89 0f       	add	r24, r25
    2dc4:	80 93 62 03 	sts	0x0362, r24
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2dc8:	40 91 62 03 	lds	r20, 0x0362
    2dcc:	24 2f       	mov	r18, r20
    2dce:	30 e0       	ldi	r19, 0x00	; 0
    2dd0:	80 91 c1 07 	lds	r24, 0x07C1
    2dd4:	82 95       	swap	r24
    2dd6:	8f 70       	andi	r24, 0x0F	; 15
    2dd8:	90 e0       	ldi	r25, 0x00	; 0
    2dda:	05 97       	sbiw	r24, 0x05	; 5
    2ddc:	88 0f       	add	r24, r24
    2dde:	99 1f       	adc	r25, r25
    2de0:	88 0f       	add	r24, r24
    2de2:	99 1f       	adc	r25, r25
    2de4:	28 17       	cp	r18, r24
    2de6:	39 07       	cpc	r19, r25
    2de8:	0c f4       	brge	.+2      	; 0x2dec <uip_process+0xb96>
    2dea:	b7 cf       	rjmp	.-146    	; 0x2d5a <uip_process+0xb04>
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2dec:	83 e0       	ldi	r24, 0x03	; 3
    2dee:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2df0:	80 91 b9 07 	lds	r24, 0x07B9
    2df4:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    2df6:	80 91 ba 07 	lds	r24, 0x07BA
    2dfa:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2dfc:	80 91 bb 07 	lds	r24, 0x07BB
    2e00:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2e02:	80 91 bc 07 	lds	r24, 0x07BC
    2e06:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    2e08:	81 e0       	ldi	r24, 0x01	; 1
    2e0a:	90 e0       	ldi	r25, 0x00	; 0
    2e0c:	ab d9       	rcall	.-3242   	; 0x2164 <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    2e0e:	82 e4       	ldi	r24, 0x42	; 66
    2e10:	80 93 23 06 	sts	0x0623, r24
      uip_connr->len = 0;
    2e14:	19 8a       	std	Y+17, r1	; 0x11
    2e16:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    2e18:	10 92 1c 06 	sts	0x061C, r1
    2e1c:	10 92 1b 06 	sts	0x061B, r1
    2e20:	8f c0       	rjmp	.+286    	; 0x2f40 <uip_process+0xcea>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    2e22:	80 e2       	ldi	r24, 0x20	; 32
    2e24:	80 93 23 06 	sts	0x0623, r24
    UIP_APPCALL();
    2e28:	0e 94 4b 08 	call	0x1096	; 0x1096 <uIPManagement_TCPCallback>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    2e2c:	e0 91 28 06 	lds	r30, 0x0628
    2e30:	f0 91 29 06 	lds	r31, 0x0629
    2e34:	11 8e       	std	Z+25, r1	; 0x19
    2e36:	44 cd       	rjmp	.-1400   	; 0x28c0 <uip_process+0x66a>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2e38:	80 91 c2 07 	lds	r24, 0x07C2
    2e3c:	80 ff       	sbrs	r24, 0
    2e3e:	29 c0       	rjmp	.+82     	; 0x2e92 <uip_process+0xc3c>
    2e40:	24 fd       	sbrc	r18, 4
    2e42:	27 c0       	rjmp	.+78     	; 0x2e92 <uip_process+0xc3c>
      if(uip_outstanding(uip_connr)) {
    2e44:	88 89       	ldd	r24, Y+16	; 0x10
    2e46:	99 89       	ldd	r25, Y+17	; 0x11
    2e48:	89 2b       	or	r24, r25
    2e4a:	09 f0       	breq	.+2      	; 0x2e4e <uip_process+0xbf8>
    2e4c:	d4 c1       	rjmp	.+936    	; 0x31f6 <uip_process+0xfa0>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    2e4e:	80 91 1b 06 	lds	r24, 0x061B
    2e52:	90 91 1c 06 	lds	r25, 0x061C
    2e56:	01 96       	adiw	r24, 0x01	; 1
    2e58:	85 d9       	rcall	.-3318   	; 0x2164 <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    2e5a:	20 91 23 06 	lds	r18, 0x0623
    2e5e:	82 2f       	mov	r24, r18
    2e60:	80 61       	ori	r24, 0x10	; 16
    2e62:	80 93 23 06 	sts	0x0623, r24
      if(uip_len > 0) {
    2e66:	80 91 1b 06 	lds	r24, 0x061B
    2e6a:	90 91 1c 06 	lds	r25, 0x061C
    2e6e:	89 2b       	or	r24, r25
    2e70:	19 f0       	breq	.+6      	; 0x2e78 <uip_process+0xc22>
	uip_flags |= UIP_NEWDATA;
    2e72:	22 61       	ori	r18, 0x12	; 18
    2e74:	20 93 23 06 	sts	0x0623, r18
      }
      UIP_APPCALL();
    2e78:	0e 94 4b 08 	call	0x1096	; 0x1096 <uIPManagement_TCPCallback>
      uip_connr->len = 1;
    2e7c:	81 e0       	ldi	r24, 0x01	; 1
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	99 8b       	std	Y+17, r25	; 0x11
    2e82:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    2e84:	88 e0       	ldi	r24, 0x08	; 8
    2e86:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    2e88:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    2e8a:	81 e1       	ldi	r24, 0x11	; 17
    2e8c:	80 93 c2 07 	sts	0x07C2, r24
    2e90:	16 c1       	rjmp	.+556    	; 0x30be <uip_process+0xe68>
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    2e92:	85 ff       	sbrs	r24, 5
    2e94:	1e c0       	rjmp	.+60     	; 0x2ed2 <uip_process+0xc7c>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    2e96:	20 91 c7 07 	lds	r18, 0x07C7
    2e9a:	30 e0       	ldi	r19, 0x00	; 0
    2e9c:	32 2f       	mov	r19, r18
    2e9e:	22 27       	eor	r18, r18
    2ea0:	80 91 c8 07 	lds	r24, 0x07C8
    2ea4:	90 e0       	ldi	r25, 0x00	; 0
    2ea6:	28 2b       	or	r18, r24
    2ea8:	39 2b       	or	r19, r25
    2eaa:	80 91 26 06 	lds	r24, 0x0626
    2eae:	90 91 27 06 	lds	r25, 0x0627
    2eb2:	82 0f       	add	r24, r18
    2eb4:	93 1f       	adc	r25, r19
    2eb6:	90 93 27 06 	sts	0x0627, r25
    2eba:	80 93 26 06 	sts	0x0626, r24
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    2ebe:	80 91 1b 06 	lds	r24, 0x061B
    2ec2:	90 91 1c 06 	lds	r25, 0x061C
    2ec6:	82 1b       	sub	r24, r18
    2ec8:	93 0b       	sbc	r25, r19
    2eca:	90 93 1c 06 	sts	0x061C, r25
    2ece:	80 93 1b 06 	sts	0x061B, r24
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2ed2:	20 91 1b 06 	lds	r18, 0x061B
    2ed6:	30 91 1c 06 	lds	r19, 0x061C
    2eda:	21 15       	cp	r18, r1
    2edc:	31 05       	cpc	r19, r1
    2ede:	51 f0       	breq	.+20     	; 0x2ef4 <uip_process+0xc9e>
    2ee0:	89 8d       	ldd	r24, Y+25	; 0x19
    2ee2:	84 fd       	sbrc	r24, 4
    2ee4:	07 c0       	rjmp	.+14     	; 0x2ef4 <uip_process+0xc9e>
      uip_flags |= UIP_NEWDATA;
    2ee6:	80 91 23 06 	lds	r24, 0x0623
    2eea:	82 60       	ori	r24, 0x02	; 2
    2eec:	80 93 23 06 	sts	0x0623, r24
      uip_add_rcv_nxt(uip_len);
    2ef0:	c9 01       	movw	r24, r18
    2ef2:	38 d9       	rcall	.-3472   	; 0x2164 <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanism.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    2ef4:	80 91 c3 07 	lds	r24, 0x07C3
    2ef8:	90 e0       	ldi	r25, 0x00	; 0
    2efa:	38 2f       	mov	r19, r24
    2efc:	22 27       	eor	r18, r18
    2efe:	80 91 c4 07 	lds	r24, 0x07C4
    2f02:	28 0f       	add	r18, r24
    2f04:	31 1d       	adc	r19, r1
    2f06:	30 93 65 03 	sts	0x0365, r19
    2f0a:	20 93 64 03 	sts	0x0364, r18
    if(tmp16 > uip_connr->initialmss ||
    2f0e:	8c 89       	ldd	r24, Y+20	; 0x14
    2f10:	9d 89       	ldd	r25, Y+21	; 0x15
    2f12:	82 17       	cp	r24, r18
    2f14:	93 07       	cpc	r25, r19
    2f16:	10 f0       	brcs	.+4      	; 0x2f1c <uip_process+0xcc6>
    2f18:	23 2b       	or	r18, r19
    2f1a:	21 f4       	brne	.+8      	; 0x2f24 <uip_process+0xcce>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    2f1c:	90 93 65 03 	sts	0x0365, r25
    2f20:	80 93 64 03 	sts	0x0364, r24
    }
    uip_connr->mss = tmp16;
    2f24:	80 91 64 03 	lds	r24, 0x0364
    2f28:	90 91 65 03 	lds	r25, 0x0365
    2f2c:	9b 8b       	std	Y+19, r25	; 0x13
    2f2e:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    2f30:	80 91 23 06 	lds	r24, 0x0623
    2f34:	90 e0       	ldi	r25, 0x00	; 0
    2f36:	83 70       	andi	r24, 0x03	; 3
    2f38:	90 70       	andi	r25, 0x00	; 0
    2f3a:	89 2b       	or	r24, r25
    2f3c:	09 f4       	brne	.+2      	; 0x2f40 <uip_process+0xcea>
    2f3e:	5b c1       	rjmp	.+694    	; 0x31f6 <uip_process+0xfa0>
      uip_slen = 0;
    2f40:	10 92 80 0d 	sts	0x0D80, r1
    2f44:	10 92 7f 0d 	sts	0x0D7F, r1
      UIP_APPCALL();
    2f48:	0e 94 4b 08 	call	0x1096	; 0x1096 <uIPManagement_TCPCallback>

    appsend:

      if(uip_flags & UIP_ABORT) {
    2f4c:	80 91 23 06 	lds	r24, 0x0623
    2f50:	28 2f       	mov	r18, r24
    2f52:	85 ff       	sbrs	r24, 5
    2f54:	07 c0       	rjmp	.+14     	; 0x2f64 <uip_process+0xd0e>
	uip_slen = 0;
    2f56:	10 92 80 0d 	sts	0x0D80, r1
    2f5a:	10 92 7f 0d 	sts	0x0D7F, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    2f5e:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    2f60:	84 e1       	ldi	r24, 0x14	; 20
    2f62:	94 cf       	rjmp	.-216    	; 0x2e8c <uip_process+0xc36>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    2f64:	84 ff       	sbrs	r24, 4
    2f66:	0a c0       	rjmp	.+20     	; 0x2f7c <uip_process+0xd26>
	uip_slen = 0;
    2f68:	10 92 80 0d 	sts	0x0D80, r1
    2f6c:	10 92 7f 0d 	sts	0x0D7F, r1
	uip_connr->len = 1;
    2f70:	81 e0       	ldi	r24, 0x01	; 1
    2f72:	90 e0       	ldi	r25, 0x00	; 0
    2f74:	99 8b       	std	Y+17, r25	; 0x11
    2f76:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    2f78:	84 e0       	ldi	r24, 0x04	; 4
    2f7a:	85 cf       	rjmp	.-246    	; 0x2e86 <uip_process+0xc30>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    2f7c:	80 91 7f 0d 	lds	r24, 0x0D7F
    2f80:	90 91 80 0d 	lds	r25, 0x0D80
    2f84:	89 2b       	or	r24, r25
    2f86:	01 f1       	breq	.+64     	; 0x2fc8 <uip_process+0xd72>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    2f88:	20 ff       	sbrs	r18, 0
    2f8a:	02 c0       	rjmp	.+4      	; 0x2f90 <uip_process+0xd3a>
	  uip_connr->len = 0;
    2f8c:	19 8a       	std	Y+17, r1	; 0x11
    2f8e:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    2f90:	88 89       	ldd	r24, Y+16	; 0x10
    2f92:	99 89       	ldd	r25, Y+17	; 0x11
    2f94:	00 97       	sbiw	r24, 0x00	; 0
    2f96:	a1 f4       	brne	.+40     	; 0x2fc0 <uip_process+0xd6a>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    2f98:	2a 89       	ldd	r18, Y+18	; 0x12
    2f9a:	3b 89       	ldd	r19, Y+19	; 0x13
    2f9c:	80 91 7f 0d 	lds	r24, 0x0D7F
    2fa0:	90 91 80 0d 	lds	r25, 0x0D80
    2fa4:	28 17       	cp	r18, r24
    2fa6:	39 07       	cpc	r19, r25
    2fa8:	20 f4       	brcc	.+8      	; 0x2fb2 <uip_process+0xd5c>
	    uip_slen = uip_connr->mss;
    2faa:	30 93 80 0d 	sts	0x0D80, r19
    2fae:	20 93 7f 0d 	sts	0x0D7F, r18
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    2fb2:	80 91 7f 0d 	lds	r24, 0x0D7F
    2fb6:	90 91 80 0d 	lds	r25, 0x0D80
    2fba:	99 8b       	std	Y+17, r25	; 0x11
    2fbc:	88 8b       	std	Y+16, r24	; 0x10
    2fbe:	04 c0       	rjmp	.+8      	; 0x2fc8 <uip_process+0xd72>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    2fc0:	90 93 80 0d 	sts	0x0D80, r25
    2fc4:	80 93 7f 0d 	sts	0x0D7F, r24
	}
      }
      uip_connr->nrtx = 0;
    2fc8:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    2fca:	80 91 1d 06 	lds	r24, 0x061D
    2fce:	90 91 1e 06 	lds	r25, 0x061E
    2fd2:	90 93 27 06 	sts	0x0627, r25
    2fd6:	80 93 26 06 	sts	0x0626, r24

      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    2fda:	80 91 7f 0d 	lds	r24, 0x0D7F
    2fde:	90 91 80 0d 	lds	r25, 0x0D80
    2fe2:	89 2b       	or	r24, r25
    2fe4:	59 f0       	breq	.+22     	; 0x2ffc <uip_process+0xda6>
    2fe6:	88 89       	ldd	r24, Y+16	; 0x10
    2fe8:	99 89       	ldd	r25, Y+17	; 0x11
    2fea:	00 97       	sbiw	r24, 0x00	; 0
    2fec:	39 f0       	breq	.+14     	; 0x2ffc <uip_process+0xda6>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    2fee:	88 96       	adiw	r24, 0x28	; 40
    2ff0:	90 93 1c 06 	sts	0x061C, r25
    2ff4:	80 93 1b 06 	sts	0x061B, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    2ff8:	88 e1       	ldi	r24, 0x18	; 24
    2ffa:	0b c0       	rjmp	.+22     	; 0x3012 <uip_process+0xdbc>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    2ffc:	80 91 23 06 	lds	r24, 0x0623
    3000:	81 ff       	sbrs	r24, 1
    3002:	f9 c0       	rjmp	.+498    	; 0x31f6 <uip_process+0xfa0>
	uip_len = UIP_TCPIP_HLEN;
    3004:	88 e2       	ldi	r24, 0x28	; 40
    3006:	90 e0       	ldi	r25, 0x00	; 0
    3008:	90 93 1c 06 	sts	0x061C, r25
    300c:	80 93 1b 06 	sts	0x061B, r24
	BUF->flags = TCP_ACK;
    3010:	80 e1       	ldi	r24, 0x10	; 16
    3012:	80 93 c2 07 	sts	0x07C2, r24
    3016:	59 c0       	rjmp	.+178    	; 0x30ca <uip_process+0xe74>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    3018:	80 91 23 06 	lds	r24, 0x0623
    301c:	80 ff       	sbrs	r24, 0
    301e:	eb c0       	rjmp	.+470    	; 0x31f6 <uip_process+0xfa0>
      uip_connr->tcpstateflags = UIP_CLOSED;
    3020:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    3022:	80 e1       	ldi	r24, 0x10	; 16
    3024:	80 93 23 06 	sts	0x0623, r24
      UIP_APPCALL();
    3028:	0e 94 4b 08 	call	0x1096	; 0x1096 <uIPManagement_TCPCallback>
    302c:	e4 c0       	rjmp	.+456    	; 0x31f6 <uip_process+0xfa0>

  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    302e:	80 91 1b 06 	lds	r24, 0x061B
    3032:	90 91 1c 06 	lds	r25, 0x061C
    3036:	00 97       	sbiw	r24, 0x00	; 0
    3038:	09 f0       	breq	.+2      	; 0x303c <uip_process+0xde6>
      uip_add_rcv_nxt(uip_len);
    303a:	94 d8       	rcall	.-3800   	; 0x2164 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    303c:	80 91 c2 07 	lds	r24, 0x07C2
    3040:	90 91 23 06 	lds	r25, 0x0623
    3044:	80 ff       	sbrs	r24, 0
    3046:	0b c0       	rjmp	.+22     	; 0x305e <uip_process+0xe08>
      if(uip_flags & UIP_ACKDATA) {
    3048:	90 ff       	sbrs	r25, 0
    304a:	06 c0       	rjmp	.+12     	; 0x3058 <uip_process+0xe02>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    304c:	87 e0       	ldi	r24, 0x07	; 7
    304e:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    3050:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    3052:	19 8a       	std	Y+17, r1	; 0x11
    3054:	18 8a       	std	Y+16, r1	; 0x10
    3056:	18 c0       	rjmp	.+48     	; 0x3088 <uip_process+0xe32>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    3058:	86 e0       	ldi	r24, 0x06	; 6
    305a:	89 8f       	std	Y+25, r24	; 0x19
    305c:	15 c0       	rjmp	.+42     	; 0x3088 <uip_process+0xe32>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    305e:	90 ff       	sbrs	r25, 0
    3060:	1c c0       	rjmp	.+56     	; 0x309a <uip_process+0xe44>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    3062:	85 e0       	ldi	r24, 0x05	; 5
    3064:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    3066:	19 8a       	std	Y+17, r1	; 0x11
    3068:	18 8a       	std	Y+16, r1	; 0x10
    306a:	c5 c0       	rjmp	.+394    	; 0x31f6 <uip_process+0xfa0>
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    306c:	80 91 1b 06 	lds	r24, 0x061B
    3070:	90 91 1c 06 	lds	r25, 0x061C
    3074:	00 97       	sbiw	r24, 0x00	; 0
    3076:	09 f0       	breq	.+2      	; 0x307a <uip_process+0xe24>
      uip_add_rcv_nxt(uip_len);
    3078:	75 d8       	rcall	.-3862   	; 0x2164 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    307a:	80 91 c2 07 	lds	r24, 0x07C2
    307e:	80 ff       	sbrs	r24, 0
    3080:	0c c0       	rjmp	.+24     	; 0x309a <uip_process+0xe44>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    3082:	87 e0       	ldi	r24, 0x07	; 7
    3084:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    3086:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    3088:	81 e0       	ldi	r24, 0x01	; 1
    308a:	90 e0       	ldi	r25, 0x00	; 0
    308c:	6b d8       	rcall	.-3882   	; 0x2164 <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    308e:	80 e1       	ldi	r24, 0x10	; 16
    3090:	80 93 23 06 	sts	0x0623, r24
      UIP_APPCALL();
    3094:	0e 94 4b 08 	call	0x1096	; 0x1096 <uIPManagement_TCPCallback>
    3098:	0f c0       	rjmp	.+30     	; 0x30b8 <uip_process+0xe62>
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
    309a:	80 91 1b 06 	lds	r24, 0x061B
    309e:	90 91 1c 06 	lds	r25, 0x061C
    30a2:	89 2b       	or	r24, r25
    30a4:	49 f4       	brne	.+18     	; 0x30b8 <uip_process+0xe62>
    30a6:	a7 c0       	rjmp	.+334    	; 0x31f6 <uip_process+0xfa0>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;

  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    30a8:	80 91 23 06 	lds	r24, 0x0623
    30ac:	80 ff       	sbrs	r24, 0
    30ae:	a3 c0       	rjmp	.+326    	; 0x31f6 <uip_process+0xfa0>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    30b0:	87 e0       	ldi	r24, 0x07	; 7
    30b2:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    30b4:	1a 8e       	std	Y+26, r1	; 0x1a
    30b6:	9f c0       	rjmp	.+318    	; 0x31f6 <uip_process+0xfa0>
  goto drop;

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    30b8:	80 e1       	ldi	r24, 0x10	; 16
    30ba:	f8 01       	movw	r30, r16
    30bc:	81 a3       	std	Z+33, r24	; 0x21

 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    30be:	88 e2       	ldi	r24, 0x28	; 40
    30c0:	90 e0       	ldi	r25, 0x00	; 0
    30c2:	90 93 1c 06 	sts	0x061C, r25
    30c6:	80 93 1b 06 	sts	0x061B, r24

 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    30ca:	80 e5       	ldi	r24, 0x50	; 80
    30cc:	80 93 c1 07 	sts	0x07C1, r24
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
 tcp_send:
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    30d0:	88 85       	ldd	r24, Y+8	; 0x08
    30d2:	80 93 bd 07 	sts	0x07BD, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    30d6:	89 85       	ldd	r24, Y+9	; 0x09
    30d8:	80 93 be 07 	sts	0x07BE, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    30dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    30de:	80 93 bf 07 	sts	0x07BF, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    30e2:	8b 85       	ldd	r24, Y+11	; 0x0b
    30e4:	80 93 c0 07 	sts	0x07C0, r24

  BUF->seqno[0] = uip_connr->snd_nxt[0];
    30e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    30ea:	80 93 b9 07 	sts	0x07B9, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    30ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    30f0:	80 93 ba 07 	sts	0x07BA, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    30f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    30f6:	80 93 bb 07 	sts	0x07BB, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    30fa:	8f 85       	ldd	r24, Y+15	; 0x0f
    30fc:	80 93 bc 07 	sts	0x07BC, r24

  BUF->proto = UIP_PROTO_TCP;
    3100:	86 e0       	ldi	r24, 0x06	; 6
    3102:	80 93 aa 07 	sts	0x07AA, r24

  BUF->srcport  = uip_connr->lport;
    3106:	8c 81       	ldd	r24, Y+4	; 0x04
    3108:	9d 81       	ldd	r25, Y+5	; 0x05
    310a:	90 93 b6 07 	sts	0x07B6, r25
    310e:	80 93 b5 07 	sts	0x07B5, r24
  BUF->destport = uip_connr->rport;
    3112:	8e 81       	ldd	r24, Y+6	; 0x06
    3114:	9f 81       	ldd	r25, Y+7	; 0x07
    3116:	90 93 b8 07 	sts	0x07B8, r25
    311a:	80 93 b7 07 	sts	0x07B7, r24

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    311e:	80 91 8f 07 	lds	r24, 0x078F
    3122:	90 91 90 07 	lds	r25, 0x0790
    3126:	a0 91 91 07 	lds	r26, 0x0791
    312a:	b0 91 92 07 	lds	r27, 0x0792
    312e:	80 93 ad 07 	sts	0x07AD, r24
    3132:	90 93 ae 07 	sts	0x07AE, r25
    3136:	a0 93 af 07 	sts	0x07AF, r26
    313a:	b0 93 b0 07 	sts	0x07B0, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
    313e:	88 81       	ld	r24, Y
    3140:	99 81       	ldd	r25, Y+1	; 0x01
    3142:	aa 81       	ldd	r26, Y+2	; 0x02
    3144:	bb 81       	ldd	r27, Y+3	; 0x03
    3146:	80 93 b1 07 	sts	0x07B1, r24
    314a:	90 93 b2 07 	sts	0x07B2, r25
    314e:	a0 93 b3 07 	sts	0x07B3, r26
    3152:	b0 93 b4 07 	sts	0x07B4, r27

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    3156:	89 8d       	ldd	r24, Y+25	; 0x19
    3158:	84 ff       	sbrs	r24, 4
    315a:	05 c0       	rjmp	.+10     	; 0x3166 <uip_process+0xf10>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    315c:	10 92 c4 07 	sts	0x07C4, r1
    3160:	10 92 c3 07 	sts	0x07C3, r1
    3164:	06 c0       	rjmp	.+12     	; 0x3172 <uip_process+0xf1c>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    3166:	85 e0       	ldi	r24, 0x05	; 5
    3168:	80 93 c3 07 	sts	0x07C3, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    316c:	84 eb       	ldi	r24, 0xB4	; 180
    316e:	80 93 c4 07 	sts	0x07C4, r24
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    3172:	80 e4       	ldi	r24, 0x40	; 64
    3174:	80 93 a9 07 	sts	0x07A9, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    3178:	80 91 1b 06 	lds	r24, 0x061B
    317c:	90 91 1c 06 	lds	r25, 0x061C
    3180:	89 2f       	mov	r24, r25
    3182:	99 27       	eor	r25, r25
    3184:	80 93 a3 07 	sts	0x07A3, r24
  BUF->len[1] = (uip_len & 0xff);
    3188:	80 91 1b 06 	lds	r24, 0x061B
    318c:	80 93 a4 07 	sts	0x07A4, r24
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    3190:	10 92 c8 07 	sts	0x07C8, r1
    3194:	10 92 c7 07 	sts	0x07C7, r1

  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    3198:	10 92 c6 07 	sts	0x07C6, r1
    319c:	10 92 c5 07 	sts	0x07C5, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    31a0:	09 d8       	rcall	.-4078   	; 0x21b4 <uip_tcpchksum>
    31a2:	80 95       	com	r24
    31a4:	90 95       	com	r25
    31a6:	90 93 c6 07 	sts	0x07C6, r25
    31aa:	80 93 c5 07 	sts	0x07C5, r24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    31ae:	85 e4       	ldi	r24, 0x45	; 69
    31b0:	80 93 a1 07 	sts	0x07A1, r24
  BUF->tos = 0;
    31b4:	10 92 a2 07 	sts	0x07A2, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    31b8:	10 92 a8 07 	sts	0x07A8, r1
    31bc:	10 92 a7 07 	sts	0x07A7, r1
  ++ipid;
    31c0:	80 91 5a 03 	lds	r24, 0x035A
    31c4:	90 91 5b 03 	lds	r25, 0x035B
    31c8:	01 96       	adiw	r24, 0x01	; 1
    31ca:	90 93 5b 03 	sts	0x035B, r25
    31ce:	80 93 5a 03 	sts	0x035A, r24
  BUF->ipid[0] = ipid >> 8;
    31d2:	29 2f       	mov	r18, r25
    31d4:	33 27       	eor	r19, r19
    31d6:	20 93 a5 07 	sts	0x07A5, r18
  BUF->ipid[1] = ipid & 0xff;
    31da:	80 93 a6 07 	sts	0x07A6, r24
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    31de:	10 92 ac 07 	sts	0x07AC, r1
    31e2:	10 92 ab 07 	sts	0x07AB, r1
  BUF->ipchksum = ~(uip_ipchksum());
    31e6:	08 d8       	rcall	.-4080   	; 0x21f8 <uip_ipchksum>
    31e8:	80 95       	com	r24
    31ea:	90 95       	com	r25
    31ec:	90 93 ac 07 	sts	0x07AC, r25
    31f0:	80 93 ab 07 	sts	0x07AB, r24
    31f4:	04 c0       	rjmp	.+8      	; 0x31fe <uip_process+0xfa8>
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;

 drop:
  uip_len = 0;
    31f6:	10 92 1c 06 	sts	0x061C, r1
    31fa:	10 92 1b 06 	sts	0x061B, r1
  uip_flags = 0;
    31fe:	10 92 23 06 	sts	0x0623, r1
  return;
}
    3202:	df 91       	pop	r29
    3204:	cf 91       	pop	r28
    3206:	1f 91       	pop	r17
    3208:	0f 91       	pop	r16
    320a:	08 95       	ret

0000320c <uip_udp_new>:
#endif /* UIP_ACTIVE_OPEN */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
struct uip_udp_conn *
uip_udp_new(const uip_ipaddr_t *ripaddr, u16_t rport)
{
    320c:	cf 92       	push	r12
    320e:	df 92       	push	r13
    3210:	ef 92       	push	r14
    3212:	ff 92       	push	r15
    3214:	0f 93       	push	r16
    3216:	1f 93       	push	r17
    3218:	cf 93       	push	r28
    321a:	df 93       	push	r29
    321c:	7c 01       	movw	r14, r24
    321e:	6b 01       	movw	r12, r22
  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    3220:	00 91 85 0d 	lds	r16, 0x0D85
    3224:	10 91 86 0d 	lds	r17, 0x0D86
    3228:	c0 91 60 03 	lds	r28, 0x0360
    322c:	d0 91 61 03 	lds	r29, 0x0361
{
  register struct uip_udp_conn *conn;

  /* Find an unused local port. */
 again:
  ++lastport;
    3230:	21 96       	adiw	r28, 0x01	; 1

  if(lastport >= 32000) {
    3232:	8d e7       	ldi	r24, 0x7D	; 125
    3234:	c0 30       	cpi	r28, 0x00	; 0
    3236:	d8 07       	cpc	r29, r24
    3238:	10 f0       	brcs	.+4      	; 0x323e <uip_udp_new+0x32>
    323a:	c0 e0       	ldi	r28, 0x00	; 0
    323c:	d0 e1       	ldi	r29, 0x10	; 16
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    323e:	ce 01       	movw	r24, r28
    3240:	0e 94 d6 10 	call	0x21ac	; 0x21ac <htons>
    3244:	08 17       	cp	r16, r24
    3246:	19 07       	cpc	r17, r25
    3248:	99 f3       	breq	.-26     	; 0x3230 <uip_udp_new+0x24>

  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    324a:	d0 93 61 03 	sts	0x0361, r29
    324e:	c0 93 60 03 	sts	0x0360, r28
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
    3252:	01 2b       	or	r16, r17
    3254:	81 f4       	brne	.+32     	; 0x3276 <uip_udp_new+0x6a>
    3256:	10 92 62 03 	sts	0x0362, r1

  if(conn == 0) {
    return 0;
  }

  conn->lport = HTONS(lastport);
    325a:	9c 2f       	mov	r25, r28
    325c:	8d 2f       	mov	r24, r29
    325e:	90 93 86 0d 	sts	0x0D86, r25
    3262:	80 93 85 0d 	sts	0x0D85, r24
  conn->rport = rport;
    3266:	d0 92 88 0d 	sts	0x0D88, r13
    326a:	c0 92 87 0d 	sts	0x0D87, r12
  if(ripaddr == NULL) {
    326e:	e1 14       	cp	r14, r1
    3270:	f1 04       	cpc	r15, r1
    3272:	81 f4       	brne	.+32     	; 0x3294 <uip_udp_new+0x88>
    3274:	06 c0       	rjmp	.+12     	; 0x3282 <uip_udp_new+0x76>
    3276:	81 e0       	ldi	r24, 0x01	; 1
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    3278:	80 93 62 03 	sts	0x0362, r24
    327c:	80 e0       	ldi	r24, 0x00	; 0
    327e:	90 e0       	ldi	r25, 0x00	; 0
    3280:	1b c0       	rjmp	.+54     	; 0x32b8 <uip_udp_new+0xac>
  }

  conn->lport = HTONS(lastport);
  conn->rport = rport;
  if(ripaddr == NULL) {
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
    3282:	10 92 81 0d 	sts	0x0D81, r1
    3286:	10 92 82 0d 	sts	0x0D82, r1
    328a:	10 92 83 0d 	sts	0x0D83, r1
    328e:	10 92 84 0d 	sts	0x0D84, r1
    3292:	0d c0       	rjmp	.+26     	; 0x32ae <uip_udp_new+0xa2>
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    3294:	f7 01       	movw	r30, r14
    3296:	80 81       	ld	r24, Z
    3298:	91 81       	ldd	r25, Z+1	; 0x01
    329a:	a2 81       	ldd	r26, Z+2	; 0x02
    329c:	b3 81       	ldd	r27, Z+3	; 0x03
    329e:	80 93 81 0d 	sts	0x0D81, r24
    32a2:	90 93 82 0d 	sts	0x0D82, r25
    32a6:	a0 93 83 0d 	sts	0x0D83, r26
    32aa:	b0 93 84 0d 	sts	0x0D84, r27
  }
  conn->ttl = UIP_TTL;
    32ae:	80 e4       	ldi	r24, 0x40	; 64
    32b0:	80 93 89 0d 	sts	0x0D89, r24
    32b4:	81 e8       	ldi	r24, 0x81	; 129
    32b6:	9d e0       	ldi	r25, 0x0D	; 13

  return conn;
}
    32b8:	df 91       	pop	r29
    32ba:	cf 91       	pop	r28
    32bc:	1f 91       	pop	r17
    32be:	0f 91       	pop	r16
    32c0:	ff 90       	pop	r15
    32c2:	ef 90       	pop	r14
    32c4:	df 90       	pop	r13
    32c6:	cf 90       	pop	r12
    32c8:	08 95       	ret

000032ca <uip_arp_update>:

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
{
    32ca:	cf 92       	push	r12
    32cc:	df 92       	push	r13
    32ce:	ef 92       	push	r14
    32d0:	ff 92       	push	r15
    32d2:	1f 93       	push	r17
    32d4:	cf 93       	push	r28
    32d6:	df 93       	push	r29
    32d8:	dc 01       	movw	r26, r24
    32da:	6b 01       	movw	r12, r22
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32dc:	10 92 c2 03 	sts	0x03C2, r1

    tabptr = &arp_table[i];
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    32e0:	60 91 19 03 	lds	r22, 0x0319
    32e4:	70 91 1a 03 	lds	r23, 0x031A
    32e8:	c0 91 1b 03 	lds	r28, 0x031B
    32ec:	d0 91 1c 03 	lds	r29, 0x031C
    32f0:	e0 e0       	ldi	r30, 0x00	; 0
    32f2:	f0 e0       	ldi	r31, 0x00	; 0
    32f4:	40 e0       	ldi	r20, 0x00	; 0
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {

    tabptr = &arp_table[i];
    32f6:	5b e0       	ldi	r21, 0x0B	; 11
    32f8:	2a c0       	rjmp	.+84     	; 0x334e <uip_arp_update+0x84>
    32fa:	45 9f       	mul	r20, r21
    32fc:	f0 01       	movw	r30, r0
    32fe:	11 24       	eor	r1, r1
    3300:	ea 59       	subi	r30, 0x9A	; 154
    3302:	fc 4f       	sbci	r31, 0xFC	; 252
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3304:	20 81       	ld	r18, Z
    3306:	31 81       	ldd	r19, Z+1	; 0x01
    3308:	26 17       	cp	r18, r22
    330a:	37 07       	cpc	r19, r23
    330c:	29 f4       	brne	.+10     	; 0x3318 <uip_arp_update+0x4e>
    330e:	82 81       	ldd	r24, Z+2	; 0x02
    3310:	93 81       	ldd	r25, Z+3	; 0x03
    3312:	8c 17       	cp	r24, r28
    3314:	9d 07       	cpc	r25, r29
    3316:	d1 f0       	breq	.+52     	; 0x334c <uip_arp_update+0x82>

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    3318:	8d 91       	ld	r24, X+
    331a:	9c 91       	ld	r25, X
    331c:	11 97       	sbiw	r26, 0x01	; 1
    331e:	82 17       	cp	r24, r18
    3320:	93 07       	cpc	r25, r19
    3322:	a1 f4       	brne	.+40     	; 0x334c <uip_arp_update+0x82>
    3324:	12 96       	adiw	r26, 0x02	; 2
    3326:	2d 91       	ld	r18, X+
    3328:	3c 91       	ld	r19, X
    332a:	13 97       	sbiw	r26, 0x03	; 3
    332c:	82 81       	ldd	r24, Z+2	; 0x02
    332e:	93 81       	ldd	r25, Z+3	; 0x03
    3330:	28 17       	cp	r18, r24
    3332:	39 07       	cpc	r19, r25
    3334:	59 f4       	brne	.+22     	; 0x334c <uip_arp_update+0x82>
    3336:	40 93 c2 03 	sts	0x03C2, r20

	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    333a:	ef 01       	movw	r28, r30
    333c:	24 96       	adiw	r28, 0x04	; 4
    333e:	d6 01       	movw	r26, r12
    3340:	86 e0       	ldi	r24, 0x06	; 6
    3342:	0d 90       	ld	r0, X+
    3344:	09 92       	st	Y+, r0
    3346:	81 50       	subi	r24, 0x01	; 1
    3348:	e1 f7       	brne	.-8      	; 0x3342 <uip_arp_update+0x78>
    334a:	66 c0       	rjmp	.+204    	; 0x3418 <uip_arp_update+0x14e>
	tabptr->time = arptime;

	return;
    334c:	4f 5f       	subi	r20, 0xFF	; 255
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    334e:	48 30       	cpi	r20, 0x08	; 8
    3350:	a0 f2       	brcs	.-88     	; 0x32fa <uip_arp_update+0x30>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3352:	10 92 c2 03 	sts	0x03C2, r1
    3356:	20 e0       	ldi	r18, 0x00	; 0
    tabptr = &arp_table[i];
    3358:	3b e0       	ldi	r19, 0x0B	; 11
    335a:	13 c0       	rjmp	.+38     	; 0x3382 <uip_arp_update+0xb8>
    335c:	23 9f       	mul	r18, r19
    335e:	f0 01       	movw	r30, r0
    3360:	11 24       	eor	r1, r1
    3362:	ea 59       	subi	r30, 0x9A	; 154
    3364:	fc 4f       	sbci	r31, 0xFC	; 252
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3366:	80 81       	ld	r24, Z
    3368:	91 81       	ldd	r25, Z+1	; 0x01
    336a:	86 17       	cp	r24, r22
    336c:	97 07       	cpc	r25, r23
    336e:	41 f4       	brne	.+16     	; 0x3380 <uip_arp_update+0xb6>
    3370:	82 81       	ldd	r24, Z+2	; 0x02
    3372:	93 81       	ldd	r25, Z+3	; 0x03
    3374:	8c 17       	cp	r24, r28
    3376:	9d 07       	cpc	r25, r29
    3378:	19 f4       	brne	.+6      	; 0x3380 <uip_arp_update+0xb6>
    337a:	20 93 c2 03 	sts	0x03C2, r18
    337e:	3c c0       	rjmp	.+120    	; 0x33f8 <uip_arp_update+0x12e>
    3380:	2f 5f       	subi	r18, 0xFF	; 255

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3382:	28 30       	cpi	r18, 0x08	; 8
    3384:	58 f3       	brcs	.-42     	; 0x335c <uip_arp_update+0x92>
    3386:	20 93 c2 03 	sts	0x03C2, r18
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    338a:	28 30       	cpi	r18, 0x08	; 8
    338c:	a9 f5       	brne	.+106    	; 0x33f8 <uip_arp_update+0x12e>
    tmpage = 0;
    338e:	10 92 c5 03 	sts	0x03C5, r1
    c = 0;
    3392:	10 92 c3 03 	sts	0x03C3, r1
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    3396:	10 91 c4 03 	lds	r17, 0x03C4
    339a:	c1 2f       	mov	r28, r17
    339c:	d0 e0       	ldi	r29, 0x00	; 0
    339e:	60 e0       	ldi	r22, 0x00	; 0
    33a0:	70 e0       	ldi	r23, 0x00	; 0
    33a2:	40 e0       	ldi	r20, 0x00	; 0
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    33a4:	8b e0       	ldi	r24, 0x0B	; 11
    33a6:	e8 2e       	mov	r14, r24
    33a8:	f1 2c       	mov	r15, r1
    33aa:	18 c0       	rjmp	.+48     	; 0x33dc <uip_arp_update+0x112>
    33ac:	84 2f       	mov	r24, r20
    33ae:	90 e0       	ldi	r25, 0x00	; 0
    33b0:	8e 9d       	mul	r24, r14
    33b2:	f0 01       	movw	r30, r0
    33b4:	8f 9d       	mul	r24, r15
    33b6:	f0 0d       	add	r31, r0
    33b8:	9e 9d       	mul	r25, r14
    33ba:	f0 0d       	add	r31, r0
    33bc:	11 24       	eor	r1, r1
    33be:	ea 59       	subi	r30, 0x9A	; 154
    33c0:	fc 4f       	sbci	r31, 0xFC	; 252
    33c2:	52 85       	ldd	r21, Z+10	; 0x0a
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    33c4:	9e 01       	movw	r18, r28
    33c6:	25 1b       	sub	r18, r21
    33c8:	31 09       	sbc	r19, r1
    33ca:	87 2f       	mov	r24, r23
    33cc:	90 e0       	ldi	r25, 0x00	; 0
    33ce:	82 17       	cp	r24, r18
    33d0:	93 07       	cpc	r25, r19
    33d2:	1c f4       	brge	.+6      	; 0x33da <uip_arp_update+0x110>
	tmpage = arptime - tabptr->time;
    33d4:	71 2f       	mov	r23, r17
    33d6:	75 1b       	sub	r23, r21
    33d8:	64 2f       	mov	r22, r20
    33da:	4f 5f       	subi	r20, 0xFF	; 255
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    33dc:	48 30       	cpi	r20, 0x08	; 8
    33de:	30 f3       	brcs	.-52     	; 0x33ac <uip_arp_update+0xe2>
    33e0:	60 93 c3 03 	sts	0x03C3, r22
    33e4:	70 93 c5 03 	sts	0x03C5, r23
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
	c = i;
      }
    }
    i = c;
    33e8:	60 93 c2 03 	sts	0x03C2, r22
    tabptr = &arp_table[i];
    33ec:	8b e0       	ldi	r24, 0x0B	; 11
    33ee:	68 9f       	mul	r22, r24
    33f0:	f0 01       	movw	r30, r0
    33f2:	11 24       	eor	r1, r1
    33f4:	ea 59       	subi	r30, 0x9A	; 154
    33f6:	fc 4f       	sbci	r31, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  uip_ipaddr_copy(&tabptr->ipaddr, ipaddr);
    33f8:	8d 91       	ld	r24, X+
    33fa:	9d 91       	ld	r25, X+
    33fc:	0d 90       	ld	r0, X+
    33fe:	bc 91       	ld	r27, X
    3400:	a0 2d       	mov	r26, r0
    3402:	ef 01       	movw	r28, r30
    3404:	89 93       	st	Y+, r24
    3406:	99 93       	st	Y+, r25
    3408:	a9 93       	st	Y+, r26
    340a:	b9 93       	st	Y+, r27
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    340c:	d6 01       	movw	r26, r12
    340e:	86 e0       	ldi	r24, 0x06	; 6
    3410:	0d 90       	ld	r0, X+
    3412:	09 92       	st	Y+, r0
    3414:	81 50       	subi	r24, 0x01	; 1
    3416:	e1 f7       	brne	.-8      	; 0x3410 <uip_arp_update+0x146>
  tabptr->time = arptime;
    3418:	80 91 c4 03 	lds	r24, 0x03C4
    341c:	82 87       	std	Z+10, r24	; 0x0a
}
    341e:	df 91       	pop	r29
    3420:	cf 91       	pop	r28
    3422:	1f 91       	pop	r17
    3424:	ff 90       	pop	r15
    3426:	ef 90       	pop	r14
    3428:	df 90       	pop	r13
    342a:	cf 90       	pop	r12
    342c:	08 95       	ret

0000342e <uip_arp_arpin>:
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
    342e:	cf 93       	push	r28
    3430:	df 93       	push	r29
  if(uip_len < sizeof(struct arp_hdr)) {
    3432:	80 91 1b 06 	lds	r24, 0x061B
    3436:	90 91 1c 06 	lds	r25, 0x061C
    343a:	8a 97       	sbiw	r24, 0x2a	; 42
    343c:	28 f4       	brcc	.+10     	; 0x3448 <uip_arp_arpin+0x1a>
    uip_len = 0;
    343e:	10 92 1c 06 	sts	0x061C, r1
    3442:	10 92 1b 06 	sts	0x061B, r1
    3446:	a4 c0       	rjmp	.+328    	; 0x3590 <uip_arp_arpin+0x162>
    return;
  }
  uip_len = 0;
    3448:	10 92 1c 06 	sts	0x061C, r1
    344c:	10 92 1b 06 	sts	0x061B, r1

  switch(BUF->opcode) {
    3450:	c3 e9       	ldi	r28, 0x93	; 147
    3452:	d7 e0       	ldi	r29, 0x07	; 7
    3454:	80 91 a7 07 	lds	r24, 0x07A7
    3458:	90 91 a8 07 	lds	r25, 0x07A8
    345c:	21 e0       	ldi	r18, 0x01	; 1
    345e:	80 30       	cpi	r24, 0x00	; 0
    3460:	92 07       	cpc	r25, r18
    3462:	29 f0       	breq	.+10     	; 0x346e <uip_arp_arpin+0x40>
    3464:	80 50       	subi	r24, 0x00	; 0
    3466:	92 40       	sbci	r25, 0x02	; 2
    3468:	09 f0       	breq	.+2      	; 0x346c <uip_arp_arpin+0x3e>
    346a:	92 c0       	rjmp	.+292    	; 0x3590 <uip_arp_arpin+0x162>
    346c:	75 c0       	rjmp	.+234    	; 0x3558 <uip_arp_arpin+0x12a>
    PRINTF("uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n",
	   BUF->dipaddr.u8[0], BUF->dipaddr.u8[1],
	   BUF->dipaddr.u8[2], BUF->dipaddr.u8[3],
	   uip_hostaddr.u8[0], uip_hostaddr.u8[1],
	   uip_hostaddr.u8[2], uip_hostaddr.u8[3]);
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    346e:	20 91 b9 07 	lds	r18, 0x07B9
    3472:	30 91 ba 07 	lds	r19, 0x07BA
    3476:	80 91 8f 07 	lds	r24, 0x078F
    347a:	90 91 90 07 	lds	r25, 0x0790
    347e:	28 17       	cp	r18, r24
    3480:	39 07       	cpc	r19, r25
    3482:	09 f0       	breq	.+2      	; 0x3486 <uip_arp_arpin+0x58>
    3484:	85 c0       	rjmp	.+266    	; 0x3590 <uip_arp_arpin+0x162>
    3486:	20 91 bb 07 	lds	r18, 0x07BB
    348a:	30 91 bc 07 	lds	r19, 0x07BC
    348e:	80 91 91 07 	lds	r24, 0x0791
    3492:	90 91 92 07 	lds	r25, 0x0792
    3496:	28 17       	cp	r18, r24
    3498:	39 07       	cpc	r19, r25
    349a:	09 f0       	breq	.+2      	; 0x349e <uip_arp_arpin+0x70>
    349c:	79 c0       	rjmp	.+242    	; 0x3590 <uip_arp_arpin+0x162>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    349e:	ce 01       	movw	r24, r28
    34a0:	4c 96       	adiw	r24, 0x1c	; 28
    34a2:	be 01       	movw	r22, r28
    34a4:	6a 5e       	subi	r22, 0xEA	; 234
    34a6:	7f 4f       	sbci	r23, 0xFF	; 255
    34a8:	10 df       	rcall	.-480    	; 0x32ca <uip_arp_update>

      BUF->opcode = HTONS(ARP_REPLY);
    34aa:	80 e0       	ldi	r24, 0x00	; 0
    34ac:	92 e0       	ldi	r25, 0x02	; 2
    34ae:	90 93 a8 07 	sts	0x07A8, r25
    34b2:	80 93 a7 07 	sts	0x07A7, r24

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    34b6:	de 01       	movw	r26, r28
    34b8:	90 96       	adiw	r26, 0x20	; 32
    34ba:	fe 01       	movw	r30, r28
    34bc:	76 96       	adiw	r30, 0x16	; 22
    34be:	86 e0       	ldi	r24, 0x06	; 6
    34c0:	01 90       	ld	r0, Z+
    34c2:	0d 92       	st	X+, r0
    34c4:	81 50       	subi	r24, 0x01	; 1
    34c6:	e1 f7       	brne	.-8      	; 0x34c0 <uip_arp_arpin+0x92>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    34c8:	a9 ea       	ldi	r26, 0xA9	; 169
    34ca:	b7 e0       	ldi	r27, 0x07	; 7
    34cc:	e4 e5       	ldi	r30, 0x54	; 84
    34ce:	f3 e0       	ldi	r31, 0x03	; 3
    34d0:	86 e0       	ldi	r24, 0x06	; 6
    34d2:	01 90       	ld	r0, Z+
    34d4:	0d 92       	st	X+, r0
    34d6:	81 50       	subi	r24, 0x01	; 1
    34d8:	e1 f7       	brne	.-8      	; 0x34d2 <uip_arp_arpin+0xa4>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    34da:	a9 e9       	ldi	r26, 0x99	; 153
    34dc:	b7 e0       	ldi	r27, 0x07	; 7
    34de:	e4 e5       	ldi	r30, 0x54	; 84
    34e0:	f3 e0       	ldi	r31, 0x03	; 3
    34e2:	86 e0       	ldi	r24, 0x06	; 6
    34e4:	01 90       	ld	r0, Z+
    34e6:	0d 92       	st	X+, r0
    34e8:	81 50       	subi	r24, 0x01	; 1
    34ea:	e1 f7       	brne	.-8      	; 0x34e4 <uip_arp_arpin+0xb6>
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    34ec:	e3 e9       	ldi	r30, 0x93	; 147
    34ee:	f7 e0       	ldi	r31, 0x07	; 7
    34f0:	df 01       	movw	r26, r30
    34f2:	90 96       	adiw	r26, 0x20	; 32
    34f4:	86 e0       	ldi	r24, 0x06	; 6
    34f6:	0d 90       	ld	r0, X+
    34f8:	01 92       	st	Z+, r0
    34fa:	81 50       	subi	r24, 0x01	; 1
    34fc:	e1 f7       	brne	.-8      	; 0x34f6 <uip_arp_arpin+0xc8>

      uip_ipaddr_copy(&BUF->dipaddr, &BUF->sipaddr);
    34fe:	80 91 af 07 	lds	r24, 0x07AF
    3502:	90 91 b0 07 	lds	r25, 0x07B0
    3506:	a0 91 b1 07 	lds	r26, 0x07B1
    350a:	b0 91 b2 07 	lds	r27, 0x07B2
    350e:	80 93 b9 07 	sts	0x07B9, r24
    3512:	90 93 ba 07 	sts	0x07BA, r25
    3516:	a0 93 bb 07 	sts	0x07BB, r26
    351a:	b0 93 bc 07 	sts	0x07BC, r27
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    351e:	80 91 8f 07 	lds	r24, 0x078F
    3522:	90 91 90 07 	lds	r25, 0x0790
    3526:	a0 91 91 07 	lds	r26, 0x0791
    352a:	b0 91 92 07 	lds	r27, 0x0792
    352e:	80 93 af 07 	sts	0x07AF, r24
    3532:	90 93 b0 07 	sts	0x07B0, r25
    3536:	a0 93 b1 07 	sts	0x07B1, r26
    353a:	b0 93 b2 07 	sts	0x07B2, r27

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    353e:	88 e0       	ldi	r24, 0x08	; 8
    3540:	96 e0       	ldi	r25, 0x06	; 6
    3542:	90 93 a0 07 	sts	0x07A0, r25
    3546:	80 93 9f 07 	sts	0x079F, r24
      uip_len = sizeof(struct arp_hdr);
    354a:	8a e2       	ldi	r24, 0x2A	; 42
    354c:	90 e0       	ldi	r25, 0x00	; 0
    354e:	90 93 1c 06 	sts	0x061C, r25
    3552:	80 93 1b 06 	sts	0x061B, r24
    3556:	1c c0       	rjmp	.+56     	; 0x3590 <uip_arp_arpin+0x162>
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    3558:	20 91 b9 07 	lds	r18, 0x07B9
    355c:	30 91 ba 07 	lds	r19, 0x07BA
    3560:	80 91 8f 07 	lds	r24, 0x078F
    3564:	90 91 90 07 	lds	r25, 0x0790
    3568:	28 17       	cp	r18, r24
    356a:	39 07       	cpc	r19, r25
    356c:	89 f4       	brne	.+34     	; 0x3590 <uip_arp_arpin+0x162>
    356e:	20 91 bb 07 	lds	r18, 0x07BB
    3572:	30 91 bc 07 	lds	r19, 0x07BC
    3576:	80 91 91 07 	lds	r24, 0x0791
    357a:	90 91 92 07 	lds	r25, 0x0792
    357e:	28 17       	cp	r18, r24
    3580:	39 07       	cpc	r19, r25
    3582:	31 f4       	brne	.+12     	; 0x3590 <uip_arp_arpin+0x162>
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    3584:	ce 01       	movw	r24, r28
    3586:	4c 96       	adiw	r24, 0x1c	; 28
    3588:	be 01       	movw	r22, r28
    358a:	6a 5e       	subi	r22, 0xEA	; 234
    358c:	7f 4f       	sbci	r23, 0xFF	; 255
    358e:	9d de       	rcall	.-710    	; 0x32ca <uip_arp_update>
    }
    break;
  }

  return;
}
    3590:	df 91       	pop	r29
    3592:	cf 91       	pop	r28
    3594:	08 95       	ret

00003596 <uip_arp_out>:

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr)) {
    3596:	20 91 b1 07 	lds	r18, 0x07B1
    359a:	30 91 b2 07 	lds	r19, 0x07B2
    359e:	80 91 15 03 	lds	r24, 0x0315
    35a2:	90 91 16 03 	lds	r25, 0x0316
    35a6:	28 17       	cp	r18, r24
    35a8:	39 07       	cpc	r19, r25
    35aa:	a9 f4       	brne	.+42     	; 0x35d6 <uip_arp_out+0x40>
    35ac:	20 91 b3 07 	lds	r18, 0x07B3
    35b0:	30 91 b4 07 	lds	r19, 0x07B4
    35b4:	80 91 17 03 	lds	r24, 0x0317
    35b8:	90 91 18 03 	lds	r25, 0x0318
    35bc:	28 17       	cp	r18, r24
    35be:	39 07       	cpc	r19, r25
    35c0:	51 f4       	brne	.+20     	; 0x35d6 <uip_arp_out+0x40>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    35c2:	a3 e9       	ldi	r26, 0x93	; 147
    35c4:	b7 e0       	ldi	r27, 0x07	; 7
    35c6:	ed e1       	ldi	r30, 0x1D	; 29
    35c8:	f3 e0       	ldi	r31, 0x03	; 3
    35ca:	86 e0       	ldi	r24, 0x06	; 6
    35cc:	01 90       	ld	r0, Z+
    35ce:	0d 92       	st	X+, r0
    35d0:	81 50       	subi	r24, 0x01	; 1
    35d2:	e1 f7       	brne	.-8      	; 0x35cc <uip_arp_out+0x36>
    35d4:	d3 c0       	rjmp	.+422    	; 0x377c <uip_arp_out+0x1e6>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask)) {
    35d6:	80 91 b1 07 	lds	r24, 0x07B1
    35da:	90 91 b2 07 	lds	r25, 0x07B2
    35de:	20 91 8f 07 	lds	r18, 0x078F
    35e2:	30 91 90 07 	lds	r19, 0x0790
    35e6:	82 27       	eor	r24, r18
    35e8:	93 27       	eor	r25, r19
    35ea:	20 91 8b 07 	lds	r18, 0x078B
    35ee:	30 91 8c 07 	lds	r19, 0x078C
    35f2:	82 23       	and	r24, r18
    35f4:	93 23       	and	r25, r19
    35f6:	89 2b       	or	r24, r25
    35f8:	91 f4       	brne	.+36     	; 0x361e <uip_arp_out+0x88>
    35fa:	80 91 b3 07 	lds	r24, 0x07B3
    35fe:	90 91 b4 07 	lds	r25, 0x07B4
    3602:	20 91 91 07 	lds	r18, 0x0791
    3606:	30 91 92 07 	lds	r19, 0x0792
    360a:	82 27       	eor	r24, r18
    360c:	93 27       	eor	r25, r19
    360e:	20 91 8d 07 	lds	r18, 0x078D
    3612:	30 91 8e 07 	lds	r19, 0x078E
    3616:	82 23       	and	r24, r18
    3618:	93 23       	and	r25, r19
    361a:	89 2b       	or	r24, r25
    361c:	49 f0       	breq	.+18     	; 0x3630 <uip_arp_out+0x9a>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(&ipaddr, &uip_draddr);
    361e:	80 91 87 07 	lds	r24, 0x0787
    3622:	90 91 88 07 	lds	r25, 0x0788
    3626:	a0 91 89 07 	lds	r26, 0x0789
    362a:	b0 91 8a 07 	lds	r27, 0x078A
    362e:	08 c0       	rjmp	.+16     	; 0x3640 <uip_arp_out+0xaa>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    3630:	80 91 b1 07 	lds	r24, 0x07B1
    3634:	90 91 b2 07 	lds	r25, 0x07B2
    3638:	a0 91 b3 07 	lds	r26, 0x07B3
    363c:	b0 91 b4 07 	lds	r27, 0x07B4
    3640:	80 93 be 03 	sts	0x03BE, r24
    3644:	90 93 bf 03 	sts	0x03BF, r25
    3648:	a0 93 c0 03 	sts	0x03C0, r26
    364c:	b0 93 c1 03 	sts	0x03C1, r27
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3650:	10 92 c2 03 	sts	0x03C2, r1
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    3654:	60 91 be 03 	lds	r22, 0x03BE
    3658:	70 91 bf 03 	lds	r23, 0x03BF
    365c:	40 91 c0 03 	lds	r20, 0x03C0
    3660:	50 91 c1 03 	lds	r21, 0x03C1
    3664:	e0 e0       	ldi	r30, 0x00	; 0
    3666:	f0 e0       	ldi	r31, 0x00	; 0
    3668:	20 e0       	ldi	r18, 0x00	; 0
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    366a:	3b e0       	ldi	r19, 0x0B	; 11
    366c:	13 c0       	rjmp	.+38     	; 0x3694 <uip_arp_out+0xfe>
    366e:	23 9f       	mul	r18, r19
    3670:	f0 01       	movw	r30, r0
    3672:	11 24       	eor	r1, r1
    3674:	ea 59       	subi	r30, 0x9A	; 154
    3676:	fc 4f       	sbci	r31, 0xFC	; 252
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    3678:	80 81       	ld	r24, Z
    367a:	91 81       	ldd	r25, Z+1	; 0x01
    367c:	68 17       	cp	r22, r24
    367e:	79 07       	cpc	r23, r25
    3680:	41 f4       	brne	.+16     	; 0x3692 <uip_arp_out+0xfc>
    3682:	82 81       	ldd	r24, Z+2	; 0x02
    3684:	93 81       	ldd	r25, Z+3	; 0x03
    3686:	48 17       	cp	r20, r24
    3688:	59 07       	cpc	r21, r25
    368a:	19 f4       	brne	.+6      	; 0x3692 <uip_arp_out+0xfc>
    368c:	20 93 c2 03 	sts	0x03C2, r18
    3690:	6d c0       	rjmp	.+218    	; 0x376c <uip_arp_out+0x1d6>
    3692:	2f 5f       	subi	r18, 0xFF	; 255
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3694:	28 30       	cpi	r18, 0x08	; 8
    3696:	58 f3       	brcs	.-42     	; 0x366e <uip_arp_out+0xd8>
    3698:	20 93 c2 03 	sts	0x03C2, r18
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    369c:	28 30       	cpi	r18, 0x08	; 8
    369e:	09 f0       	breq	.+2      	; 0x36a2 <uip_arp_out+0x10c>
    36a0:	65 c0       	rjmp	.+202    	; 0x376c <uip_arp_out+0x1d6>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    36a2:	83 e9       	ldi	r24, 0x93	; 147
    36a4:	97 e0       	ldi	r25, 0x07	; 7
    36a6:	6f ef       	ldi	r22, 0xFF	; 255
    36a8:	70 e0       	ldi	r23, 0x00	; 0
    36aa:	46 e0       	ldi	r20, 0x06	; 6
    36ac:	50 e0       	ldi	r21, 0x00	; 0
    36ae:	0e 94 2d 3d 	call	0x7a5a	; 0x7a5a <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    36b2:	e3 eb       	ldi	r30, 0xB3	; 179
    36b4:	f7 e0       	ldi	r31, 0x07	; 7
    36b6:	86 e0       	ldi	r24, 0x06	; 6
    36b8:	df 01       	movw	r26, r30
    36ba:	1d 92       	st	X+, r1
    36bc:	8a 95       	dec	r24
    36be:	e9 f7       	brne	.-6      	; 0x36ba <uip_arp_out+0x124>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    36c0:	7a 97       	sbiw	r30, 0x1a	; 26
    36c2:	a4 e5       	ldi	r26, 0x54	; 84
    36c4:	b3 e0       	ldi	r27, 0x03	; 3
    36c6:	86 e0       	ldi	r24, 0x06	; 6
    36c8:	0d 90       	ld	r0, X+
    36ca:	01 92       	st	Z+, r0
    36cc:	81 50       	subi	r24, 0x01	; 1
    36ce:	e1 f7       	brne	.-8      	; 0x36c8 <uip_arp_out+0x132>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    36d0:	a9 ea       	ldi	r26, 0xA9	; 169
    36d2:	b7 e0       	ldi	r27, 0x07	; 7
    36d4:	e4 e5       	ldi	r30, 0x54	; 84
    36d6:	f3 e0       	ldi	r31, 0x03	; 3
    36d8:	86 e0       	ldi	r24, 0x06	; 6
    36da:	01 90       	ld	r0, Z+
    36dc:	0d 92       	st	X+, r0
    36de:	81 50       	subi	r24, 0x01	; 1
    36e0:	e1 f7       	brne	.-8      	; 0x36da <uip_arp_out+0x144>

      uip_ipaddr_copy(&BUF->dipaddr, &ipaddr);
    36e2:	80 91 be 03 	lds	r24, 0x03BE
    36e6:	90 91 bf 03 	lds	r25, 0x03BF
    36ea:	a0 91 c0 03 	lds	r26, 0x03C0
    36ee:	b0 91 c1 03 	lds	r27, 0x03C1
    36f2:	80 93 b9 07 	sts	0x07B9, r24
    36f6:	90 93 ba 07 	sts	0x07BA, r25
    36fa:	a0 93 bb 07 	sts	0x07BB, r26
    36fe:	b0 93 bc 07 	sts	0x07BC, r27
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    3702:	80 91 8f 07 	lds	r24, 0x078F
    3706:	90 91 90 07 	lds	r25, 0x0790
    370a:	a0 91 91 07 	lds	r26, 0x0791
    370e:	b0 91 92 07 	lds	r27, 0x0792
    3712:	80 93 af 07 	sts	0x07AF, r24
    3716:	90 93 b0 07 	sts	0x07B0, r25
    371a:	a0 93 b1 07 	sts	0x07B1, r26
    371e:	b0 93 b2 07 	sts	0x07B2, r27
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    3722:	80 e0       	ldi	r24, 0x00	; 0
    3724:	91 e0       	ldi	r25, 0x01	; 1
    3726:	90 93 a8 07 	sts	0x07A8, r25
    372a:	80 93 a7 07 	sts	0x07A7, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    372e:	90 93 a2 07 	sts	0x07A2, r25
    3732:	80 93 a1 07 	sts	0x07A1, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    3736:	88 e0       	ldi	r24, 0x08	; 8
    3738:	90 e0       	ldi	r25, 0x00	; 0
    373a:	90 93 a4 07 	sts	0x07A4, r25
    373e:	80 93 a3 07 	sts	0x07A3, r24
      BUF->hwlen = 6;
    3742:	86 e0       	ldi	r24, 0x06	; 6
    3744:	80 93 a5 07 	sts	0x07A5, r24
      BUF->protolen = 4;
    3748:	84 e0       	ldi	r24, 0x04	; 4
    374a:	80 93 a6 07 	sts	0x07A6, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    374e:	88 e0       	ldi	r24, 0x08	; 8
    3750:	96 e0       	ldi	r25, 0x06	; 6
    3752:	90 93 a0 07 	sts	0x07A0, r25
    3756:	80 93 9f 07 	sts	0x079F, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    375a:	89 ec       	ldi	r24, 0xC9	; 201
    375c:	97 e0       	ldi	r25, 0x07	; 7
    375e:	90 93 27 06 	sts	0x0627, r25
    3762:	80 93 26 06 	sts	0x0626, r24

      uip_len = sizeof(struct arp_hdr);
    3766:	8a e2       	ldi	r24, 0x2A	; 42
    3768:	90 e0       	ldi	r25, 0x00	; 0
    376a:	1c c0       	rjmp	.+56     	; 0x37a4 <uip_arp_out+0x20e>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    376c:	a3 e9       	ldi	r26, 0x93	; 147
    376e:	b7 e0       	ldi	r27, 0x07	; 7
    3770:	34 96       	adiw	r30, 0x04	; 4
    3772:	86 e0       	ldi	r24, 0x06	; 6
    3774:	01 90       	ld	r0, Z+
    3776:	0d 92       	st	X+, r0
    3778:	81 50       	subi	r24, 0x01	; 1
    377a:	e1 f7       	brne	.-8      	; 0x3774 <uip_arp_out+0x1de>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    377c:	a9 e9       	ldi	r26, 0x99	; 153
    377e:	b7 e0       	ldi	r27, 0x07	; 7
    3780:	e4 e5       	ldi	r30, 0x54	; 84
    3782:	f3 e0       	ldi	r31, 0x03	; 3
    3784:	86 e0       	ldi	r24, 0x06	; 6
    3786:	01 90       	ld	r0, Z+
    3788:	0d 92       	st	X+, r0
    378a:	81 50       	subi	r24, 0x01	; 1
    378c:	e1 f7       	brne	.-8      	; 0x3786 <uip_arp_out+0x1f0>

  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    378e:	88 e0       	ldi	r24, 0x08	; 8
    3790:	90 e0       	ldi	r25, 0x00	; 0
    3792:	90 93 a0 07 	sts	0x07A0, r25
    3796:	80 93 9f 07 	sts	0x079F, r24

  uip_len += sizeof(struct uip_eth_hdr);
    379a:	80 91 1b 06 	lds	r24, 0x061B
    379e:	90 91 1c 06 	lds	r25, 0x061C
    37a2:	0e 96       	adiw	r24, 0x0e	; 14
    37a4:	90 93 1c 06 	sts	0x061C, r25
    37a8:	80 93 1b 06 	sts	0x061B, r24
    37ac:	08 95       	ret

000037ae <uip_arp_timer>:
void
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
    37ae:	80 91 c4 03 	lds	r24, 0x03C4
    37b2:	8f 5f       	subi	r24, 0xFF	; 255
    37b4:	80 93 c4 03 	sts	0x03C4, r24
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    37b8:	10 92 c2 03 	sts	0x03C2, r1
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    37bc:	60 91 19 03 	lds	r22, 0x0319
    37c0:	70 91 1a 03 	lds	r23, 0x031A
    37c4:	40 91 1b 03 	lds	r20, 0x031B
    37c8:	50 91 1c 03 	lds	r21, 0x031C
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    tabptr = &arp_table[i];
    37cc:	3b e0       	ldi	r19, 0x0B	; 11
    37ce:	21 c0       	rjmp	.+66     	; 0x3812 <uip_arp_timer+0x64>
    37d0:	83 9f       	mul	r24, r19
    37d2:	f0 01       	movw	r30, r0
    37d4:	11 24       	eor	r1, r1
    37d6:	ea 59       	subi	r30, 0x9A	; 154
    37d8:	fc 4f       	sbci	r31, 0xFC	; 252
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    37da:	80 81       	ld	r24, Z
    37dc:	91 81       	ldd	r25, Z+1	; 0x01
    37de:	86 17       	cp	r24, r22
    37e0:	97 07       	cpc	r25, r23
    37e2:	91 f4       	brne	.+36     	; 0x3808 <uip_arp_timer+0x5a>
    37e4:	82 81       	ldd	r24, Z+2	; 0x02
    37e6:	93 81       	ldd	r25, Z+3	; 0x03
    37e8:	84 17       	cp	r24, r20
    37ea:	95 07       	cpc	r25, r21
    37ec:	69 f4       	brne	.+26     	; 0x3808 <uip_arp_timer+0x5a>
    37ee:	80 91 c4 03 	lds	r24, 0x03C4
    37f2:	90 e0       	ldi	r25, 0x00	; 0
    37f4:	22 85       	ldd	r18, Z+10	; 0x0a
    37f6:	82 1b       	sub	r24, r18
    37f8:	91 09       	sbc	r25, r1
    37fa:	88 37       	cpi	r24, 0x78	; 120
    37fc:	91 05       	cpc	r25, r1
    37fe:	24 f0       	brlt	.+8      	; 0x3808 <uip_arp_timer+0x5a>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    3800:	10 82       	st	Z, r1
    3802:	11 82       	std	Z+1, r1	; 0x01
    3804:	12 82       	std	Z+2, r1	; 0x02
    3806:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3808:	80 91 c2 03 	lds	r24, 0x03C2
    380c:	8f 5f       	subi	r24, 0xFF	; 255
    380e:	80 93 c2 03 	sts	0x03C2, r24
    3812:	80 91 c2 03 	lds	r24, 0x03C2
    3816:	88 30       	cpi	r24, 0x08	; 8
    3818:	d8 f2       	brcs	.-74     	; 0x37d0 <uip_arp_timer+0x22>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    }
  }

}
    381a:	08 95       	ret

0000381c <uip_arp_init>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    381c:	10 92 c2 03 	sts	0x03C2, r1
    memset(&arp_table[i].ipaddr, 0, 4);
    3820:	9b e0       	ldi	r25, 0x0B	; 11
    3822:	0c c0       	rjmp	.+24     	; 0x383c <uip_arp_init+0x20>
    3824:	89 9f       	mul	r24, r25
    3826:	f0 01       	movw	r30, r0
    3828:	11 24       	eor	r1, r1
    382a:	ea 59       	subi	r30, 0x9A	; 154
    382c:	fc 4f       	sbci	r31, 0xFC	; 252
    382e:	10 82       	st	Z, r1
    3830:	11 82       	std	Z+1, r1	; 0x01
    3832:	12 82       	std	Z+2, r1	; 0x02
    3834:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3836:	8f 5f       	subi	r24, 0xFF	; 255
    3838:	80 93 c2 03 	sts	0x03C2, r24
    383c:	80 91 c2 03 	lds	r24, 0x03C2
    3840:	88 30       	cpi	r24, 0x08	; 8
    3842:	80 f3       	brcs	.-32     	; 0x3824 <uip_arp_init+0x8>
    memset(&arp_table[i].ipaddr, 0, 4);
  }
}
    3844:	08 95       	ret

00003846 <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    3846:	fc 01       	movw	r30, r24
  t->start += t->interval;
    3848:	80 81       	ld	r24, Z
    384a:	91 81       	ldd	r25, Z+1	; 0x01
    384c:	22 81       	ldd	r18, Z+2	; 0x02
    384e:	33 81       	ldd	r19, Z+3	; 0x03
    3850:	82 0f       	add	r24, r18
    3852:	93 1f       	adc	r25, r19
    3854:	91 83       	std	Z+1, r25	; 0x01
    3856:	80 83       	st	Z, r24
}
    3858:	08 95       	ret

0000385a <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    385a:	0f 93       	push	r16
    385c:	1f 93       	push	r17
    385e:	8c 01       	movw	r16, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    3860:	43 d0       	rcall	.+134    	; 0x38e8 <clock_time>
    3862:	40 e0       	ldi	r20, 0x00	; 0
    3864:	50 e0       	ldi	r21, 0x00	; 0
    3866:	f8 01       	movw	r30, r16
    3868:	20 81       	ld	r18, Z
    386a:	31 81       	ldd	r19, Z+1	; 0x01
    386c:	82 1b       	sub	r24, r18
    386e:	93 0b       	sbc	r25, r19
    3870:	22 81       	ldd	r18, Z+2	; 0x02
    3872:	33 81       	ldd	r19, Z+3	; 0x03
    3874:	82 17       	cp	r24, r18
    3876:	93 07       	cpc	r25, r19
    3878:	10 f0       	brcs	.+4      	; 0x387e <timer_expired+0x24>
    387a:	41 e0       	ldi	r20, 0x01	; 1
    387c:	50 e0       	ldi	r21, 0x00	; 0
}
    387e:	ca 01       	movw	r24, r20
    3880:	1f 91       	pop	r17
    3882:	0f 91       	pop	r16
    3884:	08 95       	ret

00003886 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    3886:	0f 93       	push	r16
    3888:	1f 93       	push	r17
    388a:	8c 01       	movw	r16, r24
  t->interval = interval;
    388c:	fc 01       	movw	r30, r24
    388e:	73 83       	std	Z+3, r23	; 0x03
    3890:	62 83       	std	Z+2, r22	; 0x02
  t->start = clock_time();
    3892:	2a d0       	rcall	.+84     	; 0x38e8 <clock_time>
    3894:	f8 01       	movw	r30, r16
    3896:	91 83       	std	Z+1, r25	; 0x01
    3898:	80 83       	st	Z, r24
}
    389a:	1f 91       	pop	r17
    389c:	0f 91       	pop	r16
    389e:	08 95       	ret

000038a0 <__vector_17>:
//Counted time
volatile clock_time_t clock_datetime = 0;

//Overflow interrupt
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
{
    38a0:	1f 92       	push	r1
    38a2:	0f 92       	push	r0
    38a4:	0f b6       	in	r0, 0x3f	; 63
    38a6:	0f 92       	push	r0
    38a8:	11 24       	eor	r1, r1
    38aa:	8f 93       	push	r24
    38ac:	9f 93       	push	r25
	clock_datetime += 1;
    38ae:	80 91 c6 03 	lds	r24, 0x03C6
    38b2:	90 91 c7 03 	lds	r25, 0x03C7
    38b6:	01 96       	adiw	r24, 0x01	; 1
    38b8:	90 93 c7 03 	sts	0x03C7, r25
    38bc:	80 93 c6 03 	sts	0x03C6, r24
}
    38c0:	9f 91       	pop	r25
    38c2:	8f 91       	pop	r24
    38c4:	0f 90       	pop	r0
    38c6:	0f be       	out	0x3f, r0	; 63
    38c8:	0f 90       	pop	r0
    38ca:	1f 90       	pop	r1
    38cc:	18 95       	reti

000038ce <clock_init>:

//Initialise the clock
void clock_init()
{
	OCR1A  = (((F_CPU / 1024) / 100) - 1);
    38ce:	8d e4       	ldi	r24, 0x4D	; 77
    38d0:	90 e0       	ldi	r25, 0x00	; 0
    38d2:	90 93 89 00 	sts	0x0089, r25
    38d6:	80 93 88 00 	sts	0x0088, r24
	TCCR1B = ((1 << WGM12) | (1 << CS12) | (1 << CS10));
    38da:	8d e0       	ldi	r24, 0x0D	; 13
    38dc:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1 << OCIE1A);
    38e0:	82 e0       	ldi	r24, 0x02	; 2
    38e2:	80 93 6f 00 	sts	0x006F, r24
}
    38e6:	08 95       	ret

000038e8 <clock_time>:
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    38e8:	f8 94       	cli
clock_time_t clock_time()
{
	clock_time_t time;

	GlobalInterruptDisable();
	time = clock_datetime;
    38ea:	80 91 c6 03 	lds	r24, 0x03C6
    38ee:	90 91 c7 03 	lds	r25, 0x03C7
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    38f2:	78 94       	sei
	GlobalInterruptEnable();

	return time;
}
    38f4:	08 95       	ret

000038f6 <uip_split_output>:
#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])

/*-----------------------------------------------------------------------------*/
void
uip_split_output(void)
{
    38f6:	cf 93       	push	r28
    38f8:	df 93       	push	r29
#if UIP_TCP
  u16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP  && uip_len == UIP_BUFSIZE) {
    38fa:	c1 ea       	ldi	r28, 0xA1	; 161
    38fc:	d7 e0       	ldi	r29, 0x07	; 7
    38fe:	80 91 aa 07 	lds	r24, 0x07AA
    3902:	86 30       	cpi	r24, 0x06	; 6
    3904:	09 f0       	breq	.+2      	; 0x3908 <uip_split_output+0x12>
    3906:	8b c0       	rjmp	.+278    	; 0x3a1e <uip_split_output+0x128>
    3908:	80 91 1b 06 	lds	r24, 0x061B
    390c:	90 91 1c 06 	lds	r25, 0x061C
    3910:	8a 5e       	subi	r24, 0xEA	; 234
    3912:	95 40       	sbci	r25, 0x05	; 5
    3914:	09 f0       	breq	.+2      	; 0x3918 <uip_split_output+0x22>
    3916:	83 c0       	rjmp	.+262    	; 0x3a1e <uip_split_output+0x128>
      ++len2;
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    3918:	80 e1       	ldi	r24, 0x10	; 16
    391a:	93 e0       	ldi	r25, 0x03	; 3
    391c:	90 93 1c 06 	sts	0x061C, r25
    3920:	80 93 1b 06 	sts	0x061B, r24
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len - UIP_LLH_LEN) >> 8;
    3924:	83 e0       	ldi	r24, 0x03	; 3
    3926:	80 93 a3 07 	sts	0x07A3, r24
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    392a:	82 e0       	ldi	r24, 0x02	; 2
    392c:	80 93 a4 07 	sts	0x07A4, r24
#endif /* UIP_CONF_IPV6 */

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    3930:	10 92 c6 07 	sts	0x07C6, r1
    3934:	10 92 c5 07 	sts	0x07C5, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    3938:	0e 94 da 10 	call	0x21b4	; 0x21b4 <uip_tcpchksum>
    393c:	80 95       	com	r24
    393e:	90 95       	com	r25
    3940:	90 93 c6 07 	sts	0x07C6, r25
    3944:	80 93 c5 07 	sts	0x07C5, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    3948:	10 92 ac 07 	sts	0x07AC, r1
    394c:	10 92 ab 07 	sts	0x07AB, r1
    BUF->ipchksum = ~(uip_ipchksum());
    3950:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <uip_ipchksum>
    3954:	80 95       	com	r24
    3956:	90 95       	com	r25
    3958:	90 93 ac 07 	sts	0x07AC, r25
    395c:	80 93 ab 07 	sts	0x07AB, r24

    /* Transmit the first packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    3960:	80 91 cf 03 	lds	r24, 0x03CF
    3964:	40 91 1b 06 	lds	r20, 0x061B
    3968:	50 91 1c 06 	lds	r21, 0x061C
    396c:	81 30       	cpi	r24, 0x01	; 1
    396e:	41 f4       	brne	.+16     	; 0x3980 <uip_split_output+0x8a>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    3970:	83 e1       	ldi	r24, 0x13	; 19
    3972:	91 e0       	ldi	r25, 0x01	; 1
    3974:	be 01       	movw	r22, r28
    3976:	6e 50       	subi	r22, 0x0E	; 14
    3978:	70 40       	sbci	r23, 0x00	; 0
    397a:	0e 94 71 34 	call	0x68e2	; 0x68e2 <RNDIS_Device_SendPacket>
    397e:	07 c0       	rjmp	.+14     	; 0x398e <uip_split_output+0x98>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    3980:	85 ee       	ldi	r24, 0xE5	; 229
    3982:	91 e0       	ldi	r25, 0x01	; 1
    3984:	be 01       	movw	r22, r28
    3986:	6e 50       	subi	r22, 0x0E	; 14
    3988:	70 40       	sbci	r23, 0x00	; 0
    398a:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <RNDIS_Host_SendPacket>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is determined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    398e:	80 e1       	ldi	r24, 0x10	; 16
    3990:	93 e0       	ldi	r25, 0x03	; 3
    3992:	90 93 1c 06 	sts	0x061C, r25
    3996:	80 93 1b 06 	sts	0x061B, r24
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len  - UIP_LLH_LEN) >> 8;
    399a:	83 e0       	ldi	r24, 0x03	; 3
    399c:	80 93 a3 07 	sts	0x07A3, r24
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    39a0:	82 e0       	ldi	r24, 0x02	; 2
    39a2:	80 93 a4 07 	sts	0x07A4, r24
#endif /* UIP_CONF_IPV6 */

    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
    39a6:	80 91 26 06 	lds	r24, 0x0626
    39aa:	90 91 27 06 	lds	r25, 0x0627
    39ae:	fc 01       	movw	r30, r24
    39b0:	dc 01       	movw	r26, r24
    39b2:	a6 52       	subi	r26, 0x26	; 38
    39b4:	bd 4f       	sbci	r27, 0xFD	; 253
    39b6:	8a ed       	ldi	r24, 0xDA	; 218
    39b8:	92 e0       	ldi	r25, 0x02	; 2
    39ba:	0d 90       	ld	r0, X+
    39bc:	01 92       	st	Z+, r0
    39be:	01 97       	sbiw	r24, 0x01	; 1
    39c0:	e1 f7       	brne	.-8      	; 0x39ba <uip_split_output+0xc4>

    uip_add32(BUF->seqno, len1);
    39c2:	89 eb       	ldi	r24, 0xB9	; 185
    39c4:	97 e0       	ldi	r25, 0x07	; 7
    39c6:	6a ed       	ldi	r22, 0xDA	; 218
    39c8:	72 e0       	ldi	r23, 0x02	; 2
    39ca:	0e 94 09 10 	call	0x2012	; 0x2012 <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
    39ce:	80 91 1f 06 	lds	r24, 0x061F
    39d2:	80 93 b9 07 	sts	0x07B9, r24
    BUF->seqno[1] = uip_acc32[1];
    39d6:	80 91 20 06 	lds	r24, 0x0620
    39da:	80 93 ba 07 	sts	0x07BA, r24
    BUF->seqno[2] = uip_acc32[2];
    39de:	80 91 21 06 	lds	r24, 0x0621
    39e2:	80 93 bb 07 	sts	0x07BB, r24
    BUF->seqno[3] = uip_acc32[3];
    39e6:	80 91 22 06 	lds	r24, 0x0622
    39ea:	80 93 bc 07 	sts	0x07BC, r24

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    39ee:	10 92 c6 07 	sts	0x07C6, r1
    39f2:	10 92 c5 07 	sts	0x07C5, r1
    BUF->tcpchksum = ~(uip_tcpchksum());
    39f6:	0e 94 da 10 	call	0x21b4	; 0x21b4 <uip_tcpchksum>
    39fa:	80 95       	com	r24
    39fc:	90 95       	com	r25
    39fe:	90 93 c6 07 	sts	0x07C6, r25
    3a02:	80 93 c5 07 	sts	0x07C5, r24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    3a06:	10 92 ac 07 	sts	0x07AC, r1
    3a0a:	10 92 ab 07 	sts	0x07AB, r1
    BUF->ipchksum = ~(uip_ipchksum());
    3a0e:	0e 94 fc 10 	call	0x21f8	; 0x21f8 <uip_ipchksum>
    3a12:	80 95       	com	r24
    3a14:	90 95       	com	r25
    3a16:	90 93 ac 07 	sts	0x07AC, r25
    3a1a:	80 93 ab 07 	sts	0x07AB, r24

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
	tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    3a1e:	80 91 cf 03 	lds	r24, 0x03CF
    3a22:	40 91 1b 06 	lds	r20, 0x061B
    3a26:	50 91 1c 06 	lds	r21, 0x061C
    3a2a:	81 30       	cpi	r24, 0x01	; 1
    3a2c:	39 f4       	brne	.+14     	; 0x3a3c <uip_split_output+0x146>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    3a2e:	83 e1       	ldi	r24, 0x13	; 19
    3a30:	91 e0       	ldi	r25, 0x01	; 1
    3a32:	63 e9       	ldi	r22, 0x93	; 147
    3a34:	77 e0       	ldi	r23, 0x07	; 7
    3a36:	0e 94 71 34 	call	0x68e2	; 0x68e2 <RNDIS_Device_SendPacket>
    3a3a:	06 c0       	rjmp	.+12     	; 0x3a48 <uip_split_output+0x152>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    3a3c:	85 ee       	ldi	r24, 0xE5	; 229
    3a3e:	91 e0       	ldi	r25, 0x01	; 1
    3a40:	63 e9       	ldi	r22, 0x93	; 147
    3a42:	77 e0       	ldi	r23, 0x07	; 7
    3a44:	0e 94 d4 38 	call	0x71a8	; 0x71a8 <RNDIS_Host_SendPacket>
#endif /* UIP_CONF_IPV6 */
}
    3a48:	df 91       	pop	r29
    3a4a:	cf 91       	pop	r28
    3a4c:	08 95       	ret

00003a4e <disk_initialize>:
DSTATUS disk_initialize (
	BYTE drv				/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    3a4e:	80 e0       	ldi	r24, 0x00	; 0
    3a50:	08 95       	ret

00003a52 <disk_status>:
DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    3a52:	80 e0       	ldi	r24, 0x00	; 0
    3a54:	08 95       	ret

00003a56 <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	BYTE count		/* Number of sectors to read (1..255) */
)
{
    3a56:	0f 93       	push	r16
    3a58:	fb 01       	movw	r30, r22
    3a5a:	ca 01       	movw	r24, r20
    3a5c:	b9 01       	movw	r22, r18
	DataflashManager_ReadBlocks_RAM(sector, count, buff);
    3a5e:	40 2f       	mov	r20, r16
    3a60:	50 e0       	ldi	r21, 0x00	; 0
    3a62:	9f 01       	movw	r18, r30
    3a64:	0e 94 34 05 	call	0xa68	; 0xa68 <DataflashManager_ReadBlocks_RAM>
	return RES_OK;
}
    3a68:	80 e0       	ldi	r24, 0x00	; 0
    3a6a:	0f 91       	pop	r16
    3a6c:	08 95       	ret

00003a6e <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    3a6e:	ef 92       	push	r14
    3a70:	ff 92       	push	r15
    3a72:	0f 93       	push	r16
    3a74:	1f 93       	push	r17
    3a76:	cf 93       	push	r28
    3a78:	df 93       	push	r29
    3a7a:	ec 01       	movw	r28, r24
    3a7c:	7a 01       	movw	r14, r20
    3a7e:	8b 01       	movw	r16, r22
	clst -= 2;
    3a80:	8e ef       	ldi	r24, 0xFE	; 254
    3a82:	9f ef       	ldi	r25, 0xFF	; 255
    3a84:	af ef       	ldi	r26, 0xFF	; 255
    3a86:	bf ef       	ldi	r27, 0xFF	; 255
    3a88:	e8 0e       	add	r14, r24
    3a8a:	f9 1e       	adc	r15, r25
    3a8c:	0a 1f       	adc	r16, r26
    3a8e:	1b 1f       	adc	r17, r27
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    3a90:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a92:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a94:	ac 85       	ldd	r26, Y+12	; 0x0c
    3a96:	bd 85       	ldd	r27, Y+13	; 0x0d
    3a98:	02 97       	sbiw	r24, 0x02	; 2
    3a9a:	a1 09       	sbc	r26, r1
    3a9c:	b1 09       	sbc	r27, r1
    3a9e:	e8 16       	cp	r14, r24
    3aa0:	f9 06       	cpc	r15, r25
    3aa2:	0a 07       	cpc	r16, r26
    3aa4:	1b 07       	cpc	r17, r27
    3aa6:	28 f0       	brcs	.+10     	; 0x3ab2 <clust2sect+0x44>
    3aa8:	20 e0       	ldi	r18, 0x00	; 0
    3aaa:	30 e0       	ldi	r19, 0x00	; 0
    3aac:	40 e0       	ldi	r20, 0x00	; 0
    3aae:	50 e0       	ldi	r21, 0x00	; 0
    3ab0:	12 c0       	rjmp	.+36     	; 0x3ad6 <clust2sect+0x68>
	return clst * fs->csize + fs->database;
    3ab2:	2a 81       	ldd	r18, Y+2	; 0x02
    3ab4:	30 e0       	ldi	r19, 0x00	; 0
    3ab6:	40 e0       	ldi	r20, 0x00	; 0
    3ab8:	50 e0       	ldi	r21, 0x00	; 0
    3aba:	c8 01       	movw	r24, r16
    3abc:	b7 01       	movw	r22, r14
    3abe:	0e 94 b3 3c 	call	0x7966	; 0x7966 <__mulsi3>
    3ac2:	9b 01       	movw	r18, r22
    3ac4:	ac 01       	movw	r20, r24
    3ac6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ac8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3aca:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3acc:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3ace:	28 0f       	add	r18, r24
    3ad0:	39 1f       	adc	r19, r25
    3ad2:	4a 1f       	adc	r20, r26
    3ad4:	5b 1f       	adc	r21, r27
}
    3ad6:	ca 01       	movw	r24, r20
    3ad8:	b9 01       	movw	r22, r18
    3ada:	df 91       	pop	r29
    3adc:	cf 91       	pop	r28
    3ade:	1f 91       	pop	r17
    3ae0:	0f 91       	pop	r16
    3ae2:	ff 90       	pop	r15
    3ae4:	ef 90       	pop	r14
    3ae6:	08 95       	ret

00003ae8 <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
    3ae8:	db 01       	movw	r26, r22
	FATFS *rfs;


	if (vol >= _VOLUMES)			/* Check if the drive number is valid */
    3aea:	88 23       	and	r24, r24
    3aec:	11 f0       	breq	.+4      	; 0x3af2 <f_mount+0xa>
    3aee:	8b e0       	ldi	r24, 0x0B	; 11
    3af0:	08 95       	ret
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];				/* Get current fs object */
    3af2:	e0 91 c8 03 	lds	r30, 0x03C8
    3af6:	f0 91 c9 03 	lds	r31, 0x03C9

	if (rfs) {
    3afa:	30 97       	sbiw	r30, 0x00	; 0
    3afc:	09 f0       	breq	.+2      	; 0x3b00 <f_mount+0x18>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT					/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;			/* Clear old fs object */
    3afe:	10 82       	st	Z, r1
	}

	if (fs) {
    3b00:	10 97       	sbiw	r26, 0x00	; 0
    3b02:	09 f0       	breq	.+2      	; 0x3b06 <f_mount+0x1e>
		fs->fs_type = 0;			/* Clear new fs object */
    3b04:	1c 92       	st	X, r1
#if _FS_REENTRANT					/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;				/* Register new fs object */
    3b06:	b0 93 c9 03 	sts	0x03C9, r27
    3b0a:	a0 93 c8 03 	sts	0x03C8, r26
    3b0e:	80 e0       	ldi	r24, 0x00	; 0

	return FR_OK;
}
    3b10:	08 95       	ret

00003b12 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
    3b12:	fc 01       	movw	r30, r24
	if (!fs || !fs->fs_type || fs->id != id)
    3b14:	00 97       	sbiw	r24, 0x00	; 0
    3b16:	81 f0       	breq	.+32     	; 0x3b38 <validate+0x26>
    3b18:	80 81       	ld	r24, Z
    3b1a:	88 23       	and	r24, r24
    3b1c:	69 f0       	breq	.+26     	; 0x3b38 <validate+0x26>
    3b1e:	86 81       	ldd	r24, Z+6	; 0x06
    3b20:	97 81       	ldd	r25, Z+7	; 0x07
    3b22:	86 17       	cp	r24, r22
    3b24:	97 07       	cpc	r25, r23
    3b26:	41 f4       	brne	.+16     	; 0x3b38 <validate+0x26>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
    3b28:	81 81       	ldd	r24, Z+1	; 0x01
    3b2a:	93 df       	rcall	.-218    	; 0x3a52 <disk_status>
    3b2c:	80 fd       	sbrc	r24, 0
    3b2e:	02 c0       	rjmp	.+4      	; 0x3b34 <validate+0x22>
    3b30:	80 e0       	ldi	r24, 0x00	; 0
    3b32:	08 95       	ret
    3b34:	83 e0       	ldi	r24, 0x03	; 3
    3b36:	08 95       	ret
    3b38:	89 e0       	ldi	r24, 0x09	; 9
		return FR_NOT_READY;

	return FR_OK;
}
    3b3a:	08 95       	ret

00003b3c <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    3b3c:	cf 93       	push	r28
    3b3e:	df 93       	push	r29
    3b40:	ec 01       	movw	r28, r24
	FRESULT res;

#if _FS_READONLY
	FATFS *fs = fp->fs;
	res = validate(fs, fp->id);
    3b42:	6a 81       	ldd	r22, Y+2	; 0x02
    3b44:	7b 81       	ldd	r23, Y+3	; 0x03
    3b46:	88 81       	ld	r24, Y
    3b48:	99 81       	ldd	r25, Y+1	; 0x01
    3b4a:	e3 df       	rcall	.-58     	; 0x3b12 <validate>
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    3b4c:	88 23       	and	r24, r24
    3b4e:	11 f4       	brne	.+4      	; 0x3b54 <f_close+0x18>
    3b50:	19 82       	std	Y+1, r1	; 0x01
    3b52:	18 82       	st	Y, r1
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
    3b54:	df 91       	pop	r29
    3b56:	cf 91       	pop	r28
    3b58:	08 95       	ret

00003b5a <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    3b5a:	cf 92       	push	r12
    3b5c:	df 92       	push	r13
    3b5e:	ef 92       	push	r14
    3b60:	ff 92       	push	r15
    3b62:	0f 93       	push	r16
    3b64:	cf 93       	push	r28
    3b66:	df 93       	push	r29
    3b68:	ec 01       	movw	r28, r24
    3b6a:	6a 01       	movw	r12, r20
    3b6c:	7b 01       	movw	r14, r22
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
    3b6e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3b70:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3b72:	a8 a1       	ldd	r26, Y+32	; 0x20
    3b74:	b9 a1       	ldd	r27, Y+33	; 0x21
    3b76:	84 17       	cp	r24, r20
    3b78:	95 07       	cpc	r25, r21
    3b7a:	a6 07       	cpc	r26, r22
    3b7c:	b7 07       	cpc	r27, r23
    3b7e:	a9 f0       	breq	.+42     	; 0x3baa <move_window+0x50>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    3b80:	41 15       	cp	r20, r1
    3b82:	51 05       	cpc	r21, r1
    3b84:	61 05       	cpc	r22, r1
    3b86:	71 05       	cpc	r23, r1
    3b88:	81 f0       	breq	.+32     	; 0x3baa <move_window+0x50>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    3b8a:	be 01       	movw	r22, r28
    3b8c:	6e 5d       	subi	r22, 0xDE	; 222
    3b8e:	7f 4f       	sbci	r23, 0xFF	; 255
    3b90:	89 81       	ldd	r24, Y+1	; 0x01
    3b92:	a7 01       	movw	r20, r14
    3b94:	96 01       	movw	r18, r12
    3b96:	01 e0       	ldi	r16, 0x01	; 1
    3b98:	5e df       	rcall	.-324    	; 0x3a56 <disk_read>
    3b9a:	88 23       	and	r24, r24
    3b9c:	11 f0       	breq	.+4      	; 0x3ba2 <move_window+0x48>
    3b9e:	81 e0       	ldi	r24, 0x01	; 1
    3ba0:	05 c0       	rjmp	.+10     	; 0x3bac <move_window+0x52>
				return FR_DISK_ERR;
			fs->winsect = sector;
    3ba2:	ce 8e       	std	Y+30, r12	; 0x1e
    3ba4:	df 8e       	std	Y+31, r13	; 0x1f
    3ba6:	e8 a2       	std	Y+32, r14	; 0x20
    3ba8:	f9 a2       	std	Y+33, r15	; 0x21
    3baa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return FR_OK;
}
    3bac:	df 91       	pop	r29
    3bae:	cf 91       	pop	r28
    3bb0:	0f 91       	pop	r16
    3bb2:	ff 90       	pop	r15
    3bb4:	ef 90       	pop	r14
    3bb6:	df 90       	pop	r13
    3bb8:	cf 90       	pop	r12
    3bba:	08 95       	ret

00003bbc <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    3bbc:	bf 92       	push	r11
    3bbe:	cf 92       	push	r12
    3bc0:	df 92       	push	r13
    3bc2:	ef 92       	push	r14
    3bc4:	ff 92       	push	r15
    3bc6:	0f 93       	push	r16
    3bc8:	1f 93       	push	r17
    3bca:	cf 93       	push	r28
    3bcc:	df 93       	push	r29
    3bce:	6c 01       	movw	r12, r24
    3bd0:	7a 01       	movw	r14, r20
    3bd2:	8b 01       	movw	r16, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    3bd4:	42 30       	cpi	r20, 0x02	; 2
    3bd6:	51 05       	cpc	r21, r1
    3bd8:	61 05       	cpc	r22, r1
    3bda:	71 05       	cpc	r23, r1
    3bdc:	08 f4       	brcc	.+2      	; 0x3be0 <get_fat+0x24>
    3bde:	aa c0       	rjmp	.+340    	; 0x3d34 <get_fat+0x178>
    3be0:	f6 01       	movw	r30, r12
    3be2:	82 85       	ldd	r24, Z+10	; 0x0a
    3be4:	93 85       	ldd	r25, Z+11	; 0x0b
    3be6:	a4 85       	ldd	r26, Z+12	; 0x0c
    3be8:	b5 85       	ldd	r27, Z+13	; 0x0d
    3bea:	48 17       	cp	r20, r24
    3bec:	59 07       	cpc	r21, r25
    3bee:	6a 07       	cpc	r22, r26
    3bf0:	7b 07       	cpc	r23, r27
    3bf2:	08 f0       	brcs	.+2      	; 0x3bf6 <get_fat+0x3a>
    3bf4:	9f c0       	rjmp	.+318    	; 0x3d34 <get_fat+0x178>
		return 1;

	switch (fs->fs_type) {
    3bf6:	80 81       	ld	r24, Z
    3bf8:	82 30       	cpi	r24, 0x02	; 2
    3bfa:	09 f4       	brne	.+2      	; 0x3bfe <get_fat+0x42>
    3bfc:	57 c0       	rjmp	.+174    	; 0x3cac <get_fat+0xf0>
    3bfe:	83 30       	cpi	r24, 0x03	; 3
    3c00:	09 f4       	brne	.+2      	; 0x3c04 <get_fat+0x48>
    3c02:	73 c0       	rjmp	.+230    	; 0x3cea <get_fat+0x12e>
    3c04:	81 30       	cpi	r24, 0x01	; 1
    3c06:	09 f0       	breq	.+2      	; 0x3c0a <get_fat+0x4e>
    3c08:	9a c0       	rjmp	.+308    	; 0x3d3e <get_fat+0x182>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    3c0a:	ea 01       	movw	r28, r20
    3c0c:	d6 95       	lsr	r29
    3c0e:	c7 95       	ror	r28
    3c10:	c4 0f       	add	r28, r20
    3c12:	d5 1f       	adc	r29, r21
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3c14:	ae 01       	movw	r20, r28
    3c16:	45 2f       	mov	r20, r21
    3c18:	55 27       	eor	r21, r21
    3c1a:	46 95       	lsr	r20
    3c1c:	60 e0       	ldi	r22, 0x00	; 0
    3c1e:	70 e0       	ldi	r23, 0x00	; 0
    3c20:	f6 01       	movw	r30, r12
    3c22:	82 89       	ldd	r24, Z+18	; 0x12
    3c24:	93 89       	ldd	r25, Z+19	; 0x13
    3c26:	a4 89       	ldd	r26, Z+20	; 0x14
    3c28:	b5 89       	ldd	r27, Z+21	; 0x15
    3c2a:	48 0f       	add	r20, r24
    3c2c:	59 1f       	adc	r21, r25
    3c2e:	6a 1f       	adc	r22, r26
    3c30:	7b 1f       	adc	r23, r27
    3c32:	c6 01       	movw	r24, r12
    3c34:	92 df       	rcall	.-220    	; 0x3b5a <move_window>
    3c36:	88 23       	and	r24, r24
    3c38:	09 f0       	breq	.+2      	; 0x3c3c <get_fat+0x80>
    3c3a:	81 c0       	rjmp	.+258    	; 0x3d3e <get_fat+0x182>
		wc = fs->win[bc % SS(fs)]; bc++;
    3c3c:	fe 01       	movw	r30, r28
    3c3e:	f1 70       	andi	r31, 0x01	; 1
    3c40:	ec 0d       	add	r30, r12
    3c42:	fd 1d       	adc	r31, r13
    3c44:	b2 a0       	ldd	r11, Z+34	; 0x22
    3c46:	21 96       	adiw	r28, 0x01	; 1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3c48:	ae 01       	movw	r20, r28
    3c4a:	45 2f       	mov	r20, r21
    3c4c:	55 27       	eor	r21, r21
    3c4e:	46 95       	lsr	r20
    3c50:	60 e0       	ldi	r22, 0x00	; 0
    3c52:	70 e0       	ldi	r23, 0x00	; 0
    3c54:	f6 01       	movw	r30, r12
    3c56:	82 89       	ldd	r24, Z+18	; 0x12
    3c58:	93 89       	ldd	r25, Z+19	; 0x13
    3c5a:	a4 89       	ldd	r26, Z+20	; 0x14
    3c5c:	b5 89       	ldd	r27, Z+21	; 0x15
    3c5e:	48 0f       	add	r20, r24
    3c60:	59 1f       	adc	r21, r25
    3c62:	6a 1f       	adc	r22, r26
    3c64:	7b 1f       	adc	r23, r27
    3c66:	c6 01       	movw	r24, r12
    3c68:	78 df       	rcall	.-272    	; 0x3b5a <move_window>
    3c6a:	88 23       	and	r24, r24
    3c6c:	09 f0       	breq	.+2      	; 0x3c70 <get_fat+0xb4>
    3c6e:	67 c0       	rjmp	.+206    	; 0x3d3e <get_fat+0x182>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    3c70:	8b 2d       	mov	r24, r11
    3c72:	90 e0       	ldi	r25, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    3c74:	d1 70       	andi	r29, 0x01	; 1
    3c76:	cc 0d       	add	r28, r12
    3c78:	dd 1d       	adc	r29, r13
    3c7a:	2a a1       	ldd	r18, Y+34	; 0x22
    3c7c:	30 e0       	ldi	r19, 0x00	; 0
    3c7e:	32 2f       	mov	r19, r18
    3c80:	22 27       	eor	r18, r18
    3c82:	28 2b       	or	r18, r24
    3c84:	39 2b       	or	r19, r25
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    3c86:	c7 01       	movw	r24, r14
    3c88:	81 70       	andi	r24, 0x01	; 1
    3c8a:	90 70       	andi	r25, 0x00	; 0
    3c8c:	89 2b       	or	r24, r25
    3c8e:	39 f0       	breq	.+14     	; 0x3c9e <get_fat+0xe2>
    3c90:	44 e0       	ldi	r20, 0x04	; 4
    3c92:	36 95       	lsr	r19
    3c94:	27 95       	ror	r18
    3c96:	4a 95       	dec	r20
    3c98:	e1 f7       	brne	.-8      	; 0x3c92 <get_fat+0xd6>
    3c9a:	b9 01       	movw	r22, r18
    3c9c:	23 c0       	rjmp	.+70     	; 0x3ce4 <get_fat+0x128>
    3c9e:	b9 01       	movw	r22, r18
    3ca0:	80 e0       	ldi	r24, 0x00	; 0
    3ca2:	90 e0       	ldi	r25, 0x00	; 0
    3ca4:	7f 70       	andi	r23, 0x0F	; 15
    3ca6:	80 70       	andi	r24, 0x00	; 0
    3ca8:	90 70       	andi	r25, 0x00	; 0
    3caa:	4d c0       	rjmp	.+154    	; 0x3d46 <get_fat+0x18a>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    3cac:	45 2f       	mov	r20, r21
    3cae:	56 2f       	mov	r21, r22
    3cb0:	67 2f       	mov	r22, r23
    3cb2:	77 27       	eor	r23, r23
    3cb4:	f6 01       	movw	r30, r12
    3cb6:	82 89       	ldd	r24, Z+18	; 0x12
    3cb8:	93 89       	ldd	r25, Z+19	; 0x13
    3cba:	a4 89       	ldd	r26, Z+20	; 0x14
    3cbc:	b5 89       	ldd	r27, Z+21	; 0x15
    3cbe:	48 0f       	add	r20, r24
    3cc0:	59 1f       	adc	r21, r25
    3cc2:	6a 1f       	adc	r22, r26
    3cc4:	7b 1f       	adc	r23, r27
    3cc6:	c6 01       	movw	r24, r12
    3cc8:	48 df       	rcall	.-368    	; 0x3b5a <move_window>
    3cca:	88 23       	and	r24, r24
    3ccc:	c1 f5       	brne	.+112    	; 0x3d3e <get_fat+0x182>
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);
    3cce:	ee 0c       	add	r14, r14
    3cd0:	ff 1c       	adc	r15, r15
    3cd2:	00 1f       	adc	r16, r16
    3cd4:	11 1f       	adc	r17, r17
    3cd6:	f7 01       	movw	r30, r14
    3cd8:	f1 70       	andi	r31, 0x01	; 1
    3cda:	ec 0d       	add	r30, r12
    3cdc:	fd 1d       	adc	r31, r13
    3cde:	82 a1       	ldd	r24, Z+34	; 0x22
    3ce0:	93 a1       	ldd	r25, Z+35	; 0x23
    3ce2:	bc 01       	movw	r22, r24
    3ce4:	80 e0       	ldi	r24, 0x00	; 0
    3ce6:	90 e0       	ldi	r25, 0x00	; 0
    3ce8:	2e c0       	rjmp	.+92     	; 0x3d46 <get_fat+0x18a>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    3cea:	97 e0       	ldi	r25, 0x07	; 7
    3cec:	76 95       	lsr	r23
    3cee:	67 95       	ror	r22
    3cf0:	57 95       	ror	r21
    3cf2:	47 95       	ror	r20
    3cf4:	9a 95       	dec	r25
    3cf6:	d1 f7       	brne	.-12     	; 0x3cec <get_fat+0x130>
    3cf8:	f6 01       	movw	r30, r12
    3cfa:	82 89       	ldd	r24, Z+18	; 0x12
    3cfc:	93 89       	ldd	r25, Z+19	; 0x13
    3cfe:	a4 89       	ldd	r26, Z+20	; 0x14
    3d00:	b5 89       	ldd	r27, Z+21	; 0x15
    3d02:	48 0f       	add	r20, r24
    3d04:	59 1f       	adc	r21, r25
    3d06:	6a 1f       	adc	r22, r26
    3d08:	7b 1f       	adc	r23, r27
    3d0a:	c6 01       	movw	r24, r12
    3d0c:	26 df       	rcall	.-436    	; 0x3b5a <move_window>
    3d0e:	88 23       	and	r24, r24
    3d10:	b1 f4       	brne	.+44     	; 0x3d3e <get_fat+0x182>
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
    3d12:	82 e0       	ldi	r24, 0x02	; 2
    3d14:	ee 0c       	add	r14, r14
    3d16:	ff 1c       	adc	r15, r15
    3d18:	00 1f       	adc	r16, r16
    3d1a:	11 1f       	adc	r17, r17
    3d1c:	8a 95       	dec	r24
    3d1e:	d1 f7       	brne	.-12     	; 0x3d14 <get_fat+0x158>
    3d20:	f7 01       	movw	r30, r14
    3d22:	f1 70       	andi	r31, 0x01	; 1
    3d24:	ec 0d       	add	r30, r12
    3d26:	fd 1d       	adc	r31, r13
    3d28:	62 a1       	ldd	r22, Z+34	; 0x22
    3d2a:	73 a1       	ldd	r23, Z+35	; 0x23
    3d2c:	84 a1       	ldd	r24, Z+36	; 0x24
    3d2e:	95 a1       	ldd	r25, Z+37	; 0x25
    3d30:	9f 70       	andi	r25, 0x0F	; 15
    3d32:	09 c0       	rjmp	.+18     	; 0x3d46 <get_fat+0x18a>
    3d34:	61 e0       	ldi	r22, 0x01	; 1
    3d36:	70 e0       	ldi	r23, 0x00	; 0
    3d38:	80 e0       	ldi	r24, 0x00	; 0
    3d3a:	90 e0       	ldi	r25, 0x00	; 0
    3d3c:	04 c0       	rjmp	.+8      	; 0x3d46 <get_fat+0x18a>
    3d3e:	6f ef       	ldi	r22, 0xFF	; 255
    3d40:	7f ef       	ldi	r23, 0xFF	; 255
    3d42:	8f ef       	ldi	r24, 0xFF	; 255
    3d44:	9f ef       	ldi	r25, 0xFF	; 255
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
    3d46:	df 91       	pop	r29
    3d48:	cf 91       	pop	r28
    3d4a:	1f 91       	pop	r17
    3d4c:	0f 91       	pop	r16
    3d4e:	ff 90       	pop	r15
    3d50:	ef 90       	pop	r14
    3d52:	df 90       	pop	r13
    3d54:	cf 90       	pop	r12
    3d56:	bf 90       	pop	r11
    3d58:	08 95       	ret

00003d5a <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    3d5a:	2f 92       	push	r2
    3d5c:	3f 92       	push	r3
    3d5e:	4f 92       	push	r4
    3d60:	5f 92       	push	r5
    3d62:	6f 92       	push	r6
    3d64:	7f 92       	push	r7
    3d66:	8f 92       	push	r8
    3d68:	9f 92       	push	r9
    3d6a:	af 92       	push	r10
    3d6c:	bf 92       	push	r11
    3d6e:	cf 92       	push	r12
    3d70:	df 92       	push	r13
    3d72:	ef 92       	push	r14
    3d74:	ff 92       	push	r15
    3d76:	0f 93       	push	r16
    3d78:	1f 93       	push	r17
    3d7a:	df 93       	push	r29
    3d7c:	cf 93       	push	r28
    3d7e:	00 d0       	rcall	.+0      	; 0x3d80 <f_lseek+0x26>
    3d80:	0f 92       	push	r0
    3d82:	cd b7       	in	r28, 0x3d	; 61
    3d84:	de b7       	in	r29, 0x3e	; 62
    3d86:	9b 83       	std	Y+3, r25	; 0x03
    3d88:	8a 83       	std	Y+2, r24	; 0x02
    3d8a:	5a 01       	movw	r10, r20
    3d8c:	6b 01       	movw	r12, r22
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    3d8e:	dc 01       	movw	r26, r24
    3d90:	12 96       	adiw	r26, 0x02	; 2
    3d92:	6d 91       	ld	r22, X+
    3d94:	7c 91       	ld	r23, X
    3d96:	13 97       	sbiw	r26, 0x03	; 3
    3d98:	8d 91       	ld	r24, X+
    3d9a:	9c 91       	ld	r25, X
    3d9c:	ba de       	rcall	.-652    	; 0x3b12 <validate>
    3d9e:	89 83       	std	Y+1, r24	; 0x01
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3da0:	88 23       	and	r24, r24
    3da2:	09 f0       	breq	.+2      	; 0x3da6 <f_lseek+0x4c>
    3da4:	2f c1       	rjmp	.+606    	; 0x4004 <f_lseek+0x2aa>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    3da6:	ea 81       	ldd	r30, Y+2	; 0x02
    3da8:	fb 81       	ldd	r31, Y+3	; 0x03
    3daa:	84 81       	ldd	r24, Z+4	; 0x04
    3dac:	87 fd       	sbrc	r24, 7
    3dae:	b1 c0       	rjmp	.+354    	; 0x3f12 <f_lseek+0x1b8>
    3db0:	ea 81       	ldd	r30, Y+2	; 0x02
    3db2:	fb 81       	ldd	r31, Y+3	; 0x03
    3db4:	82 85       	ldd	r24, Z+10	; 0x0a
    3db6:	93 85       	ldd	r25, Z+11	; 0x0b
    3db8:	a4 85       	ldd	r26, Z+12	; 0x0c
    3dba:	b5 85       	ldd	r27, Z+13	; 0x0d
    3dbc:	35 01       	movw	r6, r10
    3dbe:	46 01       	movw	r8, r12
    3dc0:	8a 15       	cp	r24, r10
    3dc2:	9b 05       	cpc	r25, r11
    3dc4:	ac 05       	cpc	r26, r12
    3dc6:	bd 05       	cpc	r27, r13
    3dc8:	10 f4       	brcc	.+4      	; 0x3dce <f_lseek+0x74>
    3dca:	3c 01       	movw	r6, r24
    3dcc:	4d 01       	movw	r8, r26
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
    3dce:	aa 81       	ldd	r26, Y+2	; 0x02
    3dd0:	bb 81       	ldd	r27, Y+3	; 0x03
    3dd2:	16 96       	adiw	r26, 0x06	; 6
    3dd4:	2d 91       	ld	r18, X+
    3dd6:	3d 91       	ld	r19, X+
    3dd8:	4d 91       	ld	r20, X+
    3dda:	5c 91       	ld	r21, X
    3ddc:	19 97       	sbiw	r26, 0x09	; 9
		fp->fptr = nsect = 0;
    3dde:	fd 01       	movw	r30, r26
    3de0:	16 82       	std	Z+6, r1	; 0x06
    3de2:	17 82       	std	Z+7, r1	; 0x07
    3de4:	10 86       	std	Z+8, r1	; 0x08
    3de6:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    3de8:	61 14       	cp	r6, r1
    3dea:	71 04       	cpc	r7, r1
    3dec:	81 04       	cpc	r8, r1
    3dee:	91 04       	cpc	r9, r1
    3df0:	09 f4       	brne	.+2      	; 0x3df4 <f_lseek+0x9a>
    3df2:	ea c0       	rjmp	.+468    	; 0x3fc8 <f_lseek+0x26e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    3df4:	aa 81       	ldd	r26, Y+2	; 0x02
    3df6:	bb 81       	ldd	r27, Y+3	; 0x03
    3df8:	ed 91       	ld	r30, X+
    3dfa:	fc 91       	ld	r31, X
    3dfc:	82 81       	ldd	r24, Z+2	; 0x02
    3dfe:	a8 2e       	mov	r10, r24
    3e00:	bb 24       	eor	r11, r11
    3e02:	cc 24       	eor	r12, r12
    3e04:	dd 24       	eor	r13, r13
    3e06:	a9 e0       	ldi	r26, 0x09	; 9
    3e08:	aa 0c       	add	r10, r10
    3e0a:	bb 1c       	adc	r11, r11
    3e0c:	cc 1c       	adc	r12, r12
    3e0e:	dd 1c       	adc	r13, r13
    3e10:	aa 95       	dec	r26
    3e12:	d1 f7       	brne	.-12     	; 0x3e08 <f_lseek+0xae>
			if (ifptr > 0 &&
    3e14:	21 15       	cp	r18, r1
    3e16:	31 05       	cpc	r19, r1
    3e18:	41 05       	cpc	r20, r1
    3e1a:	51 05       	cpc	r21, r1
    3e1c:	c1 f1       	breq	.+112    	; 0x3e8e <f_lseek+0x134>
    3e1e:	19 01       	movw	r2, r18
    3e20:	2a 01       	movw	r4, r20
    3e22:	08 94       	sec
    3e24:	21 08       	sbc	r2, r1
    3e26:	31 08       	sbc	r3, r1
    3e28:	41 08       	sbc	r4, r1
    3e2a:	51 08       	sbc	r5, r1
    3e2c:	c4 01       	movw	r24, r8
    3e2e:	b3 01       	movw	r22, r6
    3e30:	61 50       	subi	r22, 0x01	; 1
    3e32:	70 40       	sbci	r23, 0x00	; 0
    3e34:	80 40       	sbci	r24, 0x00	; 0
    3e36:	90 40       	sbci	r25, 0x00	; 0
    3e38:	a6 01       	movw	r20, r12
    3e3a:	95 01       	movw	r18, r10
    3e3c:	0e 94 d2 3c 	call	0x79a4	; 0x79a4 <__udivmodsi4>
    3e40:	79 01       	movw	r14, r18
    3e42:	8a 01       	movw	r16, r20
    3e44:	c2 01       	movw	r24, r4
    3e46:	b1 01       	movw	r22, r2
    3e48:	a6 01       	movw	r20, r12
    3e4a:	95 01       	movw	r18, r10
    3e4c:	0e 94 d2 3c 	call	0x79a4	; 0x79a4 <__udivmodsi4>
    3e50:	e2 16       	cp	r14, r18
    3e52:	f3 06       	cpc	r15, r19
    3e54:	04 07       	cpc	r16, r20
    3e56:	15 07       	cpc	r17, r21
    3e58:	d0 f0       	brcs	.+52     	; 0x3e8e <f_lseek+0x134>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    3e5a:	88 27       	eor	r24, r24
    3e5c:	99 27       	eor	r25, r25
    3e5e:	dc 01       	movw	r26, r24
    3e60:	8a 19       	sub	r24, r10
    3e62:	9b 09       	sbc	r25, r11
    3e64:	ac 09       	sbc	r26, r12
    3e66:	bd 09       	sbc	r27, r13
    3e68:	82 21       	and	r24, r2
    3e6a:	93 21       	and	r25, r3
    3e6c:	a4 21       	and	r26, r4
    3e6e:	b5 21       	and	r27, r5
    3e70:	ea 81       	ldd	r30, Y+2	; 0x02
    3e72:	fb 81       	ldd	r31, Y+3	; 0x03
    3e74:	86 83       	std	Z+6, r24	; 0x06
    3e76:	97 83       	std	Z+7, r25	; 0x07
    3e78:	a0 87       	std	Z+8, r26	; 0x08
    3e7a:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    3e7c:	68 1a       	sub	r6, r24
    3e7e:	79 0a       	sbc	r7, r25
    3e80:	8a 0a       	sbc	r8, r26
    3e82:	9b 0a       	sbc	r9, r27
				clst = fp->clust;
    3e84:	42 89       	ldd	r20, Z+18	; 0x12
    3e86:	53 89       	ldd	r21, Z+19	; 0x13
    3e88:	64 89       	ldd	r22, Z+20	; 0x14
    3e8a:	75 89       	ldd	r23, Z+21	; 0x15
    3e8c:	0d c0       	rjmp	.+26     	; 0x3ea8 <f_lseek+0x14e>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    3e8e:	aa 81       	ldd	r26, Y+2	; 0x02
    3e90:	bb 81       	ldd	r27, Y+3	; 0x03
    3e92:	1e 96       	adiw	r26, 0x0e	; 14
    3e94:	4d 91       	ld	r20, X+
    3e96:	5d 91       	ld	r21, X+
    3e98:	6d 91       	ld	r22, X+
    3e9a:	7c 91       	ld	r23, X
    3e9c:	51 97       	sbiw	r26, 0x11	; 17
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					fp->sclust = clst;
				}
#endif
				fp->clust = clst;
    3e9e:	fd 01       	movw	r30, r26
    3ea0:	42 8b       	std	Z+18, r20	; 0x12
    3ea2:	53 8b       	std	Z+19, r21	; 0x13
    3ea4:	64 8b       	std	Z+20, r22	; 0x14
    3ea6:	75 8b       	std	Z+21, r23	; 0x15
			}
			if (clst != 0) {
    3ea8:	41 15       	cp	r20, r1
    3eaa:	51 05       	cpc	r21, r1
    3eac:	61 05       	cpc	r22, r1
    3eae:	71 05       	cpc	r23, r1
    3eb0:	09 f0       	breq	.+2      	; 0x3eb4 <f_lseek+0x15a>
    3eb2:	4b c0       	rjmp	.+150    	; 0x3f4a <f_lseek+0x1f0>
    3eb4:	89 c0       	rjmp	.+274    	; 0x3fc8 <f_lseek+0x26e>
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    3eb6:	aa 81       	ldd	r26, Y+2	; 0x02
    3eb8:	bb 81       	ldd	r27, Y+3	; 0x03
    3eba:	8d 91       	ld	r24, X+
    3ebc:	9c 91       	ld	r25, X
    3ebe:	7e de       	rcall	.-772    	; 0x3bbc <get_fat>
    3ec0:	ab 01       	movw	r20, r22
    3ec2:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3ec4:	4f 3f       	cpi	r20, 0xFF	; 255
    3ec6:	bf ef       	ldi	r27, 0xFF	; 255
    3ec8:	5b 07       	cpc	r21, r27
    3eca:	bf ef       	ldi	r27, 0xFF	; 255
    3ecc:	6b 07       	cpc	r22, r27
    3ece:	bf ef       	ldi	r27, 0xFF	; 255
    3ed0:	7b 07       	cpc	r23, r27
    3ed2:	41 f4       	brne	.+16     	; 0x3ee4 <f_lseek+0x18a>
    3ed4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ed6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ed8:	84 81       	ldd	r24, Z+4	; 0x04
    3eda:	80 68       	ori	r24, 0x80	; 128
    3edc:	84 83       	std	Z+4, r24	; 0x04
    3ede:	f1 e0       	ldi	r31, 0x01	; 1
    3ee0:	f9 83       	std	Y+1, r31	; 0x01
    3ee2:	90 c0       	rjmp	.+288    	; 0x4004 <f_lseek+0x2aa>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    3ee4:	42 30       	cpi	r20, 0x02	; 2
    3ee6:	51 05       	cpc	r21, r1
    3ee8:	61 05       	cpc	r22, r1
    3eea:	71 05       	cpc	r23, r1
    3eec:	68 f0       	brcs	.+26     	; 0x3f08 <f_lseek+0x1ae>
    3eee:	aa 81       	ldd	r26, Y+2	; 0x02
    3ef0:	bb 81       	ldd	r27, Y+3	; 0x03
    3ef2:	ed 91       	ld	r30, X+
    3ef4:	fc 91       	ld	r31, X
    3ef6:	82 85       	ldd	r24, Z+10	; 0x0a
    3ef8:	93 85       	ldd	r25, Z+11	; 0x0b
    3efa:	a4 85       	ldd	r26, Z+12	; 0x0c
    3efc:	b5 85       	ldd	r27, Z+13	; 0x0d
    3efe:	48 17       	cp	r20, r24
    3f00:	59 07       	cpc	r21, r25
    3f02:	6a 07       	cpc	r22, r26
    3f04:	7b 07       	cpc	r23, r27
    3f06:	38 f0       	brcs	.+14     	; 0x3f16 <f_lseek+0x1bc>
    3f08:	ea 81       	ldd	r30, Y+2	; 0x02
    3f0a:	fb 81       	ldd	r31, Y+3	; 0x03
    3f0c:	84 81       	ldd	r24, Z+4	; 0x04
    3f0e:	80 68       	ori	r24, 0x80	; 128
    3f10:	84 83       	std	Z+4, r24	; 0x04
    3f12:	f2 e0       	ldi	r31, 0x02	; 2
    3f14:	e5 cf       	rjmp	.-54     	; 0x3ee0 <f_lseek+0x186>
					fp->clust = clst;
    3f16:	aa 81       	ldd	r26, Y+2	; 0x02
    3f18:	bb 81       	ldd	r27, Y+3	; 0x03
    3f1a:	52 96       	adiw	r26, 0x12	; 18
    3f1c:	4d 93       	st	X+, r20
    3f1e:	5d 93       	st	X+, r21
    3f20:	6d 93       	st	X+, r22
    3f22:	7c 93       	st	X, r23
    3f24:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    3f26:	ea 81       	ldd	r30, Y+2	; 0x02
    3f28:	fb 81       	ldd	r31, Y+3	; 0x03
    3f2a:	86 81       	ldd	r24, Z+6	; 0x06
    3f2c:	97 81       	ldd	r25, Z+7	; 0x07
    3f2e:	a0 85       	ldd	r26, Z+8	; 0x08
    3f30:	b1 85       	ldd	r27, Z+9	; 0x09
    3f32:	8a 0d       	add	r24, r10
    3f34:	9b 1d       	adc	r25, r11
    3f36:	ac 1d       	adc	r26, r12
    3f38:	bd 1d       	adc	r27, r13
    3f3a:	86 83       	std	Z+6, r24	; 0x06
    3f3c:	97 83       	std	Z+7, r25	; 0x07
    3f3e:	a0 87       	std	Z+8, r26	; 0x08
    3f40:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    3f42:	6a 18       	sub	r6, r10
    3f44:	7b 08       	sbc	r7, r11
    3f46:	8c 08       	sbc	r8, r12
    3f48:	9d 08       	sbc	r9, r13
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    3f4a:	a6 14       	cp	r10, r6
    3f4c:	b7 04       	cpc	r11, r7
    3f4e:	c8 04       	cpc	r12, r8
    3f50:	d9 04       	cpc	r13, r9
    3f52:	08 f4       	brcc	.+2      	; 0x3f56 <f_lseek+0x1fc>
    3f54:	b0 cf       	rjmp	.-160    	; 0x3eb6 <f_lseek+0x15c>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    3f56:	ea 81       	ldd	r30, Y+2	; 0x02
    3f58:	fb 81       	ldd	r31, Y+3	; 0x03
    3f5a:	86 81       	ldd	r24, Z+6	; 0x06
    3f5c:	97 81       	ldd	r25, Z+7	; 0x07
    3f5e:	a0 85       	ldd	r26, Z+8	; 0x08
    3f60:	b1 85       	ldd	r27, Z+9	; 0x09
    3f62:	86 0d       	add	r24, r6
    3f64:	97 1d       	adc	r25, r7
    3f66:	a8 1d       	adc	r26, r8
    3f68:	b9 1d       	adc	r27, r9
    3f6a:	86 83       	std	Z+6, r24	; 0x06
    3f6c:	97 83       	std	Z+7, r25	; 0x07
    3f6e:	a0 87       	std	Z+8, r26	; 0x08
    3f70:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    3f72:	d4 01       	movw	r26, r8
    3f74:	c3 01       	movw	r24, r6
    3f76:	91 70       	andi	r25, 0x01	; 1
    3f78:	a0 70       	andi	r26, 0x00	; 0
    3f7a:	b0 70       	andi	r27, 0x00	; 0
    3f7c:	00 97       	sbiw	r24, 0x00	; 0
    3f7e:	a1 05       	cpc	r26, r1
    3f80:	b1 05       	cpc	r27, r1
    3f82:	11 f1       	breq	.+68     	; 0x3fc8 <f_lseek+0x26e>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    3f84:	80 81       	ld	r24, Z
    3f86:	91 81       	ldd	r25, Z+1	; 0x01
    3f88:	72 dd       	rcall	.-1308   	; 0x3a6e <clust2sect>
    3f8a:	dc 01       	movw	r26, r24
    3f8c:	cb 01       	movw	r24, r22
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    3f8e:	00 97       	sbiw	r24, 0x00	; 0
    3f90:	a1 05       	cpc	r26, r1
    3f92:	b1 05       	cpc	r27, r1
    3f94:	59 f4       	brne	.+22     	; 0x3fac <f_lseek+0x252>
    3f96:	aa 81       	ldd	r26, Y+2	; 0x02
    3f98:	bb 81       	ldd	r27, Y+3	; 0x03
    3f9a:	14 96       	adiw	r26, 0x04	; 4
    3f9c:	8c 91       	ld	r24, X
    3f9e:	14 97       	sbiw	r26, 0x04	; 4
    3fa0:	80 68       	ori	r24, 0x80	; 128
    3fa2:	14 96       	adiw	r26, 0x04	; 4
    3fa4:	8c 93       	st	X, r24
    3fa6:	b2 e0       	ldi	r27, 0x02	; 2
    3fa8:	b9 83       	std	Y+1, r27	; 0x01
    3faa:	2c c0       	rjmp	.+88     	; 0x4004 <f_lseek+0x2aa>
					nsect += ofs / SS(fp->fs);
    3fac:	b4 01       	movw	r22, r8
    3fae:	a3 01       	movw	r20, r6
    3fb0:	f9 e0       	ldi	r31, 0x09	; 9
    3fb2:	76 95       	lsr	r23
    3fb4:	67 95       	ror	r22
    3fb6:	57 95       	ror	r21
    3fb8:	47 95       	ror	r20
    3fba:	fa 95       	dec	r31
    3fbc:	d1 f7       	brne	.-12     	; 0x3fb2 <f_lseek+0x258>
    3fbe:	48 0f       	add	r20, r24
    3fc0:	59 1f       	adc	r21, r25
    3fc2:	6a 1f       	adc	r22, r26
    3fc4:	7b 1f       	adc	r23, r27
    3fc6:	04 c0       	rjmp	.+8      	; 0x3fd0 <f_lseek+0x276>
    3fc8:	40 e0       	ldi	r20, 0x00	; 0
    3fca:	50 e0       	ldi	r21, 0x00	; 0
    3fcc:	60 e0       	ldi	r22, 0x00	; 0
    3fce:	70 e0       	ldi	r23, 0x00	; 0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    3fd0:	ea 81       	ldd	r30, Y+2	; 0x02
    3fd2:	fb 81       	ldd	r31, Y+3	; 0x03
    3fd4:	86 81       	ldd	r24, Z+6	; 0x06
    3fd6:	97 81       	ldd	r25, Z+7	; 0x07
    3fd8:	a0 85       	ldd	r26, Z+8	; 0x08
    3fda:	b1 85       	ldd	r27, Z+9	; 0x09
    3fdc:	91 70       	andi	r25, 0x01	; 1
    3fde:	a0 70       	andi	r26, 0x00	; 0
    3fe0:	b0 70       	andi	r27, 0x00	; 0
    3fe2:	00 97       	sbiw	r24, 0x00	; 0
    3fe4:	a1 05       	cpc	r26, r1
    3fe6:	b1 05       	cpc	r27, r1
    3fe8:	69 f0       	breq	.+26     	; 0x4004 <f_lseek+0x2aa>
    3fea:	86 89       	ldd	r24, Z+22	; 0x16
    3fec:	97 89       	ldd	r25, Z+23	; 0x17
    3fee:	a0 8d       	ldd	r26, Z+24	; 0x18
    3ff0:	b1 8d       	ldd	r27, Z+25	; 0x19
    3ff2:	48 17       	cp	r20, r24
    3ff4:	59 07       	cpc	r21, r25
    3ff6:	6a 07       	cpc	r22, r26
    3ff8:	7b 07       	cpc	r23, r27
    3ffa:	21 f0       	breq	.+8      	; 0x4004 <f_lseek+0x2aa>
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
    3ffc:	46 8b       	std	Z+22, r20	; 0x16
    3ffe:	57 8b       	std	Z+23, r21	; 0x17
    4000:	60 8f       	std	Z+24, r22	; 0x18
    4002:	71 8f       	std	Z+25, r23	; 0x19
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    4004:	89 81       	ldd	r24, Y+1	; 0x01
    4006:	0f 90       	pop	r0
    4008:	0f 90       	pop	r0
    400a:	0f 90       	pop	r0
    400c:	cf 91       	pop	r28
    400e:	df 91       	pop	r29
    4010:	1f 91       	pop	r17
    4012:	0f 91       	pop	r16
    4014:	ff 90       	pop	r15
    4016:	ef 90       	pop	r14
    4018:	df 90       	pop	r13
    401a:	cf 90       	pop	r12
    401c:	bf 90       	pop	r11
    401e:	af 90       	pop	r10
    4020:	9f 90       	pop	r9
    4022:	8f 90       	pop	r8
    4024:	7f 90       	pop	r7
    4026:	6f 90       	pop	r6
    4028:	5f 90       	pop	r5
    402a:	4f 90       	pop	r4
    402c:	3f 90       	pop	r3
    402e:	2f 90       	pop	r2
    4030:	08 95       	ret

00004032 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
    4032:	ef 92       	push	r14
    4034:	ff 92       	push	r15
    4036:	0f 93       	push	r16
    4038:	1f 93       	push	r17
    403a:	cf 93       	push	r28
    403c:	df 93       	push	r29
    403e:	ec 01       	movw	r28, r24
    4040:	8b 01       	movw	r16, r22
	DWORD clst;
	WORD ic;


	dj->index = idx;
    4042:	7d 83       	std	Y+5, r23	; 0x05
    4044:	6c 83       	std	Y+4, r22	; 0x04
	clst = dj->sclust;
    4046:	4e 81       	ldd	r20, Y+6	; 0x06
    4048:	5f 81       	ldd	r21, Y+7	; 0x07
    404a:	68 85       	ldd	r22, Y+8	; 0x08
    404c:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    404e:	41 30       	cpi	r20, 0x01	; 1
    4050:	51 05       	cpc	r21, r1
    4052:	61 05       	cpc	r22, r1
    4054:	71 05       	cpc	r23, r1
    4056:	09 f4       	brne	.+2      	; 0x405a <dir_sdi+0x28>
    4058:	90 c0       	rjmp	.+288    	; 0x417a <dir_sdi+0x148>
    405a:	e8 81       	ld	r30, Y
    405c:	f9 81       	ldd	r31, Y+1	; 0x01
    405e:	82 85       	ldd	r24, Z+10	; 0x0a
    4060:	93 85       	ldd	r25, Z+11	; 0x0b
    4062:	a4 85       	ldd	r26, Z+12	; 0x0c
    4064:	b5 85       	ldd	r27, Z+13	; 0x0d
    4066:	48 17       	cp	r20, r24
    4068:	59 07       	cpc	r21, r25
    406a:	6a 07       	cpc	r22, r26
    406c:	7b 07       	cpc	r23, r27
    406e:	08 f0       	brcs	.+2      	; 0x4072 <dir_sdi+0x40>
    4070:	84 c0       	rjmp	.+264    	; 0x417a <dir_sdi+0x148>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    4072:	41 15       	cp	r20, r1
    4074:	51 05       	cpc	r21, r1
    4076:	61 05       	cpc	r22, r1
    4078:	71 05       	cpc	r23, r1
    407a:	69 f5       	brne	.+90     	; 0x40d6 <dir_sdi+0xa4>
    407c:	80 81       	ld	r24, Z
    407e:	83 30       	cpi	r24, 0x03	; 3
    4080:	49 f4       	brne	.+18     	; 0x4094 <dir_sdi+0x62>
		clst = dj->fs->dirbase;
    4082:	46 89       	ldd	r20, Z+22	; 0x16
    4084:	57 89       	ldd	r21, Z+23	; 0x17
    4086:	60 8d       	ldd	r22, Z+24	; 0x18
    4088:	71 8d       	ldd	r23, Z+25	; 0x19

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    408a:	41 15       	cp	r20, r1
    408c:	51 05       	cpc	r21, r1
    408e:	61 05       	cpc	r22, r1
    4090:	71 05       	cpc	r23, r1
    4092:	09 f5       	brne	.+66     	; 0x40d6 <dir_sdi+0xa4>
		dj->clust = clst;
    4094:	1a 86       	std	Y+10, r1	; 0x0a
    4096:	1b 86       	std	Y+11, r1	; 0x0b
    4098:	1c 86       	std	Y+12, r1	; 0x0c
    409a:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    409c:	e8 81       	ld	r30, Y
    409e:	f9 81       	ldd	r31, Y+1	; 0x01
    40a0:	80 85       	ldd	r24, Z+8	; 0x08
    40a2:	91 85       	ldd	r25, Z+9	; 0x09
    40a4:	08 17       	cp	r16, r24
    40a6:	19 07       	cpc	r17, r25
    40a8:	08 f0       	brcs	.+2      	; 0x40ac <dir_sdi+0x7a>
    40aa:	67 c0       	rjmp	.+206    	; 0x417a <dir_sdi+0x148>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    40ac:	c8 01       	movw	r24, r16
    40ae:	a4 e0       	ldi	r26, 0x04	; 4
    40b0:	96 95       	lsr	r25
    40b2:	87 95       	ror	r24
    40b4:	aa 95       	dec	r26
    40b6:	e1 f7       	brne	.-8      	; 0x40b0 <dir_sdi+0x7e>
    40b8:	a0 e0       	ldi	r26, 0x00	; 0
    40ba:	b0 e0       	ldi	r27, 0x00	; 0
    40bc:	26 89       	ldd	r18, Z+22	; 0x16
    40be:	37 89       	ldd	r19, Z+23	; 0x17
    40c0:	40 8d       	ldd	r20, Z+24	; 0x18
    40c2:	51 8d       	ldd	r21, Z+25	; 0x19
    40c4:	82 0f       	add	r24, r18
    40c6:	93 1f       	adc	r25, r19
    40c8:	a4 1f       	adc	r26, r20
    40ca:	b5 1f       	adc	r27, r21
    40cc:	8e 87       	std	Y+14, r24	; 0x0e
    40ce:	9f 87       	std	Y+15, r25	; 0x0f
    40d0:	a8 8b       	std	Y+16, r26	; 0x10
    40d2:	b9 8b       	std	Y+17, r27	; 0x11
    40d4:	42 c0       	rjmp	.+132    	; 0x415a <dir_sdi+0x128>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    40d6:	82 81       	ldd	r24, Z+2	; 0x02
    40d8:	e8 2e       	mov	r14, r24
    40da:	ff 24       	eor	r15, r15
    40dc:	e4 e0       	ldi	r30, 0x04	; 4
    40de:	ee 0c       	add	r14, r14
    40e0:	ff 1c       	adc	r15, r15
    40e2:	ea 95       	dec	r30
    40e4:	e1 f7       	brne	.-8      	; 0x40de <dir_sdi+0xac>
    40e6:	1f c0       	rjmp	.+62     	; 0x4126 <dir_sdi+0xf4>
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    40e8:	69 dd       	rcall	.-1326   	; 0x3bbc <get_fat>
    40ea:	ab 01       	movw	r20, r22
    40ec:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    40ee:	4f 3f       	cpi	r20, 0xFF	; 255
    40f0:	8f ef       	ldi	r24, 0xFF	; 255
    40f2:	58 07       	cpc	r21, r24
    40f4:	8f ef       	ldi	r24, 0xFF	; 255
    40f6:	68 07       	cpc	r22, r24
    40f8:	8f ef       	ldi	r24, 0xFF	; 255
    40fa:	78 07       	cpc	r23, r24
    40fc:	11 f4       	brne	.+4      	; 0x4102 <dir_sdi+0xd0>
    40fe:	81 e0       	ldi	r24, 0x01	; 1
    4100:	3d c0       	rjmp	.+122    	; 0x417c <dir_sdi+0x14a>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    4102:	42 30       	cpi	r20, 0x02	; 2
    4104:	51 05       	cpc	r21, r1
    4106:	61 05       	cpc	r22, r1
    4108:	71 05       	cpc	r23, r1
    410a:	b8 f1       	brcs	.+110    	; 0x417a <dir_sdi+0x148>
    410c:	e8 81       	ld	r30, Y
    410e:	f9 81       	ldd	r31, Y+1	; 0x01
    4110:	82 85       	ldd	r24, Z+10	; 0x0a
    4112:	93 85       	ldd	r25, Z+11	; 0x0b
    4114:	a4 85       	ldd	r26, Z+12	; 0x0c
    4116:	b5 85       	ldd	r27, Z+13	; 0x0d
    4118:	48 17       	cp	r20, r24
    411a:	59 07       	cpc	r21, r25
    411c:	6a 07       	cpc	r22, r26
    411e:	7b 07       	cpc	r23, r27
    4120:	60 f5       	brcc	.+88     	; 0x417a <dir_sdi+0x148>
				return FR_INT_ERR;
			idx -= ic;
    4122:	0e 19       	sub	r16, r14
    4124:	1f 09       	sbc	r17, r15
    4126:	88 81       	ld	r24, Y
    4128:	99 81       	ldd	r25, Y+1	; 0x01
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
    412a:	0e 15       	cp	r16, r14
    412c:	1f 05       	cpc	r17, r15
    412e:	e0 f6       	brcc	.-72     	; 0x40e8 <dir_sdi+0xb6>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    4130:	4a 87       	std	Y+10, r20	; 0x0a
    4132:	5b 87       	std	Y+11, r21	; 0x0b
    4134:	6c 87       	std	Y+12, r22	; 0x0c
    4136:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    4138:	9a dc       	rcall	.-1740   	; 0x3a6e <clust2sect>
    413a:	98 01       	movw	r18, r16
    413c:	44 e0       	ldi	r20, 0x04	; 4
    413e:	36 95       	lsr	r19
    4140:	27 95       	ror	r18
    4142:	4a 95       	dec	r20
    4144:	e1 f7       	brne	.-8      	; 0x413e <dir_sdi+0x10c>
    4146:	40 e0       	ldi	r20, 0x00	; 0
    4148:	50 e0       	ldi	r21, 0x00	; 0
    414a:	26 0f       	add	r18, r22
    414c:	37 1f       	adc	r19, r23
    414e:	48 1f       	adc	r20, r24
    4150:	59 1f       	adc	r21, r25
    4152:	2e 87       	std	Y+14, r18	; 0x0e
    4154:	3f 87       	std	Y+15, r19	; 0x0f
    4156:	48 8b       	std	Y+16, r20	; 0x10
    4158:	59 8b       	std	Y+17, r21	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    415a:	88 81       	ld	r24, Y
    415c:	99 81       	ldd	r25, Y+1	; 0x01
    415e:	82 96       	adiw	r24, 0x22	; 34
    4160:	0f 70       	andi	r16, 0x0F	; 15
    4162:	10 70       	andi	r17, 0x00	; 0
    4164:	b5 e0       	ldi	r27, 0x05	; 5
    4166:	00 0f       	add	r16, r16
    4168:	11 1f       	adc	r17, r17
    416a:	ba 95       	dec	r27
    416c:	e1 f7       	brne	.-8      	; 0x4166 <dir_sdi+0x134>
    416e:	80 0f       	add	r24, r16
    4170:	91 1f       	adc	r25, r17
    4172:	9b 8b       	std	Y+19, r25	; 0x13
    4174:	8a 8b       	std	Y+18, r24	; 0x12
    4176:	80 e0       	ldi	r24, 0x00	; 0
    4178:	01 c0       	rjmp	.+2      	; 0x417c <dir_sdi+0x14a>

	return FR_OK;	/* Seek succeeded */
    417a:	82 e0       	ldi	r24, 0x02	; 2
}
    417c:	df 91       	pop	r29
    417e:	cf 91       	pop	r28
    4180:	1f 91       	pop	r17
    4182:	0f 91       	pop	r16
    4184:	ff 90       	pop	r15
    4186:	ef 90       	pop	r14
    4188:	08 95       	ret

0000418a <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    418a:	2f 92       	push	r2
    418c:	3f 92       	push	r3
    418e:	4f 92       	push	r4
    4190:	5f 92       	push	r5
    4192:	6f 92       	push	r6
    4194:	7f 92       	push	r7
    4196:	8f 92       	push	r8
    4198:	9f 92       	push	r9
    419a:	af 92       	push	r10
    419c:	bf 92       	push	r11
    419e:	cf 92       	push	r12
    41a0:	df 92       	push	r13
    41a2:	ef 92       	push	r14
    41a4:	ff 92       	push	r15
    41a6:	0f 93       	push	r16
    41a8:	1f 93       	push	r17
    41aa:	cf 93       	push	r28
    41ac:	df 93       	push	r29
    41ae:	ec 01       	movw	r28, r24
    41b0:	8b 01       	movw	r16, r22
    41b2:	3a 01       	movw	r6, r20
    41b4:	19 01       	movw	r2, r18
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
    41b6:	f9 01       	movw	r30, r18
    41b8:	11 82       	std	Z+1, r1	; 0x01
    41ba:	10 82       	st	Z, r1

	res = validate(fp->fs, fp->id);				/* Check validity */
    41bc:	6a 81       	ldd	r22, Y+2	; 0x02
    41be:	7b 81       	ldd	r23, Y+3	; 0x03
    41c0:	88 81       	ld	r24, Y
    41c2:	99 81       	ldd	r25, Y+1	; 0x01
    41c4:	a6 dc       	rcall	.-1716   	; 0x3b12 <validate>
    41c6:	88 2e       	mov	r8, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    41c8:	88 23       	and	r24, r24
    41ca:	09 f0       	breq	.+2      	; 0x41ce <f_read+0x44>
    41cc:	fc c0       	rjmp	.+504    	; 0x43c6 <f_read+0x23c>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    41ce:	8c 81       	ldd	r24, Y+4	; 0x04
    41d0:	87 fd       	sbrc	r24, 7
    41d2:	51 c0       	rjmp	.+162    	; 0x4276 <f_read+0xec>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    41d4:	80 fd       	sbrc	r24, 0
    41d6:	03 c0       	rjmp	.+6      	; 0x41de <f_read+0x54>
    41d8:	77 e0       	ldi	r23, 0x07	; 7
    41da:	87 2e       	mov	r8, r23
    41dc:	f4 c0       	rjmp	.+488    	; 0x43c6 <f_read+0x23c>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    41de:	2a 85       	ldd	r18, Y+10	; 0x0a
    41e0:	3b 85       	ldd	r19, Y+11	; 0x0b
    41e2:	4c 85       	ldd	r20, Y+12	; 0x0c
    41e4:	5d 85       	ldd	r21, Y+13	; 0x0d
    41e6:	8e 81       	ldd	r24, Y+6	; 0x06
    41e8:	9f 81       	ldd	r25, Y+7	; 0x07
    41ea:	a8 85       	ldd	r26, Y+8	; 0x08
    41ec:	b9 85       	ldd	r27, Y+9	; 0x09
    41ee:	28 1b       	sub	r18, r24
    41f0:	39 0b       	sbc	r19, r25
    41f2:	4a 0b       	sbc	r20, r26
    41f4:	5b 0b       	sbc	r21, r27
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    41f6:	c3 01       	movw	r24, r6
    41f8:	a0 e0       	ldi	r26, 0x00	; 0
    41fa:	b0 e0       	ldi	r27, 0x00	; 0
    41fc:	28 17       	cp	r18, r24
    41fe:	39 07       	cpc	r19, r25
    4200:	4a 07       	cpc	r20, r26
    4202:	5b 07       	cpc	r21, r27
    4204:	08 f4       	brcc	.+2      	; 0x4208 <f_read+0x7e>
    4206:	39 01       	movw	r6, r18
)
{
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;
    4208:	28 01       	movw	r4, r16
    420a:	d9 c0       	rjmp	.+434    	; 0x43be <f_read+0x234>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    420c:	2e 81       	ldd	r18, Y+6	; 0x06
    420e:	3f 81       	ldd	r19, Y+7	; 0x07
    4210:	48 85       	ldd	r20, Y+8	; 0x08
    4212:	59 85       	ldd	r21, Y+9	; 0x09
    4214:	da 01       	movw	r26, r20
    4216:	c9 01       	movw	r24, r18
    4218:	91 70       	andi	r25, 0x01	; 1
    421a:	a0 70       	andi	r26, 0x00	; 0
    421c:	b0 70       	andi	r27, 0x00	; 0
    421e:	00 97       	sbiw	r24, 0x00	; 0
    4220:	a1 05       	cpc	r26, r1
    4222:	b1 05       	cpc	r27, r1
    4224:	09 f0       	breq	.+2      	; 0x4228 <f_read+0x9e>
    4226:	72 c0       	rjmp	.+228    	; 0x430c <f_read+0x182>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    4228:	e8 81       	ld	r30, Y
    422a:	f9 81       	ldd	r31, Y+1	; 0x01
    422c:	da 01       	movw	r26, r20
    422e:	c9 01       	movw	r24, r18
    4230:	69 e0       	ldi	r22, 0x09	; 9
    4232:	b6 95       	lsr	r27
    4234:	a7 95       	ror	r26
    4236:	97 95       	ror	r25
    4238:	87 95       	ror	r24
    423a:	6a 95       	dec	r22
    423c:	d1 f7       	brne	.-12     	; 0x4232 <f_read+0xa8>
    423e:	92 80       	ldd	r9, Z+2	; 0x02
    4240:	9a 94       	dec	r9
    4242:	98 22       	and	r9, r24
			if (!csect) {						/* On the cluster boundary? */
    4244:	41 f5       	brne	.+80     	; 0x4296 <f_read+0x10c>
				if (fp->fptr == 0) {			/* On the top of the file? */
    4246:	21 15       	cp	r18, r1
    4248:	31 05       	cpc	r19, r1
    424a:	41 05       	cpc	r20, r1
    424c:	51 05       	cpc	r21, r1
    424e:	29 f4       	brne	.+10     	; 0x425a <f_read+0xd0>
					clst = fp->sclust;			/* Follow from the origin */
    4250:	6e 85       	ldd	r22, Y+14	; 0x0e
    4252:	7f 85       	ldd	r23, Y+15	; 0x0f
    4254:	88 89       	ldd	r24, Y+16	; 0x10
    4256:	99 89       	ldd	r25, Y+17	; 0x11
    4258:	06 c0       	rjmp	.+12     	; 0x4266 <f_read+0xdc>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    425a:	4a 89       	ldd	r20, Y+18	; 0x12
    425c:	5b 89       	ldd	r21, Y+19	; 0x13
    425e:	6c 89       	ldd	r22, Y+20	; 0x14
    4260:	7d 89       	ldd	r23, Y+21	; 0x15
    4262:	cf 01       	movw	r24, r30
    4264:	ab dc       	rcall	.-1706   	; 0x3bbc <get_fat>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    4266:	62 30       	cpi	r22, 0x02	; 2
    4268:	71 05       	cpc	r23, r1
    426a:	81 05       	cpc	r24, r1
    426c:	91 05       	cpc	r25, r1
    426e:	30 f4       	brcc	.+12     	; 0x427c <f_read+0xf2>
    4270:	8c 81       	ldd	r24, Y+4	; 0x04
    4272:	80 68       	ori	r24, 0x80	; 128
    4274:	8c 83       	std	Y+4, r24	; 0x04
    4276:	92 e0       	ldi	r25, 0x02	; 2
    4278:	89 2e       	mov	r8, r25
    427a:	a5 c0       	rjmp	.+330    	; 0x43c6 <f_read+0x23c>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    427c:	6f 3f       	cpi	r22, 0xFF	; 255
    427e:	ff ef       	ldi	r31, 0xFF	; 255
    4280:	7f 07       	cpc	r23, r31
    4282:	ff ef       	ldi	r31, 0xFF	; 255
    4284:	8f 07       	cpc	r24, r31
    4286:	ff ef       	ldi	r31, 0xFF	; 255
    4288:	9f 07       	cpc	r25, r31
    428a:	09 f4       	brne	.+2      	; 0x428e <f_read+0x104>
    428c:	4c c0       	rjmp	.+152    	; 0x4326 <f_read+0x19c>
				fp->clust = clst;				/* Update current cluster */
    428e:	6a 8b       	std	Y+18, r22	; 0x12
    4290:	7b 8b       	std	Y+19, r23	; 0x13
    4292:	8c 8b       	std	Y+20, r24	; 0x14
    4294:	9d 8b       	std	Y+21, r25	; 0x15
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    4296:	08 81       	ld	r16, Y
    4298:	19 81       	ldd	r17, Y+1	; 0x01
    429a:	4a 89       	ldd	r20, Y+18	; 0x12
    429c:	5b 89       	ldd	r21, Y+19	; 0x13
    429e:	6c 89       	ldd	r22, Y+20	; 0x14
    42a0:	7d 89       	ldd	r23, Y+21	; 0x15
    42a2:	c8 01       	movw	r24, r16
    42a4:	e4 db       	rcall	.-2104   	; 0x3a6e <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    42a6:	61 15       	cp	r22, r1
    42a8:	71 05       	cpc	r23, r1
    42aa:	81 05       	cpc	r24, r1
    42ac:	91 05       	cpc	r25, r1
    42ae:	01 f3       	breq	.-64     	; 0x4270 <f_read+0xe6>
			sect += csect;
    42b0:	5b 01       	movw	r10, r22
    42b2:	6c 01       	movw	r12, r24
    42b4:	a9 0c       	add	r10, r9
    42b6:	b1 1c       	adc	r11, r1
    42b8:	c1 1c       	adc	r12, r1
    42ba:	d1 1c       	adc	r13, r1
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    42bc:	73 01       	movw	r14, r6
    42be:	ef 2c       	mov	r14, r15
    42c0:	ff 24       	eor	r15, r15
    42c2:	e6 94       	lsr	r14
			if (cc) {							/* Read maximum contiguous sectors directly */
    42c4:	e1 14       	cp	r14, r1
    42c6:	f1 04       	cpc	r15, r1
    42c8:	e9 f0       	breq	.+58     	; 0x4304 <f_read+0x17a>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    42ca:	f8 01       	movw	r30, r16
    42cc:	22 81       	ldd	r18, Z+2	; 0x02
    42ce:	e9 2d       	mov	r30, r9
    42d0:	f0 e0       	ldi	r31, 0x00	; 0
    42d2:	c7 01       	movw	r24, r14
    42d4:	8e 0f       	add	r24, r30
    42d6:	9f 1f       	adc	r25, r31
    42d8:	62 2f       	mov	r22, r18
    42da:	70 e0       	ldi	r23, 0x00	; 0
    42dc:	68 17       	cp	r22, r24
    42de:	79 07       	cpc	r23, r25
    42e0:	18 f4       	brcc	.+6      	; 0x42e8 <f_read+0x15e>
					cc = fp->fs->csize - csect;
    42e2:	7b 01       	movw	r14, r22
    42e4:	ee 1a       	sub	r14, r30
    42e6:	ff 0a       	sbc	r15, r31
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    42e8:	f8 01       	movw	r30, r16
    42ea:	81 81       	ldd	r24, Z+1	; 0x01
    42ec:	b2 01       	movw	r22, r4
    42ee:	a6 01       	movw	r20, r12
    42f0:	95 01       	movw	r18, r10
    42f2:	0e 2d       	mov	r16, r14
    42f4:	b0 db       	rcall	.-2208   	; 0x3a56 <disk_read>
    42f6:	88 23       	and	r24, r24
    42f8:	b1 f4       	brne	.+44     	; 0x4326 <f_read+0x19c>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    42fa:	b7 01       	movw	r22, r14
    42fc:	76 2f       	mov	r23, r22
    42fe:	66 27       	eor	r22, r22
    4300:	77 0f       	add	r23, r23
    4302:	43 c0       	rjmp	.+134    	; 0x438a <f_read+0x200>
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
    4304:	ae 8a       	std	Y+22, r10	; 0x16
    4306:	bf 8a       	std	Y+23, r11	; 0x17
    4308:	c8 8e       	std	Y+24, r12	; 0x18
    430a:	d9 8e       	std	Y+25, r13	; 0x19
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    430c:	ee 80       	ldd	r14, Y+6	; 0x06
    430e:	ff 80       	ldd	r15, Y+7	; 0x07
    4310:	08 85       	ldd	r16, Y+8	; 0x08
    4312:	19 85       	ldd	r17, Y+9	; 0x09
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    4314:	4e 89       	ldd	r20, Y+22	; 0x16
    4316:	5f 89       	ldd	r21, Y+23	; 0x17
    4318:	68 8d       	ldd	r22, Y+24	; 0x18
    431a:	79 8d       	ldd	r23, Y+25	; 0x19
    431c:	88 81       	ld	r24, Y
    431e:	99 81       	ldd	r25, Y+1	; 0x01
    4320:	1c dc       	rcall	.-1992   	; 0x3b5a <move_window>
    4322:	88 23       	and	r24, r24
    4324:	31 f0       	breq	.+12     	; 0x4332 <f_read+0x1a8>
			ABORT(fp->fs, FR_DISK_ERR);
    4326:	8c 81       	ldd	r24, Y+4	; 0x04
    4328:	80 68       	ori	r24, 0x80	; 128
    432a:	8c 83       	std	Y+4, r24	; 0x04
    432c:	88 24       	eor	r8, r8
    432e:	83 94       	inc	r8
    4330:	4a c0       	rjmp	.+148    	; 0x43c6 <f_read+0x23c>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    4332:	c7 01       	movw	r24, r14
    4334:	91 70       	andi	r25, 0x01	; 1
    4336:	20 e0       	ldi	r18, 0x00	; 0
    4338:	32 e0       	ldi	r19, 0x02	; 2
    433a:	28 1b       	sub	r18, r24
    433c:	39 0b       	sbc	r19, r25
    433e:	b3 01       	movw	r22, r6
    4340:	26 15       	cp	r18, r6
    4342:	37 05       	cpc	r19, r7
    4344:	08 f4       	brcc	.+2      	; 0x4348 <f_read+0x1be>
    4346:	b9 01       	movw	r22, r18

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;
    4348:	8e 81       	ldd	r24, Y+6	; 0x06
    434a:	9f 81       	ldd	r25, Y+7	; 0x07
    434c:	91 70       	andi	r25, 0x01	; 1
    434e:	82 96       	adiw	r24, 0x22	; 34
    4350:	48 81       	ld	r20, Y
    4352:	59 81       	ldd	r21, Y+1	; 0x01
    4354:	48 0f       	add	r20, r24
    4356:	59 1f       	adc	r21, r25
    4358:	da 01       	movw	r26, r20
    435a:	f2 01       	movw	r30, r4
    435c:	9b 01       	movw	r18, r22
    435e:	06 c0       	rjmp	.+12     	; 0x436c <f_read+0x1e2>

#if _WORD_ACCESS == 1
	while (cnt >= sizeof(int)) {
		*(int*)d = *(int*)s;
    4360:	8d 91       	ld	r24, X+
    4362:	9d 91       	ld	r25, X+
    4364:	81 93       	st	Z+, r24
    4366:	91 93       	st	Z+, r25
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
    4368:	22 50       	subi	r18, 0x02	; 2
    436a:	30 40       	sbci	r19, 0x00	; 0
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof(int)) {
    436c:	22 30       	cpi	r18, 0x02	; 2
    436e:	31 05       	cpc	r19, r1
    4370:	b8 f7       	brcc	.-18     	; 0x4360 <f_read+0x1d6>
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    4372:	cb 01       	movw	r24, r22
    4374:	8e 7f       	andi	r24, 0xFE	; 254
    4376:	fa 01       	movw	r30, r20
    4378:	e8 0f       	add	r30, r24
    437a:	f9 1f       	adc	r31, r25
    437c:	d2 01       	movw	r26, r4
    437e:	a8 0f       	add	r26, r24
    4380:	b9 1f       	adc	r27, r25
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
    4382:	60 ff       	sbrs	r22, 0
    4384:	02 c0       	rjmp	.+4      	; 0x438a <f_read+0x200>
		*d++ = *s++;
    4386:	80 81       	ld	r24, Z
    4388:	8c 93       	st	X, r24
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    438a:	46 0e       	add	r4, r22
    438c:	57 1e       	adc	r5, r23
    438e:	cb 01       	movw	r24, r22
    4390:	a0 e0       	ldi	r26, 0x00	; 0
    4392:	b0 e0       	ldi	r27, 0x00	; 0
    4394:	2e 81       	ldd	r18, Y+6	; 0x06
    4396:	3f 81       	ldd	r19, Y+7	; 0x07
    4398:	48 85       	ldd	r20, Y+8	; 0x08
    439a:	59 85       	ldd	r21, Y+9	; 0x09
    439c:	28 0f       	add	r18, r24
    439e:	39 1f       	adc	r19, r25
    43a0:	4a 1f       	adc	r20, r26
    43a2:	5b 1f       	adc	r21, r27
    43a4:	2e 83       	std	Y+6, r18	; 0x06
    43a6:	3f 83       	std	Y+7, r19	; 0x07
    43a8:	48 87       	std	Y+8, r20	; 0x08
    43aa:	59 87       	std	Y+9, r21	; 0x09
    43ac:	f1 01       	movw	r30, r2
    43ae:	80 81       	ld	r24, Z
    43b0:	91 81       	ldd	r25, Z+1	; 0x01
    43b2:	86 0f       	add	r24, r22
    43b4:	97 1f       	adc	r25, r23
    43b6:	91 83       	std	Z+1, r25	; 0x01
    43b8:	80 83       	st	Z, r24
    43ba:	66 1a       	sub	r6, r22
    43bc:	77 0a       	sbc	r7, r23
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    43be:	61 14       	cp	r6, r1
    43c0:	71 04       	cpc	r7, r1
    43c2:	09 f0       	breq	.+2      	; 0x43c6 <f_read+0x23c>
    43c4:	23 cf       	rjmp	.-442    	; 0x420c <f_read+0x82>
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    43c6:	88 2d       	mov	r24, r8
    43c8:	df 91       	pop	r29
    43ca:	cf 91       	pop	r28
    43cc:	1f 91       	pop	r17
    43ce:	0f 91       	pop	r16
    43d0:	ff 90       	pop	r15
    43d2:	ef 90       	pop	r14
    43d4:	df 90       	pop	r13
    43d6:	cf 90       	pop	r12
    43d8:	bf 90       	pop	r11
    43da:	af 90       	pop	r10
    43dc:	9f 90       	pop	r9
    43de:	8f 90       	pop	r8
    43e0:	7f 90       	pop	r7
    43e2:	6f 90       	pop	r6
    43e4:	5f 90       	pop	r5
    43e6:	4f 90       	pop	r4
    43e8:	3f 90       	pop	r3
    43ea:	2f 90       	pop	r2
    43ec:	08 95       	ret

000043ee <check_fs>:
static
BYTE check_fs (	/* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    43ee:	0f 93       	push	r16
    43f0:	cf 93       	push	r28
    43f2:	df 93       	push	r29
    43f4:	ec 01       	movw	r28, r24
    43f6:	9a 01       	movw	r18, r20
    43f8:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    43fa:	bc 01       	movw	r22, r24
    43fc:	6e 5d       	subi	r22, 0xDE	; 222
    43fe:	7f 4f       	sbci	r23, 0xFF	; 255
    4400:	89 81       	ldd	r24, Y+1	; 0x01
    4402:	01 e0       	ldi	r16, 0x01	; 1
    4404:	28 db       	rcall	.-2480   	; 0x3a56 <disk_read>
    4406:	88 23       	and	r24, r24
    4408:	11 f0       	breq	.+4      	; 0x440e <check_fs+0x20>
    440a:	23 e0       	ldi	r18, 0x03	; 3
    440c:	29 c0       	rjmp	.+82     	; 0x4460 <check_fs+0x72>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    440e:	c0 5e       	subi	r28, 0xE0	; 224
    4410:	dd 4f       	sbci	r29, 0xFD	; 253
    4412:	88 81       	ld	r24, Y
    4414:	99 81       	ldd	r25, Y+1	; 0x01
    4416:	c0 52       	subi	r28, 0x20	; 32
    4418:	d2 40       	sbci	r29, 0x02	; 2
    441a:	85 55       	subi	r24, 0x55	; 85
    441c:	9a 4a       	sbci	r25, 0xAA	; 170
    441e:	11 f0       	breq	.+4      	; 0x4424 <check_fs+0x36>
    4420:	22 e0       	ldi	r18, 0x02	; 2
    4422:	1e c0       	rjmp	.+60     	; 0x4460 <check_fs+0x72>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    4424:	c8 5a       	subi	r28, 0xA8	; 168
    4426:	df 4f       	sbci	r29, 0xFF	; 255
    4428:	88 81       	ld	r24, Y
    442a:	99 81       	ldd	r25, Y+1	; 0x01
    442c:	aa 81       	ldd	r26, Y+2	; 0x02
    442e:	bb 81       	ldd	r27, Y+3	; 0x03
    4430:	c8 55       	subi	r28, 0x58	; 88
    4432:	d0 40       	sbci	r29, 0x00	; 0
    4434:	b0 70       	andi	r27, 0x00	; 0
    4436:	86 54       	subi	r24, 0x46	; 70
    4438:	91 44       	sbci	r25, 0x41	; 65
    443a:	a4 45       	sbci	r26, 0x54	; 84
    443c:	b0 40       	sbci	r27, 0x00	; 0
    443e:	11 f4       	brne	.+4      	; 0x4444 <check_fs+0x56>
    4440:	20 e0       	ldi	r18, 0x00	; 0
    4442:	0e c0       	rjmp	.+28     	; 0x4460 <check_fs+0x72>
    4444:	20 e0       	ldi	r18, 0x00	; 0
    4446:	cc 58       	subi	r28, 0x8C	; 140
    4448:	df 4f       	sbci	r29, 0xFF	; 255
    444a:	88 81       	ld	r24, Y
    444c:	99 81       	ldd	r25, Y+1	; 0x01
    444e:	aa 81       	ldd	r26, Y+2	; 0x02
    4450:	bb 81       	ldd	r27, Y+3	; 0x03
    4452:	b0 70       	andi	r27, 0x00	; 0
    4454:	86 54       	subi	r24, 0x46	; 70
    4456:	91 44       	sbci	r25, 0x41	; 65
    4458:	a4 45       	sbci	r26, 0x54	; 84
    445a:	b0 40       	sbci	r27, 0x00	; 0
    445c:	09 f0       	breq	.+2      	; 0x4460 <check_fs+0x72>
    445e:	21 e0       	ldi	r18, 0x01	; 1
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    4460:	82 2f       	mov	r24, r18
    4462:	df 91       	pop	r29
    4464:	cf 91       	pop	r28
    4466:	0f 91       	pop	r16
    4468:	08 95       	ret

0000446a <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    446a:	2f 92       	push	r2
    446c:	3f 92       	push	r3
    446e:	4f 92       	push	r4
    4470:	5f 92       	push	r5
    4472:	6f 92       	push	r6
    4474:	7f 92       	push	r7
    4476:	8f 92       	push	r8
    4478:	9f 92       	push	r9
    447a:	af 92       	push	r10
    447c:	bf 92       	push	r11
    447e:	cf 92       	push	r12
    4480:	df 92       	push	r13
    4482:	ef 92       	push	r14
    4484:	ff 92       	push	r15
    4486:	0f 93       	push	r16
    4488:	1f 93       	push	r17
    448a:	df 93       	push	r29
    448c:	cf 93       	push	r28
    448e:	cd b7       	in	r28, 0x3d	; 61
    4490:	de b7       	in	r29, 0x3e	; 62
    4492:	af 97       	sbiw	r28, 0x2f	; 47
    4494:	0f b6       	in	r0, 0x3f	; 63
    4496:	f8 94       	cli
    4498:	de bf       	out	0x3e, r29	; 62
    449a:	0f be       	out	0x3f, r0	; 63
    449c:	cd bf       	out	0x3d, r28	; 61
    449e:	9c a7       	std	Y+44, r25	; 0x2c
    44a0:	8b a7       	std	Y+43, r24	; 0x2b
    44a2:	7e a7       	std	Y+46, r23	; 0x2e
    44a4:	6d a7       	std	Y+45, r22	; 0x2d
    44a6:	4f a7       	std	Y+47, r20	; 0x2f
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
    44a8:	dc 01       	movw	r26, r24
    44aa:	1d 92       	st	X+, r1
    44ac:	1c 92       	st	X, r1
	WORD nrsv;
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    44ae:	ed a5       	ldd	r30, Y+45	; 0x2d
    44b0:	fe a5       	ldd	r31, Y+46	; 0x2e
    44b2:	80 81       	ld	r24, Z
    44b4:	28 2f       	mov	r18, r24
    44b6:	30 e0       	ldi	r19, 0x00	; 0
    44b8:	20 53       	subi	r18, 0x30	; 48
    44ba:	30 40       	sbci	r19, 0x00	; 0
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    44bc:	2a 30       	cpi	r18, 0x0A	; 10
    44be:	31 05       	cpc	r19, r1
    44c0:	50 f4       	brcc	.+20     	; 0x44d6 <f_open+0x6c>
    44c2:	81 81       	ldd	r24, Z+1	; 0x01
    44c4:	8a 33       	cpi	r24, 0x3A	; 58
    44c6:	39 f4       	brne	.+14     	; 0x44d6 <f_open+0x6c>
		p += 2; *path = p;				/* Return pointer to the path name */
    44c8:	32 96       	adiw	r30, 0x02	; 2
    44ca:	fe a7       	std	Y+46, r31	; 0x2e
    44cc:	ed a7       	std	Y+45, r30	; 0x2d
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the logical drive is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    44ce:	23 2b       	or	r18, r19
    44d0:	11 f0       	breq	.+4      	; 0x44d6 <f_open+0x6c>
    44d2:	6b e0       	ldi	r22, 0x0B	; 11
    44d4:	bc c1       	rjmp	.+888    	; 0x484e <f_open+0x3e4>
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    44d6:	80 90 c8 03 	lds	r8, 0x03C8
    44da:	90 90 c9 03 	lds	r9, 0x03C9
    44de:	9e 86       	std	Y+14, r9	; 0x0e
    44e0:	8d 86       	std	Y+13, r8	; 0x0d
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    44e2:	81 14       	cp	r8, r1
    44e4:	91 04       	cpc	r9, r1
    44e6:	11 f4       	brne	.+4      	; 0x44ec <f_open+0x82>
    44e8:	6c e0       	ldi	r22, 0x0C	; 12
    44ea:	b1 c1       	rjmp	.+866    	; 0x484e <f_open+0x3e4>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
    44ec:	d4 01       	movw	r26, r8
    44ee:	8c 91       	ld	r24, X
    44f0:	88 23       	and	r24, r24
    44f2:	29 f0       	breq	.+10     	; 0x44fe <f_open+0x94>
		stat = disk_status(fs->drv);
    44f4:	11 96       	adiw	r26, 0x01	; 1
    44f6:	8c 91       	ld	r24, X
    44f8:	ac da       	rcall	.-2728   	; 0x3a52 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    44fa:	80 ff       	sbrs	r24, 0
    44fc:	a5 c1       	rjmp	.+842    	; 0x4848 <f_open+0x3de>
	}

	/* The logical drive must be mounted. */
	/* Following code attempts to mount a volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    44fe:	f4 01       	movw	r30, r8
    4500:	10 82       	st	Z, r1
	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
    4502:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    4504:	80 e0       	ldi	r24, 0x00	; 0
    4506:	a3 da       	rcall	.-2746   	; 0x3a4e <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    4508:	80 ff       	sbrs	r24, 0
    450a:	02 c0       	rjmp	.+4      	; 0x4510 <f_open+0xa6>
    450c:	63 e0       	ldi	r22, 0x03	; 3
    450e:	9f c1       	rjmp	.+830    	; 0x484e <f_open+0x3e4>
#if !_FS_READONLY
	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
    4510:	c4 01       	movw	r24, r8
    4512:	40 e0       	ldi	r20, 0x00	; 0
    4514:	50 e0       	ldi	r21, 0x00	; 0
    4516:	60 e0       	ldi	r22, 0x00	; 0
    4518:	70 e0       	ldi	r23, 0x00	; 0
    451a:	69 df       	rcall	.-302    	; 0x43ee <check_fs>
	if (fmt == 1) {						/* Not an FAT-VBR, the disk may be partitioned */
    451c:	81 30       	cpi	r24, 0x01	; 1
    451e:	29 f0       	breq	.+10     	; 0x452a <f_open+0xc0>
    4520:	1f a2       	std	Y+39, r1	; 0x27
    4522:	18 a6       	std	Y+40, r1	; 0x28
    4524:	19 a6       	std	Y+41, r1	; 0x29
    4526:	1a a6       	std	Y+42, r1	; 0x2a
    4528:	15 c0       	rjmp	.+42     	; 0x4554 <f_open+0xea>
		/* Check the partition listed in top of the partition table */
		tbl = &fs->win[MBR_Table + LD2PT(vol) * SZ_PTE];/* Partition table */
    452a:	f4 01       	movw	r30, r8
    452c:	e0 52       	subi	r30, 0x20	; 32
    452e:	fe 4f       	sbci	r31, 0xFE	; 254
		if (tbl[4]) {									/* Is the partition existing? */
    4530:	84 81       	ldd	r24, Z+4	; 0x04
    4532:	88 23       	and	r24, r24
    4534:	09 f4       	brne	.+2      	; 0x4538 <f_open+0xce>
    4536:	8a c1       	rjmp	.+788    	; 0x484c <f_open+0x3e2>
			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
    4538:	80 85       	ldd	r24, Z+8	; 0x08
    453a:	91 85       	ldd	r25, Z+9	; 0x09
    453c:	a2 85       	ldd	r26, Z+10	; 0x0a
    453e:	b3 85       	ldd	r27, Z+11	; 0x0b
    4540:	8f a3       	std	Y+39, r24	; 0x27
    4542:	98 a7       	std	Y+40, r25	; 0x28
    4544:	a9 a7       	std	Y+41, r26	; 0x29
    4546:	ba a7       	std	Y+42, r27	; 0x2a
			fmt = check_fs(fs, bsect);					/* Check the partition */
    4548:	c4 01       	movw	r24, r8
    454a:	4f a1       	ldd	r20, Y+39	; 0x27
    454c:	58 a5       	ldd	r21, Y+40	; 0x28
    454e:	69 a5       	ldd	r22, Y+41	; 0x29
    4550:	7a a5       	ldd	r23, Y+42	; 0x2a
    4552:	4d df       	rcall	.-358    	; 0x43ee <check_fs>
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    4554:	83 30       	cpi	r24, 0x03	; 3
    4556:	11 f4       	brne	.+4      	; 0x455c <f_open+0xf2>
    4558:	61 e0       	ldi	r22, 0x01	; 1
    455a:	79 c1       	rjmp	.+754    	; 0x484e <f_open+0x3e4>
	if (fmt) return FR_NO_FILESYSTEM;					/* No FAT volume is found */
    455c:	88 23       	and	r24, r24
    455e:	09 f0       	breq	.+2      	; 0x4562 <f_open+0xf8>
    4560:	75 c1       	rjmp	.+746    	; 0x484c <f_open+0x3e2>

	/* Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    4562:	d4 01       	movw	r26, r8
    4564:	9d 96       	adiw	r26, 0x2d	; 45
    4566:	8d 91       	ld	r24, X+
    4568:	9c 91       	ld	r25, X
    456a:	9e 97       	sbiw	r26, 0x2e	; 46
    456c:	80 50       	subi	r24, 0x00	; 0
    456e:	92 40       	sbci	r25, 0x02	; 2
    4570:	09 f0       	breq	.+2      	; 0x4574 <f_open+0x10a>
    4572:	6c c1       	rjmp	.+728    	; 0x484c <f_open+0x3e2>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    4574:	f4 01       	movw	r30, r8
    4576:	80 ad       	ldd	r24, Z+56	; 0x38
    4578:	91 ad       	ldd	r25, Z+57	; 0x39
    457a:	7c 01       	movw	r14, r24
    457c:	00 e0       	ldi	r16, 0x00	; 0
    457e:	10 e0       	ldi	r17, 0x00	; 0
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    4580:	e1 14       	cp	r14, r1
    4582:	f1 04       	cpc	r15, r1
    4584:	01 05       	cpc	r16, r1
    4586:	11 05       	cpc	r17, r1
    4588:	69 f4       	brne	.+26     	; 0x45a4 <f_open+0x13a>
    458a:	86 e4       	ldi	r24, 0x46	; 70
    458c:	90 e0       	ldi	r25, 0x00	; 0
    458e:	88 0e       	add	r8, r24
    4590:	99 1e       	adc	r9, r25
    4592:	d4 01       	movw	r26, r8
    4594:	ed 90       	ld	r14, X+
    4596:	fd 90       	ld	r15, X+
    4598:	0d 91       	ld	r16, X+
    459a:	1c 91       	ld	r17, X
    459c:	ea eb       	ldi	r30, 0xBA	; 186
    459e:	ff ef       	ldi	r31, 0xFF	; 255
    45a0:	8e 0e       	add	r8, r30
    45a2:	9f 1e       	adc	r9, r31
	fs->fsize = fasize;
    45a4:	d4 01       	movw	r26, r8
    45a6:	1e 96       	adiw	r26, 0x0e	; 14
    45a8:	ed 92       	st	X+, r14
    45aa:	fd 92       	st	X+, r15
    45ac:	0d 93       	st	X+, r16
    45ae:	1c 93       	st	X, r17
    45b0:	51 97       	sbiw	r26, 0x11	; 17

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    45b2:	d2 96       	adiw	r26, 0x32	; 50
    45b4:	4c 91       	ld	r20, X
    45b6:	d2 97       	sbiw	r26, 0x32	; 50
    45b8:	13 96       	adiw	r26, 0x03	; 3
    45ba:	4c 93       	st	X, r20
    45bc:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    45be:	84 2f       	mov	r24, r20
    45c0:	81 50       	subi	r24, 0x01	; 1
    45c2:	82 30       	cpi	r24, 0x02	; 2
    45c4:	08 f0       	brcs	.+2      	; 0x45c8 <f_open+0x15e>
    45c6:	42 c1       	rjmp	.+644    	; 0x484c <f_open+0x3e2>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    45c8:	9f 96       	adiw	r26, 0x2f	; 47
    45ca:	2c 91       	ld	r18, X
    45cc:	9f 97       	sbiw	r26, 0x2f	; 47
    45ce:	12 96       	adiw	r26, 0x02	; 2
    45d0:	2c 93       	st	X, r18
    45d2:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    45d4:	22 23       	and	r18, r18
    45d6:	09 f4       	brne	.+2      	; 0x45da <f_open+0x170>
    45d8:	39 c1       	rjmp	.+626    	; 0x484c <f_open+0x3e2>
    45da:	30 e0       	ldi	r19, 0x00	; 0
    45dc:	c9 01       	movw	r24, r18
    45de:	01 97       	sbiw	r24, 0x01	; 1
    45e0:	82 23       	and	r24, r18
    45e2:	93 23       	and	r25, r19
    45e4:	89 2b       	or	r24, r25
    45e6:	09 f0       	breq	.+2      	; 0x45ea <f_open+0x180>
    45e8:	31 c1       	rjmp	.+610    	; 0x484c <f_open+0x3e2>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    45ea:	d3 96       	adiw	r26, 0x33	; 51
    45ec:	6d 90       	ld	r6, X+
    45ee:	7c 90       	ld	r7, X
    45f0:	d4 97       	sbiw	r26, 0x34	; 52
    45f2:	19 96       	adiw	r26, 0x09	; 9
    45f4:	7c 92       	st	X, r7
    45f6:	6e 92       	st	-X, r6
    45f8:	18 97       	sbiw	r26, 0x08	; 8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    45fa:	c3 01       	movw	r24, r6
    45fc:	8f 70       	andi	r24, 0x0F	; 15
    45fe:	90 70       	andi	r25, 0x00	; 0
    4600:	89 2b       	or	r24, r25
    4602:	09 f0       	breq	.+2      	; 0x4606 <f_open+0x19c>
    4604:	23 c1       	rjmp	.+582    	; 0x484c <f_open+0x3e2>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    4606:	d5 96       	adiw	r26, 0x35	; 53
    4608:	8d 91       	ld	r24, X+
    460a:	9c 91       	ld	r25, X
    460c:	d6 97       	sbiw	r26, 0x36	; 54
    460e:	5c 01       	movw	r10, r24
    4610:	cc 24       	eor	r12, r12
    4612:	dd 24       	eor	r13, r13
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    4614:	a1 14       	cp	r10, r1
    4616:	b1 04       	cpc	r11, r1
    4618:	c1 04       	cpc	r12, r1
    461a:	d1 04       	cpc	r13, r1
    461c:	69 f4       	brne	.+26     	; 0x4638 <f_open+0x1ce>
    461e:	e2 e4       	ldi	r30, 0x42	; 66
    4620:	f0 e0       	ldi	r31, 0x00	; 0
    4622:	8e 0e       	add	r8, r30
    4624:	9f 1e       	adc	r9, r31
    4626:	d4 01       	movw	r26, r8
    4628:	ad 90       	ld	r10, X+
    462a:	bd 90       	ld	r11, X+
    462c:	cd 90       	ld	r12, X+
    462e:	dc 90       	ld	r13, X
    4630:	ee eb       	ldi	r30, 0xBE	; 190
    4632:	ff ef       	ldi	r31, 0xFF	; 255
    4634:	8e 0e       	add	r8, r30
    4636:	9f 1e       	adc	r9, r31

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    4638:	d4 01       	movw	r26, r8
    463a:	d0 96       	adiw	r26, 0x30	; 48
    463c:	4d 90       	ld	r4, X+
    463e:	5c 90       	ld	r5, X
    4640:	d1 97       	sbiw	r26, 0x31	; 49
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    4642:	41 14       	cp	r4, r1
    4644:	51 04       	cpc	r5, r1
    4646:	09 f4       	brne	.+2      	; 0x464a <f_open+0x1e0>
    4648:	01 c1       	rjmp	.+514    	; 0x484c <f_open+0x3e2>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    464a:	24 2f       	mov	r18, r20
    464c:	30 e0       	ldi	r19, 0x00	; 0
    464e:	40 e0       	ldi	r20, 0x00	; 0
    4650:	50 e0       	ldi	r21, 0x00	; 0
    4652:	c8 01       	movw	r24, r16
    4654:	b7 01       	movw	r22, r14
    4656:	0e 94 b3 3c 	call	0x7966	; 0x7966 <__mulsi3>
    465a:	6b a3       	std	Y+35, r22	; 0x23
    465c:	7c a3       	std	Y+36, r23	; 0x24
    465e:	8d a3       	std	Y+37, r24	; 0x25
    4660:	9e a3       	std	Y+38, r25	; 0x26

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    4662:	12 01       	movw	r2, r4
    4664:	44 24       	eor	r4, r4
    4666:	55 24       	eor	r5, r5
    4668:	24 e0       	ldi	r18, 0x04	; 4
    466a:	76 94       	lsr	r7
    466c:	67 94       	ror	r6
    466e:	2a 95       	dec	r18
    4670:	e1 f7       	brne	.-8      	; 0x466a <f_open+0x200>
    4672:	73 01       	movw	r14, r6
    4674:	00 e0       	ldi	r16, 0x00	; 0
    4676:	10 e0       	ldi	r17, 0x00	; 0
    4678:	e2 0c       	add	r14, r2
    467a:	f3 1c       	adc	r15, r3
    467c:	04 1d       	adc	r16, r4
    467e:	15 1d       	adc	r17, r5
    4680:	e6 0e       	add	r14, r22
    4682:	f7 1e       	adc	r15, r23
    4684:	08 1f       	adc	r16, r24
    4686:	19 1f       	adc	r17, r25
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    4688:	ae 14       	cp	r10, r14
    468a:	bf 04       	cpc	r11, r15
    468c:	c0 06       	cpc	r12, r16
    468e:	d1 06       	cpc	r13, r17
    4690:	08 f4       	brcc	.+2      	; 0x4694 <f_open+0x22a>
    4692:	dc c0       	rjmp	.+440    	; 0x484c <f_open+0x3e2>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    4694:	ae 18       	sub	r10, r14
    4696:	bf 08       	sbc	r11, r15
    4698:	c0 0a       	sbc	r12, r16
    469a:	d1 0a       	sbc	r13, r17
    469c:	f4 01       	movw	r30, r8
    469e:	22 81       	ldd	r18, Z+2	; 0x02
    46a0:	30 e0       	ldi	r19, 0x00	; 0
    46a2:	40 e0       	ldi	r20, 0x00	; 0
    46a4:	50 e0       	ldi	r21, 0x00	; 0
    46a6:	c6 01       	movw	r24, r12
    46a8:	b5 01       	movw	r22, r10
    46aa:	0e 94 d2 3c 	call	0x79a4	; 0x79a4 <__udivmodsi4>
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    46ae:	21 15       	cp	r18, r1
    46b0:	31 05       	cpc	r19, r1
    46b2:	41 05       	cpc	r20, r1
    46b4:	51 05       	cpc	r21, r1
    46b6:	09 f4       	brne	.+2      	; 0x46ba <f_open+0x250>
    46b8:	c9 c0       	rjmp	.+402    	; 0x484c <f_open+0x3e2>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    46ba:	26 3f       	cpi	r18, 0xF6	; 246
    46bc:	ff e0       	ldi	r31, 0x0F	; 15
    46be:	3f 07       	cpc	r19, r31
    46c0:	f0 e0       	ldi	r31, 0x00	; 0
    46c2:	4f 07       	cpc	r20, r31
    46c4:	f0 e0       	ldi	r31, 0x00	; 0
    46c6:	5f 07       	cpc	r21, r31
    46c8:	10 f4       	brcc	.+4      	; 0x46ce <f_open+0x264>
    46ca:	e1 e0       	ldi	r30, 0x01	; 1
    46cc:	0b c0       	rjmp	.+22     	; 0x46e4 <f_open+0x27a>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    46ce:	26 3f       	cpi	r18, 0xF6	; 246
    46d0:	8f ef       	ldi	r24, 0xFF	; 255
    46d2:	38 07       	cpc	r19, r24
    46d4:	80 e0       	ldi	r24, 0x00	; 0
    46d6:	48 07       	cpc	r20, r24
    46d8:	80 e0       	ldi	r24, 0x00	; 0
    46da:	58 07       	cpc	r21, r24
    46dc:	10 f0       	brcs	.+4      	; 0x46e2 <f_open+0x278>
    46de:	e3 e0       	ldi	r30, 0x03	; 3
    46e0:	01 c0       	rjmp	.+2      	; 0x46e4 <f_open+0x27a>
    46e2:	e2 e0       	ldi	r30, 0x02	; 2

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    46e4:	82 e0       	ldi	r24, 0x02	; 2
    46e6:	a8 2e       	mov	r10, r24
    46e8:	b1 2c       	mov	r11, r1
    46ea:	c1 2c       	mov	r12, r1
    46ec:	d1 2c       	mov	r13, r1
    46ee:	a2 0e       	add	r10, r18
    46f0:	b3 1e       	adc	r11, r19
    46f2:	c4 1e       	adc	r12, r20
    46f4:	d5 1e       	adc	r13, r21
    46f6:	d4 01       	movw	r26, r8
    46f8:	1a 96       	adiw	r26, 0x0a	; 10
    46fa:	ad 92       	st	X+, r10
    46fc:	bd 92       	st	X+, r11
    46fe:	cd 92       	st	X+, r12
    4700:	dc 92       	st	X, r13
    4702:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->database = bsect + sysect;						/* Data start sector */
    4704:	8f a1       	ldd	r24, Y+39	; 0x27
    4706:	98 a5       	ldd	r25, Y+40	; 0x28
    4708:	a9 a5       	ldd	r26, Y+41	; 0x29
    470a:	ba a5       	ldd	r27, Y+42	; 0x2a
    470c:	e8 0e       	add	r14, r24
    470e:	f9 1e       	adc	r15, r25
    4710:	0a 1f       	adc	r16, r26
    4712:	1b 1f       	adc	r17, r27
    4714:	d4 01       	movw	r26, r8
    4716:	5a 96       	adiw	r26, 0x1a	; 26
    4718:	ed 92       	st	X+, r14
    471a:	fd 92       	st	X+, r15
    471c:	0d 93       	st	X+, r16
    471e:	1c 93       	st	X, r17
    4720:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    4722:	4f a1       	ldd	r20, Y+39	; 0x27
    4724:	58 a5       	ldd	r21, Y+40	; 0x28
    4726:	69 a5       	ldd	r22, Y+41	; 0x29
    4728:	7a a5       	ldd	r23, Y+42	; 0x2a
    472a:	42 0d       	add	r20, r2
    472c:	53 1d       	adc	r21, r3
    472e:	64 1d       	adc	r22, r4
    4730:	75 1d       	adc	r23, r5
    4732:	52 96       	adiw	r26, 0x12	; 18
    4734:	4d 93       	st	X+, r20
    4736:	5d 93       	st	X+, r21
    4738:	6d 93       	st	X+, r22
    473a:	7c 93       	st	X, r23
    473c:	55 97       	sbiw	r26, 0x15	; 21
    473e:	18 96       	adiw	r26, 0x08	; 8
    4740:	8d 91       	ld	r24, X+
    4742:	9c 91       	ld	r25, X
    4744:	19 97       	sbiw	r26, 0x09	; 9
	if (fmt == FS_FAT32) {
    4746:	e3 30       	cpi	r30, 0x03	; 3
    4748:	09 f5       	brne	.+66     	; 0x478c <f_open+0x322>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    474a:	89 2b       	or	r24, r25
    474c:	09 f0       	breq	.+2      	; 0x4750 <f_open+0x2e6>
    474e:	7e c0       	rjmp	.+252    	; 0x484c <f_open+0x3e2>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    4750:	8e e4       	ldi	r24, 0x4E	; 78
    4752:	90 e0       	ldi	r25, 0x00	; 0
    4754:	88 0e       	add	r8, r24
    4756:	99 1e       	adc	r9, r25
    4758:	d4 01       	movw	r26, r8
    475a:	2d 91       	ld	r18, X+
    475c:	3d 91       	ld	r19, X+
    475e:	4d 91       	ld	r20, X+
    4760:	5c 91       	ld	r21, X
    4762:	82 eb       	ldi	r24, 0xB2	; 178
    4764:	9f ef       	ldi	r25, 0xFF	; 255
    4766:	88 0e       	add	r8, r24
    4768:	99 1e       	adc	r9, r25
    476a:	d4 01       	movw	r26, r8
    476c:	56 96       	adiw	r26, 0x16	; 22
    476e:	2d 93       	st	X+, r18
    4770:	3d 93       	st	X+, r19
    4772:	4d 93       	st	X+, r20
    4774:	5c 93       	st	X, r21
    4776:	59 97       	sbiw	r26, 0x19	; 25
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    4778:	a6 01       	movw	r20, r12
    477a:	95 01       	movw	r18, r10
    477c:	02 e0       	ldi	r16, 0x02	; 2
    477e:	22 0f       	add	r18, r18
    4780:	33 1f       	adc	r19, r19
    4782:	44 1f       	adc	r20, r20
    4784:	55 1f       	adc	r21, r21
    4786:	0a 95       	dec	r16
    4788:	d1 f7       	brne	.-12     	; 0x477e <f_open+0x314>
    478a:	33 c0       	rjmp	.+102    	; 0x47f2 <f_open+0x388>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    478c:	89 2b       	or	r24, r25
    478e:	09 f4       	brne	.+2      	; 0x4792 <f_open+0x328>
    4790:	5d c0       	rjmp	.+186    	; 0x484c <f_open+0x3e2>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    4792:	8b a1       	ldd	r24, Y+35	; 0x23
    4794:	9c a1       	ldd	r25, Y+36	; 0x24
    4796:	ad a1       	ldd	r26, Y+37	; 0x25
    4798:	be a1       	ldd	r27, Y+38	; 0x26
    479a:	48 0f       	add	r20, r24
    479c:	59 1f       	adc	r21, r25
    479e:	6a 1f       	adc	r22, r26
    47a0:	7b 1f       	adc	r23, r27
    47a2:	d4 01       	movw	r26, r8
    47a4:	56 96       	adiw	r26, 0x16	; 22
    47a6:	4d 93       	st	X+, r20
    47a8:	5d 93       	st	X+, r21
    47aa:	6d 93       	st	X+, r22
    47ac:	7c 93       	st	X, r23
    47ae:	59 97       	sbiw	r26, 0x19	; 25
    47b0:	d6 01       	movw	r26, r12
    47b2:	c5 01       	movw	r24, r10
    47b4:	88 0f       	add	r24, r24
    47b6:	99 1f       	adc	r25, r25
    47b8:	aa 1f       	adc	r26, r26
    47ba:	bb 1f       	adc	r27, r27
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    47bc:	e2 30       	cpi	r30, 0x02	; 2
    47be:	19 f4       	brne	.+6      	; 0x47c6 <f_open+0x35c>
    47c0:	9c 01       	movw	r18, r24
    47c2:	ad 01       	movw	r20, r26
    47c4:	16 c0       	rjmp	.+44     	; 0x47f2 <f_open+0x388>
    47c6:	9c 01       	movw	r18, r24
    47c8:	ad 01       	movw	r20, r26
    47ca:	2a 0d       	add	r18, r10
    47cc:	3b 1d       	adc	r19, r11
    47ce:	4c 1d       	adc	r20, r12
    47d0:	5d 1d       	adc	r21, r13
    47d2:	56 95       	lsr	r21
    47d4:	47 95       	ror	r20
    47d6:	37 95       	ror	r19
    47d8:	27 95       	ror	r18
    47da:	81 e0       	ldi	r24, 0x01	; 1
    47dc:	90 e0       	ldi	r25, 0x00	; 0
    47de:	a0 e0       	ldi	r26, 0x00	; 0
    47e0:	b0 e0       	ldi	r27, 0x00	; 0
    47e2:	a8 22       	and	r10, r24
    47e4:	b9 22       	and	r11, r25
    47e6:	ca 22       	and	r12, r26
    47e8:	db 22       	and	r13, r27
    47ea:	2a 0d       	add	r18, r10
    47ec:	3b 1d       	adc	r19, r11
    47ee:	4c 1d       	adc	r20, r12
    47f0:	5d 1d       	adc	r21, r13
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    47f2:	21 50       	subi	r18, 0x01	; 1
    47f4:	3e 4f       	sbci	r19, 0xFE	; 254
    47f6:	4f 4f       	sbci	r20, 0xFF	; 255
    47f8:	5f 4f       	sbci	r21, 0xFF	; 255
    47fa:	a9 e0       	ldi	r26, 0x09	; 9
    47fc:	56 95       	lsr	r21
    47fe:	47 95       	ror	r20
    4800:	37 95       	ror	r19
    4802:	27 95       	ror	r18
    4804:	aa 95       	dec	r26
    4806:	d1 f7       	brne	.-12     	; 0x47fc <f_open+0x392>
    4808:	d4 01       	movw	r26, r8
    480a:	1e 96       	adiw	r26, 0x0e	; 14
    480c:	ed 90       	ld	r14, X+
    480e:	fd 90       	ld	r15, X+
    4810:	0d 91       	ld	r16, X+
    4812:	1c 91       	ld	r17, X
    4814:	51 97       	sbiw	r26, 0x11	; 17
    4816:	e2 16       	cp	r14, r18
    4818:	f3 06       	cpc	r15, r19
    481a:	04 07       	cpc	r16, r20
    481c:	15 07       	cpc	r17, r21
    481e:	b0 f0       	brcs	.+44     	; 0x484c <f_open+0x3e2>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    4820:	ec 93       	st	X, r30
	fs->id = ++Fsid;		/* File system mount ID */
    4822:	80 91 ca 03 	lds	r24, 0x03CA
    4826:	90 91 cb 03 	lds	r25, 0x03CB
    482a:	01 96       	adiw	r24, 0x01	; 1
    482c:	90 93 cb 03 	sts	0x03CB, r25
    4830:	80 93 ca 03 	sts	0x03CA, r24
    4834:	17 96       	adiw	r26, 0x07	; 7
    4836:	9c 93       	st	X, r25
    4838:	8e 93       	st	-X, r24
    483a:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    483c:	f4 01       	movw	r30, r8
    483e:	16 8e       	std	Z+30, r1	; 0x1e
    4840:	17 8e       	std	Z+31, r1	; 0x1f
    4842:	10 a2       	std	Z+32, r1	; 0x20
    4844:	11 a2       	std	Z+33, r1	; 0x21
	fs->wflag = 0;
    4846:	14 82       	std	Z+4, r1	; 0x04
    4848:	60 e0       	ldi	r22, 0x00	; 0
    484a:	01 c0       	rjmp	.+2      	; 0x484e <f_open+0x3e4>
    484c:	6d e0       	ldi	r22, 0x0D	; 13
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
    484e:	ce 01       	movw	r24, r28
    4850:	01 96       	adiw	r24, 0x01	; 1
    4852:	9a a3       	std	Y+34, r25	; 0x22
    4854:	89 a3       	std	Y+33, r24	; 0x21
	if (res == FR_OK)
    4856:	66 23       	and	r22, r22
    4858:	09 f0       	breq	.+2      	; 0x485c <f_open+0x3f2>
    485a:	b1 c1       	rjmp	.+866    	; 0x4bbe <f_open+0x754>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    485c:	ad a5       	ldd	r26, Y+45	; 0x2d
    485e:	be a5       	ldd	r27, Y+46	; 0x2e
    4860:	8c 91       	ld	r24, X
    4862:	8f 32       	cpi	r24, 0x2F	; 47
    4864:	11 f0       	breq	.+4      	; 0x486a <f_open+0x400>
    4866:	8c 35       	cpi	r24, 0x5C	; 92
    4868:	29 f4       	brne	.+10     	; 0x4874 <f_open+0x40a>
		path++;
    486a:	ed a5       	ldd	r30, Y+45	; 0x2d
    486c:	fe a5       	ldd	r31, Y+46	; 0x2e
    486e:	31 96       	adiw	r30, 0x01	; 1
    4870:	fe a7       	std	Y+46, r31	; 0x2e
    4872:	ed a7       	std	Y+45, r30	; 0x2d
	dj->sclust = 0;						/* Start from the root dir */
    4874:	1b 8a       	std	Y+19, r1	; 0x13
    4876:	1c 8a       	std	Y+20, r1	; 0x14
    4878:	1d 8a       	std	Y+21, r1	; 0x15
    487a:	1e 8a       	std	Y+22, r1	; 0x16
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    487c:	ad a5       	ldd	r26, Y+45	; 0x2d
    487e:	be a5       	ldd	r27, Y+46	; 0x2e
    4880:	8c 91       	ld	r24, X
    4882:	80 32       	cpi	r24, 0x20	; 32
    4884:	78 f4       	brcc	.+30     	; 0x48a4 <f_open+0x43a>
		res = dir_sdi(dj, 0);
    4886:	ce 01       	movw	r24, r28
    4888:	0d 96       	adiw	r24, 0x0d	; 13
    488a:	60 e0       	ldi	r22, 0x00	; 0
    488c:	70 e0       	ldi	r23, 0x00	; 0
    488e:	d1 db       	rcall	.-2142   	; 0x4032 <dir_sdi>
    4890:	68 2f       	mov	r22, r24
		dj->dir = 0;
    4892:	18 a2       	std	Y+32, r1	; 0x20
    4894:	1f 8e       	std	Y+31, r1	; 0x1f
    4896:	93 c1       	rjmp	.+806    	; 0x4bbe <f_open+0x754>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    4898:	ed a5       	ldd	r30, Y+45	; 0x2d
    489a:	fe a5       	ldd	r31, Y+46	; 0x2e
    489c:	31 96       	adiw	r30, 0x01	; 1
    489e:	fe a7       	std	Y+46, r31	; 0x2e
    48a0:	ed a7       	std	Y+45, r30	; 0x2d
    48a2:	09 c0       	rjmp	.+18     	; 0x48b6 <f_open+0x44c>
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    48a4:	f0 e2       	ldi	r31, 0x20	; 32
    48a6:	9f 2e       	mov	r9, r31
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    48a8:	ed e0       	ldi	r30, 0x0D	; 13
    48aa:	ae 2e       	mov	r10, r30
    48ac:	b1 2c       	mov	r11, r1
    48ae:	ac 0e       	add	r10, r28
    48b0:	bd 1e       	adc	r11, r29
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    48b2:	75 e0       	ldi	r23, 0x05	; 5
    48b4:	87 2e       	mov	r8, r23
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    48b6:	ad a5       	ldd	r26, Y+45	; 0x2d
    48b8:	be a5       	ldd	r27, Y+46	; 0x2e
    48ba:	8c 91       	ld	r24, X
    48bc:	8f 32       	cpi	r24, 0x2F	; 47
    48be:	61 f3       	breq	.-40     	; 0x4898 <f_open+0x42e>
    48c0:	8c 35       	cpi	r24, 0x5C	; 92
    48c2:	51 f3       	breq	.-44     	; 0x4898 <f_open+0x42e>
	sfn = dj->fn;
    48c4:	a9 a1       	ldd	r26, Y+33	; 0x21
    48c6:	ba a1       	ldd	r27, Y+34	; 0x22
    48c8:	fd 01       	movw	r30, r26
    48ca:	8b e0       	ldi	r24, 0x0B	; 11
    48cc:	90 e0       	ldi	r25, 0x00	; 0
    48ce:	01 c0       	rjmp	.+2      	; 0x48d2 <f_open+0x468>
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    48d0:	91 92       	st	Z+, r9
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    48d2:	01 97       	sbiw	r24, 0x01	; 1
    48d4:	2f ef       	ldi	r18, 0xFF	; 255
    48d6:	8f 3f       	cpi	r24, 0xFF	; 255
    48d8:	92 07       	cpc	r25, r18
    48da:	d1 f7       	brne	.-12     	; 0x48d0 <f_open+0x466>
    48dc:	40 e0       	ldi	r20, 0x00	; 0
    48de:	50 e0       	ldi	r21, 0x00	; 0
    48e0:	cc 24       	eor	r12, r12
    48e2:	dd 24       	eor	r13, r13
    48e4:	68 e0       	ldi	r22, 0x08	; 8
    48e6:	e6 2e       	mov	r14, r22
    48e8:	f1 2c       	mov	r15, r1
    48ea:	10 e0       	ldi	r17, 0x00	; 0
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    48ec:	ed a5       	ldd	r30, Y+45	; 0x2d
    48ee:	fe a5       	ldd	r31, Y+46	; 0x2e
    48f0:	ec 0d       	add	r30, r12
    48f2:	fd 1d       	adc	r31, r13
    48f4:	20 81       	ld	r18, Z
    48f6:	08 94       	sec
    48f8:	c1 1c       	adc	r12, r1
    48fa:	d1 1c       	adc	r13, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    48fc:	21 32       	cpi	r18, 0x21	; 33
    48fe:	08 f4       	brcc	.+2      	; 0x4902 <f_open+0x498>
    4900:	67 c0       	rjmp	.+206    	; 0x49d0 <f_open+0x566>
    4902:	2f 32       	cpi	r18, 0x2F	; 47
    4904:	09 f4       	brne	.+2      	; 0x4908 <f_open+0x49e>
    4906:	c6 c1       	rjmp	.+908    	; 0x4c94 <f_open+0x82a>
    4908:	2c 35       	cpi	r18, 0x5C	; 92
    490a:	09 f4       	brne	.+2      	; 0x490e <f_open+0x4a4>
    490c:	c3 c1       	rjmp	.+902    	; 0x4c94 <f_open+0x82a>
		if (c == '.' || i >= ni) {
    490e:	2e 32       	cpi	r18, 0x2E	; 46
    4910:	19 f0       	breq	.+6      	; 0x4918 <f_open+0x4ae>
    4912:	4e 15       	cp	r20, r14
    4914:	5f 05       	cpc	r21, r15
    4916:	80 f0       	brcs	.+32     	; 0x4938 <f_open+0x4ce>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    4918:	88 e0       	ldi	r24, 0x08	; 8
    491a:	e8 16       	cp	r14, r24
    491c:	f1 04       	cpc	r15, r1
    491e:	09 f0       	breq	.+2      	; 0x4922 <f_open+0x4b8>
    4920:	49 c1       	rjmp	.+658    	; 0x4bb4 <f_open+0x74a>
    4922:	2e 32       	cpi	r18, 0x2E	; 46
    4924:	09 f0       	breq	.+2      	; 0x4928 <f_open+0x4be>
    4926:	46 c1       	rjmp	.+652    	; 0x4bb4 <f_open+0x74a>
			i = 8; ni = 11;
			b <<= 2; continue;
    4928:	11 0f       	add	r17, r17
    492a:	11 0f       	add	r17, r17
    492c:	48 e0       	ldi	r20, 0x08	; 8
    492e:	50 e0       	ldi	r21, 0x00	; 0
    4930:	3b e0       	ldi	r19, 0x0B	; 11
    4932:	e3 2e       	mov	r14, r19
    4934:	f1 2c       	mov	r15, r1
    4936:	da cf       	rjmp	.-76     	; 0x48ec <f_open+0x482>
		}
		if (c >= 0x80) {				/* Extended char? */
    4938:	27 fd       	sbrc	r18, 7
			b |= 3;						/* Eliminate NT flag */
    493a:	13 60       	ori	r17, 0x03	; 3
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    493c:	82 2f       	mov	r24, r18
    493e:	81 58       	subi	r24, 0x81	; 129
    4940:	8f 31       	cpi	r24, 0x1F	; 31
    4942:	18 f0       	brcs	.+6      	; 0x494a <f_open+0x4e0>
    4944:	8f 55       	subi	r24, 0x5F	; 95
    4946:	8d 31       	cpi	r24, 0x1D	; 29
    4948:	10 f5       	brcc	.+68     	; 0x498e <f_open+0x524>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    494a:	ed a5       	ldd	r30, Y+45	; 0x2d
    494c:	fe a5       	ldd	r31, Y+46	; 0x2e
    494e:	ec 0d       	add	r30, r12
    4950:	fd 1d       	adc	r31, r13
    4952:	30 81       	ld	r19, Z
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    4954:	83 2f       	mov	r24, r19
    4956:	80 54       	subi	r24, 0x40	; 64
    4958:	8f 33       	cpi	r24, 0x3F	; 63
    495a:	20 f0       	brcs	.+8      	; 0x4964 <f_open+0x4fa>
    495c:	80 54       	subi	r24, 0x40	; 64
    495e:	8d 37       	cpi	r24, 0x7D	; 125
    4960:	08 f0       	brcs	.+2      	; 0x4964 <f_open+0x4fa>
    4962:	28 c1       	rjmp	.+592    	; 0x4bb4 <f_open+0x74a>
    4964:	c7 01       	movw	r24, r14
    4966:	01 97       	sbiw	r24, 0x01	; 1
    4968:	48 17       	cp	r20, r24
    496a:	59 07       	cpc	r21, r25
    496c:	08 f0       	brcs	.+2      	; 0x4970 <f_open+0x506>
    496e:	22 c1       	rjmp	.+580    	; 0x4bb4 <f_open+0x74a>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    4970:	08 94       	sec
    4972:	c1 1c       	adc	r12, r1
    4974:	d1 1c       	adc	r13, r1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    4976:	fd 01       	movw	r30, r26
    4978:	e4 0f       	add	r30, r20
    497a:	f5 1f       	adc	r31, r21
    497c:	20 83       	st	Z, r18
    497e:	ca 01       	movw	r24, r20
    4980:	01 96       	adiw	r24, 0x01	; 1
			sfn[i++] = d;
    4982:	fd 01       	movw	r30, r26
    4984:	e8 0f       	add	r30, r24
    4986:	f9 1f       	adc	r31, r25
    4988:	30 83       	st	Z, r19
    498a:	ac 01       	movw	r20, r24
    498c:	1e c0       	rjmp	.+60     	; 0x49ca <f_open+0x560>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    498e:	62 2f       	mov	r22, r18
    4990:	70 e0       	ldi	r23, 0x00	; 0
    4992:	e3 e2       	ldi	r30, 0x23	; 35
    4994:	f3 e0       	ldi	r31, 0x03	; 3
    4996:	01 c0       	rjmp	.+2      	; 0x499a <f_open+0x530>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    4998:	31 96       	adiw	r30, 0x01	; 1
    499a:	80 81       	ld	r24, Z
    499c:	88 23       	and	r24, r24
    499e:	29 f0       	breq	.+10     	; 0x49aa <f_open+0x540>
    49a0:	90 e0       	ldi	r25, 0x00	; 0
    49a2:	86 17       	cp	r24, r22
    49a4:	97 07       	cpc	r25, r23
    49a6:	c1 f7       	brne	.-16     	; 0x4998 <f_open+0x52e>
    49a8:	05 c1       	rjmp	.+522    	; 0x4bb4 <f_open+0x74a>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    49aa:	82 2f       	mov	r24, r18
    49ac:	81 54       	subi	r24, 0x41	; 65
    49ae:	8a 31       	cpi	r24, 0x1A	; 26
    49b0:	10 f4       	brcc	.+4      	; 0x49b6 <f_open+0x54c>
				b |= 2;
    49b2:	12 60       	ori	r17, 0x02	; 2
    49b4:	06 c0       	rjmp	.+12     	; 0x49c2 <f_open+0x558>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    49b6:	82 2f       	mov	r24, r18
    49b8:	81 56       	subi	r24, 0x61	; 97
    49ba:	8a 31       	cpi	r24, 0x1A	; 26
    49bc:	10 f4       	brcc	.+4      	; 0x49c2 <f_open+0x558>
					b |= 1; c -= 0x20;
    49be:	11 60       	ori	r17, 0x01	; 1
    49c0:	20 52       	subi	r18, 0x20	; 32
				}
			}
			sfn[i++] = c;
    49c2:	fd 01       	movw	r30, r26
    49c4:	e4 0f       	add	r30, r20
    49c6:	f5 1f       	adc	r31, r21
    49c8:	20 83       	st	Z, r18
    49ca:	4f 5f       	subi	r20, 0xFF	; 255
    49cc:	5f 4f       	sbci	r21, 0xFF	; 255
    49ce:	8e cf       	rjmp	.-228    	; 0x48ec <f_open+0x482>
    49d0:	91 2f       	mov	r25, r17
    49d2:	64 e0       	ldi	r22, 0x04	; 4
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    49d4:	45 2b       	or	r20, r21
    49d6:	09 f4       	brne	.+2      	; 0x49da <f_open+0x570>
    49d8:	ed c0       	rjmp	.+474    	; 0x4bb4 <f_open+0x74a>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    49da:	8c 91       	ld	r24, X
    49dc:	85 3e       	cpi	r24, 0xE5	; 229
    49de:	09 f4       	brne	.+2      	; 0x49e2 <f_open+0x578>
    49e0:	8c 92       	st	X, r8

	if (ni == 8) b <<= 2;
    49e2:	e8 e0       	ldi	r30, 0x08	; 8
    49e4:	ee 16       	cp	r14, r30
    49e6:	f1 04       	cpc	r15, r1
    49e8:	19 f4       	brne	.+6      	; 0x49f0 <f_open+0x586>
    49ea:	91 2f       	mov	r25, r17
    49ec:	99 0f       	add	r25, r25
    49ee:	99 0f       	add	r25, r25
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    49f0:	29 2f       	mov	r18, r25
    49f2:	30 e0       	ldi	r19, 0x00	; 0
    49f4:	c9 01       	movw	r24, r18
    49f6:	83 70       	andi	r24, 0x03	; 3
    49f8:	90 70       	andi	r25, 0x00	; 0
    49fa:	01 97       	sbiw	r24, 0x01	; 1
    49fc:	09 f4       	brne	.+2      	; 0x4a00 <f_open+0x596>
    49fe:	60 61       	ori	r22, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    4a00:	2c 70       	andi	r18, 0x0C	; 12
    4a02:	30 70       	andi	r19, 0x00	; 0
    4a04:	24 30       	cpi	r18, 0x04	; 4
    4a06:	31 05       	cpc	r19, r1
    4a08:	09 f4       	brne	.+2      	; 0x4a0c <f_open+0x5a2>
    4a0a:	68 60       	ori	r22, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    4a0c:	1b 96       	adiw	r26, 0x0b	; 11
    4a0e:	6c 93       	st	X, r22
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    4a10:	c5 01       	movw	r24, r10
    4a12:	60 e0       	ldi	r22, 0x00	; 0
    4a14:	70 e0       	ldi	r23, 0x00	; 0
    4a16:	0d db       	rcall	.-2534   	; 0x4032 <dir_sdi>
    4a18:	48 2f       	mov	r20, r24
	if (res != FR_OK) return res;
    4a1a:	88 23       	and	r24, r24
    4a1c:	09 f0       	breq	.+2      	; 0x4a20 <f_open+0x5b6>
    4a1e:	9e c0       	rjmp	.+316    	; 0x4b5c <f_open+0x6f2>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    4a20:	4b 8d       	ldd	r20, Y+27	; 0x1b
    4a22:	5c 8d       	ldd	r21, Y+28	; 0x1c
    4a24:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4a26:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4a28:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a2c:	96 d8       	rcall	.-3796   	; 0x3b5a <move_window>
    4a2e:	48 2f       	mov	r20, r24
		if (res != FR_OK) break;
    4a30:	88 23       	and	r24, r24
    4a32:	09 f0       	breq	.+2      	; 0x4a36 <f_open+0x5cc>
    4a34:	93 c0       	rjmp	.+294    	; 0x4b5c <f_open+0x6f2>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    4a36:	ef 8d       	ldd	r30, Y+31	; 0x1f
    4a38:	f8 a1       	ldd	r31, Y+32	; 0x20
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    4a3a:	80 81       	ld	r24, Z
    4a3c:	88 23       	and	r24, r24
    4a3e:	09 f4       	brne	.+2      	; 0x4a42 <f_open+0x5d8>
    4a40:	8c c0       	rjmp	.+280    	; 0x4b5a <f_open+0x6f0>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    4a42:	83 85       	ldd	r24, Z+11	; 0x0b
    4a44:	83 fd       	sbrc	r24, 3
    4a46:	12 c0       	rjmp	.+36     	; 0x4a6c <f_open+0x602>
    4a48:	a9 a1       	ldd	r26, Y+33	; 0x21
    4a4a:	ba a1       	ldd	r27, Y+34	; 0x22
    4a4c:	2b e0       	ldi	r18, 0x0B	; 11
    4a4e:	30 e0       	ldi	r19, 0x00	; 0
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    4a50:	21 50       	subi	r18, 0x01	; 1
    4a52:	30 40       	sbci	r19, 0x00	; 0
    4a54:	8f ef       	ldi	r24, 0xFF	; 255
    4a56:	2f 3f       	cpi	r18, 0xFF	; 255
    4a58:	38 07       	cpc	r19, r24
    4a5a:	09 f4       	brne	.+2      	; 0x4a5e <f_open+0x5f4>
    4a5c:	7f c0       	rjmp	.+254    	; 0x4b5c <f_open+0x6f2>
    4a5e:	90 81       	ld	r25, Z
    4a60:	8c 91       	ld	r24, X
    4a62:	98 17       	cp	r25, r24
    4a64:	19 f4       	brne	.+6      	; 0x4a6c <f_open+0x602>
    4a66:	31 96       	adiw	r30, 0x01	; 1
    4a68:	11 96       	adiw	r26, 0x01	; 1
    4a6a:	f2 cf       	rjmp	.-28     	; 0x4a50 <f_open+0x5e6>
{
	DWORD clst;
	WORD i;


	i = dj->index + 1;
    4a6c:	09 89       	ldd	r16, Y+17	; 0x11
    4a6e:	1a 89       	ldd	r17, Y+18	; 0x12
    4a70:	0f 5f       	subi	r16, 0xFF	; 255
    4a72:	1f 4f       	sbci	r17, 0xFF	; 255
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    4a74:	09 f4       	brne	.+2      	; 0x4a78 <f_open+0x60e>
    4a76:	71 c0       	rjmp	.+226    	; 0x4b5a <f_open+0x6f0>
    4a78:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4a7a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4a7c:	ad 8d       	ldd	r26, Y+29	; 0x1d
    4a7e:	be 8d       	ldd	r27, Y+30	; 0x1e
    4a80:	00 97       	sbiw	r24, 0x00	; 0
    4a82:	a1 05       	cpc	r26, r1
    4a84:	b1 05       	cpc	r27, r1
    4a86:	09 f4       	brne	.+2      	; 0x4a8a <f_open+0x620>
    4a88:	68 c0       	rjmp	.+208    	; 0x4b5a <f_open+0x6f0>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    4a8a:	2f e0       	ldi	r18, 0x0F	; 15
    4a8c:	e2 2e       	mov	r14, r18
    4a8e:	f1 2c       	mov	r15, r1
    4a90:	e0 22       	and	r14, r16
    4a92:	f1 22       	and	r15, r17
    4a94:	e1 14       	cp	r14, r1
    4a96:	f1 04       	cpc	r15, r1
    4a98:	09 f0       	breq	.+2      	; 0x4a9c <f_open+0x632>
    4a9a:	50 c0       	rjmp	.+160    	; 0x4b3c <f_open+0x6d2>
		dj->sect++;					/* Next sector */
    4a9c:	01 96       	adiw	r24, 0x01	; 1
    4a9e:	a1 1d       	adc	r26, r1
    4aa0:	b1 1d       	adc	r27, r1
    4aa2:	8b 8f       	std	Y+27, r24	; 0x1b
    4aa4:	9c 8f       	std	Y+28, r25	; 0x1c
    4aa6:	ad 8f       	std	Y+29, r26	; 0x1d
    4aa8:	be 8f       	std	Y+30, r27	; 0x1e

		if (dj->clust == 0) {	/* Static table */
    4aaa:	4f 89       	ldd	r20, Y+23	; 0x17
    4aac:	58 8d       	ldd	r21, Y+24	; 0x18
    4aae:	69 8d       	ldd	r22, Y+25	; 0x19
    4ab0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4ab2:	ed 85       	ldd	r30, Y+13	; 0x0d
    4ab4:	fe 85       	ldd	r31, Y+14	; 0x0e
    4ab6:	41 15       	cp	r20, r1
    4ab8:	51 05       	cpc	r21, r1
    4aba:	61 05       	cpc	r22, r1
    4abc:	71 05       	cpc	r23, r1
    4abe:	31 f4       	brne	.+12     	; 0x4acc <f_open+0x662>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    4ac0:	80 85       	ldd	r24, Z+8	; 0x08
    4ac2:	91 85       	ldd	r25, Z+9	; 0x09
    4ac4:	08 17       	cp	r16, r24
    4ac6:	19 07       	cpc	r17, r25
    4ac8:	c8 f1       	brcs	.+114    	; 0x4b3c <f_open+0x6d2>
    4aca:	47 c0       	rjmp	.+142    	; 0x4b5a <f_open+0x6f0>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    4acc:	82 81       	ldd	r24, Z+2	; 0x02
    4ace:	90 e0       	ldi	r25, 0x00	; 0
    4ad0:	01 97       	sbiw	r24, 0x01	; 1
    4ad2:	98 01       	movw	r18, r16
    4ad4:	a4 e0       	ldi	r26, 0x04	; 4
    4ad6:	36 95       	lsr	r19
    4ad8:	27 95       	ror	r18
    4ada:	aa 95       	dec	r26
    4adc:	e1 f7       	brne	.-8      	; 0x4ad6 <f_open+0x66c>
    4ade:	82 23       	and	r24, r18
    4ae0:	93 23       	and	r25, r19
    4ae2:	89 2b       	or	r24, r25
    4ae4:	59 f5       	brne	.+86     	; 0x4b3c <f_open+0x6d2>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    4ae6:	cf 01       	movw	r24, r30
    4ae8:	69 d8       	rcall	.-3886   	; 0x3bbc <get_fat>
    4aea:	ab 01       	movw	r20, r22
    4aec:	bc 01       	movw	r22, r24
				if (clst <= 1) return FR_INT_ERR;
    4aee:	42 30       	cpi	r20, 0x02	; 2
    4af0:	51 05       	cpc	r21, r1
    4af2:	61 05       	cpc	r22, r1
    4af4:	71 05       	cpc	r23, r1
    4af6:	10 f4       	brcc	.+4      	; 0x4afc <f_open+0x692>
    4af8:	42 e0       	ldi	r20, 0x02	; 2
    4afa:	30 c0       	rjmp	.+96     	; 0x4b5c <f_open+0x6f2>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    4afc:	4f 3f       	cpi	r20, 0xFF	; 255
    4afe:	9f ef       	ldi	r25, 0xFF	; 255
    4b00:	59 07       	cpc	r21, r25
    4b02:	9f ef       	ldi	r25, 0xFF	; 255
    4b04:	69 07       	cpc	r22, r25
    4b06:	9f ef       	ldi	r25, 0xFF	; 255
    4b08:	79 07       	cpc	r23, r25
    4b0a:	11 f4       	brne	.+4      	; 0x4b10 <f_open+0x6a6>
    4b0c:	41 e0       	ldi	r20, 0x01	; 1
    4b0e:	26 c0       	rjmp	.+76     	; 0x4b5c <f_open+0x6f2>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    4b10:	ed 85       	ldd	r30, Y+13	; 0x0d
    4b12:	fe 85       	ldd	r31, Y+14	; 0x0e
    4b14:	82 85       	ldd	r24, Z+10	; 0x0a
    4b16:	93 85       	ldd	r25, Z+11	; 0x0b
    4b18:	a4 85       	ldd	r26, Z+12	; 0x0c
    4b1a:	b5 85       	ldd	r27, Z+13	; 0x0d
    4b1c:	48 17       	cp	r20, r24
    4b1e:	59 07       	cpc	r21, r25
    4b20:	6a 07       	cpc	r22, r26
    4b22:	7b 07       	cpc	r23, r27
    4b24:	d0 f4       	brcc	.+52     	; 0x4b5a <f_open+0x6f0>
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    4b26:	4f 8b       	std	Y+23, r20	; 0x17
    4b28:	58 8f       	std	Y+24, r21	; 0x18
    4b2a:	69 8f       	std	Y+25, r22	; 0x19
    4b2c:	7a 8f       	std	Y+26, r23	; 0x1a
				dj->sect = clust2sect(dj->fs, clst);
    4b2e:	cf 01       	movw	r24, r30
    4b30:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <clust2sect>
    4b34:	6b 8f       	std	Y+27, r22	; 0x1b
    4b36:	7c 8f       	std	Y+28, r23	; 0x1c
    4b38:	8d 8f       	std	Y+29, r24	; 0x1d
    4b3a:	9e 8f       	std	Y+30, r25	; 0x1e
			}
		}
	}

	dj->index = i;
    4b3c:	1a 8b       	std	Y+18, r17	; 0x12
    4b3e:	09 8b       	std	Y+17, r16	; 0x11
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    4b40:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b42:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b44:	82 96       	adiw	r24, 0x22	; 34
    4b46:	25 e0       	ldi	r18, 0x05	; 5
    4b48:	ee 0c       	add	r14, r14
    4b4a:	ff 1c       	adc	r15, r15
    4b4c:	2a 95       	dec	r18
    4b4e:	e1 f7       	brne	.-8      	; 0x4b48 <f_open+0x6de>
    4b50:	8e 0d       	add	r24, r14
    4b52:	9f 1d       	adc	r25, r15
    4b54:	98 a3       	std	Y+32, r25	; 0x20
    4b56:	8f 8f       	std	Y+31, r24	; 0x1f
    4b58:	63 cf       	rjmp	.-314    	; 0x4a20 <f_open+0x5b6>
    4b5a:	44 e0       	ldi	r20, 0x04	; 4
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    4b5c:	e9 a1       	ldd	r30, Y+33	; 0x21
    4b5e:	fa a1       	ldd	r31, Y+34	; 0x22
    4b60:	83 85       	ldd	r24, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
    4b62:	44 23       	and	r20, r20
    4b64:	31 f0       	breq	.+12     	; 0x4b72 <f_open+0x708>
    4b66:	64 2f       	mov	r22, r20
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    4b68:	44 30       	cpi	r20, 0x04	; 4
    4b6a:	31 f5       	brne	.+76     	; 0x4bb8 <f_open+0x74e>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    4b6c:	82 ff       	sbrs	r24, 2
    4b6e:	26 c0       	rjmp	.+76     	; 0x4bbc <f_open+0x752>
    4b70:	26 c0       	rjmp	.+76     	; 0x4bbe <f_open+0x754>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    4b72:	82 fd       	sbrc	r24, 2
    4b74:	21 c0       	rjmp	.+66     	; 0x4bb8 <f_open+0x74e>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    4b76:	ef 8d       	ldd	r30, Y+31	; 0x1f
    4b78:	f8 a1       	ldd	r31, Y+32	; 0x20
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    4b7a:	83 85       	ldd	r24, Z+11	; 0x0b
    4b7c:	84 ff       	sbrs	r24, 4
    4b7e:	1e c0       	rjmp	.+60     	; 0x4bbc <f_open+0x752>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    4b80:	ad a5       	ldd	r26, Y+45	; 0x2d
    4b82:	be a5       	ldd	r27, Y+46	; 0x2e
    4b84:	ac 0d       	add	r26, r12
    4b86:	bd 1d       	adc	r27, r13
    4b88:	be a7       	std	Y+46, r27	; 0x2e
    4b8a:	ad a7       	std	Y+45, r26	; 0x2d
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
    4b8c:	84 89       	ldd	r24, Z+20	; 0x14
    4b8e:	95 89       	ldd	r25, Z+21	; 0x15
    4b90:	a0 e0       	ldi	r26, 0x00	; 0
    4b92:	b0 e0       	ldi	r27, 0x00	; 0
    4b94:	dc 01       	movw	r26, r24
    4b96:	99 27       	eor	r25, r25
    4b98:	88 27       	eor	r24, r24
    4b9a:	22 8d       	ldd	r18, Z+26	; 0x1a
    4b9c:	33 8d       	ldd	r19, Z+27	; 0x1b
    4b9e:	40 e0       	ldi	r20, 0x00	; 0
    4ba0:	50 e0       	ldi	r21, 0x00	; 0
    4ba2:	82 2b       	or	r24, r18
    4ba4:	93 2b       	or	r25, r19
    4ba6:	a4 2b       	or	r26, r20
    4ba8:	b5 2b       	or	r27, r21
    4baa:	8b 8b       	std	Y+19, r24	; 0x13
    4bac:	9c 8b       	std	Y+20, r25	; 0x14
    4bae:	ad 8b       	std	Y+21, r26	; 0x15
    4bb0:	be 8b       	std	Y+22, r27	; 0x16
    4bb2:	81 ce       	rjmp	.-766    	; 0x48b6 <f_open+0x44c>
    4bb4:	66 e0       	ldi	r22, 0x06	; 6
    4bb6:	03 c0       	rjmp	.+6      	; 0x4bbe <f_open+0x754>
    4bb8:	64 2f       	mov	r22, r20
    4bba:	01 c0       	rjmp	.+2      	; 0x4bbe <f_open+0x754>
    4bbc:	65 e0       	ldi	r22, 0x05	; 5
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
    4bbe:	ef 8d       	ldd	r30, Y+31	; 0x1f
    4bc0:	f8 a1       	ldd	r31, Y+32	; 0x20
		if (!fp->lockid) res = FR_INT_ERR;
#endif
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
    4bc2:	66 23       	and	r22, r22
    4bc4:	09 f0       	breq	.+2      	; 0x4bc8 <f_open+0x75e>
    4bc6:	4a c0       	rjmp	.+148    	; 0x4c5c <f_open+0x7f2>
		if (!dir) {						/* Current dir itself */
    4bc8:	30 97       	sbiw	r30, 0x00	; 0
    4bca:	11 f4       	brne	.+4      	; 0x4bd0 <f_open+0x766>
    4bcc:	66 e0       	ldi	r22, 0x06	; 6
    4bce:	46 c0       	rjmp	.+140    	; 0x4c5c <f_open+0x7f2>
			res = FR_INVALID_NAME;
		} else {
			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
    4bd0:	83 85       	ldd	r24, Z+11	; 0x0b
    4bd2:	84 fd       	sbrc	r24, 4
    4bd4:	5d c0       	rjmp	.+186    	; 0x4c90 <f_open+0x826>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
    4bd6:	bf a5       	ldd	r27, Y+47	; 0x2f
    4bd8:	b1 70       	andi	r27, 0x01	; 1
    4bda:	2b 2f       	mov	r18, r27
    4bdc:	ab a5       	ldd	r26, Y+43	; 0x2b
    4bde:	bc a5       	ldd	r27, Y+44	; 0x2c
    4be0:	14 96       	adiw	r26, 0x04	; 4
    4be2:	2c 93       	st	X, r18
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    4be4:	84 89       	ldd	r24, Z+20	; 0x14
    4be6:	95 89       	ldd	r25, Z+21	; 0x15
    4be8:	a0 e0       	ldi	r26, 0x00	; 0
    4bea:	b0 e0       	ldi	r27, 0x00	; 0
    4bec:	8c 01       	movw	r16, r24
    4bee:	ff 24       	eor	r15, r15
    4bf0:	ee 24       	eor	r14, r14
    4bf2:	22 8d       	ldd	r18, Z+26	; 0x1a
    4bf4:	33 8d       	ldd	r19, Z+27	; 0x1b
    4bf6:	40 e0       	ldi	r20, 0x00	; 0
    4bf8:	50 e0       	ldi	r21, 0x00	; 0
    4bfa:	e2 2a       	or	r14, r18
    4bfc:	f3 2a       	or	r15, r19
    4bfe:	04 2b       	or	r16, r20
    4c00:	15 2b       	or	r17, r21
    4c02:	ab a5       	ldd	r26, Y+43	; 0x2b
    4c04:	bc a5       	ldd	r27, Y+44	; 0x2c
    4c06:	1e 96       	adiw	r26, 0x0e	; 14
    4c08:	ed 92       	st	X+, r14
    4c0a:	fd 92       	st	X+, r15
    4c0c:	0d 93       	st	X+, r16
    4c0e:	1c 93       	st	X, r17
    4c10:	51 97       	sbiw	r26, 0x11	; 17
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    4c12:	84 8d       	ldd	r24, Z+28	; 0x1c
    4c14:	95 8d       	ldd	r25, Z+29	; 0x1d
    4c16:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4c18:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4c1a:	eb a5       	ldd	r30, Y+43	; 0x2b
    4c1c:	fc a5       	ldd	r31, Y+44	; 0x2c
    4c1e:	82 87       	std	Z+10, r24	; 0x0a
    4c20:	93 87       	std	Z+11, r25	; 0x0b
    4c22:	a4 87       	std	Z+12, r26	; 0x0c
    4c24:	b5 87       	std	Z+13, r27	; 0x0d
		fp->fptr = 0;						/* File pointer */
    4c26:	ab a5       	ldd	r26, Y+43	; 0x2b
    4c28:	bc a5       	ldd	r27, Y+44	; 0x2c
    4c2a:	16 96       	adiw	r26, 0x06	; 6
    4c2c:	1d 92       	st	X+, r1
    4c2e:	1d 92       	st	X+, r1
    4c30:	1d 92       	st	X+, r1
    4c32:	1c 92       	st	X, r1
    4c34:	19 97       	sbiw	r26, 0x09	; 9
		fp->dsect = 0;
    4c36:	eb a5       	ldd	r30, Y+43	; 0x2b
    4c38:	fc a5       	ldd	r31, Y+44	; 0x2c
    4c3a:	16 8a       	std	Z+22, r1	; 0x16
    4c3c:	17 8a       	std	Z+23, r1	; 0x17
    4c3e:	10 8e       	std	Z+24, r1	; 0x18
    4c40:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    4c42:	ed 85       	ldd	r30, Y+13	; 0x0d
    4c44:	fe 85       	ldd	r31, Y+14	; 0x0e
    4c46:	ab a5       	ldd	r26, Y+43	; 0x2b
    4c48:	bc a5       	ldd	r27, Y+44	; 0x2c
    4c4a:	11 96       	adiw	r26, 0x01	; 1
    4c4c:	fc 93       	st	X, r31
    4c4e:	ee 93       	st	-X, r30
    4c50:	86 81       	ldd	r24, Z+6	; 0x06
    4c52:	97 81       	ldd	r25, Z+7	; 0x07
    4c54:	13 96       	adiw	r26, 0x03	; 3
    4c56:	9c 93       	st	X, r25
    4c58:	8e 93       	st	-X, r24
    4c5a:	12 97       	sbiw	r26, 0x02	; 2
	}

	LEAVE_FF(dj.fs, res);
}
    4c5c:	86 2f       	mov	r24, r22
    4c5e:	af 96       	adiw	r28, 0x2f	; 47
    4c60:	0f b6       	in	r0, 0x3f	; 63
    4c62:	f8 94       	cli
    4c64:	de bf       	out	0x3e, r29	; 62
    4c66:	0f be       	out	0x3f, r0	; 63
    4c68:	cd bf       	out	0x3d, r28	; 61
    4c6a:	cf 91       	pop	r28
    4c6c:	df 91       	pop	r29
    4c6e:	1f 91       	pop	r17
    4c70:	0f 91       	pop	r16
    4c72:	ff 90       	pop	r15
    4c74:	ef 90       	pop	r14
    4c76:	df 90       	pop	r13
    4c78:	cf 90       	pop	r12
    4c7a:	bf 90       	pop	r11
    4c7c:	af 90       	pop	r10
    4c7e:	9f 90       	pop	r9
    4c80:	8f 90       	pop	r8
    4c82:	7f 90       	pop	r7
    4c84:	6f 90       	pop	r6
    4c86:	5f 90       	pop	r5
    4c88:	4f 90       	pop	r4
    4c8a:	3f 90       	pop	r3
    4c8c:	2f 90       	pop	r2
    4c8e:	08 95       	ret
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    4c90:	64 e0       	ldi	r22, 0x04	; 4
    4c92:	e4 cf       	rjmp	.-56     	; 0x4c5c <f_open+0x7f2>
    4c94:	91 2f       	mov	r25, r17
    4c96:	60 e0       	ldi	r22, 0x00	; 0
    4c98:	9d ce       	rjmp	.-710    	; 0x49d4 <f_open+0x56a>

00004c9a <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
    4c9a:	38 2f       	mov	r19, r24
    4c9c:	28 2f       	mov	r18, r24
    4c9e:	2c c0       	rjmp	.+88     	; 0x4cf8 <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    4ca0:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);
		
		if (EPNum == Number)
    4ca4:	23 17       	cp	r18, r19
    4ca6:	21 f4       	brne	.+8      	; 0x4cb0 <Endpoint_ConfigureEndpoint_Prv+0x16>
    4ca8:	76 2f       	mov	r23, r22
    4caa:	94 2f       	mov	r25, r20
    4cac:	50 e0       	ldi	r21, 0x00	; 0
    4cae:	06 c0       	rjmp	.+12     	; 0x4cbc <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    4cb0:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    4cb4:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
    4cb8:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    4cbc:	91 ff       	sbrs	r25, 1
    4cbe:	1b c0       	rjmp	.+54     	; 0x4cf6 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    4cc0:	80 91 eb 00 	lds	r24, 0x00EB
    4cc4:	8e 7f       	andi	r24, 0xFE	; 254
    4cc6:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    4cca:	80 91 ed 00 	lds	r24, 0x00ED
    4cce:	8d 7f       	andi	r24, 0xFD	; 253
    4cd0:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    4cd4:	80 91 eb 00 	lds	r24, 0x00EB
    4cd8:	81 60       	ori	r24, 0x01	; 1
    4cda:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    4cde:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    4ce2:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
    4ce6:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    4cea:	80 91 ee 00 	lds	r24, 0x00EE
			
		if (!(Endpoint_IsConfigured()))
    4cee:	87 fd       	sbrc	r24, 7
    4cf0:	02 c0       	rjmp	.+4      	; 0x4cf6 <Endpoint_ConfigureEndpoint_Prv+0x5c>
    4cf2:	80 e0       	ldi	r24, 0x00	; 0
    4cf4:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else	
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    4cf6:	2f 5f       	subi	r18, 0xFF	; 255
    4cf8:	27 30       	cpi	r18, 0x07	; 7
    4cfa:	90 f2       	brcs	.-92     	; 0x4ca0 <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    4cfc:	30 93 e9 00 	sts	0x00E9, r19
    4d00:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    4d02:	08 95       	ret

00004d04 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    4d04:	80 91 a4 0d 	lds	r24, 0x0DA4
    4d08:	88 23       	and	r24, r24
    4d0a:	8c f4       	brge	.+34     	; 0x4d2e <Endpoint_ClearStatusStage+0x2a>
    4d0c:	03 c0       	rjmp	.+6      	; 0x4d14 <Endpoint_ClearStatusStage+0x10>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    4d0e:	8e b3       	in	r24, 0x1e	; 30
    4d10:	88 23       	and	r24, r24
    4d12:	b1 f0       	breq	.+44     	; 0x4d40 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4d14:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    4d18:	82 ff       	sbrs	r24, 2
    4d1a:	f9 cf       	rjmp	.-14     	; 0x4d0e <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4d1c:	80 91 e8 00 	lds	r24, 0x00E8
    4d20:	8b 77       	andi	r24, 0x7B	; 123
    4d22:	80 93 e8 00 	sts	0x00E8, r24
    4d26:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    4d28:	8e b3       	in	r24, 0x1e	; 30
    4d2a:	88 23       	and	r24, r24
    4d2c:	49 f0       	breq	.+18     	; 0x4d40 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4d2e:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    4d32:	80 ff       	sbrs	r24, 0
    4d34:	f9 cf       	rjmp	.-14     	; 0x4d28 <Endpoint_ClearStatusStage+0x24>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4d36:	80 91 e8 00 	lds	r24, 0x00E8
    4d3a:	8e 77       	andi	r24, 0x7E	; 126
    4d3c:	80 93 e8 00 	sts	0x00E8, r24
    4d40:	08 95       	ret

00004d42 <Endpoint_WaitUntilReady>:
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    4d42:	40 91 e4 00 	lds	r20, 0x00E4
    4d46:	50 91 e5 00 	lds	r21, 0x00E5
    4d4a:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
    4d4c:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    4d50:	80 78       	andi	r24, 0x80	; 128
    4d52:	80 38       	cpi	r24, 0x80	; 128
    4d54:	29 f4       	brne	.+10     	; 0x4d60 <Endpoint_WaitUntilReady+0x1e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4d56:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
    4d5a:	80 ff       	sbrs	r24, 0
    4d5c:	05 c0       	rjmp	.+10     	; 0x4d68 <Endpoint_WaitUntilReady+0x26>
    4d5e:	21 c0       	rjmp	.+66     	; 0x4da2 <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4d60:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    4d64:	82 fd       	sbrc	r24, 2
    4d66:	1d c0       	rjmp	.+58     	; 0x4da2 <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4d68:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4d6a:	88 23       	and	r24, r24
    4d6c:	11 f4       	brne	.+4      	; 0x4d72 <Endpoint_WaitUntilReady+0x30>
    4d6e:	82 e0       	ldi	r24, 0x02	; 2
    4d70:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4d72:	85 30       	cpi	r24, 0x05	; 5
    4d74:	11 f4       	brne	.+4      	; 0x4d7a <Endpoint_WaitUntilReady+0x38>
    4d76:	83 e0       	ldi	r24, 0x03	; 3
    4d78:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    4d7a:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    4d7e:	85 ff       	sbrs	r24, 5
    4d80:	02 c0       	rjmp	.+4      	; 0x4d86 <Endpoint_WaitUntilReady+0x44>
    4d82:	81 e0       	ldi	r24, 0x01	; 1
    4d84:	08 95       	ret
    4d86:	80 91 e4 00 	lds	r24, 0x00E4
    4d8a:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    4d8e:	84 17       	cp	r24, r20
    4d90:	95 07       	cpc	r25, r21
    4d92:	e1 f2       	breq	.-72     	; 0x4d4c <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    4d94:	22 23       	and	r18, r18
    4d96:	11 f4       	brne	.+4      	; 0x4d9c <Endpoint_WaitUntilReady+0x5a>
    4d98:	84 e0       	ldi	r24, 0x04	; 4
    4d9a:	08 95       	ret
    4d9c:	21 50       	subi	r18, 0x01	; 1
    4d9e:	ac 01       	movw	r20, r24
    4da0:	d5 cf       	rjmp	.-86     	; 0x4d4c <Endpoint_WaitUntilReady+0xa>
    4da2:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    4da4:	08 95       	ret

00004da6 <USB_Host_WaitMS>:
		USB_ResetInterface();
	}
}

uint8_t USB_Host_WaitMS(uint8_t MS)
{
    4da6:	98 2f       	mov	r25, r24
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    4da8:	20 91 9e 00 	lds	r18, 0x009E
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    4dac:	30 91 a0 00 	lds	r19, 0x00A0
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    4db0:	80 91 a0 00 	lds	r24, 0x00A0
    4db4:	8f 7d       	andi	r24, 0xDF	; 223
    4db6:	80 93 a0 00 	sts	0x00A0, r24
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4dba:	80 91 9f 00 	lds	r24, 0x009F
    4dbe:	8f 7d       	andi	r24, 0xDF	; 223
    4dc0:	80 93 9f 00 	sts	0x009F, r24
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4dc4:	80 91 9e 00 	lds	r24, 0x009E
    4dc8:	81 60       	ori	r24, 0x01	; 1
    4dca:	80 93 9e 00 	sts	0x009E, r24
    4dce:	2a c0       	rjmp	.+84     	; 0x4e24 <USB_Host_WaitMS+0x7e>
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    4dd0:	80 91 9f 00 	lds	r24, 0x009F

	USB_Host_ResumeBus();

	while (MS)
	{
		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    4dd4:	85 ff       	sbrs	r24, 5
    4dd6:	06 c0       	rjmp	.+12     	; 0x4de4 <USB_Host_WaitMS+0x3e>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4dd8:	80 91 9f 00 	lds	r24, 0x009F
    4ddc:	8f 7d       	andi	r24, 0xDF	; 223
    4dde:	80 93 9f 00 	sts	0x009F, r24
		{
			USB_INT_Clear(USB_INT_HSOFI);
			MS--;
    4de2:	91 50       	subi	r25, 0x01	; 1
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
    4de4:	80 91 ac 0d 	lds	r24, 0x0DAC
    4de8:	81 30       	cpi	r24, 0x01	; 1
    4dea:	f9 f0       	breq	.+62     	; 0x4e2a <USB_Host_WaitMS+0x84>
    4dec:	80 91 cf 03 	lds	r24, 0x03CF
    4df0:	82 30       	cpi	r24, 0x02	; 2
    4df2:	d9 f4       	brne	.+54     	; 0x4e2a <USB_Host_WaitMS+0x84>
			 *  \return Boolean \c true if an error has occurred on the selected pipe, \c false otherwise.
			 */
			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsError(void)
			{
				return ((UPINTX & (1 << PERRI)) ? true : false);
    4df4:	80 91 a6 00 	lds	r24, 0x00A6
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;

			break;
		}

		if (Pipe_IsError() == true)
    4df8:	84 ff       	sbrs	r24, 4
    4dfa:	09 c0       	rjmp	.+18     	; 0x4e0e <USB_Host_WaitMS+0x68>

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    4dfc:	10 92 f5 00 	sts	0x00F5, r1
				UPINTX &= ~(1 << PERRI);
    4e00:	80 91 a6 00 	lds	r24, 0x00A6
    4e04:	8f 7e       	andi	r24, 0xEF	; 239
    4e06:	80 93 a6 00 	sts	0x00A6, r24
    4e0a:	92 e0       	ldi	r25, 0x02	; 2
    4e0c:	0f c0       	rjmp	.+30     	; 0x4e2c <USB_Host_WaitMS+0x86>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    4e0e:	80 91 a6 00 	lds	r24, 0x00A6
			ErrorCode = HOST_WAITERROR_PipeError;

			break;
		}

		if (Pipe_IsStalled() == true)
    4e12:	81 ff       	sbrs	r24, 1
    4e14:	07 c0       	rjmp	.+14     	; 0x4e24 <USB_Host_WaitMS+0x7e>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearStall(void)
			{
				UPINTX &= ~(1 << RXSTALLI);
    4e16:	80 91 a6 00 	lds	r24, 0x00A6
    4e1a:	8d 7f       	andi	r24, 0xFD	; 253
    4e1c:	80 93 a6 00 	sts	0x00A6, r24
    4e20:	93 e0       	ldi	r25, 0x03	; 3
    4e22:	04 c0       	rjmp	.+8      	; 0x4e2c <USB_Host_WaitMS+0x86>
	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	USB_Host_ResumeBus();

	while (MS)
    4e24:	99 23       	and	r25, r25
    4e26:	a1 f6       	brne	.-88     	; 0x4dd0 <USB_Host_WaitMS+0x2a>
    4e28:	01 c0       	rjmp	.+2      	; 0x4e2c <USB_Host_WaitMS+0x86>
    4e2a:	91 e0       	ldi	r25, 0x01	; 1

			break;
		}
	}

	if (BusSuspended)
    4e2c:	20 fd       	sbrc	r18, 0
    4e2e:	05 c0       	rjmp	.+10     	; 0x4e3a <USB_Host_WaitMS+0x94>
			 *        some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    4e30:	80 91 9e 00 	lds	r24, 0x009E
    4e34:	8e 7f       	andi	r24, 0xFE	; 254
    4e36:	80 93 9e 00 	sts	0x009E, r24
	  USB_Host_SuspendBus();

	if (HSOFIEnabled)
    4e3a:	35 ff       	sbrs	r19, 5
    4e3c:	05 c0       	rjmp	.+10     	; 0x4e48 <USB_Host_WaitMS+0xa2>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    4e3e:	80 91 a0 00 	lds	r24, 0x00A0
    4e42:	80 62       	ori	r24, 0x20	; 32
    4e44:	80 93 a0 00 	sts	0x00A0, r24
	  USB_INT_Enable(USB_INT_HSOFI);

	return ErrorCode;
}
    4e48:	89 2f       	mov	r24, r25
    4e4a:	08 95       	ret

00004e4c <USB_Host_ResetDevice>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    4e4c:	60 91 9e 00 	lds	r22, 0x009E
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    4e50:	80 91 a0 00 	lds	r24, 0x00A0
    4e54:	8d 7f       	andi	r24, 0xFD	; 253
    4e56:	80 93 a0 00 	sts	0x00A0, r24
			 *  woken up automatically and the bus resumed after the reset has been correctly issued.
			 */
			static inline void USB_Host_ResetBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResetBus(void)
			{
				UHCON |=  (1 << RESET);
    4e5a:	80 91 9e 00 	lds	r24, 0x009E
    4e5e:	82 60       	ori	r24, 0x02	; 2
    4e60:	80 93 9e 00 	sts	0x009E, r24
			 *  \return Boolean \c true if no bus reset is currently being sent, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusResetComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusResetComplete(void)
			{
				return ((UHCON & (1 << RESET)) ? false : true);
    4e64:	80 91 9e 00 	lds	r24, 0x009E
	bool BusSuspended = USB_Host_IsBusSuspended();

	USB_INT_Disable(USB_INT_DDISCI);

	USB_Host_ResetBus();
	while (!(USB_Host_IsBusResetComplete()));
    4e68:	81 fd       	sbrc	r24, 1
    4e6a:	fc cf       	rjmp	.-8      	; 0x4e64 <USB_Host_ResetDevice+0x18>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    4e6c:	80 91 9e 00 	lds	r24, 0x009E
    4e70:	81 60       	ori	r24, 0x01	; 1
    4e72:	80 93 9e 00 	sts	0x009E, r24
	USB_Host_ResumeBus();
	
	USB_Host_ConfigurationNumber = 0;
    4e76:	10 92 a2 0d 	sts	0x0DA2, r1
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    4e7a:	30 91 a0 00 	lds	r19, 0x00A0
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    4e7e:	80 91 a0 00 	lds	r24, 0x00A0
    4e82:	8f 7d       	andi	r24, 0xDF	; 223
    4e84:	80 93 a0 00 	sts	0x00A0, r24
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4e88:	80 91 9f 00 	lds	r24, 0x009F
    4e8c:	8f 7d       	andi	r24, 0xDF	; 223
    4e8e:	80 93 9f 00 	sts	0x009F, r24
    4e92:	2a e0       	ldi	r18, 0x0A	; 10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4e94:	40 ed       	ldi	r20, 0xD0	; 208
    4e96:	57 e0       	ldi	r21, 0x07	; 7
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    4e98:	80 91 9f 00 	lds	r24, 0x009F
		/* Workaround for powerless-pull-up devices. After a USB bus reset,
		   all disconnection interrupts are suppressed while a USB frame is
		   looked for - if it is found within 10ms, the device is still
		   present.                                                        */

		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    4e9c:	85 ff       	sbrs	r24, 5
    4e9e:	0b c0       	rjmp	.+22     	; 0x4eb6 <USB_Host_ResetDevice+0x6a>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    4ea0:	80 91 9f 00 	lds	r24, 0x009F
    4ea4:	8f 7d       	andi	r24, 0xDF	; 223
    4ea6:	80 93 9f 00 	sts	0x009F, r24
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    4eaa:	80 91 9f 00 	lds	r24, 0x009F
    4eae:	8d 7f       	andi	r24, 0xFD	; 253
    4eb0:	80 93 9f 00 	sts	0x009F, r24
    4eb4:	05 c0       	rjmp	.+10     	; 0x4ec0 <USB_Host_ResetDevice+0x74>
    4eb6:	ca 01       	movw	r24, r20
    4eb8:	01 97       	sbiw	r24, 0x01	; 1
    4eba:	f1 f7       	brne	.-4      	; 0x4eb8 <USB_Host_ResetDevice+0x6c>
	bool HSOFIEnabled = USB_INT_IsEnabled(USB_INT_HSOFI);

	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	for (uint8_t MSRem = 10; MSRem != 0; MSRem--)
    4ebc:	21 50       	subi	r18, 0x01	; 1
    4ebe:	61 f7       	brne	.-40     	; 0x4e98 <USB_Host_ResetDevice+0x4c>
		}

		Delay_MS(1);
	}

	if (HSOFIEnabled)
    4ec0:	35 ff       	sbrs	r19, 5
    4ec2:	05 c0       	rjmp	.+10     	; 0x4ece <USB_Host_ResetDevice+0x82>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    4ec4:	80 91 a0 00 	lds	r24, 0x00A0
    4ec8:	80 62       	ori	r24, 0x20	; 32
    4eca:	80 93 a0 00 	sts	0x00A0, r24
	  USB_INT_Enable(USB_INT_HSOFI);

	if (BusSuspended)
    4ece:	60 fd       	sbrc	r22, 0
    4ed0:	05 c0       	rjmp	.+10     	; 0x4edc <USB_Host_ResetDevice+0x90>
			 *        some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    4ed2:	80 91 9e 00 	lds	r24, 0x009E
    4ed6:	8e 7f       	andi	r24, 0xFE	; 254
    4ed8:	80 93 9e 00 	sts	0x009E, r24
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    4edc:	80 91 a0 00 	lds	r24, 0x00A0
    4ee0:	82 60       	ori	r24, 0x02	; 2
    4ee2:	80 93 a0 00 	sts	0x00A0, r24
	  USB_Host_SuspendBus();

	USB_INT_Enable(USB_INT_DDISCI);
}
    4ee6:	08 95       	ret

00004ee8 <USB_Host_ProcessNextHostState>:

#define  __INCLUDE_FROM_HOST_C
#include "../Host.h"

void USB_Host_ProcessNextHostState(void)
{
    4ee8:	ef 92       	push	r14
    4eea:	0f 93       	push	r16
    4eec:	1f 93       	push	r17
    4eee:	df 93       	push	r29
    4ef0:	cf 93       	push	r28
    4ef2:	cd b7       	in	r28, 0x3d	; 61
    4ef4:	de b7       	in	r29, 0x3e	; 62
    4ef6:	28 97       	sbiw	r28, 0x08	; 8
    4ef8:	0f b6       	in	r0, 0x3f	; 63
    4efa:	f8 94       	cli
    4efc:	de bf       	out	0x3e, r29	; 62
    4efe:	0f be       	out	0x3f, r0	; 63
    4f00:	cd bf       	out	0x3d, r28	; 61
	uint8_t SubErrorCode = HOST_ENUMERROR_NoError;

	static uint16_t WaitMSRemaining;
	static uint8_t  PostWaitState;

	switch (USB_HostState)
    4f02:	80 91 ac 0d 	lds	r24, 0x0DAC
    4f06:	85 30       	cpi	r24, 0x05	; 5
    4f08:	09 f4       	brne	.+2      	; 0x4f0c <USB_Host_ProcessNextHostState+0x24>
    4f0a:	94 c0       	rjmp	.+296    	; 0x5034 <USB_Host_ProcessNextHostState+0x14c>
    4f0c:	86 30       	cpi	r24, 0x06	; 6
    4f0e:	68 f4       	brcc	.+26     	; 0x4f2a <USB_Host_ProcessNextHostState+0x42>
    4f10:	82 30       	cpi	r24, 0x02	; 2
    4f12:	b9 f1       	breq	.+110    	; 0x4f82 <USB_Host_ProcessNextHostState+0x9a>
    4f14:	83 30       	cpi	r24, 0x03	; 3
    4f16:	18 f4       	brcc	.+6      	; 0x4f1e <USB_Host_ProcessNextHostState+0x36>
    4f18:	88 23       	and	r24, r24
    4f1a:	a1 f0       	breq	.+40     	; 0x4f44 <USB_Host_ProcessNextHostState+0x5c>
    4f1c:	09 c1       	rjmp	.+530    	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
    4f1e:	83 30       	cpi	r24, 0x03	; 3
    4f20:	d1 f1       	breq	.+116    	; 0x4f96 <USB_Host_ProcessNextHostState+0xae>
    4f22:	84 30       	cpi	r24, 0x04	; 4
    4f24:	09 f0       	breq	.+2      	; 0x4f28 <USB_Host_ProcessNextHostState+0x40>
    4f26:	04 c1       	rjmp	.+520    	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
    4f28:	5d c0       	rjmp	.+186    	; 0x4fe4 <USB_Host_ProcessNextHostState+0xfc>
    4f2a:	87 30       	cpi	r24, 0x07	; 7
    4f2c:	09 f4       	brne	.+2      	; 0x4f30 <USB_Host_ProcessNextHostState+0x48>
    4f2e:	9b c0       	rjmp	.+310    	; 0x5066 <USB_Host_ProcessNextHostState+0x17e>
    4f30:	87 30       	cpi	r24, 0x07	; 7
    4f32:	08 f4       	brcc	.+2      	; 0x4f36 <USB_Host_ProcessNextHostState+0x4e>
    4f34:	8a c0       	rjmp	.+276    	; 0x504a <USB_Host_ProcessNextHostState+0x162>
    4f36:	88 30       	cpi	r24, 0x08	; 8
    4f38:	09 f4       	brne	.+2      	; 0x4f3c <USB_Host_ProcessNextHostState+0x54>
    4f3a:	b4 c0       	rjmp	.+360    	; 0x50a4 <USB_Host_ProcessNextHostState+0x1bc>
    4f3c:	89 30       	cpi	r24, 0x09	; 9
    4f3e:	09 f0       	breq	.+2      	; 0x4f42 <USB_Host_ProcessNextHostState+0x5a>
    4f40:	f7 c0       	rjmp	.+494    	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
    4f42:	d9 c0       	rjmp	.+434    	; 0x50f6 <USB_Host_ProcessNextHostState+0x20e>
	{
		case HOST_STATE_WaitForDevice:
			if (WaitMSRemaining)
    4f44:	00 91 cd 03 	lds	r16, 0x03CD
    4f48:	10 91 ce 03 	lds	r17, 0x03CE
    4f4c:	01 15       	cp	r16, r1
    4f4e:	11 05       	cpc	r17, r1
    4f50:	09 f4       	brne	.+2      	; 0x4f54 <USB_Host_ProcessNextHostState+0x6c>
    4f52:	ee c0       	rjmp	.+476    	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
			{
				if ((SubErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    4f54:	81 e0       	ldi	r24, 0x01	; 1
    4f56:	27 df       	rcall	.-434    	; 0x4da6 <USB_Host_WaitMS>
    4f58:	68 2f       	mov	r22, r24
    4f5a:	88 23       	and	r24, r24
    4f5c:	31 f0       	breq	.+12     	; 0x4f6a <USB_Host_ProcessNextHostState+0x82>
				{
					USB_HostState = PostWaitState;
    4f5e:	80 91 cc 03 	lds	r24, 0x03CC
    4f62:	80 93 ac 0d 	sts	0x0DAC, r24
    4f66:	91 e0       	ldi	r25, 0x01	; 1
    4f68:	df c0       	rjmp	.+446    	; 0x5128 <USB_Host_ProcessNextHostState+0x240>
					ErrorCode     = HOST_ENUMERROR_WaitStage;
					break;
				}

				if (!(--WaitMSRemaining))
    4f6a:	c8 01       	movw	r24, r16
    4f6c:	01 97       	sbiw	r24, 0x01	; 1
    4f6e:	90 93 ce 03 	sts	0x03CE, r25
    4f72:	80 93 cd 03 	sts	0x03CD, r24
    4f76:	89 2b       	or	r24, r25
    4f78:	09 f0       	breq	.+2      	; 0x4f7c <USB_Host_ProcessNextHostState+0x94>
    4f7a:	da c0       	rjmp	.+436    	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
				  USB_HostState = PostWaitState;
    4f7c:	80 91 cc 03 	lds	r24, 0x03CC
    4f80:	07 c0       	rjmp	.+14     	; 0x4f90 <USB_Host_ProcessNextHostState+0xa8>
			}

			break;
		case HOST_STATE_Powered:
			WaitMSRemaining = HOST_DEVICE_SETTLE_DELAY_MS;
    4f82:	88 ee       	ldi	r24, 0xE8	; 232
    4f84:	93 e0       	ldi	r25, 0x03	; 3
    4f86:	90 93 ce 03 	sts	0x03CE, r25
    4f8a:	80 93 cd 03 	sts	0x03CD, r24

			USB_HostState = HOST_STATE_Powered_WaitForDeviceSettle;
    4f8e:	83 e0       	ldi	r24, 0x03	; 3
    4f90:	80 93 ac 0d 	sts	0x0DAC, r24
    4f94:	cd c0       	rjmp	.+410    	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
			break;
		case HOST_STATE_Powered_WaitForDeviceSettle:
			if (WaitMSRemaining--)
    4f96:	80 91 cd 03 	lds	r24, 0x03CD
    4f9a:	90 91 ce 03 	lds	r25, 0x03CE
    4f9e:	01 97       	sbiw	r24, 0x01	; 1
    4fa0:	90 93 ce 03 	sts	0x03CE, r25
    4fa4:	80 93 cd 03 	sts	0x03CD, r24
    4fa8:	01 96       	adiw	r24, 0x01	; 1
    4faa:	29 f0       	breq	.+10     	; 0x4fb6 <USB_Host_ProcessNextHostState+0xce>
    4fac:	80 ed       	ldi	r24, 0xD0	; 208
    4fae:	97 e0       	ldi	r25, 0x07	; 7
    4fb0:	01 97       	sbiw	r24, 0x01	; 1
    4fb2:	f1 f7       	brne	.-4      	; 0x4fb0 <USB_Host_ProcessNextHostState+0xc8>
    4fb4:	bd c0       	rjmp	.+378    	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
			}

			static inline void USB_Host_VBUS_Manual_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				PORTE  &= ~(1 << 7);
    4fb6:	77 98       	cbi	0x0e, 7	; 14

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    4fb8:	80 91 d8 00 	lds	r24, 0x00D8
    4fbc:	80 61       	ori	r24, 0x10	; 16
    4fbe:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_Host_VBUS_Auto_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Enable(void)
			{
				OTGCON &= ~(1 << VBUSHWC);
    4fc2:	80 91 dd 00 	lds	r24, 0x00DD
    4fc6:	8b 7f       	andi	r24, 0xFB	; 251
    4fc8:	80 93 dd 00 	sts	0x00DD, r24
				UHWCON |=  (1 << UVCONE);
    4fcc:	80 91 d7 00 	lds	r24, 0x00D7
    4fd0:	80 61       	ori	r24, 0x10	; 16
    4fd2:	80 93 d7 00 	sts	0x00D7, r24
			}

			static inline void USB_Host_VBUS_Auto_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_On(void)
			{
				OTGCON |=  (1 << VBUSREQ);
    4fd6:	80 91 dd 00 	lds	r24, 0x00DD
    4fda:	82 60       	ori	r24, 0x02	; 2
    4fdc:	80 93 dd 00 	sts	0x00DD, r24

				USB_OTGPAD_On();
				USB_Host_VBUS_Auto_Enable();
				USB_Host_VBUS_Auto_On();

				USB_HostState = HOST_STATE_Powered_WaitForConnect;
    4fe0:	84 e0       	ldi	r24, 0x04	; 4
    4fe2:	d6 cf       	rjmp	.-84     	; 0x4f90 <USB_Host_ProcessNextHostState+0xa8>
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
    4fe4:	80 91 9f 00 	lds	r24, 0x009F
			}

			break;
		case HOST_STATE_Powered_WaitForConnect:
			if (USB_INT_HasOccurred(USB_INT_DCONNI))
    4fe8:	80 ff       	sbrs	r24, 0
    4fea:	a2 c0       	rjmp	.+324    	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    4fec:	80 91 9f 00 	lds	r24, 0x009F
    4ff0:	8e 7f       	andi	r24, 0xFE	; 254
    4ff2:	80 93 9f 00 	sts	0x009F, r24
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    4ff6:	80 91 9f 00 	lds	r24, 0x009F
    4ffa:	8d 7f       	andi	r24, 0xFD	; 253
    4ffc:	80 93 9f 00 	sts	0x009F, r24
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    5000:	80 91 df 00 	lds	r24, 0x00DF
    5004:	8d 7f       	andi	r24, 0xFD	; 253
    5006:	80 93 df 00 	sts	0x00DF, r24
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
    500a:	80 91 de 00 	lds	r24, 0x00DE
    500e:	82 60       	ori	r24, 0x02	; 2
    5010:	80 93 de 00 	sts	0x00DE, r24
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    5014:	80 91 9e 00 	lds	r24, 0x009E
    5018:	81 60       	ori	r24, 0x01	; 1
    501a:	80 93 9e 00 	sts	0x009E, r24

				USB_INT_Clear(USB_INT_VBERRI);
				USB_INT_Enable(USB_INT_VBERRI);

				USB_Host_ResumeBus();
				Pipe_ClearPipes();
    501e:	f2 d0       	rcall	.+484    	; 0x5204 <Pipe_ClearPipes>

				HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Powered_DoReset);
    5020:	10 92 ac 0d 	sts	0x0DAC, r1
    5024:	84 e6       	ldi	r24, 0x64	; 100
    5026:	90 e0       	ldi	r25, 0x00	; 0
    5028:	90 93 ce 03 	sts	0x03CE, r25
    502c:	80 93 cd 03 	sts	0x03CD, r24
    5030:	85 e0       	ldi	r24, 0x05	; 5
    5032:	5e c0       	rjmp	.+188    	; 0x50f0 <USB_Host_ProcessNextHostState+0x208>
			}

			break;
		case HOST_STATE_Powered_DoReset:
			USB_Host_ResetDevice();
    5034:	0b df       	rcall	.-490    	; 0x4e4c <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Powered_ConfigPipe);
    5036:	10 92 ac 0d 	sts	0x0DAC, r1
    503a:	88 ec       	ldi	r24, 0xC8	; 200
    503c:	90 e0       	ldi	r25, 0x00	; 0
    503e:	90 93 ce 03 	sts	0x03CE, r25
    5042:	80 93 cd 03 	sts	0x03CD, r24
    5046:	86 e0       	ldi	r24, 0x06	; 6
    5048:	53 c0       	rjmp	.+166    	; 0x50f0 <USB_Host_ProcessNextHostState+0x208>
			break;
		case HOST_STATE_Powered_ConfigPipe:
			Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL,
    504a:	80 e0       	ldi	r24, 0x00	; 0
    504c:	60 e0       	ldi	r22, 0x00	; 0
    504e:	40 e0       	ldi	r20, 0x00	; 0
    5050:	20 e0       	ldi	r18, 0x00	; 0
    5052:	00 e4       	ldi	r16, 0x40	; 64
    5054:	10 e0       	ldi	r17, 0x00	; 0
    5056:	ee 24       	eor	r14, r14
    5058:	77 d0       	rcall	.+238    	; 0x5148 <Pipe_ConfigurePipe>
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    505a:	80 91 ac 00 	lds	r24, 0x00AC
							   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
							   PIPE_CONTROLPIPE_DEFAULT_SIZE, PIPE_BANK_SINGLE);

			if (!(Pipe_IsConfigured()))
    505e:	87 ff       	sbrs	r24, 7
    5060:	61 c0       	rjmp	.+194    	; 0x5124 <USB_Host_ProcessNextHostState+0x23c>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_HostState = HOST_STATE_Default;
    5062:	87 e0       	ldi	r24, 0x07	; 7
    5064:	95 cf       	rjmp	.-214    	; 0x4f90 <USB_Host_ProcessNextHostState+0xa8>
			break;
		case HOST_STATE_Default:
			USB_ControlRequest = (USB_Request_Header_t)
    5066:	a4 ea       	ldi	r26, 0xA4	; 164
    5068:	bd e0       	ldi	r27, 0x0D	; 13
    506a:	ea e3       	ldi	r30, 0x3A	; 58
    506c:	f3 e0       	ldi	r31, 0x03	; 3
    506e:	88 e0       	ldi	r24, 0x08	; 8
    5070:	01 90       	ld	r0, Z+
    5072:	0d 92       	st	X+, r0
    5074:	81 50       	subi	r24, 0x01	; 1
    5076:	e1 f7       	brne	.-8      	; 0x5070 <USB_Host_ProcessNextHostState+0x188>
					.wLength       = 8,
				};

			uint8_t DataBuffer[8];

			if ((SubErrorCode = USB_Host_SendControlRequest(DataBuffer)) != HOST_SENDCONTROL_Successful)
    5078:	ce 01       	movw	r24, r28
    507a:	01 96       	adiw	r24, 0x01	; 1
    507c:	0e 94 50 31 	call	0x62a0	; 0x62a0 <USB_Host_SendControlRequest>
    5080:	68 2f       	mov	r22, r24
    5082:	88 23       	and	r24, r24
    5084:	09 f0       	breq	.+2      	; 0x5088 <USB_Host_ProcessNextHostState+0x1a0>
    5086:	4c c0       	rjmp	.+152    	; 0x5120 <USB_Host_ProcessNextHostState+0x238>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			USB_Host_ControlPipeSize = DataBuffer[offsetof(USB_Descriptor_Device_t, Endpoint0Size)];
    5088:	88 85       	ldd	r24, Y+8	; 0x08
    508a:	80 93 42 03 	sts	0x0342, r24

			USB_Host_ResetDevice();
    508e:	de de       	rcall	.-580    	; 0x4e4c <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
    5090:	10 92 ac 0d 	sts	0x0DAC, r1
    5094:	88 ec       	ldi	r24, 0xC8	; 200
    5096:	90 e0       	ldi	r25, 0x00	; 0
    5098:	90 93 ce 03 	sts	0x03CE, r25
    509c:	80 93 cd 03 	sts	0x03CD, r24
    50a0:	88 e0       	ldi	r24, 0x08	; 8
    50a2:	26 c0       	rjmp	.+76     	; 0x50f0 <USB_Host_ProcessNextHostState+0x208>
			break;
		case HOST_STATE_Default_PostReset:
			Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL,
    50a4:	00 91 42 03 	lds	r16, 0x0342
    50a8:	10 e0       	ldi	r17, 0x00	; 0
    50aa:	80 e0       	ldi	r24, 0x00	; 0
    50ac:	60 e0       	ldi	r22, 0x00	; 0
    50ae:	40 e0       	ldi	r20, 0x00	; 0
    50b0:	20 e0       	ldi	r18, 0x00	; 0
    50b2:	ee 24       	eor	r14, r14
    50b4:	49 d0       	rcall	.+146    	; 0x5148 <Pipe_ConfigurePipe>
    50b6:	80 91 ac 00 	lds	r24, 0x00AC
			                   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
			                   USB_Host_ControlPipeSize, PIPE_BANK_SINGLE);

			if (!(Pipe_IsConfigured()))
    50ba:	87 ff       	sbrs	r24, 7
    50bc:	33 c0       	rjmp	.+102    	; 0x5124 <USB_Host_ProcessNextHostState+0x23c>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_ControlRequest = (USB_Request_Header_t)
    50be:	a4 ea       	ldi	r26, 0xA4	; 164
    50c0:	bd e0       	ldi	r27, 0x0D	; 13
    50c2:	e2 e3       	ldi	r30, 0x32	; 50
    50c4:	f3 e0       	ldi	r31, 0x03	; 3
    50c6:	88 e0       	ldi	r24, 0x08	; 8
    50c8:	01 90       	ld	r0, Z+
    50ca:	0d 92       	st	X+, r0
    50cc:	81 50       	subi	r24, 0x01	; 1
    50ce:	e1 f7       	brne	.-8      	; 0x50c8 <USB_Host_ProcessNextHostState+0x1e0>
					.wValue        = USB_HOST_DEVICEADDRESS,
					.wIndex        = 0,
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
    50d0:	80 e0       	ldi	r24, 0x00	; 0
    50d2:	90 e0       	ldi	r25, 0x00	; 0
    50d4:	0e 94 50 31 	call	0x62a0	; 0x62a0 <USB_Host_SendControlRequest>
    50d8:	68 2f       	mov	r22, r24
    50da:	88 23       	and	r24, r24
    50dc:	09 f5       	brne	.+66     	; 0x5120 <USB_Host_ProcessNextHostState+0x238>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Default_PostAddressSet);
    50de:	10 92 ac 0d 	sts	0x0DAC, r1
    50e2:	84 e6       	ldi	r24, 0x64	; 100
    50e4:	90 e0       	ldi	r25, 0x00	; 0
    50e6:	90 93 ce 03 	sts	0x03CE, r25
    50ea:	80 93 cd 03 	sts	0x03CD, r24
    50ee:	89 e0       	ldi	r24, 0x09	; 9
    50f0:	80 93 cc 03 	sts	0x03CC, r24
    50f4:	1d c0       	rjmp	.+58     	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
			}

			static inline void USB_Host_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SetDeviceAddress(const uint8_t Address)
			{
				UHADDR  =  (Address & 0x7F);
    50f6:	81 e0       	ldi	r24, 0x01	; 1
    50f8:	80 93 a1 00 	sts	0x00A1, r24
			break;
		case HOST_STATE_Default_PostAddressSet:
			USB_Host_SetDeviceAddress(USB_HOST_DEVICEADDRESS);

			USB_HostState = HOST_STATE_Addressed;
    50fc:	8a e0       	ldi	r24, 0x0A	; 10
    50fe:	80 93 ac 0d 	sts	0x0DAC, r24

			EVENT_USB_Host_DeviceEnumerationComplete();
    5102:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <EVENT_USB_Host_DeviceEnumerationComplete>
    5106:	14 c0       	rjmp	.+40     	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
	{
		EVENT_USB_Host_DeviceEnumerationFailed(ErrorCode, SubErrorCode);
    5108:	89 2f       	mov	r24, r25
    510a:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <EVENT_USB_Host_DeviceEnumerationFailed>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    510e:	80 91 dd 00 	lds	r24, 0x00DD
    5112:	81 60       	ori	r24, 0x01	; 1
    5114:	80 93 dd 00 	sts	0x00DD, r24

		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_DeviceUnattached();
    5118:	0e 94 df 02 	call	0x5be	; 0x5be <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    511c:	f2 d0       	rcall	.+484    	; 0x5302 <USB_ResetInterface>
    511e:	08 c0       	rjmp	.+16     	; 0x5130 <USB_Host_ProcessNextHostState+0x248>
	}
}
    5120:	93 e0       	ldi	r25, 0x03	; 3
    5122:	02 c0       	rjmp	.+4      	; 0x5128 <USB_Host_ProcessNextHostState+0x240>
    5124:	94 e0       	ldi	r25, 0x04	; 4
    5126:	60 e0       	ldi	r22, 0x00	; 0

			EVENT_USB_Host_DeviceEnumerationComplete();
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
    5128:	80 91 ac 0d 	lds	r24, 0x0DAC
    512c:	81 30       	cpi	r24, 0x01	; 1
    512e:	61 f7       	brne	.-40     	; 0x5108 <USB_Host_ProcessNextHostState+0x220>

		EVENT_USB_Host_DeviceUnattached();

		USB_ResetInterface();
	}
}
    5130:	28 96       	adiw	r28, 0x08	; 8
    5132:	0f b6       	in	r0, 0x3f	; 63
    5134:	f8 94       	cli
    5136:	de bf       	out	0x3e, r29	; 62
    5138:	0f be       	out	0x3f, r0	; 63
    513a:	cd bf       	out	0x3d, r28	; 61
    513c:	cf 91       	pop	r28
    513e:	df 91       	pop	r29
    5140:	1f 91       	pop	r17
    5142:	0f 91       	pop	r16
    5144:	ef 90       	pop	r14
    5146:	08 95       	ret

00005148 <Pipe_ConfigurePipe>:
                        const uint8_t Type,
                        const uint8_t Token,
                        const uint8_t EndpointNumber,
                        const uint16_t Size,
                        const uint8_t Banks)
{
    5148:	ef 92       	push	r14
    514a:	0f 93       	push	r16
    514c:	1f 93       	push	r17
    514e:	e8 2f       	mov	r30, r24
    5150:	7e 2d       	mov	r23, r14

		Pipe_SelectPipe(PNum);
		
		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
    5152:	62 95       	swap	r22
    5154:	66 0f       	add	r22, r22
    5156:	66 0f       	add	r22, r22
    5158:	60 7c       	andi	r22, 0xC0	; 192
    515a:	64 2b       	or	r22, r20
    515c:	2f 70       	andi	r18, 0x0F	; 15
    515e:	62 2b       	or	r22, r18
    5160:	38 2f       	mov	r19, r24
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    5162:	72 60       	ori	r23, 0x02	; 2
    5164:	45 c0       	rjmp	.+138    	; 0x51f0 <Pipe_ConfigurePipe+0xa8>
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    5166:	30 93 a7 00 	sts	0x00A7, r19
		uint8_t UPCFG2XTemp;
		uint8_t UPIENXTemp;

		Pipe_SelectPipe(PNum);
		
		if (PNum == Number)
    516a:	3e 17       	cp	r19, r30
    516c:	a1 f4       	brne	.+40     	; 0x5196 <Pipe_ConfigurePipe+0x4e>
    516e:	88 e0       	ldi	r24, 0x08	; 8
    5170:	90 e0       	ldi	r25, 0x00	; 0
    5172:	20 e0       	ldi	r18, 0x00	; 0
    5174:	03 c0       	rjmp	.+6      	; 0x517c <Pipe_ConfigurePipe+0x34>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
				{
					MaskVal++;
    5176:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    5178:	88 0f       	add	r24, r24
    517a:	99 1f       	adc	r25, r25
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
    517c:	80 17       	cp	r24, r16
    517e:	91 07       	cpc	r25, r17
    5180:	10 f4       	brcc	.+4      	; 0x5186 <Pipe_ConfigurePipe+0x3e>
    5182:	25 30       	cpi	r18, 0x05	; 5
    5184:	c1 f7       	brne	.-16     	; 0x5176 <Pipe_ConfigurePipe+0x2e>
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    5186:	92 2f       	mov	r25, r18
    5188:	92 95       	swap	r25
    518a:	90 7f       	andi	r25, 0xF0	; 240
    518c:	97 2b       	or	r25, r23
    518e:	56 2f       	mov	r21, r22
    5190:	40 e0       	ldi	r20, 0x00	; 0
    5192:	20 e0       	ldi	r18, 0x00	; 0
    5194:	08 c0       	rjmp	.+16     	; 0x51a6 <Pipe_ConfigurePipe+0x5e>
			UPCFG2XTemp = 0;
			UPIENXTemp  = 0;
		}
		else
		{
			UPCFG0XTemp = UPCFG0X;
    5196:	50 91 aa 00 	lds	r21, 0x00AA
			UPCFG1XTemp = UPCFG1X;
    519a:	90 91 ab 00 	lds	r25, 0x00AB
			UPCFG2XTemp = UPCFG2X;
    519e:	40 91 ad 00 	lds	r20, 0x00AD
			UPIENXTemp  = UPIENX;
    51a2:	20 91 ae 00 	lds	r18, 0x00AE
		}

		if (!(UPCFG1XTemp & (1 << ALLOC)))
    51a6:	91 ff       	sbrs	r25, 1
    51a8:	22 c0       	rjmp	.+68     	; 0x51ee <Pipe_ConfigurePipe+0xa6>
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    51aa:	80 91 a9 00 	lds	r24, 0x00A9
    51ae:	8e 7f       	andi	r24, 0xFE	; 254
    51b0:	80 93 a9 00 	sts	0x00A9, r24
		  continue;
		  
		Pipe_DisablePipe();
		UPCFG1X &= ~(1 << ALLOC);
    51b4:	80 91 ab 00 	lds	r24, 0x00AB
    51b8:	8d 7f       	andi	r24, 0xFD	; 253
    51ba:	80 93 ab 00 	sts	0x00AB, r24
			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePipe().
			 */
			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_EnablePipe(void)
			{
				UPCONX |= (1 << PEN);
    51be:	80 91 a9 00 	lds	r24, 0x00A9
    51c2:	81 60       	ori	r24, 0x01	; 1
    51c4:	80 93 a9 00 	sts	0x00A9, r24

		Pipe_EnablePipe();
		UPCFG0X = UPCFG0XTemp;
    51c8:	50 93 aa 00 	sts	0x00AA, r21
		UPCFG1X = UPCFG1XTemp;
    51cc:	90 93 ab 00 	sts	0x00AB, r25
		UPCFG2X = UPCFG2XTemp;
    51d0:	40 93 ad 00 	sts	0x00AD, r20
		UPIENX  = UPIENXTemp;
    51d4:	20 93 ae 00 	sts	0x00AE, r18

			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetInfiniteINRequests(void)
			{
				UPCONX |= (1 << INMODE);
    51d8:	80 91 a9 00 	lds	r24, 0x00A9
    51dc:	80 62       	ori	r24, 0x20	; 32
    51de:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    51e2:	80 91 ac 00 	lds	r24, 0x00AC

		Pipe_SetInfiniteINRequests();
	
		if (!(Pipe_IsConfigured()))
    51e6:	87 fd       	sbrc	r24, 7
    51e8:	02 c0       	rjmp	.+4      	; 0x51ee <Pipe_ConfigurePipe+0xa6>
    51ea:	80 e0       	ldi	r24, 0x00	; 0
    51ec:	07 c0       	rjmp	.+14     	; 0x51fc <Pipe_ConfigurePipe+0xb4>

	Pipe_SetInfiniteINRequests();

	return Pipe_IsConfigured();
#else	
	for (uint8_t PNum = Number; PNum < PIPE_TOTAL_PIPES; PNum++)
    51ee:	3f 5f       	subi	r19, 0xFF	; 255
    51f0:	37 30       	cpi	r19, 0x07	; 7
    51f2:	08 f4       	brcc	.+2      	; 0x51f6 <Pipe_ConfigurePipe+0xae>
    51f4:	b8 cf       	rjmp	.-144    	; 0x5166 <Pipe_ConfigurePipe+0x1e>
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    51f6:	e0 93 a7 00 	sts	0x00A7, r30
    51fa:	81 e0       	ldi	r24, 0x01	; 1
	}
		
	Pipe_SelectPipe(Number);	
	return true;
#endif
}
    51fc:	1f 91       	pop	r17
    51fe:	0f 91       	pop	r16
    5200:	ef 90       	pop	r14
    5202:	08 95       	ret

00005204 <Pipe_ClearPipes>:

void Pipe_ClearPipes(void)
{
	UPINT = 0;
    5204:	10 92 f8 00 	sts	0x00F8, r1
    5208:	90 e0       	ldi	r25, 0x00	; 0
    520a:	90 93 a7 00 	sts	0x00A7, r25

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
	{
		Pipe_SelectPipe(PNum);
		UPIENX  = 0;
    520e:	10 92 ae 00 	sts	0x00AE, r1
		UPINTX  = 0;
    5212:	10 92 a6 00 	sts	0x00A6, r1
		UPCFG1X = 0;
    5216:	10 92 ab 00 	sts	0x00AB, r1
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    521a:	80 91 a9 00 	lds	r24, 0x00A9
    521e:	8e 7f       	andi	r24, 0xFE	; 254
    5220:	80 93 a9 00 	sts	0x00A9, r24

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    5224:	9f 5f       	subi	r25, 0xFF	; 255
    5226:	97 30       	cpi	r25, 0x07	; 7
    5228:	81 f7       	brne	.-32     	; 0x520a <Pipe_ClearPipes+0x6>
		UPIENX  = 0;
		UPINTX  = 0;
		UPCFG1X = 0;
		Pipe_DisablePipe();
	}
}
    522a:	08 95       	ret

0000522c <Pipe_IsEndpointBound>:

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
    522c:	48 2f       	mov	r20, r24
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return (UPNUM & PIPE_PIPENUM_MASK);
    522e:	30 91 a7 00 	lds	r19, 0x00A7
    5232:	20 e0       	ldi	r18, 0x00	; 0
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    5234:	20 93 a7 00 	sts	0x00A7, r18
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    5238:	80 91 ac 00 	lds	r24, 0x00AC

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
	{
		Pipe_SelectPipe(PNum);

		if (!(Pipe_IsConfigured()))
    523c:	87 ff       	sbrs	r24, 7
    523e:	10 c0       	rjmp	.+32     	; 0x5260 <Pipe_IsEndpointBound+0x34>
			 *  \return Endpoint address the currently selected pipe is bound to.
			 */
			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
			{
				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
    5240:	90 91 aa 00 	lds	r25, 0x00AA
			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    5244:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \return Endpoint address the currently selected pipe is bound to.
			 */
			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
			{
				return (((UPCFG0X >> PEPNUM0) & PIPE_EPNUM_MASK) |
    5248:	80 73       	andi	r24, 0x30	; 48
    524a:	80 31       	cpi	r24, 0x10	; 16
    524c:	11 f0       	breq	.+4      	; 0x5252 <Pipe_IsEndpointBound+0x26>
    524e:	80 e0       	ldi	r24, 0x00	; 0
    5250:	01 c0       	rjmp	.+2      	; 0x5254 <Pipe_IsEndpointBound+0x28>
    5252:	80 e8       	ldi	r24, 0x80	; 128
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
    5254:	9f 70       	andi	r25, 0x0F	; 15
    5256:	89 2b       	or	r24, r25
    5258:	84 17       	cp	r24, r20
    525a:	11 f4       	brne	.+4      	; 0x5260 <Pipe_IsEndpointBound+0x34>
    525c:	81 e0       	ldi	r24, 0x01	; 1
    525e:	08 95       	ret

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    5260:	2f 5f       	subi	r18, 0xFF	; 255
    5262:	27 30       	cpi	r18, 0x07	; 7
    5264:	39 f7       	brne	.-50     	; 0x5234 <Pipe_IsEndpointBound+0x8>
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return (UPNUM & PIPE_PIPENUM_MASK);
    5266:	37 70       	andi	r19, 0x07	; 7
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    5268:	30 93 a7 00 	sts	0x00A7, r19
    526c:	80 e0       	ldi	r24, 0x00	; 0
		  return true;
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
}
    526e:	08 95       	ret

00005270 <Pipe_WaitUntilReady>:
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Host_GetFrameNumber(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t USB_Host_GetFrameNumber(void)
			{
				return UHFNUM;
    5270:	40 91 a2 00 	lds	r20, 0x00A2
    5274:	50 91 a3 00 	lds	r21, 0x00A3
    5278:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    527a:	80 91 aa 00 	lds	r24, 0x00AA

	uint16_t PreviousFrameNumber = USB_Host_GetFrameNumber();

	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    527e:	80 73       	andi	r24, 0x30	; 48
    5280:	80 31       	cpi	r24, 0x10	; 16
    5282:	29 f4       	brne	.+10     	; 0x528e <Pipe_WaitUntilReady+0x1e>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    5284:	80 91 a6 00 	lds	r24, 0x00A6
		{
			if (Pipe_IsINReceived())
    5288:	80 ff       	sbrs	r24, 0
    528a:	05 c0       	rjmp	.+10     	; 0x5296 <Pipe_WaitUntilReady+0x26>
    528c:	1e c0       	rjmp	.+60     	; 0x52ca <Pipe_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    528e:	80 91 a6 00 	lds	r24, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
    5292:	82 fd       	sbrc	r24, 2
    5294:	1a c0       	rjmp	.+52     	; 0x52ca <Pipe_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    5296:	80 91 a6 00 	lds	r24, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}

		if (Pipe_IsStalled())
    529a:	81 ff       	sbrs	r24, 1
    529c:	02 c0       	rjmp	.+4      	; 0x52a2 <Pipe_WaitUntilReady+0x32>
    529e:	81 e0       	ldi	r24, 0x01	; 1
    52a0:	08 95       	ret
		  return PIPE_READYWAIT_PipeStalled;
		else if (USB_HostState == HOST_STATE_Unattached)
    52a2:	80 91 ac 0d 	lds	r24, 0x0DAC
    52a6:	81 30       	cpi	r24, 0x01	; 1
    52a8:	11 f4       	brne	.+4      	; 0x52ae <Pipe_WaitUntilReady+0x3e>
    52aa:	82 e0       	ldi	r24, 0x02	; 2
    52ac:	08 95       	ret
    52ae:	80 91 a2 00 	lds	r24, 0x00A2
    52b2:	90 91 a3 00 	lds	r25, 0x00A3
		  return PIPE_READYWAIT_DeviceDisconnected;

		uint16_t CurrentFrameNumber = USB_Host_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    52b6:	84 17       	cp	r24, r20
    52b8:	95 07       	cpc	r25, r21
    52ba:	f9 f2       	breq	.-66     	; 0x527a <Pipe_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    52bc:	22 23       	and	r18, r18
    52be:	11 f4       	brne	.+4      	; 0x52c4 <Pipe_WaitUntilReady+0x54>
    52c0:	83 e0       	ldi	r24, 0x03	; 3
    52c2:	08 95       	ret
    52c4:	21 50       	subi	r18, 0x01	; 1
    52c6:	ac 01       	movw	r20, r24
    52c8:	d8 cf       	rjmp	.-80     	; 0x527a <Pipe_WaitUntilReady+0xa>
    52ca:	80 e0       	ldi	r24, 0x00	; 0
			  return PIPE_READYWAIT_Timeout;
		}
	}
}
    52cc:	08 95       	ret

000052ce <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    52ce:	ce d0       	rcall	.+412    	; 0x546c <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    52d0:	d9 d0       	rcall	.+434    	; 0x5484 <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    52d2:	e0 ee       	ldi	r30, 0xE0	; 224
    52d4:	f0 e0       	ldi	r31, 0x00	; 0
    52d6:	80 81       	ld	r24, Z
    52d8:	81 60       	ori	r24, 0x01	; 1
    52da:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON  &= ~(1 << USBE);
    52dc:	a8 ed       	ldi	r26, 0xD8	; 216
    52de:	b0 e0       	ldi	r27, 0x00	; 0
    52e0:	8c 91       	ld	r24, X
    52e2:	8f 77       	andi	r24, 0x7F	; 127
    52e4:	8c 93       	st	X, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    52e6:	19 bc       	out	0x29, r1	; 41

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  &= ~(1 << UVREGE);
    52e8:	e7 ed       	ldi	r30, 0xD7	; 215
    52ea:	f0 e0       	ldi	r31, 0x00	; 0
    52ec:	80 81       	ld	r24, Z
    52ee:	8e 7f       	andi	r24, 0xFE	; 254
    52f0:	80 83       	st	Z, r24
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON  &= ~(1 << OTGPADE);
    52f2:	8c 91       	ld	r24, X
    52f4:	8f 7e       	andi	r24, 0xEF	; 239
    52f6:	8c 93       	st	X, r24
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_Off();
	#endif

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
    52f8:	10 92 cf 03 	sts	0x03CF, r1
	#endif

	USB_IsInitialized = false;
    52fc:	10 92 a3 0d 	sts	0x0DA3, r1
}
    5300:	08 95       	ret

00005302 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    5302:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
    5304:	10 91 d7 00 	lds	r17, 0x00D7
	#endif

	USB_INT_DisableAllInterrupts();
    5308:	b1 d0       	rcall	.+354    	; 0x546c <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    530a:	bc d0       	rcall	.+376    	; 0x5484 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    530c:	80 91 d8 00 	lds	r24, 0x00D8
    5310:	8f 77       	andi	r24, 0x7F	; 127
    5312:	80 93 d8 00 	sts	0x00D8, r24
				USBCON |=  (1 << USBE);
    5316:	80 91 d8 00 	lds	r24, 0x00D8
    531a:	80 68       	ori	r24, 0x80	; 128
    531c:	80 93 d8 00 	sts	0x00D8, r24

	USB_Controller_Reset();

	#if defined(USB_CAN_BE_BOTH)
	if (UIDModeSelectEnabled)
    5320:	16 ff       	sbrs	r17, 6
    5322:	05 c0       	rjmp	.+10     	; 0x532e <USB_ResetInterface+0x2c>
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    5324:	80 91 d8 00 	lds	r24, 0x00D8
    5328:	82 60       	ori	r24, 0x02	; 2
    532a:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    532e:	80 91 d8 00 	lds	r24, 0x00D8
    5332:	8f 7d       	andi	r24, 0xDF	; 223
    5334:	80 93 d8 00 	sts	0x00D8, r24
	  USB_INT_Enable(USB_INT_IDTI);
	#endif

	USB_CLK_Unfreeze();

	if (USB_CurrentMode == USB_MODE_Device)
    5338:	80 91 cf 03 	lds	r24, 0x03CF
    533c:	81 30       	cpi	r24, 0x01	; 1
    533e:	59 f5       	brne	.+86     	; 0x5396 <USB_ResetInterface+0x94>
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    5340:	80 91 d7 00 	lds	r24, 0x00D7
    5344:	80 68       	ori	r24, 0x80	; 128
    5346:	80 93 d7 00 	sts	0x00D7, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    534a:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    534c:	1e ba       	out	0x1e, r1	; 30
	USB_Device_ConfigurationNumber  = 0;
    534e:	10 92 9f 0d 	sts	0x0D9F, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    5352:	10 92 a1 0d 	sts	0x0DA1, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    5356:	10 92 a0 0d 	sts	0x0DA0, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    535a:	80 91 e0 00 	lds	r24, 0x00E0
    535e:	8b 7f       	andi	r24, 0xFB	; 251
    5360:	80 93 e0 00 	sts	0x00E0, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    5364:	80 91 d8 00 	lds	r24, 0x00D8
    5368:	81 60       	ori	r24, 0x01	; 1
    536a:	80 93 d8 00 	sts	0x00D8, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    536e:	80 e0       	ldi	r24, 0x00	; 0
    5370:	60 e0       	ldi	r22, 0x00	; 0
    5372:	42 e0       	ldi	r20, 0x02	; 2
    5374:	92 dc       	rcall	.-1756   	; 0x4c9a <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    5376:	80 91 e1 00 	lds	r24, 0x00E1
    537a:	8e 7f       	andi	r24, 0xFE	; 254
    537c:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    5380:	80 91 e2 00 	lds	r24, 0x00E2
    5384:	81 60       	ori	r24, 0x01	; 1
    5386:	80 93 e2 00 	sts	0x00E2, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    538a:	80 91 e2 00 	lds	r24, 0x00E2
    538e:	88 60       	ori	r24, 0x08	; 8
    5390:	80 93 e2 00 	sts	0x00E2, r24
    5394:	38 c0       	rjmp	.+112    	; 0x5406 <USB_ResetInterface+0x104>
		}

		USB_Init_Device();
		#endif
	}
	else if (USB_CurrentMode == USB_MODE_Host)
    5396:	80 91 cf 03 	lds	r24, 0x03CF
    539a:	82 30       	cpi	r24, 0x02	; 2
    539c:	c9 f5       	brne	.+114    	; 0x5410 <USB_ResetInterface+0x10e>
	{
		#if defined(USB_CAN_BE_HOST)
		UHWCON &= ~(1 << UIMOD);
    539e:	80 91 d7 00 	lds	r24, 0x00D7
    53a2:	8f 77       	andi	r24, 0x7F	; 127
    53a4:	80 93 d7 00 	sts	0x00D7, r24

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    53a8:	8c e0       	ldi	r24, 0x0C	; 12
    53aa:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    53ac:	8e e0       	ldi	r24, 0x0E	; 14
    53ae:	89 bd       	out	0x29, r24	; 41

		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			#if defined(USB_CAN_BE_HOST)
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));		
    53b0:	09 b4       	in	r0, 0x29	; 41
    53b2:	00 fe       	sbrs	r0, 0
    53b4:	fd cf       	rjmp	.-6      	; 0x53b0 <USB_ResetInterface+0xae>
#endif

#if defined(USB_CAN_BE_HOST)
static void USB_Init_Host(void)
{
	USB_HostState                = HOST_STATE_Unattached;
    53b6:	81 e0       	ldi	r24, 0x01	; 1
    53b8:	80 93 ac 0d 	sts	0x0DAC, r24
	USB_Host_ConfigurationNumber = 0;
    53bc:	10 92 a2 0d 	sts	0x0DA2, r1
	USB_Host_ControlPipeSize     = PIPE_CONTROLPIPE_DEFAULT_SIZE;
    53c0:	80 e4       	ldi	r24, 0x40	; 64
    53c2:	80 93 42 03 	sts	0x0342, r24
	#if !defined(__DOXYGEN__)
		/* Macros: */
			static inline void USB_Host_HostMode_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_HostMode_On(void)
			{
				USBCON |=  (1 << HOST);
    53c6:	80 91 d8 00 	lds	r24, 0x00D8
    53ca:	80 64       	ori	r24, 0x40	; 64
    53cc:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    53d0:	80 91 dd 00 	lds	r24, 0x00DD
    53d4:	81 60       	ori	r24, 0x01	; 1
    53d6:	80 93 dd 00 	sts	0x00DD, r24
			}

			static inline void USB_Host_VBUS_Manual_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Enable(void)
			{
				OTGCON |=  (1 << VBUSHWC);
    53da:	80 91 dd 00 	lds	r24, 0x00DD
    53de:	84 60       	ori	r24, 0x04	; 4
    53e0:	80 93 dd 00 	sts	0x00DD, r24
				UHWCON &= ~(1 << UVCONE);
    53e4:	80 91 d7 00 	lds	r24, 0x00D7
    53e8:	8f 7e       	andi	r24, 0xEF	; 239
    53ea:	80 93 d7 00 	sts	0x00D7, r24

				DDRE   |=  (1 << 7);
    53ee:	6f 9a       	sbi	0x0d, 7	; 13
			}

			static inline void USB_Host_VBUS_Manual_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_On(void)
			{
				PORTE  |=  (1 << 7);
    53f0:	77 9a       	sbi	0x0e, 7	; 14
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN |= (1 << SRPE);						
    53f2:	80 91 de 00 	lds	r24, 0x00DE
    53f6:	81 60       	ori	r24, 0x01	; 1
    53f8:	80 93 de 00 	sts	0x00DE, r24
						break;
					case USB_INT_RSTI:
						UHIEN  |= (1 << RSTE);
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
    53fc:	80 91 de 00 	lds	r24, 0x00DE
    5400:	84 60       	ori	r24, 0x04	; 4
    5402:	80 93 de 00 	sts	0x00DE, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    5406:	80 91 e0 00 	lds	r24, 0x00E0
    540a:	8e 7f       	andi	r24, 0xFE	; 254
    540c:	80 93 e0 00 	sts	0x00E0, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    5410:	80 91 d8 00 	lds	r24, 0x00D8
    5414:	80 61       	ori	r24, 0x10	; 16
    5416:	80 93 d8 00 	sts	0x00D8, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    541a:	1f 91       	pop	r17
    541c:	08 95       	ret

0000541e <USB_Init>:

               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
    541e:	98 2f       	mov	r25, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    5420:	80 91 d7 00 	lds	r24, 0x00D7
    5424:	81 60       	ori	r24, 0x01	; 1
    5426:	80 93 d7 00 	sts	0x00D7, r24
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif
	}

	#if defined(USB_CAN_BE_BOTH)
	if (Mode == USB_MODE_UID)
    542a:	93 30       	cpi	r25, 0x03	; 3
    542c:	a1 f4       	brne	.+40     	; 0x5456 <USB_Init+0x38>
	{
		UHWCON |=  (1 << UIDE);
    542e:	80 91 d7 00 	lds	r24, 0x00D7
    5432:	80 64       	ori	r24, 0x40	; 64
    5434:	80 93 d7 00 	sts	0x00D7, r24
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    5438:	80 91 d8 00 	lds	r24, 0x00D8
    543c:	82 60       	ori	r24, 0x02	; 2
    543e:	80 93 d8 00 	sts	0x00D8, r24

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5442:	80 91 d9 00 	lds	r24, 0x00D9
    5446:	81 fd       	sbrc	r24, 1
    5448:	02 c0       	rjmp	.+4      	; 0x544e <USB_Init+0x30>
    544a:	82 e0       	ldi	r24, 0x02	; 2
    544c:	01 c0       	rjmp	.+2      	; 0x5450 <USB_Init+0x32>
    544e:	81 e0       	ldi	r24, 0x01	; 1
		USB_INT_Enable(USB_INT_IDTI);
		USB_CurrentMode = USB_GetUSBModeFromUID();
    5450:	80 93 cf 03 	sts	0x03CF, r24
    5454:	07 c0       	rjmp	.+14     	; 0x5464 <USB_Init+0x46>
	}
	else
	{
		UHWCON &= ~(1 << UIDE);
    5456:	80 91 d7 00 	lds	r24, 0x00D7
    545a:	8f 7b       	andi	r24, 0xBF	; 191
    545c:	80 93 d7 00 	sts	0x00D7, r24
		USB_CurrentMode = Mode;
    5460:	90 93 cf 03 	sts	0x03CF, r25
	}
	#endif

	USB_IsInitialized = true;
    5464:	81 e0       	ldi	r24, 0x01	; 1
    5466:	80 93 a3 0d 	sts	0x0DA3, r24

	USB_ResetInterface();
}
    546a:	4b cf       	rjmp	.-362    	; 0x5302 <USB_ResetInterface>

0000546c <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    546c:	e8 ed       	ldi	r30, 0xD8	; 216
    546e:	f0 e0       	ldi	r31, 0x00	; 0
    5470:	80 81       	ld	r24, Z
    5472:	8c 7f       	andi	r24, 0xFC	; 252
    5474:	80 83       	st	Z, r24
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGIEN  = 0;
    5476:	10 92 de 00 	sts	0x00DE, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
    547a:	10 92 a0 00 	sts	0x00A0, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    547e:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    5482:	08 95       	ret

00005484 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    5484:	10 92 da 00 	sts	0x00DA, r1
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGINT = 0;
    5488:	10 92 df 00 	sts	0x00DF, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
    548c:	10 92 9f 00 	sts	0x009F, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    5490:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    5494:	08 95       	ret

00005496 <__vector_11>:
	#endif
}

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
    5496:	1f 92       	push	r1
    5498:	0f 92       	push	r0
    549a:	0f b6       	in	r0, 0x3f	; 63
    549c:	0f 92       	push	r0
    549e:	0b b6       	in	r0, 0x3b	; 59
    54a0:	0f 92       	push	r0
    54a2:	11 24       	eor	r1, r1
    54a4:	1f 93       	push	r17
    54a6:	2f 93       	push	r18
    54a8:	3f 93       	push	r19
    54aa:	4f 93       	push	r20
    54ac:	5f 93       	push	r21
    54ae:	6f 93       	push	r22
    54b0:	7f 93       	push	r23
    54b2:	8f 93       	push	r24
    54b4:	9f 93       	push	r25
    54b6:	af 93       	push	r26
    54b8:	bf 93       	push	r27
    54ba:	ef 93       	push	r30
    54bc:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    54be:	e9 ee       	ldi	r30, 0xE9	; 233
    54c0:	f0 e0       	ldi	r31, 0x00	; 0
    54c2:	10 81       	ld	r17, Z
    54c4:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    54c6:	10 82       	st	Z, r1
						break;
					case USB_INT_SOFI:
						UDIEN  &= ~(1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX &= ~(1 << RXSTPE);
    54c8:	e0 ef       	ldi	r30, 0xF0	; 240
    54ca:	f0 e0       	ldi	r31, 0x00	; 0
    54cc:	80 81       	ld	r24, Z
    54ce:	87 7f       	andi	r24, 0xF7	; 247
    54d0:	80 83       	st	Z, r24
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    54d2:	78 94       	sei
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);

	GlobalInterruptEnable();

	USB_Device_ProcessControlRequest();
    54d4:	2e d5       	rcall	.+2652   	; 0x5f32 <USB_Device_ProcessControlRequest>
    54d6:	a9 ee       	ldi	r26, 0xE9	; 233
    54d8:	b0 e0       	ldi	r27, 0x00	; 0
    54da:	1c 92       	st	X, r1
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    54dc:	e0 ef       	ldi	r30, 0xF0	; 240
    54de:	f0 e0       	ldi	r31, 0x00	; 0
    54e0:	80 81       	ld	r24, Z
    54e2:	88 60       	ori	r24, 0x08	; 8
    54e4:	80 83       	st	Z, r24
    54e6:	1c 93       	st	X, r17

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
    54e8:	ff 91       	pop	r31
    54ea:	ef 91       	pop	r30
    54ec:	bf 91       	pop	r27
    54ee:	af 91       	pop	r26
    54f0:	9f 91       	pop	r25
    54f2:	8f 91       	pop	r24
    54f4:	7f 91       	pop	r23
    54f6:	6f 91       	pop	r22
    54f8:	5f 91       	pop	r21
    54fa:	4f 91       	pop	r20
    54fc:	3f 91       	pop	r19
    54fe:	2f 91       	pop	r18
    5500:	1f 91       	pop	r17
    5502:	0f 90       	pop	r0
    5504:	0b be       	out	0x3b, r0	; 59
    5506:	0f 90       	pop	r0
    5508:	0f be       	out	0x3f, r0	; 63
    550a:	0f 90       	pop	r0
    550c:	1f 90       	pop	r1
    550e:	18 95       	reti

00005510 <__vector_10>:
	UDINT  = 0;
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    5510:	1f 92       	push	r1
    5512:	0f 92       	push	r0
    5514:	0f b6       	in	r0, 0x3f	; 63
    5516:	0f 92       	push	r0
    5518:	0b b6       	in	r0, 0x3b	; 59
    551a:	0f 92       	push	r0
    551c:	11 24       	eor	r1, r1
    551e:	2f 93       	push	r18
    5520:	3f 93       	push	r19
    5522:	4f 93       	push	r20
    5524:	5f 93       	push	r21
    5526:	6f 93       	push	r22
    5528:	7f 93       	push	r23
    552a:	8f 93       	push	r24
    552c:	9f 93       	push	r25
    552e:	af 93       	push	r26
    5530:	bf 93       	push	r27
    5532:	ef 93       	push	r30
    5534:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    5536:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    553a:	82 ff       	sbrs	r24, 2
    553c:	0a c0       	rjmp	.+20     	; 0x5552 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    553e:	80 91 e2 00 	lds	r24, 0x00E2
    5542:	82 ff       	sbrs	r24, 2
    5544:	06 c0       	rjmp	.+12     	; 0x5552 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    5546:	80 91 e1 00 	lds	r24, 0x00E1
    554a:	8b 7f       	andi	r24, 0xFB	; 251
    554c:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    5550:	7c d6       	rcall	.+3320   	; 0x624a <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    5552:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    5556:	80 ff       	sbrs	r24, 0
    5558:	1d c0       	rjmp	.+58     	; 0x5594 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    555a:	80 91 d8 00 	lds	r24, 0x00D8
    555e:	80 ff       	sbrs	r24, 0
    5560:	19 c0       	rjmp	.+50     	; 0x5594 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    5562:	80 91 da 00 	lds	r24, 0x00DA
    5566:	8e 7f       	andi	r24, 0xFE	; 254
    5568:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    556c:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    5570:	80 ff       	sbrs	r24, 0
    5572:	0c c0       	rjmp	.+24     	; 0x558c <__vector_10+0x7c>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5574:	8c e0       	ldi	r24, 0x0C	; 12
    5576:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5578:	8e e0       	ldi	r24, 0x0E	; 14
    557a:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    557c:	09 b4       	in	r0, 0x29	; 41
    557e:	00 fe       	sbrs	r0, 0
    5580:	fd cf       	rjmp	.-6      	; 0x557c <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    5582:	81 e0       	ldi	r24, 0x01	; 1
    5584:	8e bb       	out	0x1e, r24	; 30
			EVENT_USB_Device_Connect();
    5586:	0e 94 c7 02 	call	0x58e	; 0x58e <EVENT_USB_Device_Connect>
    558a:	04 c0       	rjmp	.+8      	; 0x5594 <__vector_10+0x84>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    558c:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    558e:	1e ba       	out	0x1e, r1	; 30
			EVENT_USB_Device_Disconnect();
    5590:	0e 94 95 02 	call	0x52a	; 0x52a <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    5594:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    5598:	80 ff       	sbrs	r24, 0
    559a:	17 c0       	rjmp	.+46     	; 0x55ca <__vector_10+0xba>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    559c:	80 91 e2 00 	lds	r24, 0x00E2
    55a0:	80 ff       	sbrs	r24, 0
    55a2:	13 c0       	rjmp	.+38     	; 0x55ca <__vector_10+0xba>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    55a4:	80 91 e2 00 	lds	r24, 0x00E2
    55a8:	8e 7f       	andi	r24, 0xFE	; 254
    55aa:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    55ae:	80 91 e2 00 	lds	r24, 0x00E2
    55b2:	80 61       	ori	r24, 0x10	; 16
    55b4:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    55b8:	80 91 d8 00 	lds	r24, 0x00D8
    55bc:	80 62       	ori	r24, 0x20	; 32
    55be:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    55c2:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    55c4:	85 e0       	ldi	r24, 0x05	; 5
    55c6:	8e bb       	out	0x1e, r24	; 30
		EVENT_USB_Device_Suspend();
    55c8:	40 d6       	rcall	.+3200   	; 0x624a <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    55ca:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    55ce:	84 ff       	sbrs	r24, 4
    55d0:	2c c0       	rjmp	.+88     	; 0x562a <__vector_10+0x11a>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    55d2:	80 91 e2 00 	lds	r24, 0x00E2
    55d6:	84 ff       	sbrs	r24, 4
    55d8:	28 c0       	rjmp	.+80     	; 0x562a <__vector_10+0x11a>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    55da:	8c e0       	ldi	r24, 0x0C	; 12
    55dc:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    55de:	8e e0       	ldi	r24, 0x0E	; 14
    55e0:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    55e2:	09 b4       	in	r0, 0x29	; 41
    55e4:	00 fe       	sbrs	r0, 0
    55e6:	fd cf       	rjmp	.-6      	; 0x55e2 <__vector_10+0xd2>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    55e8:	80 91 d8 00 	lds	r24, 0x00D8
    55ec:	8f 7d       	andi	r24, 0xDF	; 223
    55ee:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    55f2:	80 91 e1 00 	lds	r24, 0x00E1
    55f6:	8f 7e       	andi	r24, 0xEF	; 239
    55f8:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    55fc:	80 91 e2 00 	lds	r24, 0x00E2
    5600:	8f 7e       	andi	r24, 0xEF	; 239
    5602:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    5606:	80 91 e2 00 	lds	r24, 0x00E2
    560a:	81 60       	ori	r24, 0x01	; 1
    560c:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    5610:	80 91 9f 0d 	lds	r24, 0x0D9F
    5614:	88 23       	and	r24, r24
    5616:	31 f4       	brne	.+12     	; 0x5624 <__vector_10+0x114>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    5618:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    561c:	87 fd       	sbrc	r24, 7
    561e:	02 c0       	rjmp	.+4      	; 0x5624 <__vector_10+0x114>
    5620:	81 e0       	ldi	r24, 0x01	; 1
    5622:	01 c0       	rjmp	.+2      	; 0x5626 <__vector_10+0x116>
    5624:	84 e0       	ldi	r24, 0x04	; 4
    5626:	8e bb       	out	0x1e, r24	; 30

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    5628:	10 d6       	rcall	.+3104   	; 0x624a <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    562a:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    562e:	83 ff       	sbrs	r24, 3
    5630:	26 c0       	rjmp	.+76     	; 0x567e <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    5632:	80 91 e2 00 	lds	r24, 0x00E2
    5636:	83 ff       	sbrs	r24, 3
    5638:	22 c0       	rjmp	.+68     	; 0x567e <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    563a:	80 91 e1 00 	lds	r24, 0x00E1
    563e:	87 7f       	andi	r24, 0xF7	; 247
    5640:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    5644:	82 e0       	ldi	r24, 0x02	; 2
    5646:	8e bb       	out	0x1e, r24	; 30
		USB_Device_ConfigurationNumber = 0;
    5648:	10 92 9f 0d 	sts	0x0D9F, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    564c:	80 91 e1 00 	lds	r24, 0x00E1
    5650:	8e 7f       	andi	r24, 0xFE	; 254
    5652:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    5656:	80 91 e2 00 	lds	r24, 0x00E2
    565a:	8e 7f       	andi	r24, 0xFE	; 254
    565c:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    5660:	80 91 e2 00 	lds	r24, 0x00E2
    5664:	80 61       	ori	r24, 0x10	; 16
    5666:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    566a:	80 e0       	ldi	r24, 0x00	; 0
    566c:	60 e0       	ldi	r22, 0x00	; 0
    566e:	42 e0       	ldi	r20, 0x02	; 2
    5670:	14 db       	rcall	.-2520   	; 0x4c9a <Endpoint_ConfigureEndpoint_Prv>
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    5672:	80 91 f0 00 	lds	r24, 0x00F0
    5676:	88 60       	ori	r24, 0x08	; 8
    5678:	80 93 f0 00 	sts	0x00F0, r24

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    567c:	e6 d5       	rcall	.+3020   	; 0x624a <USB_Event_Stub>
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    567e:	80 91 9f 00 	lds	r24, 0x009F
	}
	#endif

	#if defined(USB_CAN_BE_HOST)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_HSOFI) && USB_INT_IsEnabled(USB_INT_HSOFI))
    5682:	85 ff       	sbrs	r24, 5
    5684:	0a c0       	rjmp	.+20     	; 0x569a <__vector_10+0x18a>
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    5686:	80 91 a0 00 	lds	r24, 0x00A0
    568a:	85 ff       	sbrs	r24, 5
    568c:	06 c0       	rjmp	.+12     	; 0x569a <__vector_10+0x18a>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    568e:	80 91 9f 00 	lds	r24, 0x009F
    5692:	8f 7d       	andi	r24, 0xDF	; 223
    5694:	80 93 9f 00 	sts	0x009F, r24
	{
		USB_INT_Clear(USB_INT_HSOFI);

		EVENT_USB_Host_StartOfFrame();
    5698:	d8 d5       	rcall	.+2992   	; 0x624a <USB_Event_Stub>
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
    569a:	80 91 9f 00 	lds	r24, 0x009F
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_DDISCI) && USB_INT_IsEnabled(USB_INT_DDISCI))
    569e:	81 ff       	sbrs	r24, 1
    56a0:	16 c0       	rjmp	.+44     	; 0x56ce <__vector_10+0x1be>
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
					case USB_INT_DCONNI:
						return (UHIEN  & (1 << DCONNE));
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
    56a2:	80 91 a0 00 	lds	r24, 0x00A0
    56a6:	81 ff       	sbrs	r24, 1
    56a8:	12 c0       	rjmp	.+36     	; 0x56ce <__vector_10+0x1be>
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    56aa:	80 91 9f 00 	lds	r24, 0x009F
    56ae:	8d 7f       	andi	r24, 0xFD	; 253
    56b0:	80 93 9f 00 	sts	0x009F, r24
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    56b4:	80 91 9f 00 	lds	r24, 0x009F
    56b8:	8e 7f       	andi	r24, 0xFE	; 254
    56ba:	80 93 9f 00 	sts	0x009F, r24
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    56be:	80 91 a0 00 	lds	r24, 0x00A0
    56c2:	8d 7f       	andi	r24, 0xFD	; 253
    56c4:	80 93 a0 00 	sts	0x00A0, r24
	{
		USB_INT_Clear(USB_INT_DDISCI);
		USB_INT_Clear(USB_INT_DCONNI);
		USB_INT_Disable(USB_INT_DDISCI);

		EVENT_USB_Host_DeviceUnattached();
    56c8:	0e 94 df 02 	call	0x5be	; 0x5be <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    56cc:	1a de       	rcall	.-972    	; 0x5302 <USB_ResetInterface>
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
    56ce:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_VBERRI) && USB_INT_IsEnabled(USB_INT_VBERRI))
    56d2:	81 ff       	sbrs	r24, 1
    56d4:	17 c0       	rjmp	.+46     	; 0x5704 <__vector_10+0x1f4>
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
    56d6:	80 91 de 00 	lds	r24, 0x00DE
    56da:	81 ff       	sbrs	r24, 1
    56dc:	13 c0       	rjmp	.+38     	; 0x5704 <__vector_10+0x1f4>
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    56de:	80 91 df 00 	lds	r24, 0x00DF
    56e2:	8d 7f       	andi	r24, 0xFD	; 253
    56e4:	80 93 df 00 	sts	0x00DF, r24
			}

			static inline void USB_Host_VBUS_Manual_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				PORTE  &= ~(1 << 7);
    56e8:	77 98       	cbi	0x0e, 7	; 14
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    56ea:	80 91 dd 00 	lds	r24, 0x00DD
    56ee:	81 60       	ori	r24, 0x01	; 1
    56f0:	80 93 dd 00 	sts	0x00DD, r24
		USB_INT_Clear(USB_INT_VBERRI);

		USB_Host_VBUS_Manual_Off();
		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_HostError(HOST_ERROR_VBusVoltageDip);
    56f4:	80 e0       	ldi	r24, 0x00	; 0
    56f6:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <EVENT_USB_Host_HostError>
		EVENT_USB_Host_DeviceUnattached();
    56fa:	0e 94 df 02 	call	0x5be	; 0x5be <EVENT_USB_Host_DeviceUnattached>

		USB_HostState = HOST_STATE_Unattached;
    56fe:	81 e0       	ldi	r24, 0x01	; 1
    5700:	80 93 ac 0d 	sts	0x0DAC, r24
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
					case USB_INT_SRPI:
						return (OTGINT & (1 << SRPI));
    5704:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_SRPI) && USB_INT_IsEnabled(USB_INT_SRPI))
    5708:	80 ff       	sbrs	r24, 0
    570a:	18 c0       	rjmp	.+48     	; 0x573c <__vector_10+0x22c>
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
					case USB_INT_SRPI:
						return (OTGIEN & (1 << SRPE));
    570c:	80 91 de 00 	lds	r24, 0x00DE
    5710:	80 ff       	sbrs	r24, 0
    5712:	14 c0       	rjmp	.+40     	; 0x573c <__vector_10+0x22c>
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
						break;
					case USB_INT_SRPI:
						OTGINT &= ~(1 << SRPI);
    5714:	80 91 df 00 	lds	r24, 0x00DF
    5718:	8e 7f       	andi	r24, 0xFE	; 254
    571a:	80 93 df 00 	sts	0x00DF, r24
						break;
					case USB_INT_VBERRI:
						OTGIEN &= ~(1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN &= ~(1 << SRPE);						
    571e:	80 91 de 00 	lds	r24, 0x00DE
    5722:	8e 7f       	andi	r24, 0xFE	; 254
    5724:	80 93 de 00 	sts	0x00DE, r24
	{
		USB_INT_Clear(USB_INT_SRPI);
		USB_INT_Disable(USB_INT_SRPI);

		EVENT_USB_Host_DeviceAttached();
    5728:	0e 94 da 02 	call	0x5b4	; 0x5b4 <EVENT_USB_Host_DeviceAttached>
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    572c:	80 91 a0 00 	lds	r24, 0x00A0
    5730:	82 60       	ori	r24, 0x02	; 2
    5732:	80 93 a0 00 	sts	0x00A0, r24

		USB_INT_Enable(USB_INT_DDISCI);

		USB_HostState = HOST_STATE_Powered;
    5736:	82 e0       	ldi	r24, 0x02	; 2
    5738:	80 93 ac 0d 	sts	0x0DAC, r24
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
    573c:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_BCERRI) && USB_INT_IsEnabled(USB_INT_BCERRI))
    5740:	82 ff       	sbrs	r24, 2
    5742:	10 c0       	rjmp	.+32     	; 0x5764 <__vector_10+0x254>
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
    5744:	80 91 de 00 	lds	r24, 0x00DE
    5748:	82 ff       	sbrs	r24, 2
    574a:	0c c0       	rjmp	.+24     	; 0x5764 <__vector_10+0x254>
						break;
					case USB_INT_RSTI:
						UHINT  &= ~(1 << RSTI);
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
    574c:	80 91 df 00 	lds	r24, 0x00DF
    5750:	8b 7f       	andi	r24, 0xFB	; 251
    5752:	80 93 df 00 	sts	0x00DF, r24
	{
		USB_INT_Clear(USB_INT_BCERRI);

		EVENT_USB_Host_DeviceEnumerationFailed(HOST_ENUMERROR_NoDeviceDetected, 0);
    5756:	82 e0       	ldi	r24, 0x02	; 2
    5758:	60 e0       	ldi	r22, 0x00	; 0
    575a:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <EVENT_USB_Host_DeviceEnumerationFailed>
		EVENT_USB_Host_DeviceUnattached();
    575e:	0e 94 df 02 	call	0x5be	; 0x5be <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    5762:	cf dd       	rcall	.-1122   	; 0x5302 <USB_ResetInterface>
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
    5764:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_CAN_BE_BOTH)
	if (USB_INT_HasOccurred(USB_INT_IDTI) && USB_INT_IsEnabled(USB_INT_IDTI))
    5768:	81 ff       	sbrs	r24, 1
    576a:	1f c0       	rjmp	.+62     	; 0x57aa <__vector_10+0x29a>
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
    576c:	80 91 d8 00 	lds	r24, 0x00D8
    5770:	81 ff       	sbrs	r24, 1
    5772:	1b c0       	rjmp	.+54     	; 0x57aa <__vector_10+0x29a>
						USBINT &= ~(1 << VBUSTI);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBINT &= ~(1 << IDTI);
    5774:	80 91 da 00 	lds	r24, 0x00DA
    5778:	8d 7f       	andi	r24, 0xFD	; 253
    577a:	80 93 da 00 	sts	0x00DA, r24
	{
		USB_INT_Clear(USB_INT_IDTI);

		if (USB_DeviceState != DEVICE_STATE_Unattached)
    577e:	8e b3       	in	r24, 0x1e	; 30
    5780:	88 23       	and	r24, r24
    5782:	11 f0       	breq	.+4      	; 0x5788 <__vector_10+0x278>
		  EVENT_USB_Device_Disconnect();
    5784:	0e 94 95 02 	call	0x52a	; 0x52a <EVENT_USB_Device_Disconnect>

		if (USB_HostState != HOST_STATE_Unattached)
    5788:	80 91 ac 0d 	lds	r24, 0x0DAC
    578c:	81 30       	cpi	r24, 0x01	; 1
    578e:	11 f0       	breq	.+4      	; 0x5794 <__vector_10+0x284>
		  EVENT_USB_Host_DeviceUnattached();
    5790:	0e 94 df 02 	call	0x5be	; 0x5be <EVENT_USB_Host_DeviceUnattached>

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5794:	80 91 d9 00 	lds	r24, 0x00D9
    5798:	81 fd       	sbrc	r24, 1
    579a:	02 c0       	rjmp	.+4      	; 0x57a0 <__vector_10+0x290>
    579c:	82 e0       	ldi	r24, 0x02	; 2
    579e:	01 c0       	rjmp	.+2      	; 0x57a2 <__vector_10+0x292>
    57a0:	81 e0       	ldi	r24, 0x01	; 1

		USB_CurrentMode = USB_GetUSBModeFromUID();
    57a2:	80 93 cf 03 	sts	0x03CF, r24
		USB_ResetInterface();
    57a6:	ad dd       	rcall	.-1190   	; 0x5302 <USB_ResetInterface>

		EVENT_USB_UIDChange();
    57a8:	50 d5       	rcall	.+2720   	; 0x624a <USB_Event_Stub>
	}
	#endif
}
    57aa:	ff 91       	pop	r31
    57ac:	ef 91       	pop	r30
    57ae:	bf 91       	pop	r27
    57b0:	af 91       	pop	r26
    57b2:	9f 91       	pop	r25
    57b4:	8f 91       	pop	r24
    57b6:	7f 91       	pop	r23
    57b8:	6f 91       	pop	r22
    57ba:	5f 91       	pop	r21
    57bc:	4f 91       	pop	r20
    57be:	3f 91       	pop	r19
    57c0:	2f 91       	pop	r18
    57c2:	0f 90       	pop	r0
    57c4:	0b be       	out	0x3b, r0	; 59
    57c6:	0f 90       	pop	r0
    57c8:	0f be       	out	0x3f, r0	; 63
    57ca:	0f 90       	pop	r0
    57cc:	1f 90       	pop	r1
    57ce:	18 95       	reti

000057d0 <Endpoint_Write_Control_Stream_LE>:
    57d0:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    57d2:	40 91 aa 0d 	lds	r20, 0x0DAA
    57d6:	50 91 ab 0d 	lds	r21, 0x0DAB
    57da:	46 17       	cp	r20, r22
    57dc:	57 07       	cpc	r21, r23
    57de:	18 f4       	brcc	.+6      	; 0x57e6 <Endpoint_Write_Control_Stream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    57e0:	f9 01       	movw	r30, r18
    57e2:	90 e0       	ldi	r25, 0x00	; 0
    57e4:	3c c0       	rjmp	.+120    	; 0x585e <Endpoint_Write_Control_Stream_LE+0x8e>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    57e6:	61 15       	cp	r22, r1
    57e8:	71 05       	cpc	r23, r1
    57ea:	11 f0       	breq	.+4      	; 0x57f0 <Endpoint_Write_Control_Stream_LE+0x20>
    57ec:	ab 01       	movw	r20, r22
    57ee:	f8 cf       	rjmp	.-16     	; 0x57e0 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    57f0:	80 91 e8 00 	lds	r24, 0x00E8
    57f4:	8e 77       	andi	r24, 0x7E	; 126
    57f6:	80 93 e8 00 	sts	0x00E8, r24
    57fa:	40 e0       	ldi	r20, 0x00	; 0
    57fc:	50 e0       	ldi	r21, 0x00	; 0
    57fe:	f0 cf       	rjmp	.-32     	; 0x57e0 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    5800:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    5802:	88 23       	and	r24, r24
    5804:	e9 f1       	breq	.+122    	; 0x5880 <Endpoint_Write_Control_Stream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    5806:	85 30       	cpi	r24, 0x05	; 5
    5808:	e9 f1       	breq	.+122    	; 0x5884 <Endpoint_Write_Control_Stream_LE+0xb4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    580a:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    580e:	83 ff       	sbrs	r24, 3
    5810:	02 c0       	rjmp	.+4      	; 0x5816 <Endpoint_Write_Control_Stream_LE+0x46>
    5812:	81 e0       	ldi	r24, 0x01	; 1
    5814:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5816:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    581a:	82 fd       	sbrc	r24, 2
    581c:	2b c0       	rjmp	.+86     	; 0x5874 <Endpoint_Write_Control_Stream_LE+0xa4>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    581e:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    5822:	80 ff       	sbrs	r24, 0
    5824:	1c c0       	rjmp	.+56     	; 0x585e <Endpoint_Write_Control_Stream_LE+0x8e>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    5826:	20 91 f2 00 	lds	r18, 0x00F2
    582a:	30 91 f3 00 	lds	r19, 0x00F3
    582e:	07 c0       	rjmp	.+14     	; 0x583e <Endpoint_Write_Control_Stream_LE+0x6e>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    5830:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5832:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    5836:	41 50       	subi	r20, 0x01	; 1
    5838:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    583a:	2f 5f       	subi	r18, 0xFF	; 255
    583c:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    583e:	41 15       	cp	r20, r1
    5840:	51 05       	cpc	r21, r1
    5842:	19 f0       	breq	.+6      	; 0x584a <Endpoint_Write_Control_Stream_LE+0x7a>
    5844:	28 30       	cpi	r18, 0x08	; 8
    5846:	31 05       	cpc	r19, r1
    5848:	98 f3       	brcs	.-26     	; 0x5830 <Endpoint_Write_Control_Stream_LE+0x60>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    584a:	90 e0       	ldi	r25, 0x00	; 0
    584c:	28 30       	cpi	r18, 0x08	; 8
    584e:	31 05       	cpc	r19, r1
    5850:	09 f4       	brne	.+2      	; 0x5854 <Endpoint_Write_Control_Stream_LE+0x84>
    5852:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5854:	80 91 e8 00 	lds	r24, 0x00E8
    5858:	8e 77       	andi	r24, 0x7E	; 126
    585a:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    585e:	41 15       	cp	r20, r1
    5860:	51 05       	cpc	r21, r1
    5862:	71 f6       	brne	.-100    	; 0x5800 <Endpoint_Write_Control_Stream_LE+0x30>
    5864:	99 23       	and	r25, r25
    5866:	61 f6       	brne	.-104    	; 0x5800 <Endpoint_Write_Control_Stream_LE+0x30>
    5868:	05 c0       	rjmp	.+10     	; 0x5874 <Endpoint_Write_Control_Stream_LE+0xa4>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    586a:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    586c:	88 23       	and	r24, r24
    586e:	41 f0       	breq	.+16     	; 0x5880 <Endpoint_Write_Control_Stream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    5870:	85 30       	cpi	r24, 0x05	; 5
    5872:	41 f0       	breq	.+16     	; 0x5884 <Endpoint_Write_Control_Stream_LE+0xb4>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5874:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    5878:	82 ff       	sbrs	r24, 2
    587a:	f7 cf       	rjmp	.-18     	; 0x586a <Endpoint_Write_Control_Stream_LE+0x9a>
    587c:	80 e0       	ldi	r24, 0x00	; 0
    587e:	08 95       	ret
    5880:	82 e0       	ldi	r24, 0x02	; 2
    5882:	08 95       	ret
    5884:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    5886:	08 95       	ret

00005888 <Endpoint_Read_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    5888:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    588a:	61 15       	cp	r22, r1
    588c:	71 05       	cpc	r23, r1
    588e:	29 f4       	brne	.+10     	; 0x589a <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5890:	80 91 e8 00 	lds	r24, 0x00E8
    5894:	8b 77       	andi	r24, 0x7B	; 123
    5896:	80 93 e8 00 	sts	0x00E8, r24
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    589a:	f9 01       	movw	r30, r18
    589c:	21 c0       	rjmp	.+66     	; 0x58e0 <Endpoint_Read_Control_Stream_LE+0x58>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    589e:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    58a0:	88 23       	and	r24, r24
    58a2:	69 f1       	breq	.+90     	; 0x58fe <Endpoint_Read_Control_Stream_LE+0x76>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    58a4:	85 30       	cpi	r24, 0x05	; 5
    58a6:	69 f1       	breq	.+90     	; 0x5902 <Endpoint_Read_Control_Stream_LE+0x7a>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    58a8:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    58ac:	83 ff       	sbrs	r24, 3
    58ae:	02 c0       	rjmp	.+4      	; 0x58b4 <Endpoint_Read_Control_Stream_LE+0x2c>
    58b0:	81 e0       	ldi	r24, 0x01	; 1
    58b2:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    58b4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    58b8:	82 ff       	sbrs	r24, 2
    58ba:	f1 cf       	rjmp	.-30     	; 0x589e <Endpoint_Read_Control_Stream_LE+0x16>
    58bc:	06 c0       	rjmp	.+12     	; 0x58ca <Endpoint_Read_Control_Stream_LE+0x42>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    58be:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    58c2:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    58c4:	61 50       	subi	r22, 0x01	; 1
    58c6:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    58c8:	31 f0       	breq	.+12     	; 0x58d6 <Endpoint_Read_Control_Stream_LE+0x4e>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    58ca:	80 91 f2 00 	lds	r24, 0x00F2
    58ce:	90 91 f3 00 	lds	r25, 0x00F3
    58d2:	89 2b       	or	r24, r25
    58d4:	a1 f7       	brne	.-24     	; 0x58be <Endpoint_Read_Control_Stream_LE+0x36>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    58d6:	80 91 e8 00 	lds	r24, 0x00E8
    58da:	8b 77       	andi	r24, 0x7B	; 123
    58dc:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    58e0:	61 15       	cp	r22, r1
    58e2:	71 05       	cpc	r23, r1
    58e4:	e1 f6       	brne	.-72     	; 0x589e <Endpoint_Read_Control_Stream_LE+0x16>
    58e6:	05 c0       	rjmp	.+10     	; 0x58f2 <Endpoint_Read_Control_Stream_LE+0x6a>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    58e8:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    58ea:	88 23       	and	r24, r24
    58ec:	41 f0       	breq	.+16     	; 0x58fe <Endpoint_Read_Control_Stream_LE+0x76>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    58ee:	85 30       	cpi	r24, 0x05	; 5
    58f0:	41 f0       	breq	.+16     	; 0x5902 <Endpoint_Read_Control_Stream_LE+0x7a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    58f2:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    58f6:	80 ff       	sbrs	r24, 0
    58f8:	f7 cf       	rjmp	.-18     	; 0x58e8 <Endpoint_Read_Control_Stream_LE+0x60>
    58fa:	80 e0       	ldi	r24, 0x00	; 0
    58fc:	08 95       	ret
    58fe:	82 e0       	ldi	r24, 0x02	; 2
    5900:	08 95       	ret
    5902:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    5904:	08 95       	ret

00005906 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    5906:	fc 01       	movw	r30, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    5908:	40 91 aa 0d 	lds	r20, 0x0DAA
    590c:	50 91 ab 0d 	lds	r21, 0x0DAB
    5910:	46 17       	cp	r20, r22
    5912:	57 07       	cpc	r21, r23
    5914:	10 f4       	brcc	.+4      	; 0x591a <Endpoint_Write_Control_PStream_LE+0x14>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5916:	90 e0       	ldi	r25, 0x00	; 0
    5918:	3f c0       	rjmp	.+126    	; 0x5998 <Endpoint_Write_Control_PStream_LE+0x92>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    591a:	61 15       	cp	r22, r1
    591c:	71 05       	cpc	r23, r1
    591e:	11 f0       	breq	.+4      	; 0x5924 <Endpoint_Write_Control_PStream_LE+0x1e>
    5920:	ab 01       	movw	r20, r22
    5922:	f9 cf       	rjmp	.-14     	; 0x5916 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5924:	80 91 e8 00 	lds	r24, 0x00E8
    5928:	8e 77       	andi	r24, 0x7E	; 126
    592a:	80 93 e8 00 	sts	0x00E8, r24
    592e:	40 e0       	ldi	r20, 0x00	; 0
    5930:	50 e0       	ldi	r21, 0x00	; 0
    5932:	f1 cf       	rjmp	.-30     	; 0x5916 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    5934:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    5936:	88 23       	and	r24, r24
    5938:	09 f4       	brne	.+2      	; 0x593c <Endpoint_Write_Control_PStream_LE+0x36>
    593a:	3f c0       	rjmp	.+126    	; 0x59ba <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    593c:	85 30       	cpi	r24, 0x05	; 5
    593e:	09 f4       	brne	.+2      	; 0x5942 <Endpoint_Write_Control_PStream_LE+0x3c>
    5940:	3e c0       	rjmp	.+124    	; 0x59be <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5942:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    5946:	83 ff       	sbrs	r24, 3
    5948:	02 c0       	rjmp	.+4      	; 0x594e <Endpoint_Write_Control_PStream_LE+0x48>
    594a:	81 e0       	ldi	r24, 0x01	; 1
    594c:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    594e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    5952:	82 fd       	sbrc	r24, 2
    5954:	2c c0       	rjmp	.+88     	; 0x59ae <Endpoint_Write_Control_PStream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5956:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    595a:	80 ff       	sbrs	r24, 0
    595c:	1d c0       	rjmp	.+58     	; 0x5998 <Endpoint_Write_Control_PStream_LE+0x92>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    595e:	20 91 f2 00 	lds	r18, 0x00F2
    5962:	30 91 f3 00 	lds	r19, 0x00F3
    5966:	08 c0       	rjmp	.+16     	; 0x5978 <Endpoint_Write_Control_PStream_LE+0x72>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    5968:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    596a:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    596e:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    5970:	41 50       	subi	r20, 0x01	; 1
    5972:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    5974:	2f 5f       	subi	r18, 0xFF	; 255
    5976:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    5978:	41 15       	cp	r20, r1
    597a:	51 05       	cpc	r21, r1
    597c:	19 f0       	breq	.+6      	; 0x5984 <Endpoint_Write_Control_PStream_LE+0x7e>
    597e:	28 30       	cpi	r18, 0x08	; 8
    5980:	31 05       	cpc	r19, r1
    5982:	90 f3       	brcs	.-28     	; 0x5968 <Endpoint_Write_Control_PStream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    5984:	90 e0       	ldi	r25, 0x00	; 0
    5986:	28 30       	cpi	r18, 0x08	; 8
    5988:	31 05       	cpc	r19, r1
    598a:	09 f4       	brne	.+2      	; 0x598e <Endpoint_Write_Control_PStream_LE+0x88>
    598c:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    598e:	80 91 e8 00 	lds	r24, 0x00E8
    5992:	8e 77       	andi	r24, 0x7E	; 126
    5994:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    5998:	41 15       	cp	r20, r1
    599a:	51 05       	cpc	r21, r1
    599c:	59 f6       	brne	.-106    	; 0x5934 <Endpoint_Write_Control_PStream_LE+0x2e>
    599e:	99 23       	and	r25, r25
    59a0:	49 f6       	brne	.-110    	; 0x5934 <Endpoint_Write_Control_PStream_LE+0x2e>
    59a2:	05 c0       	rjmp	.+10     	; 0x59ae <Endpoint_Write_Control_PStream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    59a4:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    59a6:	88 23       	and	r24, r24
    59a8:	41 f0       	breq	.+16     	; 0x59ba <Endpoint_Write_Control_PStream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    59aa:	85 30       	cpi	r24, 0x05	; 5
    59ac:	41 f0       	breq	.+16     	; 0x59be <Endpoint_Write_Control_PStream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    59ae:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    59b2:	82 ff       	sbrs	r24, 2
    59b4:	f7 cf       	rjmp	.-18     	; 0x59a4 <Endpoint_Write_Control_PStream_LE+0x9e>
    59b6:	80 e0       	ldi	r24, 0x00	; 0
    59b8:	08 95       	ret
    59ba:	82 e0       	ldi	r24, 0x02	; 2
    59bc:	08 95       	ret
    59be:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    59c0:	08 95       	ret

000059c2 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    59c2:	bf 92       	push	r11
    59c4:	cf 92       	push	r12
    59c6:	df 92       	push	r13
    59c8:	ef 92       	push	r14
    59ca:	ff 92       	push	r15
    59cc:	0f 93       	push	r16
    59ce:	1f 93       	push	r17
    59d0:	cf 93       	push	r28
    59d2:	df 93       	push	r29
    59d4:	ec 01       	movw	r28, r24
    59d6:	7b 01       	movw	r14, r22
    59d8:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    59da:	b3 d9       	rcall	.-3226   	; 0x4d42 <Endpoint_WaitUntilReady>
    59dc:	b8 2e       	mov	r11, r24
    59de:	88 23       	and	r24, r24
    59e0:	89 f5       	brne	.+98     	; 0x5a44 <Endpoint_Read_Stream_LE+0x82>
	  return ErrorCode;

	if (BytesProcessed != NULL)
    59e2:	c1 14       	cp	r12, r1
    59e4:	d1 04       	cpc	r13, r1
    59e6:	39 f0       	breq	.+14     	; 0x59f6 <Endpoint_Read_Stream_LE+0x34>
	{
		Length -= *BytesProcessed;
    59e8:	f6 01       	movw	r30, r12
    59ea:	80 81       	ld	r24, Z
    59ec:	91 81       	ldd	r25, Z+1	; 0x01
    59ee:	e8 1a       	sub	r14, r24
    59f0:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    59f2:	c8 0f       	add	r28, r24
    59f4:	d9 1f       	adc	r29, r25
    59f6:	00 e0       	ldi	r16, 0x00	; 0
    59f8:	10 e0       	ldi	r17, 0x00	; 0
    59fa:	21 c0       	rjmp	.+66     	; 0x5a3e <Endpoint_Read_Stream_LE+0x7c>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    59fc:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    5a00:	85 fd       	sbrc	r24, 5
    5a02:	15 c0       	rjmp	.+42     	; 0x5a2e <Endpoint_Read_Stream_LE+0x6c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5a04:	80 91 e8 00 	lds	r24, 0x00E8
    5a08:	8b 77       	andi	r24, 0x7B	; 123
    5a0a:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    5a0e:	c1 14       	cp	r12, r1
    5a10:	d1 04       	cpc	r13, r1
    5a12:	49 f0       	breq	.+18     	; 0x5a26 <Endpoint_Read_Stream_LE+0x64>
			{
				*BytesProcessed += BytesInTransfer;
    5a14:	f6 01       	movw	r30, r12
    5a16:	80 81       	ld	r24, Z
    5a18:	91 81       	ldd	r25, Z+1	; 0x01
    5a1a:	80 0f       	add	r24, r16
    5a1c:	91 1f       	adc	r25, r17
    5a1e:	91 83       	std	Z+1, r25	; 0x01
    5a20:	80 83       	st	Z, r24
    5a22:	85 e0       	ldi	r24, 0x05	; 5
    5a24:	10 c0       	rjmp	.+32     	; 0x5a46 <Endpoint_Read_Stream_LE+0x84>

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    5a26:	8d d9       	rcall	.-3302   	; 0x4d42 <Endpoint_WaitUntilReady>
    5a28:	88 23       	and	r24, r24
    5a2a:	49 f0       	breq	.+18     	; 0x5a3e <Endpoint_Read_Stream_LE+0x7c>
    5a2c:	0c c0       	rjmp	.+24     	; 0x5a46 <Endpoint_Read_Stream_LE+0x84>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    5a2e:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5a32:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    5a34:	08 94       	sec
    5a36:	e1 08       	sbc	r14, r1
    5a38:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    5a3a:	0f 5f       	subi	r16, 0xFF	; 255
    5a3c:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    5a3e:	e1 14       	cp	r14, r1
    5a40:	f1 04       	cpc	r15, r1
    5a42:	e1 f6       	brne	.-72     	; 0x59fc <Endpoint_Read_Stream_LE+0x3a>
    5a44:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    5a46:	df 91       	pop	r29
    5a48:	cf 91       	pop	r28
    5a4a:	1f 91       	pop	r17
    5a4c:	0f 91       	pop	r16
    5a4e:	ff 90       	pop	r15
    5a50:	ef 90       	pop	r14
    5a52:	df 90       	pop	r13
    5a54:	cf 90       	pop	r12
    5a56:	bf 90       	pop	r11
    5a58:	08 95       	ret

00005a5a <Endpoint_Write_Stream_BE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5a5a:	bf 92       	push	r11
    5a5c:	cf 92       	push	r12
    5a5e:	df 92       	push	r13
    5a60:	ef 92       	push	r14
    5a62:	ff 92       	push	r15
    5a64:	0f 93       	push	r16
    5a66:	1f 93       	push	r17
    5a68:	cf 93       	push	r28
    5a6a:	df 93       	push	r29
    5a6c:	8c 01       	movw	r16, r24
    5a6e:	eb 01       	movw	r28, r22
    5a70:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    5a72:	67 d9       	rcall	.-3378   	; 0x4d42 <Endpoint_WaitUntilReady>
    5a74:	b8 2e       	mov	r11, r24
    5a76:	88 23       	and	r24, r24
    5a78:	b1 f5       	brne	.+108    	; 0x5ae6 <Endpoint_Write_Stream_BE+0x8c>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5a7a:	21 97       	sbiw	r28, 0x01	; 1
    5a7c:	0c 0f       	add	r16, r28
    5a7e:	1d 1f       	adc	r17, r29
    5a80:	21 96       	adiw	r28, 0x01	; 1
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5a82:	c1 14       	cp	r12, r1
    5a84:	d1 04       	cpc	r13, r1
    5a86:	39 f0       	breq	.+14     	; 0x5a96 <Endpoint_Write_Stream_BE+0x3c>
	{
		Length -= *BytesProcessed;
    5a88:	f6 01       	movw	r30, r12
    5a8a:	80 81       	ld	r24, Z
    5a8c:	91 81       	ldd	r25, Z+1	; 0x01
    5a8e:	c8 1b       	sub	r28, r24
    5a90:	d9 0b       	sbc	r29, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    5a92:	08 1b       	sub	r16, r24
    5a94:	19 0b       	sbc	r17, r25
    5a96:	ee 24       	eor	r14, r14
    5a98:	ff 24       	eor	r15, r15
    5a9a:	23 c0       	rjmp	.+70     	; 0x5ae2 <Endpoint_Write_Stream_BE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5a9c:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    5aa0:	85 fd       	sbrc	r24, 5
    5aa2:	15 c0       	rjmp	.+42     	; 0x5ace <Endpoint_Write_Stream_BE+0x74>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5aa4:	80 91 e8 00 	lds	r24, 0x00E8
    5aa8:	8e 77       	andi	r24, 0x7E	; 126
    5aaa:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    5aae:	c1 14       	cp	r12, r1
    5ab0:	d1 04       	cpc	r13, r1
    5ab2:	49 f0       	breq	.+18     	; 0x5ac6 <Endpoint_Write_Stream_BE+0x6c>
			{
				*BytesProcessed += BytesInTransfer;
    5ab4:	f6 01       	movw	r30, r12
    5ab6:	80 81       	ld	r24, Z
    5ab8:	91 81       	ldd	r25, Z+1	; 0x01
    5aba:	8e 0d       	add	r24, r14
    5abc:	9f 1d       	adc	r25, r15
    5abe:	91 83       	std	Z+1, r25	; 0x01
    5ac0:	80 83       	st	Z, r24
    5ac2:	85 e0       	ldi	r24, 0x05	; 5
    5ac4:	11 c0       	rjmp	.+34     	; 0x5ae8 <Endpoint_Write_Stream_BE+0x8e>

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    5ac6:	3d d9       	rcall	.-3462   	; 0x4d42 <Endpoint_WaitUntilReady>
    5ac8:	88 23       	and	r24, r24
    5aca:	59 f0       	breq	.+22     	; 0x5ae2 <Endpoint_Write_Stream_BE+0x88>
    5acc:	0d c0       	rjmp	.+26     	; 0x5ae8 <Endpoint_Write_Stream_BE+0x8e>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5ace:	f8 01       	movw	r30, r16
    5ad0:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5ad2:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
    5ad6:	01 50       	subi	r16, 0x01	; 1
    5ad8:	10 40       	sbci	r17, 0x00	; 0
			Length--;
    5ada:	21 97       	sbiw	r28, 0x01	; 1
			BytesInTransfer++;
    5adc:	08 94       	sec
    5ade:	e1 1c       	adc	r14, r1
    5ae0:	f1 1c       	adc	r15, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    5ae2:	20 97       	sbiw	r28, 0x00	; 0
    5ae4:	d9 f6       	brne	.-74     	; 0x5a9c <Endpoint_Write_Stream_BE+0x42>
    5ae6:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    5ae8:	df 91       	pop	r29
    5aea:	cf 91       	pop	r28
    5aec:	1f 91       	pop	r17
    5aee:	0f 91       	pop	r16
    5af0:	ff 90       	pop	r15
    5af2:	ef 90       	pop	r14
    5af4:	df 90       	pop	r13
    5af6:	cf 90       	pop	r12
    5af8:	bf 90       	pop	r11
    5afa:	08 95       	ret

00005afc <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5afc:	bf 92       	push	r11
    5afe:	cf 92       	push	r12
    5b00:	df 92       	push	r13
    5b02:	ef 92       	push	r14
    5b04:	ff 92       	push	r15
    5b06:	0f 93       	push	r16
    5b08:	1f 93       	push	r17
    5b0a:	cf 93       	push	r28
    5b0c:	df 93       	push	r29
    5b0e:	ec 01       	movw	r28, r24
    5b10:	7b 01       	movw	r14, r22
    5b12:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    5b14:	16 d9       	rcall	.-3540   	; 0x4d42 <Endpoint_WaitUntilReady>
    5b16:	b8 2e       	mov	r11, r24
    5b18:	88 23       	and	r24, r24
    5b1a:	89 f5       	brne	.+98     	; 0x5b7e <Endpoint_Write_Stream_LE+0x82>
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5b1c:	c1 14       	cp	r12, r1
    5b1e:	d1 04       	cpc	r13, r1
    5b20:	39 f0       	breq	.+14     	; 0x5b30 <Endpoint_Write_Stream_LE+0x34>
	{
		Length -= *BytesProcessed;
    5b22:	f6 01       	movw	r30, r12
    5b24:	80 81       	ld	r24, Z
    5b26:	91 81       	ldd	r25, Z+1	; 0x01
    5b28:	e8 1a       	sub	r14, r24
    5b2a:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    5b2c:	c8 0f       	add	r28, r24
    5b2e:	d9 1f       	adc	r29, r25
    5b30:	00 e0       	ldi	r16, 0x00	; 0
    5b32:	10 e0       	ldi	r17, 0x00	; 0
    5b34:	21 c0       	rjmp	.+66     	; 0x5b78 <Endpoint_Write_Stream_LE+0x7c>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5b36:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    5b3a:	85 fd       	sbrc	r24, 5
    5b3c:	15 c0       	rjmp	.+42     	; 0x5b68 <Endpoint_Write_Stream_LE+0x6c>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5b3e:	80 91 e8 00 	lds	r24, 0x00E8
    5b42:	8e 77       	andi	r24, 0x7E	; 126
    5b44:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    5b48:	c1 14       	cp	r12, r1
    5b4a:	d1 04       	cpc	r13, r1
    5b4c:	49 f0       	breq	.+18     	; 0x5b60 <Endpoint_Write_Stream_LE+0x64>
			{
				*BytesProcessed += BytesInTransfer;
    5b4e:	f6 01       	movw	r30, r12
    5b50:	80 81       	ld	r24, Z
    5b52:	91 81       	ldd	r25, Z+1	; 0x01
    5b54:	80 0f       	add	r24, r16
    5b56:	91 1f       	adc	r25, r17
    5b58:	91 83       	std	Z+1, r25	; 0x01
    5b5a:	80 83       	st	Z, r24
    5b5c:	85 e0       	ldi	r24, 0x05	; 5
    5b5e:	10 c0       	rjmp	.+32     	; 0x5b80 <Endpoint_Write_Stream_LE+0x84>

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    5b60:	f0 d8       	rcall	.-3616   	; 0x4d42 <Endpoint_WaitUntilReady>
    5b62:	88 23       	and	r24, r24
    5b64:	49 f0       	breq	.+18     	; 0x5b78 <Endpoint_Write_Stream_LE+0x7c>
    5b66:	0c c0       	rjmp	.+24     	; 0x5b80 <Endpoint_Write_Stream_LE+0x84>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5b68:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5b6a:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    5b6e:	08 94       	sec
    5b70:	e1 08       	sbc	r14, r1
    5b72:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    5b74:	0f 5f       	subi	r16, 0xFF	; 255
    5b76:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    5b78:	e1 14       	cp	r14, r1
    5b7a:	f1 04       	cpc	r15, r1
    5b7c:	e1 f6       	brne	.-72     	; 0x5b36 <Endpoint_Write_Stream_LE+0x3a>
    5b7e:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    5b80:	df 91       	pop	r29
    5b82:	cf 91       	pop	r28
    5b84:	1f 91       	pop	r17
    5b86:	0f 91       	pop	r16
    5b88:	ff 90       	pop	r15
    5b8a:	ef 90       	pop	r14
    5b8c:	df 90       	pop	r13
    5b8e:	cf 90       	pop	r12
    5b90:	bf 90       	pop	r11
    5b92:	08 95       	ret

00005b94 <Endpoint_Null_Stream>:
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
    5b94:	df 92       	push	r13
    5b96:	ef 92       	push	r14
    5b98:	ff 92       	push	r15
    5b9a:	0f 93       	push	r16
    5b9c:	1f 93       	push	r17
    5b9e:	cf 93       	push	r28
    5ba0:	df 93       	push	r29
    5ba2:	ec 01       	movw	r28, r24
    5ba4:	8b 01       	movw	r16, r22
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;
	
	if ((ErrorCode = Endpoint_WaitUntilReady()))
    5ba6:	cd d8       	rcall	.-3686   	; 0x4d42 <Endpoint_WaitUntilReady>
    5ba8:	d8 2e       	mov	r13, r24
    5baa:	88 23       	and	r24, r24
    5bac:	61 f5       	brne	.+88     	; 0x5c06 <Endpoint_Null_Stream+0x72>
	  return ErrorCode;
	  
	if (BytesProcessed != NULL)
    5bae:	01 15       	cp	r16, r1
    5bb0:	11 05       	cpc	r17, r1
    5bb2:	29 f0       	breq	.+10     	; 0x5bbe <Endpoint_Null_Stream+0x2a>
	  Length -= *BytesProcessed;
    5bb4:	f8 01       	movw	r30, r16
    5bb6:	80 81       	ld	r24, Z
    5bb8:	91 81       	ldd	r25, Z+1	; 0x01
    5bba:	c8 1b       	sub	r28, r24
    5bbc:	d9 0b       	sbc	r29, r25
    5bbe:	ee 24       	eor	r14, r14
    5bc0:	ff 24       	eor	r15, r15
    5bc2:	1f c0       	rjmp	.+62     	; 0x5c02 <Endpoint_Null_Stream+0x6e>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5bc4:	80 91 e8 00 	lds	r24, 0x00E8

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    5bc8:	85 fd       	sbrc	r24, 5
    5bca:	15 c0       	rjmp	.+42     	; 0x5bf6 <Endpoint_Null_Stream+0x62>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5bcc:	80 91 e8 00 	lds	r24, 0x00E8
    5bd0:	8e 77       	andi	r24, 0x7E	; 126
    5bd2:	80 93 e8 00 	sts	0x00E8, r24
		{
			Endpoint_ClearIN();

			if (BytesProcessed != NULL)
    5bd6:	01 15       	cp	r16, r1
    5bd8:	11 05       	cpc	r17, r1
    5bda:	49 f0       	breq	.+18     	; 0x5bee <Endpoint_Null_Stream+0x5a>
			{
				*BytesProcessed += BytesInTransfer;
    5bdc:	f8 01       	movw	r30, r16
    5bde:	80 81       	ld	r24, Z
    5be0:	91 81       	ldd	r25, Z+1	; 0x01
    5be2:	8e 0d       	add	r24, r14
    5be4:	9f 1d       	adc	r25, r15
    5be6:	91 83       	std	Z+1, r25	; 0x01
    5be8:	80 83       	st	Z, r24
    5bea:	85 e0       	ldi	r24, 0x05	; 5
    5bec:	0d c0       	rjmp	.+26     	; 0x5c08 <Endpoint_Null_Stream+0x74>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    5bee:	a9 d8       	rcall	.-3758   	; 0x4d42 <Endpoint_WaitUntilReady>
    5bf0:	88 23       	and	r24, r24
    5bf2:	39 f0       	breq	.+14     	; 0x5c02 <Endpoint_Null_Stream+0x6e>
    5bf4:	09 c0       	rjmp	.+18     	; 0x5c08 <Endpoint_Null_Stream+0x74>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5bf6:	10 92 f1 00 	sts	0x00F1, r1
		}
		else
		{
			Endpoint_Write_8(0);

			Length--;
    5bfa:	21 97       	sbiw	r28, 0x01	; 1
			BytesInTransfer++;
    5bfc:	08 94       	sec
    5bfe:	e1 1c       	adc	r14, r1
    5c00:	f1 1c       	adc	r15, r1
	  return ErrorCode;
	  
	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
    5c02:	20 97       	sbiw	r28, 0x00	; 0
    5c04:	f9 f6       	brne	.-66     	; 0x5bc4 <Endpoint_Null_Stream+0x30>
    5c06:	8d 2d       	mov	r24, r13
			BytesInTransfer++;
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
}
    5c08:	df 91       	pop	r29
    5c0a:	cf 91       	pop	r28
    5c0c:	1f 91       	pop	r17
    5c0e:	0f 91       	pop	r16
    5c10:	ff 90       	pop	r15
    5c12:	ef 90       	pop	r14
    5c14:	df 90       	pop	r13
    5c16:	08 95       	ret

00005c18 <Pipe_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5c18:	bf 92       	push	r11
    5c1a:	cf 92       	push	r12
    5c1c:	df 92       	push	r13
    5c1e:	ef 92       	push	r14
    5c20:	ff 92       	push	r15
    5c22:	0f 93       	push	r16
    5c24:	1f 93       	push	r17
    5c26:	cf 93       	push	r28
    5c28:	df 93       	push	r29
    5c2a:	ec 01       	movw	r28, r24
    5c2c:	7b 01       	movw	r14, r22
    5c2e:	6a 01       	movw	r12, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5c30:	80 91 aa 00 	lds	r24, 0x00AA
    5c34:	8f 7c       	andi	r24, 0xCF	; 207
    5c36:	80 61       	ori	r24, 0x10	; 16
    5c38:	80 93 aa 00 	sts	0x00AA, r24
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    5c3c:	19 db       	rcall	.-2510   	; 0x5270 <Pipe_WaitUntilReady>
    5c3e:	b8 2e       	mov	r11, r24
    5c40:	88 23       	and	r24, r24
    5c42:	89 f5       	brne	.+98     	; 0x5ca6 <Pipe_Read_Stream_LE+0x8e>
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5c44:	c1 14       	cp	r12, r1
    5c46:	d1 04       	cpc	r13, r1
    5c48:	39 f0       	breq	.+14     	; 0x5c58 <Pipe_Read_Stream_LE+0x40>
	{
		Length -= *BytesProcessed;
    5c4a:	f6 01       	movw	r30, r12
    5c4c:	80 81       	ld	r24, Z
    5c4e:	91 81       	ldd	r25, Z+1	; 0x01
    5c50:	e8 1a       	sub	r14, r24
    5c52:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    5c54:	c8 0f       	add	r28, r24
    5c56:	d9 1f       	adc	r29, r25
    5c58:	00 e0       	ldi	r16, 0x00	; 0
    5c5a:	10 e0       	ldi	r17, 0x00	; 0
    5c5c:	21 c0       	rjmp	.+66     	; 0x5ca0 <Pipe_Read_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5c5e:	80 91 a6 00 	lds	r24, 0x00A6
	}
	
	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5c62:	85 fd       	sbrc	r24, 5
    5c64:	15 c0       	rjmp	.+42     	; 0x5c90 <Pipe_Read_Stream_LE+0x78>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5c66:	80 91 a6 00 	lds	r24, 0x00A6
    5c6a:	8e 77       	andi	r24, 0x7E	; 126
    5c6c:	80 93 a6 00 	sts	0x00A6, r24
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    5c70:	c1 14       	cp	r12, r1
    5c72:	d1 04       	cpc	r13, r1
    5c74:	49 f0       	breq	.+18     	; 0x5c88 <Pipe_Read_Stream_LE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    5c76:	f6 01       	movw	r30, r12
    5c78:	80 81       	ld	r24, Z
    5c7a:	91 81       	ldd	r25, Z+1	; 0x01
    5c7c:	80 0f       	add	r24, r16
    5c7e:	91 1f       	adc	r25, r17
    5c80:	91 83       	std	Z+1, r25	; 0x01
    5c82:	80 83       	st	Z, r24
    5c84:	84 e0       	ldi	r24, 0x04	; 4
    5c86:	10 c0       	rjmp	.+32     	; 0x5ca8 <Pipe_Read_Stream_LE+0x90>
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5c88:	f3 da       	rcall	.-2586   	; 0x5270 <Pipe_WaitUntilReady>
    5c8a:	88 23       	and	r24, r24
    5c8c:	49 f0       	breq	.+18     	; 0x5ca0 <Pipe_Read_Stream_LE+0x88>
    5c8e:	0c c0       	rjmp	.+24     	; 0x5ca8 <Pipe_Read_Stream_LE+0x90>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    5c90:	80 91 af 00 	lds	r24, 0x00AF
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5c94:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    5c96:	08 94       	sec
    5c98:	e1 08       	sbc	r14, r1
    5c9a:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    5c9c:	0f 5f       	subi	r16, 0xFF	; 255
    5c9e:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}
	
	while (Length)
    5ca0:	e1 14       	cp	r14, r1
    5ca2:	f1 04       	cpc	r15, r1
    5ca4:	e1 f6       	brne	.-72     	; 0x5c5e <Pipe_Read_Stream_LE+0x46>
    5ca6:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    5ca8:	df 91       	pop	r29
    5caa:	cf 91       	pop	r28
    5cac:	1f 91       	pop	r17
    5cae:	0f 91       	pop	r16
    5cb0:	ff 90       	pop	r15
    5cb2:	ef 90       	pop	r14
    5cb4:	df 90       	pop	r13
    5cb6:	cf 90       	pop	r12
    5cb8:	bf 90       	pop	r11
    5cba:	08 95       	ret

00005cbc <Pipe_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5cbc:	bf 92       	push	r11
    5cbe:	cf 92       	push	r12
    5cc0:	df 92       	push	r13
    5cc2:	ef 92       	push	r14
    5cc4:	ff 92       	push	r15
    5cc6:	0f 93       	push	r16
    5cc8:	1f 93       	push	r17
    5cca:	cf 93       	push	r28
    5ccc:	df 93       	push	r29
    5cce:	ec 01       	movw	r28, r24
    5cd0:	7b 01       	movw	r14, r22
    5cd2:	6a 01       	movw	r12, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5cd4:	80 91 aa 00 	lds	r24, 0x00AA
    5cd8:	8f 7c       	andi	r24, 0xCF	; 207
    5cda:	80 62       	ori	r24, 0x20	; 32
    5cdc:	80 93 aa 00 	sts	0x00AA, r24
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    5ce0:	c7 da       	rcall	.-2674   	; 0x5270 <Pipe_WaitUntilReady>
    5ce2:	b8 2e       	mov	r11, r24
    5ce4:	88 23       	and	r24, r24
    5ce6:	89 f5       	brne	.+98     	; 0x5d4a <Pipe_Write_Stream_LE+0x8e>
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5ce8:	c1 14       	cp	r12, r1
    5cea:	d1 04       	cpc	r13, r1
    5cec:	39 f0       	breq	.+14     	; 0x5cfc <Pipe_Write_Stream_LE+0x40>
	{
		Length -= *BytesProcessed;
    5cee:	f6 01       	movw	r30, r12
    5cf0:	80 81       	ld	r24, Z
    5cf2:	91 81       	ldd	r25, Z+1	; 0x01
    5cf4:	e8 1a       	sub	r14, r24
    5cf6:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    5cf8:	c8 0f       	add	r28, r24
    5cfa:	d9 1f       	adc	r29, r25
    5cfc:	00 e0       	ldi	r16, 0x00	; 0
    5cfe:	10 e0       	ldi	r17, 0x00	; 0
    5d00:	21 c0       	rjmp	.+66     	; 0x5d44 <Pipe_Write_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5d02:	80 91 a6 00 	lds	r24, 0x00A6
	}
	
	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5d06:	85 fd       	sbrc	r24, 5
    5d08:	15 c0       	rjmp	.+42     	; 0x5d34 <Pipe_Write_Stream_LE+0x78>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    5d0a:	80 91 a6 00 	lds	r24, 0x00A6
    5d0e:	8b 77       	andi	r24, 0x7B	; 123
    5d10:	80 93 a6 00 	sts	0x00A6, r24
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    5d14:	c1 14       	cp	r12, r1
    5d16:	d1 04       	cpc	r13, r1
    5d18:	49 f0       	breq	.+18     	; 0x5d2c <Pipe_Write_Stream_LE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    5d1a:	f6 01       	movw	r30, r12
    5d1c:	80 81       	ld	r24, Z
    5d1e:	91 81       	ldd	r25, Z+1	; 0x01
    5d20:	80 0f       	add	r24, r16
    5d22:	91 1f       	adc	r25, r17
    5d24:	91 83       	std	Z+1, r25	; 0x01
    5d26:	80 83       	st	Z, r24
    5d28:	84 e0       	ldi	r24, 0x04	; 4
    5d2a:	10 c0       	rjmp	.+32     	; 0x5d4c <Pipe_Write_Stream_LE+0x90>
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5d2c:	a1 da       	rcall	.-2750   	; 0x5270 <Pipe_WaitUntilReady>
    5d2e:	88 23       	and	r24, r24
    5d30:	49 f0       	breq	.+18     	; 0x5d44 <Pipe_Write_Stream_LE+0x88>
    5d32:	0c c0       	rjmp	.+24     	; 0x5d4c <Pipe_Write_Stream_LE+0x90>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5d34:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    5d36:	80 93 af 00 	sts	0x00AF, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    5d3a:	08 94       	sec
    5d3c:	e1 08       	sbc	r14, r1
    5d3e:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    5d40:	0f 5f       	subi	r16, 0xFF	; 255
    5d42:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}
	
	while (Length)
    5d44:	e1 14       	cp	r14, r1
    5d46:	f1 04       	cpc	r15, r1
    5d48:	e1 f6       	brne	.-72     	; 0x5d02 <Pipe_Write_Stream_LE+0x46>
    5d4a:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    5d4c:	df 91       	pop	r29
    5d4e:	cf 91       	pop	r28
    5d50:	1f 91       	pop	r17
    5d52:	0f 91       	pop	r16
    5d54:	ff 90       	pop	r15
    5d56:	ef 90       	pop	r14
    5d58:	df 90       	pop	r13
    5d5a:	cf 90       	pop	r12
    5d5c:	bf 90       	pop	r11
    5d5e:	08 95       	ret

00005d60 <Pipe_Discard_Stream>:

#include "PipeStream_AVR8.h"

uint8_t Pipe_Discard_Stream(uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5d60:	df 92       	push	r13
    5d62:	ef 92       	push	r14
    5d64:	ff 92       	push	r15
    5d66:	0f 93       	push	r16
    5d68:	1f 93       	push	r17
    5d6a:	cf 93       	push	r28
    5d6c:	df 93       	push	r29
    5d6e:	8c 01       	movw	r16, r24
    5d70:	7b 01       	movw	r14, r22
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5d72:	80 91 aa 00 	lds	r24, 0x00AA
    5d76:	8f 7c       	andi	r24, 0xCF	; 207
    5d78:	80 61       	ori	r24, 0x10	; 16
    5d7a:	80 93 aa 00 	sts	0x00AA, r24
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;
	
	Pipe_SetPipeToken(PIPE_TOKEN_IN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    5d7e:	78 da       	rcall	.-2832   	; 0x5270 <Pipe_WaitUntilReady>
    5d80:	d8 2e       	mov	r13, r24
    5d82:	88 23       	and	r24, r24
    5d84:	61 f5       	brne	.+88     	; 0x5dde <Pipe_Discard_Stream+0x7e>
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5d86:	e1 14       	cp	r14, r1
    5d88:	f1 04       	cpc	r15, r1
    5d8a:	29 f0       	breq	.+10     	; 0x5d96 <Pipe_Discard_Stream+0x36>
	  Length -= *BytesProcessed;
    5d8c:	f7 01       	movw	r30, r14
    5d8e:	80 81       	ld	r24, Z
    5d90:	91 81       	ldd	r25, Z+1	; 0x01
    5d92:	08 1b       	sub	r16, r24
    5d94:	19 0b       	sbc	r17, r25
    5d96:	c0 e0       	ldi	r28, 0x00	; 0
    5d98:	d0 e0       	ldi	r29, 0x00	; 0
    5d9a:	1e c0       	rjmp	.+60     	; 0x5dd8 <Pipe_Discard_Stream+0x78>
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5d9c:	80 91 a6 00 	lds	r24, 0x00A6

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5da0:	85 fd       	sbrc	r24, 5
    5da2:	15 c0       	rjmp	.+42     	; 0x5dce <Pipe_Discard_Stream+0x6e>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5da4:	80 91 a6 00 	lds	r24, 0x00A6
    5da8:	8e 77       	andi	r24, 0x7E	; 126
    5daa:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearIN();
				
			if (BytesProcessed != NULL)
    5dae:	e1 14       	cp	r14, r1
    5db0:	f1 04       	cpc	r15, r1
    5db2:	49 f0       	breq	.+18     	; 0x5dc6 <Pipe_Discard_Stream+0x66>
			{
				*BytesProcessed += BytesInTransfer;
    5db4:	f7 01       	movw	r30, r14
    5db6:	80 81       	ld	r24, Z
    5db8:	91 81       	ldd	r25, Z+1	; 0x01
    5dba:	8c 0f       	add	r24, r28
    5dbc:	9d 1f       	adc	r25, r29
    5dbe:	91 83       	std	Z+1, r25	; 0x01
    5dc0:	80 83       	st	Z, r24
    5dc2:	84 e0       	ldi	r24, 0x04	; 4
    5dc4:	0d c0       	rjmp	.+26     	; 0x5de0 <Pipe_Discard_Stream+0x80>
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5dc6:	54 da       	rcall	.-2904   	; 0x5270 <Pipe_WaitUntilReady>
    5dc8:	88 23       	and	r24, r24
    5dca:	31 f0       	breq	.+12     	; 0x5dd8 <Pipe_Discard_Stream+0x78>
    5dcc:	09 c0       	rjmp	.+18     	; 0x5de0 <Pipe_Discard_Stream+0x80>
			static inline void Pipe_Discard_8(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Discard_8(void)
			{
				uint8_t Dummy;

				Dummy = UPDATX;
    5dce:	80 91 af 00 	lds	r24, 0x00AF
		}
		else
		{
			Pipe_Discard_8();
			
			Length--;
    5dd2:	01 50       	subi	r16, 0x01	; 1
    5dd4:	10 40       	sbci	r17, 0x00	; 0
			BytesInTransfer++;
    5dd6:	21 96       	adiw	r28, 0x01	; 1
	  return ErrorCode;

	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
    5dd8:	01 15       	cp	r16, r1
    5dda:	11 05       	cpc	r17, r1
    5ddc:	f9 f6       	brne	.-66     	; 0x5d9c <Pipe_Discard_Stream+0x3c>
    5dde:	8d 2d       	mov	r24, r13
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    5de0:	df 91       	pop	r29
    5de2:	cf 91       	pop	r28
    5de4:	1f 91       	pop	r17
    5de6:	0f 91       	pop	r16
    5de8:	ff 90       	pop	r15
    5dea:	ef 90       	pop	r14
    5dec:	df 90       	pop	r13
    5dee:	08 95       	ret

00005df0 <USB_GetNextDescriptorComp>:

uint8_t USB_GetNextDescriptorComp(uint16_t* const BytesRem,
                                  void** const CurrConfigLoc,
                                  ConfigComparatorPtr_t const ComparatorRoutine)
{
    5df0:	af 92       	push	r10
    5df2:	bf 92       	push	r11
    5df4:	cf 92       	push	r12
    5df6:	df 92       	push	r13
    5df8:	ef 92       	push	r14
    5dfa:	ff 92       	push	r15
    5dfc:	0f 93       	push	r16
    5dfe:	1f 93       	push	r17
    5e00:	cf 93       	push	r28
    5e02:	df 93       	push	r29
    5e04:	6c 01       	movw	r12, r24
    5e06:	7b 01       	movw	r14, r22
    5e08:	5a 01       	movw	r10, r20
    5e0a:	28 c0       	rjmp	.+80     	; 0x5e5c <USB_GetNextDescriptorComp+0x6c>
	uint8_t ErrorCode;

	while (*BytesRem)
	{
		uint8_t* PrevDescLoc  = *CurrConfigLoc;
    5e0c:	f7 01       	movw	r30, r14
    5e0e:	00 81       	ld	r16, Z
    5e10:	11 81       	ldd	r17, Z+1	; 0x01
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2);
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc)
			{
				uint16_t CurrDescriptorSize = DESCRIPTOR_CAST(*CurrConfigLoc, USB_Descriptor_Header_t).Size;
    5e12:	f8 01       	movw	r30, r16
    5e14:	80 81       	ld	r24, Z
    5e16:	90 e0       	ldi	r25, 0x00	; 0
    5e18:	9e 01       	movw	r18, r28
    5e1a:	8c 17       	cp	r24, r28
    5e1c:	9d 07       	cpc	r25, r29
    5e1e:	08 f4       	brcc	.+2      	; 0x5e22 <USB_GetNextDescriptorComp+0x32>
    5e20:	9c 01       	movw	r18, r24
				
				if (*BytesRem < CurrDescriptorSize)
				  CurrDescriptorSize = *BytesRem;

				*CurrConfigLoc  = (void*)((uintptr_t)*CurrConfigLoc + CurrDescriptorSize);
    5e22:	c8 01       	movw	r24, r16
    5e24:	82 0f       	add	r24, r18
    5e26:	93 1f       	adc	r25, r19
    5e28:	f7 01       	movw	r30, r14
    5e2a:	91 83       	std	Z+1, r25	; 0x01
    5e2c:	80 83       	st	Z, r24
				*BytesRem      -= CurrDescriptorSize;
    5e2e:	f6 01       	movw	r30, r12
    5e30:	80 81       	ld	r24, Z
    5e32:	91 81       	ldd	r25, Z+1	; 0x01
    5e34:	82 1b       	sub	r24, r18
    5e36:	93 0b       	sbc	r25, r19
    5e38:	91 83       	std	Z+1, r25	; 0x01
    5e3a:	80 83       	st	Z, r24
		uint16_t PrevBytesRem = *BytesRem;

		USB_GetNextDescriptor(BytesRem, CurrConfigLoc);

		if ((ErrorCode = ComparatorRoutine(*CurrConfigLoc)) != DESCRIPTOR_SEARCH_NotFound)
    5e3c:	f7 01       	movw	r30, r14
    5e3e:	80 81       	ld	r24, Z
    5e40:	91 81       	ldd	r25, Z+1	; 0x01
    5e42:	f5 01       	movw	r30, r10
    5e44:	09 95       	icall
    5e46:	82 30       	cpi	r24, 0x02	; 2
    5e48:	49 f0       	breq	.+18     	; 0x5e5c <USB_GetNextDescriptorComp+0x6c>
		{
			if (ErrorCode == DESCRIPTOR_SEARCH_Fail)
    5e4a:	81 30       	cpi	r24, 0x01	; 1
    5e4c:	69 f4       	brne	.+26     	; 0x5e68 <USB_GetNextDescriptorComp+0x78>
			{
				*CurrConfigLoc = PrevDescLoc;
    5e4e:	f7 01       	movw	r30, r14
    5e50:	11 83       	std	Z+1, r17	; 0x01
    5e52:	00 83       	st	Z, r16
				*BytesRem      = PrevBytesRem;
    5e54:	f6 01       	movw	r30, r12
    5e56:	d1 83       	std	Z+1, r29	; 0x01
    5e58:	c0 83       	st	Z, r28
    5e5a:	06 c0       	rjmp	.+12     	; 0x5e68 <USB_GetNextDescriptorComp+0x78>
                                  void** const CurrConfigLoc,
                                  ConfigComparatorPtr_t const ComparatorRoutine)
{
	uint8_t ErrorCode;

	while (*BytesRem)
    5e5c:	f6 01       	movw	r30, r12
    5e5e:	c0 81       	ld	r28, Z
    5e60:	d1 81       	ldd	r29, Z+1	; 0x01
    5e62:	20 97       	sbiw	r28, 0x00	; 0
    5e64:	99 f6       	brne	.-90     	; 0x5e0c <USB_GetNextDescriptorComp+0x1c>
    5e66:	82 e0       	ldi	r24, 0x02	; 2
			return ErrorCode;
		}
	}

	return DESCRIPTOR_SEARCH_COMP_EndOfDescriptor;
}
    5e68:	df 91       	pop	r29
    5e6a:	cf 91       	pop	r28
    5e6c:	1f 91       	pop	r17
    5e6e:	0f 91       	pop	r16
    5e70:	ff 90       	pop	r15
    5e72:	ef 90       	pop	r14
    5e74:	df 90       	pop	r13
    5e76:	cf 90       	pop	r12
    5e78:	bf 90       	pop	r11
    5e7a:	af 90       	pop	r10
    5e7c:	08 95       	ret

00005e7e <USB_Host_GetDeviceConfigDescriptor>:
#if defined(USB_CAN_BE_HOST)
uint8_t USB_Host_GetDeviceConfigDescriptor(const uint8_t ConfigNumber,
                                           uint16_t* const ConfigSizePtr,
                                           void* const BufferPtr,
                                           const uint16_t BufferSize)
{
    5e7e:	cf 92       	push	r12
    5e80:	df 92       	push	r13
    5e82:	ef 92       	push	r14
    5e84:	ff 92       	push	r15
    5e86:	0f 93       	push	r16
    5e88:	1f 93       	push	r17
    5e8a:	df 93       	push	r29
    5e8c:	cf 93       	push	r28
    5e8e:	cd b7       	in	r28, 0x3d	; 61
    5e90:	de b7       	in	r29, 0x3e	; 62
    5e92:	29 97       	sbiw	r28, 0x09	; 9
    5e94:	0f b6       	in	r0, 0x3f	; 63
    5e96:	f8 94       	cli
    5e98:	de bf       	out	0x3e, r29	; 62
    5e9a:	0f be       	out	0x3f, r0	; 63
    5e9c:	cd bf       	out	0x3d, r28	; 61
    5e9e:	6b 01       	movw	r12, r22
    5ea0:	8a 01       	movw	r16, r20
    5ea2:	79 01       	movw	r14, r18
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    5ea4:	90 e8       	ldi	r25, 0x80	; 128
    5ea6:	90 93 a4 0d 	sts	0x0DA4, r25
    5eaa:	96 e0       	ldi	r25, 0x06	; 6
    5eac:	90 93 a5 0d 	sts	0x0DA5, r25
    5eb0:	90 e0       	ldi	r25, 0x00	; 0
    5eb2:	01 97       	sbiw	r24, 0x01	; 1
    5eb4:	92 60       	ori	r25, 0x02	; 2
    5eb6:	90 93 a7 0d 	sts	0x0DA7, r25
    5eba:	80 93 a6 0d 	sts	0x0DA6, r24
    5ebe:	10 92 a9 0d 	sts	0x0DA9, r1
    5ec2:	10 92 a8 0d 	sts	0x0DA8, r1
    5ec6:	89 e0       	ldi	r24, 0x09	; 9
    5ec8:	90 e0       	ldi	r25, 0x00	; 0
    5eca:	90 93 ab 0d 	sts	0x0DAB, r25
    5ece:	80 93 aa 0d 	sts	0x0DAA, r24
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    5ed2:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = sizeof(USB_Descriptor_Configuration_Header_t),
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) != HOST_SENDCONTROL_Successful)
    5ed6:	ce 01       	movw	r24, r28
    5ed8:	01 96       	adiw	r24, 0x01	; 1
    5eda:	e2 d1       	rcall	.+964    	; 0x62a0 <USB_Host_SendControlRequest>
    5edc:	28 2f       	mov	r18, r24
    5ede:	88 23       	and	r24, r24
    5ee0:	c1 f4       	brne	.+48     	; 0x5f12 <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return ErrorCode;

	*ConfigSizePtr = le16_to_cpu(DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)->TotalConfigurationSize);
    5ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    5ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    5ee6:	f6 01       	movw	r30, r12
    5ee8:	91 83       	std	Z+1, r25	; 0x01
    5eea:	80 83       	st	Z, r24

	if (*ConfigSizePtr > BufferSize)
    5eec:	e8 16       	cp	r14, r24
    5eee:	f9 06       	cpc	r15, r25
    5ef0:	10 f4       	brcc	.+4      	; 0x5ef6 <USB_Host_GetDeviceConfigDescriptor+0x78>
    5ef2:	25 e0       	ldi	r18, 0x05	; 5
    5ef4:	0e c0       	rjmp	.+28     	; 0x5f12 <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return HOST_GETCONFIG_BuffOverflow;

	USB_ControlRequest.wLength = *ConfigSizePtr;
    5ef6:	90 93 ab 0d 	sts	0x0DAB, r25
    5efa:	80 93 aa 0d 	sts	0x0DAA, r24

	if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) != HOST_SENDCONTROL_Successful)
    5efe:	c8 01       	movw	r24, r16
    5f00:	cf d1       	rcall	.+926    	; 0x62a0 <USB_Host_SendControlRequest>
    5f02:	28 2f       	mov	r18, r24
    5f04:	88 23       	and	r24, r24
    5f06:	29 f4       	brne	.+10     	; 0x5f12 <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return ErrorCode;

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    5f08:	f8 01       	movw	r30, r16
    5f0a:	81 81       	ldd	r24, Z+1	; 0x01
    5f0c:	82 30       	cpi	r24, 0x02	; 2
    5f0e:	09 f0       	breq	.+2      	; 0x5f12 <USB_Host_GetDeviceConfigDescriptor+0x94>
    5f10:	26 e0       	ldi	r18, 0x06	; 6
	  return HOST_GETCONFIG_InvalidData;

	return HOST_GETCONFIG_Successful;
}
    5f12:	82 2f       	mov	r24, r18
    5f14:	29 96       	adiw	r28, 0x09	; 9
    5f16:	0f b6       	in	r0, 0x3f	; 63
    5f18:	f8 94       	cli
    5f1a:	de bf       	out	0x3e, r29	; 62
    5f1c:	0f be       	out	0x3f, r0	; 63
    5f1e:	cd bf       	out	0x3d, r28	; 61
    5f20:	cf 91       	pop	r28
    5f22:	df 91       	pop	r29
    5f24:	1f 91       	pop	r17
    5f26:	0f 91       	pop	r16
    5f28:	ff 90       	pop	r15
    5f2a:	ef 90       	pop	r14
    5f2c:	df 90       	pop	r13
    5f2e:	cf 90       	pop	r12
    5f30:	08 95       	ret

00005f32 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    5f32:	0f 93       	push	r16
    5f34:	1f 93       	push	r17
    5f36:	df 93       	push	r29
    5f38:	cf 93       	push	r28
    5f3a:	cd b7       	in	r28, 0x3d	; 61
    5f3c:	de b7       	in	r29, 0x3e	; 62
    5f3e:	ac 97       	sbiw	r28, 0x2c	; 44
    5f40:	0f b6       	in	r0, 0x3f	; 63
    5f42:	f8 94       	cli
    5f44:	de bf       	out	0x3e, r29	; 62
    5f46:	0f be       	out	0x3f, r0	; 63
    5f48:	cd bf       	out	0x3d, r28	; 61
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    5f4a:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bmRequestType = Endpoint_Read_8();
    5f4e:	80 93 a4 0d 	sts	0x0DA4, r24
    5f52:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
    5f56:	80 93 a5 0d 	sts	0x0DA5, r24
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    5f5a:	20 91 f1 00 	lds	r18, 0x00F1
    5f5e:	82 2f       	mov	r24, r18
				Data.Bytes[1] = UEDATX;
    5f60:	20 91 f1 00 	lds	r18, 0x00F1
    5f64:	92 2f       	mov	r25, r18
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
    5f66:	90 93 a7 0d 	sts	0x0DA7, r25
    5f6a:	80 93 a6 0d 	sts	0x0DA6, r24
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    5f6e:	20 91 f1 00 	lds	r18, 0x00F1
    5f72:	82 2f       	mov	r24, r18
				Data.Bytes[1] = UEDATX;
    5f74:	20 91 f1 00 	lds	r18, 0x00F1
    5f78:	92 2f       	mov	r25, r18
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
    5f7a:	90 93 a9 0d 	sts	0x0DA9, r25
    5f7e:	80 93 a8 0d 	sts	0x0DA8, r24
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    5f82:	20 91 f1 00 	lds	r18, 0x00F1
    5f86:	82 2f       	mov	r24, r18
				Data.Bytes[1] = UEDATX;
    5f88:	20 91 f1 00 	lds	r18, 0x00F1
    5f8c:	92 2f       	mov	r25, r18
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
    5f8e:	90 93 ab 0d 	sts	0x0DAB, r25
    5f92:	80 93 aa 0d 	sts	0x0DAA, r24

	EVENT_USB_Device_ControlRequest();
    5f96:	0e 94 a4 02 	call	0x548	; 0x548 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5f9a:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    5f9e:	83 ff       	sbrs	r24, 3
    5fa0:	3b c1       	rjmp	.+630    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    5fa2:	80 91 a4 0d 	lds	r24, 0x0DA4

		switch (USB_ControlRequest.bRequest)
    5fa6:	30 91 a5 0d 	lds	r19, 0x0DA5
    5faa:	35 30       	cpi	r19, 0x05	; 5
    5fac:	09 f4       	brne	.+2      	; 0x5fb0 <USB_Device_ProcessControlRequest+0x7e>
    5fae:	87 c0       	rjmp	.+270    	; 0x60be <USB_Device_ProcessControlRequest+0x18c>
    5fb0:	36 30       	cpi	r19, 0x06	; 6
    5fb2:	40 f4       	brcc	.+16     	; 0x5fc4 <USB_Device_ProcessControlRequest+0x92>
    5fb4:	31 30       	cpi	r19, 0x01	; 1
    5fb6:	c9 f1       	breq	.+114    	; 0x602a <USB_Device_ProcessControlRequest+0xf8>
    5fb8:	31 30       	cpi	r19, 0x01	; 1
    5fba:	70 f0       	brcs	.+28     	; 0x5fd8 <USB_Device_ProcessControlRequest+0xa6>
    5fbc:	33 30       	cpi	r19, 0x03	; 3
    5fbe:	09 f0       	breq	.+2      	; 0x5fc2 <USB_Device_ProcessControlRequest+0x90>
    5fc0:	2b c1       	rjmp	.+598    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
    5fc2:	33 c0       	rjmp	.+102    	; 0x602a <USB_Device_ProcessControlRequest+0xf8>
    5fc4:	38 30       	cpi	r19, 0x08	; 8
    5fc6:	09 f4       	brne	.+2      	; 0x5fca <USB_Device_ProcessControlRequest+0x98>
    5fc8:	f7 c0       	rjmp	.+494    	; 0x61b8 <USB_Device_ProcessControlRequest+0x286>
    5fca:	39 30       	cpi	r19, 0x09	; 9
    5fcc:	09 f4       	brne	.+2      	; 0x5fd0 <USB_Device_ProcessControlRequest+0x9e>
    5fce:	07 c1       	rjmp	.+526    	; 0x61de <USB_Device_ProcessControlRequest+0x2ac>
    5fd0:	36 30       	cpi	r19, 0x06	; 6
    5fd2:	09 f0       	breq	.+2      	; 0x5fd6 <USB_Device_ProcessControlRequest+0xa4>
    5fd4:	21 c1       	rjmp	.+578    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
    5fd6:	97 c0       	rjmp	.+302    	; 0x6106 <USB_Device_ProcessControlRequest+0x1d4>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    5fd8:	80 38       	cpi	r24, 0x80	; 128
    5fda:	21 f0       	breq	.+8      	; 0x5fe4 <USB_Device_ProcessControlRequest+0xb2>
    5fdc:	82 38       	cpi	r24, 0x82	; 130
    5fde:	09 f0       	breq	.+2      	; 0x5fe2 <USB_Device_ProcessControlRequest+0xb0>
    5fe0:	1b c1       	rjmp	.+566    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
    5fe2:	08 c0       	rjmp	.+16     	; 0x5ff4 <USB_Device_ProcessControlRequest+0xc2>
    5fe4:	90 91 a0 0d 	lds	r25, 0x0DA0
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    5fe8:	80 91 a1 0d 	lds	r24, 0x0DA1
    5fec:	88 23       	and	r24, r24
    5fee:	99 f0       	breq	.+38     	; 0x6016 <USB_Device_ProcessControlRequest+0xe4>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    5ff0:	92 60       	ori	r25, 0x02	; 2
    5ff2:	11 c0       	rjmp	.+34     	; 0x6016 <USB_Device_ProcessControlRequest+0xe4>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    5ff4:	80 91 a8 0d 	lds	r24, 0x0DA8
    5ff8:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    5ffa:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    5ffe:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    6002:	90 e0       	ldi	r25, 0x00	; 0
    6004:	25 e0       	ldi	r18, 0x05	; 5
    6006:	96 95       	lsr	r25
    6008:	87 95       	ror	r24
    600a:	2a 95       	dec	r18
    600c:	e1 f7       	brne	.-8      	; 0x6006 <USB_Device_ProcessControlRequest+0xd4>
    600e:	98 2f       	mov	r25, r24
    6010:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6012:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6016:	80 91 e8 00 	lds	r24, 0x00E8
    601a:	87 7f       	andi	r24, 0xF7	; 247
    601c:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    6020:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
    6024:	10 92 f1 00 	sts	0x00F1, r1
    6028:	d2 c0       	rjmp	.+420    	; 0x61ce <USB_Device_ProcessControlRequest+0x29c>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    602a:	88 23       	and	r24, r24
    602c:	19 f0       	breq	.+6      	; 0x6034 <USB_Device_ProcessControlRequest+0x102>
    602e:	82 30       	cpi	r24, 0x02	; 2
    6030:	09 f0       	breq	.+2      	; 0x6034 <USB_Device_ProcessControlRequest+0x102>
    6032:	f2 c0       	rjmp	.+484    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    6034:	90 e0       	ldi	r25, 0x00	; 0
    6036:	8f 71       	andi	r24, 0x1F	; 31
    6038:	90 70       	andi	r25, 0x00	; 0
    603a:	00 97       	sbiw	r24, 0x00	; 0
    603c:	21 f0       	breq	.+8      	; 0x6046 <USB_Device_ProcessControlRequest+0x114>
    603e:	02 97       	sbiw	r24, 0x02	; 2
    6040:	09 f0       	breq	.+2      	; 0x6044 <USB_Device_ProcessControlRequest+0x112>
    6042:	ea c0       	rjmp	.+468    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
    6044:	0c c0       	rjmp	.+24     	; 0x605e <USB_Device_ProcessControlRequest+0x12c>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    6046:	80 91 a6 0d 	lds	r24, 0x0DA6
    604a:	81 30       	cpi	r24, 0x01	; 1
    604c:	09 f0       	breq	.+2      	; 0x6050 <USB_Device_ProcessControlRequest+0x11e>
    604e:	e4 c0       	rjmp	.+456    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    6050:	10 92 a1 0d 	sts	0x0DA1, r1
    6054:	33 30       	cpi	r19, 0x03	; 3
    6056:	69 f5       	brne	.+90     	; 0x60b2 <USB_Device_ProcessControlRequest+0x180>
    6058:	80 93 a1 0d 	sts	0x0DA1, r24
    605c:	2a c0       	rjmp	.+84     	; 0x60b2 <USB_Device_ProcessControlRequest+0x180>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    605e:	80 91 a6 0d 	lds	r24, 0x0DA6
    6062:	88 23       	and	r24, r24
    6064:	31 f5       	brne	.+76     	; 0x60b2 <USB_Device_ProcessControlRequest+0x180>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    6066:	20 91 a8 0d 	lds	r18, 0x0DA8
    606a:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    606c:	09 f4       	brne	.+2      	; 0x6070 <USB_Device_ProcessControlRequest+0x13e>
    606e:	d4 c0       	rjmp	.+424    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6070:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    6074:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    6078:	80 ff       	sbrs	r24, 0
    607a:	1b c0       	rjmp	.+54     	; 0x60b2 <USB_Device_ProcessControlRequest+0x180>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    607c:	33 30       	cpi	r19, 0x03	; 3
    607e:	21 f4       	brne	.+8      	; 0x6088 <USB_Device_ProcessControlRequest+0x156>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6080:	80 91 eb 00 	lds	r24, 0x00EB
    6084:	80 62       	ori	r24, 0x20	; 32
    6086:	13 c0       	rjmp	.+38     	; 0x60ae <USB_Device_ProcessControlRequest+0x17c>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6088:	80 91 eb 00 	lds	r24, 0x00EB
    608c:	80 61       	ori	r24, 0x10	; 16
    608e:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    6092:	81 e0       	ldi	r24, 0x01	; 1
    6094:	90 e0       	ldi	r25, 0x00	; 0
    6096:	02 c0       	rjmp	.+4      	; 0x609c <USB_Device_ProcessControlRequest+0x16a>
    6098:	88 0f       	add	r24, r24
    609a:	99 1f       	adc	r25, r25
    609c:	2a 95       	dec	r18
    609e:	e2 f7       	brpl	.-8      	; 0x6098 <USB_Device_ProcessControlRequest+0x166>
    60a0:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    60a4:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    60a8:	80 91 eb 00 	lds	r24, 0x00EB
    60ac:	88 60       	ori	r24, 0x08	; 8
    60ae:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    60b2:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    60b6:	80 91 e8 00 	lds	r24, 0x00E8
    60ba:	87 7f       	andi	r24, 0xF7	; 247
    60bc:	8b c0       	rjmp	.+278    	; 0x61d4 <USB_Device_ProcessControlRequest+0x2a2>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    60be:	88 23       	and	r24, r24
    60c0:	09 f0       	breq	.+2      	; 0x60c4 <USB_Device_ProcessControlRequest+0x192>
    60c2:	aa c0       	rjmp	.+340    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    60c4:	10 91 a6 0d 	lds	r17, 0x0DA6
    60c8:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    60ca:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    60cc:	f8 94       	cli
    60ce:	80 91 e8 00 	lds	r24, 0x00E8
    60d2:	87 7f       	andi	r24, 0xF7	; 247
    60d4:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    60d8:	0e 94 82 26 	call	0x4d04	; 0x4d04 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    60dc:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    60e0:	80 ff       	sbrs	r24, 0
    60e2:	fc cf       	rjmp	.-8      	; 0x60dc <USB_Device_ProcessControlRequest+0x1aa>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    60e4:	80 91 e3 00 	lds	r24, 0x00E3
    60e8:	80 78       	andi	r24, 0x80	; 128
    60ea:	81 2b       	or	r24, r17

				UDADDR = Temp;
    60ec:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR = Temp | (1 << ADDEN);
    60f0:	80 68       	ori	r24, 0x80	; 128
    60f2:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    60f6:	11 23       	and	r17, r17
    60f8:	11 f4       	brne	.+4      	; 0x60fe <USB_Device_ProcessControlRequest+0x1cc>
    60fa:	82 e0       	ldi	r24, 0x02	; 2
    60fc:	01 c0       	rjmp	.+2      	; 0x6100 <USB_Device_ProcessControlRequest+0x1ce>
    60fe:	83 e0       	ldi	r24, 0x03	; 3
    6100:	8e bb       	out	0x1e, r24	; 30
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    6102:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    6104:	89 c0       	rjmp	.+274    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6106:	80 58       	subi	r24, 0x80	; 128
    6108:	82 30       	cpi	r24, 0x02	; 2
    610a:	08 f0       	brcs	.+2      	; 0x610e <USB_Device_ProcessControlRequest+0x1dc>
    610c:	85 c0       	rjmp	.+266    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    610e:	80 91 a6 0d 	lds	r24, 0x0DA6
    6112:	90 91 a7 0d 	lds	r25, 0x0DA7
    6116:	23 e0       	ldi	r18, 0x03	; 3
    6118:	8c 3d       	cpi	r24, 0xDC	; 220
    611a:	92 07       	cpc	r25, r18
    611c:	09 f0       	breq	.+2      	; 0x6120 <USB_Device_ProcessControlRequest+0x1ee>
    611e:	33 c0       	rjmp	.+102    	; 0x6186 <USB_Device_ProcessControlRequest+0x254>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    6120:	83 e0       	ldi	r24, 0x03	; 3
    6122:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    6124:	8a e2       	ldi	r24, 0x2A	; 42
    6126:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    6128:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    612a:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    612c:	de 01       	movw	r26, r28
    612e:	15 96       	adiw	r26, 0x05	; 5
    6130:	6e e0       	ldi	r22, 0x0E	; 14
    6132:	40 e0       	ldi	r20, 0x00	; 0
    6134:	50 e0       	ldi	r21, 0x00	; 0
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    6136:	11 e2       	ldi	r17, 0x21	; 33
    6138:	e6 2f       	mov	r30, r22
    613a:	f0 e0       	ldi	r31, 0x00	; 0
    613c:	10 93 57 00 	sts	0x0057, r17
    6140:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
    6142:	40 ff       	sbrs	r20, 0
    6144:	03 c0       	rjmp	.+6      	; 0x614c <USB_Device_ProcessControlRequest+0x21a>
					{
						SerialByte >>= 4;
    6146:	82 95       	swap	r24
    6148:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    614a:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    614c:	8f 70       	andi	r24, 0x0F	; 15
    614e:	28 2f       	mov	r18, r24
    6150:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    6152:	8a 30       	cpi	r24, 0x0A	; 10
    6154:	18 f0       	brcs	.+6      	; 0x615c <USB_Device_ProcessControlRequest+0x22a>
    6156:	c9 01       	movw	r24, r18
    6158:	c7 96       	adiw	r24, 0x37	; 55
    615a:	02 c0       	rjmp	.+4      	; 0x6160 <USB_Device_ProcessControlRequest+0x22e>
    615c:	c9 01       	movw	r24, r18
    615e:	c0 96       	adiw	r24, 0x30	; 48
    6160:	8d 93       	st	X+, r24
    6162:	9d 93       	st	X+, r25
    6164:	4f 5f       	subi	r20, 0xFF	; 255
    6166:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    6168:	44 31       	cpi	r20, 0x14	; 20
    616a:	51 05       	cpc	r21, r1
    616c:	29 f7       	brne	.-54     	; 0x6138 <USB_Device_ProcessControlRequest+0x206>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    616e:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6170:	80 91 e8 00 	lds	r24, 0x00E8
    6174:	87 7f       	andi	r24, 0xF7	; 247
    6176:	80 93 e8 00 	sts	0x00E8, r24
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    617a:	ce 01       	movw	r24, r28
    617c:	03 96       	adiw	r24, 0x03	; 3
    617e:	6a e2       	ldi	r22, 0x2A	; 42
    6180:	70 e0       	ldi	r23, 0x00	; 0
    6182:	26 db       	rcall	.-2484   	; 0x57d0 <Endpoint_Write_Control_Stream_LE>
    6184:	13 c0       	rjmp	.+38     	; 0x61ac <USB_Device_ProcessControlRequest+0x27a>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    6186:	60 91 a8 0d 	lds	r22, 0x0DA8
    618a:	ae 01       	movw	r20, r28
    618c:	4f 5f       	subi	r20, 0xFF	; 255
    618e:	5f 4f       	sbci	r21, 0xFF	; 255
    6190:	0e 94 67 02 	call	0x4ce	; 0x4ce <CALLBACK_USB_GetDescriptor>
    6194:	bc 01       	movw	r22, r24
    6196:	00 97       	sbiw	r24, 0x00	; 0
    6198:	09 f4       	brne	.+2      	; 0x619c <USB_Device_ProcessControlRequest+0x26a>
    619a:	3e c0       	rjmp	.+124    	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
    619c:	80 91 e8 00 	lds	r24, 0x00E8
    61a0:	87 7f       	andi	r24, 0xF7	; 247
    61a2:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    61a6:	89 81       	ldd	r24, Y+1	; 0x01
    61a8:	9a 81       	ldd	r25, Y+2	; 0x02
    61aa:	ad db       	rcall	.-2214   	; 0x5906 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    61ac:	80 91 e8 00 	lds	r24, 0x00E8
    61b0:	8b 77       	andi	r24, 0x7B	; 123
    61b2:	80 93 e8 00 	sts	0x00E8, r24
    61b6:	30 c0       	rjmp	.+96     	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    61b8:	80 38       	cpi	r24, 0x80	; 128
    61ba:	71 f5       	brne	.+92     	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    61bc:	80 91 e8 00 	lds	r24, 0x00E8
    61c0:	87 7f       	andi	r24, 0xF7	; 247
    61c2:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    61c6:	80 91 9f 0d 	lds	r24, 0x0D9F
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    61ca:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    61ce:	80 91 e8 00 	lds	r24, 0x00E8
    61d2:	8e 77       	andi	r24, 0x7E	; 126
    61d4:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    61d8:	0e 94 82 26 	call	0x4d04	; 0x4d04 <Endpoint_ClearStatusStage>
    61dc:	1d c0       	rjmp	.+58     	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    61de:	88 23       	and	r24, r24
    61e0:	d9 f4       	brne	.+54     	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    61e2:	90 91 a6 0d 	lds	r25, 0x0DA6
    61e6:	92 30       	cpi	r25, 0x02	; 2
    61e8:	b8 f4       	brcc	.+46     	; 0x6218 <USB_Device_ProcessControlRequest+0x2e6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    61ea:	80 91 e8 00 	lds	r24, 0x00E8
    61ee:	87 7f       	andi	r24, 0xF7	; 247
    61f0:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    61f4:	90 93 9f 0d 	sts	0x0D9F, r25

	Endpoint_ClearStatusStage();
    61f8:	0e 94 82 26 	call	0x4d04	; 0x4d04 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    61fc:	80 91 9f 0d 	lds	r24, 0x0D9F
    6200:	88 23       	and	r24, r24
    6202:	31 f4       	brne	.+12     	; 0x6210 <USB_Device_ProcessControlRequest+0x2de>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6204:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    6208:	87 fd       	sbrc	r24, 7
    620a:	02 c0       	rjmp	.+4      	; 0x6210 <USB_Device_ProcessControlRequest+0x2de>
    620c:	81 e0       	ldi	r24, 0x01	; 1
    620e:	01 c0       	rjmp	.+2      	; 0x6212 <USB_Device_ProcessControlRequest+0x2e0>
    6210:	84 e0       	ldi	r24, 0x04	; 4
    6212:	8e bb       	out	0x1e, r24	; 30

	EVENT_USB_Device_ConfigurationChanged();
    6214:	0e 94 ac 02 	call	0x558	; 0x558 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6218:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    621c:	83 ff       	sbrs	r24, 3
    621e:	0a c0       	rjmp	.+20     	; 0x6234 <USB_Device_ProcessControlRequest+0x302>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6220:	80 91 eb 00 	lds	r24, 0x00EB
    6224:	80 62       	ori	r24, 0x20	; 32
    6226:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    622a:	80 91 e8 00 	lds	r24, 0x00E8
    622e:	87 7f       	andi	r24, 0xF7	; 247
    6230:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    6234:	ac 96       	adiw	r28, 0x2c	; 44
    6236:	0f b6       	in	r0, 0x3f	; 63
    6238:	f8 94       	cli
    623a:	de bf       	out	0x3e, r29	; 62
    623c:	0f be       	out	0x3f, r0	; 63
    623e:	cd bf       	out	0x3d, r28	; 61
    6240:	cf 91       	pop	r28
    6242:	df 91       	pop	r29
    6244:	1f 91       	pop	r17
    6246:	0f 91       	pop	r16
    6248:	08 95       	ret

0000624a <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    624a:	08 95       	ret

0000624c <USB_Host_WaitForIOS>:

	return ReturnStatus;
}

static uint8_t USB_Host_WaitForIOS(const uint8_t WaitType)
{
    624c:	1f 93       	push	r17
    624e:	cf 93       	push	r28
    6250:	df 93       	push	r29
    6252:	18 2f       	mov	r17, r24
    6254:	c8 ee       	ldi	r28, 0xE8	; 232
    6256:	d3 e0       	ldi	r29, 0x03	; 3
    6258:	0a c0       	rjmp	.+20     	; 0x626e <USB_Host_WaitForIOS+0x22>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
	{
		uint8_t ErrorCode;

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    625a:	81 e0       	ldi	r24, 0x01	; 1
    625c:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <USB_Host_WaitMS>
    6260:	88 23       	and	r24, r24
    6262:	d1 f4       	brne	.+52     	; 0x6298 <USB_Host_WaitForIOS+0x4c>
		  return ErrorCode;

		if (!(TimeoutCounter--))
    6264:	20 97       	sbiw	r28, 0x00	; 0
    6266:	11 f4       	brne	.+4      	; 0x626c <USB_Host_WaitForIOS+0x20>
    6268:	84 e0       	ldi	r24, 0x04	; 4
    626a:	16 c0       	rjmp	.+44     	; 0x6298 <USB_Host_WaitForIOS+0x4c>
    626c:	21 97       	sbiw	r28, 0x01	; 1
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    626e:	11 23       	and	r17, r17
    6270:	29 f4       	brne	.+10     	; 0x627c <USB_Host_WaitForIOS+0x30>
			 *  \return Boolean \c true if the current pipe is ready for a SETUP packet, \c false otherwise.
			 */
			static inline bool Pipe_IsSETUPSent(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsSETUPSent(void)
			{
				return ((UPINTX & (1 << TXSTPI)) ? true : false);
    6272:	80 91 a6 00 	lds	r24, 0x00A6
    6276:	83 ff       	sbrs	r24, 3
    6278:	f0 cf       	rjmp	.-32     	; 0x625a <USB_Host_WaitForIOS+0xe>
    627a:	0d c0       	rjmp	.+26     	; 0x6296 <USB_Host_WaitForIOS+0x4a>
    627c:	11 30       	cpi	r17, 0x01	; 1
    627e:	29 f4       	brne	.+10     	; 0x628a <USB_Host_WaitForIOS+0x3e>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    6280:	80 91 a6 00 	lds	r24, 0x00A6
    6284:	80 ff       	sbrs	r24, 0
    6286:	e9 cf       	rjmp	.-46     	; 0x625a <USB_Host_WaitForIOS+0xe>
    6288:	06 c0       	rjmp	.+12     	; 0x6296 <USB_Host_WaitForIOS+0x4a>
    628a:	12 30       	cpi	r17, 0x02	; 2
    628c:	31 f7       	brne	.-52     	; 0x625a <USB_Host_WaitForIOS+0xe>
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    628e:	80 91 a6 00 	lds	r24, 0x00A6
    6292:	82 ff       	sbrs	r24, 2
    6294:	e2 cf       	rjmp	.-60     	; 0x625a <USB_Host_WaitForIOS+0xe>
    6296:	80 e0       	ldi	r24, 0x00	; 0
		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
	}

	return HOST_SENDCONTROL_Successful;
}
    6298:	df 91       	pop	r29
    629a:	cf 91       	pop	r28
    629c:	1f 91       	pop	r17
    629e:	08 95       	ret

000062a0 <USB_Host_SendControlRequest>:
#include "HostStandardReq.h"

uint8_t USB_Host_ConfigurationNumber;

uint8_t USB_Host_SendControlRequest(void* const BufferPtr)
{
    62a0:	ff 92       	push	r15
    62a2:	0f 93       	push	r16
    62a4:	1f 93       	push	r17
    62a6:	cf 93       	push	r28
    62a8:	df 93       	push	r29
    62aa:	8c 01       	movw	r16, r24
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    62ac:	f0 90 9e 00 	lds	r15, 0x009E
	uint8_t* DataStream   = (uint8_t*)BufferPtr;
	bool     BusSuspended = USB_Host_IsBusSuspended();
	uint8_t  ReturnStatus = HOST_SENDCONTROL_Successful;
	uint16_t DataLen      = USB_ControlRequest.wLength;
    62b0:	c0 91 aa 0d 	lds	r28, 0x0DAA
    62b4:	d0 91 ab 0d 	lds	r29, 0x0DAB
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    62b8:	80 91 9e 00 	lds	r24, 0x009E
    62bc:	81 60       	ori	r24, 0x01	; 1
    62be:	80 93 9e 00 	sts	0x009E, r24

	USB_Host_ResumeBus();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    62c2:	81 e0       	ldi	r24, 0x01	; 1
    62c4:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <USB_Host_WaitMS>
    62c8:	98 2f       	mov	r25, r24
    62ca:	88 23       	and	r24, r24
    62cc:	09 f0       	breq	.+2      	; 0x62d0 <USB_Host_SendControlRequest+0x30>
    62ce:	f1 c0       	rjmp	.+482    	; 0x64b2 <USB_Host_SendControlRequest+0x212>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    62d0:	80 91 aa 00 	lds	r24, 0x00AA
    62d4:	8f 7c       	andi	r24, 0xCF	; 207
    62d6:	80 93 aa 00 	sts	0x00AA, r24

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    62da:	10 92 f5 00 	sts	0x00F5, r1
				UPINTX &= ~(1 << PERRI);
    62de:	80 91 a6 00 	lds	r24, 0x00A6
    62e2:	8f 7e       	andi	r24, 0xEF	; 239
    62e4:	80 93 a6 00 	sts	0x00A6, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    62e8:	80 91 a9 00 	lds	r24, 0x00A9
    62ec:	8f 7b       	andi	r24, 0xBF	; 191
    62ee:	80 93 a9 00 	sts	0x00A9, r24
	Pipe_SetPipeToken(PIPE_TOKEN_SETUP);
	Pipe_ClearError();

	Pipe_Unfreeze();

	Pipe_Write_8(USB_ControlRequest.bmRequestType);
    62f2:	80 91 a4 0d 	lds	r24, 0x0DA4
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    62f6:	80 93 af 00 	sts	0x00AF, r24
	Pipe_Write_8(USB_ControlRequest.bRequest);
    62fa:	80 91 a5 0d 	lds	r24, 0x0DA5
    62fe:	80 93 af 00 	sts	0x00AF, r24
	Pipe_Write_16_LE(USB_ControlRequest.wValue);
    6302:	80 91 a6 0d 	lds	r24, 0x0DA6
    6306:	90 91 a7 0d 	lds	r25, 0x0DA7
			 *  \param[in] Data  Data to write to the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_16_LE(const uint16_t Data)
			{
				UPDATX = (Data & 0xFF);
    630a:	80 93 af 00 	sts	0x00AF, r24
				UPDATX = (Data >> 8);
    630e:	89 2f       	mov	r24, r25
    6310:	99 27       	eor	r25, r25
    6312:	80 93 af 00 	sts	0x00AF, r24
	Pipe_Write_16_LE(USB_ControlRequest.wIndex);
    6316:	80 91 a8 0d 	lds	r24, 0x0DA8
    631a:	90 91 a9 0d 	lds	r25, 0x0DA9
			 *  \param[in] Data  Data to write to the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_16_LE(const uint16_t Data)
			{
				UPDATX = (Data & 0xFF);
    631e:	80 93 af 00 	sts	0x00AF, r24
				UPDATX = (Data >> 8);
    6322:	89 2f       	mov	r24, r25
    6324:	99 27       	eor	r25, r25
    6326:	80 93 af 00 	sts	0x00AF, r24
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
    632a:	80 91 aa 0d 	lds	r24, 0x0DAA
    632e:	90 91 ab 0d 	lds	r25, 0x0DAB
			 *  \param[in] Data  Data to write to the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_16_LE(const uint16_t Data)
			{
				UPDATX = (Data & 0xFF);
    6332:	80 93 af 00 	sts	0x00AF, r24
				UPDATX = (Data >> 8);
    6336:	89 2f       	mov	r24, r25
    6338:	99 27       	eor	r25, r25
    633a:	80 93 af 00 	sts	0x00AF, r24
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearSETUP(void)
			{
				UPINTX &= ~((1 << TXSTPI) | (1 << FIFOCON));
    633e:	80 91 a6 00 	lds	r24, 0x00A6
    6342:	87 77       	andi	r24, 0x77	; 119
    6344:	80 93 a6 00 	sts	0x00A6, r24

	Pipe_ClearSETUP();

	if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_SetupSent)) != HOST_SENDCONTROL_Successful)
    6348:	80 e0       	ldi	r24, 0x00	; 0
    634a:	80 df       	rcall	.-256    	; 0x624c <USB_Host_WaitForIOS>
    634c:	98 2f       	mov	r25, r24
    634e:	88 23       	and	r24, r24
    6350:	09 f0       	breq	.+2      	; 0x6354 <USB_Host_SendControlRequest+0xb4>
    6352:	af c0       	rjmp	.+350    	; 0x64b2 <USB_Host_SendControlRequest+0x212>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    6354:	80 91 a9 00 	lds	r24, 0x00A9
    6358:	80 64       	ori	r24, 0x40	; 64
    635a:	80 93 a9 00 	sts	0x00A9, r24
	  goto End_Of_Control_Send;

	Pipe_Freeze();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    635e:	81 e0       	ldi	r24, 0x01	; 1
    6360:	0e 94 d3 26 	call	0x4da6	; 0x4da6 <USB_Host_WaitMS>
    6364:	98 2f       	mov	r25, r24
    6366:	88 23       	and	r24, r24
    6368:	09 f0       	breq	.+2      	; 0x636c <USB_Host_SendControlRequest+0xcc>
    636a:	a3 c0       	rjmp	.+326    	; 0x64b2 <USB_Host_SendControlRequest+0x212>
	  goto End_Of_Control_Send;

	if ((USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION) == REQDIR_DEVICETOHOST)
    636c:	80 91 a4 0d 	lds	r24, 0x0DA4
    6370:	87 ff       	sbrs	r24, 7
    6372:	52 c0       	rjmp	.+164    	; 0x6418 <USB_Host_SendControlRequest+0x178>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    6374:	80 91 aa 00 	lds	r24, 0x00AA
    6378:	8f 7c       	andi	r24, 0xCF	; 207
    637a:	80 61       	ori	r24, 0x10	; 16
    637c:	80 93 aa 00 	sts	0x00AA, r24
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
    6380:	01 15       	cp	r16, r1
    6382:	11 05       	cpc	r17, r1
    6384:	69 f5       	brne	.+90     	; 0x63e0 <USB_Host_SendControlRequest+0x140>
    6386:	2e c0       	rjmp	.+92     	; 0x63e4 <USB_Host_SendControlRequest+0x144>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    6388:	80 91 a9 00 	lds	r24, 0x00A9
    638c:	8f 7b       	andi	r24, 0xBF	; 191
    638e:	80 93 a9 00 	sts	0x00A9, r24
		{
			while (DataLen)
			{
				Pipe_Unfreeze();

				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    6392:	81 e0       	ldi	r24, 0x01	; 1
    6394:	5b df       	rcall	.-330    	; 0x624c <USB_Host_WaitForIOS>
    6396:	98 2f       	mov	r25, r24
    6398:	88 23       	and	r24, r24
    639a:	09 f0       	breq	.+2      	; 0x639e <USB_Host_SendControlRequest+0xfe>
    639c:	8a c0       	rjmp	.+276    	; 0x64b2 <USB_Host_SendControlRequest+0x212>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    639e:	80 91 f6 00 	lds	r24, 0x00F6
    63a2:	90 91 f7 00 	lds	r25, 0x00F7
				  goto End_Of_Control_Send;

				if (!(Pipe_BytesInPipe()))
    63a6:	89 2b       	or	r24, r25
    63a8:	49 f4       	brne	.+18     	; 0x63bc <USB_Host_SendControlRequest+0x11c>
    63aa:	c0 e0       	ldi	r28, 0x00	; 0
    63ac:	d0 e0       	ldi	r29, 0x00	; 0
    63ae:	06 c0       	rjmp	.+12     	; 0x63bc <USB_Host_SendControlRequest+0x11c>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    63b0:	80 91 af 00 	lds	r24, 0x00AF
				  DataLen = 0;

				while (Pipe_BytesInPipe() && DataLen)
				{
					*(DataStream++) = Pipe_Read_8();
    63b4:	f8 01       	movw	r30, r16
    63b6:	81 93       	st	Z+, r24
    63b8:	8f 01       	movw	r16, r30
					DataLen--;
    63ba:	21 97       	sbiw	r28, 0x01	; 1
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    63bc:	80 91 f6 00 	lds	r24, 0x00F6
    63c0:	90 91 f7 00 	lds	r25, 0x00F7
				  goto End_Of_Control_Send;

				if (!(Pipe_BytesInPipe()))
				  DataLen = 0;

				while (Pipe_BytesInPipe() && DataLen)
    63c4:	89 2b       	or	r24, r25
    63c6:	11 f0       	breq	.+4      	; 0x63cc <USB_Host_SendControlRequest+0x12c>
    63c8:	20 97       	sbiw	r28, 0x00	; 0
    63ca:	91 f7       	brne	.-28     	; 0x63b0 <USB_Host_SendControlRequest+0x110>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    63cc:	80 91 a9 00 	lds	r24, 0x00A9
    63d0:	80 64       	ori	r24, 0x40	; 64
    63d2:	80 93 a9 00 	sts	0x00A9, r24
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    63d6:	80 91 a6 00 	lds	r24, 0x00A6
    63da:	8e 77       	andi	r24, 0x7E	; 126
    63dc:	80 93 a6 00 	sts	0x00A6, r24
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
		{
			while (DataLen)
    63e0:	20 97       	sbiw	r28, 0x00	; 0
    63e2:	91 f6       	brne	.-92     	; 0x6388 <USB_Host_SendControlRequest+0xe8>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    63e4:	80 91 aa 00 	lds	r24, 0x00AA
    63e8:	8f 7c       	andi	r24, 0xCF	; 207
    63ea:	80 62       	ori	r24, 0x20	; 32
    63ec:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    63f0:	80 91 a9 00 	lds	r24, 0x00A9
    63f4:	8f 7b       	andi	r24, 0xBF	; 191
    63f6:	80 93 a9 00 	sts	0x00A9, r24
		}

		Pipe_SetPipeToken(PIPE_TOKEN_OUT);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    63fa:	82 e0       	ldi	r24, 0x02	; 2
    63fc:	27 df       	rcall	.-434    	; 0x624c <USB_Host_WaitForIOS>
    63fe:	98 2f       	mov	r25, r24
    6400:	88 23       	and	r24, r24
    6402:	09 f0       	breq	.+2      	; 0x6406 <USB_Host_SendControlRequest+0x166>
    6404:	56 c0       	rjmp	.+172    	; 0x64b2 <USB_Host_SendControlRequest+0x212>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    6406:	80 91 a6 00 	lds	r24, 0x00A6
    640a:	8b 77       	andi	r24, 0x7B	; 123
    640c:	80 93 a6 00 	sts	0x00A6, r24
		  goto End_Of_Control_Send;

		Pipe_ClearOUT();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6410:	82 e0       	ldi	r24, 0x02	; 2
    6412:	1c df       	rcall	.-456    	; 0x624c <USB_Host_WaitForIOS>
    6414:	98 2f       	mov	r25, r24
    6416:	4d c0       	rjmp	.+154    	; 0x64b2 <USB_Host_SendControlRequest+0x212>
		  goto End_Of_Control_Send;
	}
	else
	{
		if (DataStream != NULL)
    6418:	01 15       	cp	r16, r1
    641a:	11 05       	cpc	r17, r1
    641c:	a9 f1       	breq	.+106    	; 0x6488 <USB_Host_SendControlRequest+0x1e8>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    641e:	80 91 aa 00 	lds	r24, 0x00AA
    6422:	8f 7c       	andi	r24, 0xCF	; 207
    6424:	80 62       	ori	r24, 0x20	; 32
    6426:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    642a:	80 91 a9 00 	lds	r24, 0x00A9
    642e:	8f 7b       	andi	r24, 0xBF	; 191
    6430:	80 93 a9 00 	sts	0x00A9, r24
    6434:	1d c0       	rjmp	.+58     	; 0x6470 <USB_Host_SendControlRequest+0x1d0>
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6436:	82 e0       	ldi	r24, 0x02	; 2
    6438:	09 df       	rcall	.-494    	; 0x624c <USB_Host_WaitForIOS>
    643a:	98 2f       	mov	r25, r24
    643c:	88 23       	and	r24, r24
    643e:	c9 f5       	brne	.+114    	; 0x64b2 <USB_Host_SendControlRequest+0x212>
				  goto End_Of_Control_Send;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
    6440:	80 91 42 03 	lds	r24, 0x0342
    6444:	28 2f       	mov	r18, r24
    6446:	30 e0       	ldi	r19, 0x00	; 0
    6448:	07 c0       	rjmp	.+14     	; 0x6458 <USB_Host_SendControlRequest+0x1b8>
				{
					Pipe_Write_8(*(DataStream++));
    644a:	f8 01       	movw	r30, r16
    644c:	81 91       	ld	r24, Z+
    644e:	8f 01       	movw	r16, r30
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    6450:	80 93 af 00 	sts	0x00AF, r24
					DataLen--;
    6454:	21 97       	sbiw	r28, 0x01	; 1
			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
				  goto End_Of_Control_Send;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
    6456:	39 f0       	breq	.+14     	; 0x6466 <USB_Host_SendControlRequest+0x1c6>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    6458:	80 91 f6 00 	lds	r24, 0x00F6
    645c:	90 91 f7 00 	lds	r25, 0x00F7
    6460:	82 17       	cp	r24, r18
    6462:	93 07       	cpc	r25, r19
    6464:	90 f3       	brcs	.-28     	; 0x644a <USB_Host_SendControlRequest+0x1aa>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    6466:	80 91 a6 00 	lds	r24, 0x00A6
    646a:	8b 77       	andi	r24, 0x7B	; 123
    646c:	80 93 a6 00 	sts	0x00A6, r24
		if (DataStream != NULL)
		{
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
    6470:	20 97       	sbiw	r28, 0x00	; 0
    6472:	09 f7       	brne	.-62     	; 0x6436 <USB_Host_SendControlRequest+0x196>
				}

				Pipe_ClearOUT();
			}

			if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6474:	82 e0       	ldi	r24, 0x02	; 2
    6476:	ea de       	rcall	.-556    	; 0x624c <USB_Host_WaitForIOS>
    6478:	98 2f       	mov	r25, r24
    647a:	88 23       	and	r24, r24
    647c:	d1 f4       	brne	.+52     	; 0x64b2 <USB_Host_SendControlRequest+0x212>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    647e:	80 91 a9 00 	lds	r24, 0x00A9
    6482:	80 64       	ori	r24, 0x40	; 64
    6484:	80 93 a9 00 	sts	0x00A9, r24
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    6488:	80 91 aa 00 	lds	r24, 0x00AA
    648c:	8f 7c       	andi	r24, 0xCF	; 207
    648e:	80 61       	ori	r24, 0x10	; 16
    6490:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    6494:	80 91 a9 00 	lds	r24, 0x00A9
    6498:	8f 7b       	andi	r24, 0xBF	; 191
    649a:	80 93 a9 00 	sts	0x00A9, r24
		}

		Pipe_SetPipeToken(PIPE_TOKEN_IN);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    649e:	81 e0       	ldi	r24, 0x01	; 1
    64a0:	d5 de       	rcall	.-598    	; 0x624c <USB_Host_WaitForIOS>
    64a2:	98 2f       	mov	r25, r24
    64a4:	88 23       	and	r24, r24
    64a6:	29 f4       	brne	.+10     	; 0x64b2 <USB_Host_SendControlRequest+0x212>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    64a8:	80 91 a6 00 	lds	r24, 0x00A6
    64ac:	8e 77       	andi	r24, 0x7E	; 126
    64ae:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    64b2:	80 91 a9 00 	lds	r24, 0x00A9
    64b6:	80 64       	ori	r24, 0x40	; 64
    64b8:	80 93 a9 00 	sts	0x00A9, r24
	}

End_Of_Control_Send:
	Pipe_Freeze();

	if (BusSuspended)
    64bc:	f0 fc       	sbrc	r15, 0
    64be:	05 c0       	rjmp	.+10     	; 0x64ca <USB_Host_SendControlRequest+0x22a>
			 *        some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    64c0:	80 91 9e 00 	lds	r24, 0x009E
    64c4:	8e 7f       	andi	r24, 0xFE	; 254
    64c6:	80 93 9e 00 	sts	0x009E, r24
			 *  \param[in] PipeNumber  Index of the pipe to reset.
			 */
			static inline void Pipe_ResetPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ResetPipe(const uint8_t PipeNumber)
			{
				UPRST = (1 << PipeNumber);
    64ca:	81 e0       	ldi	r24, 0x01	; 1
    64cc:	80 93 a8 00 	sts	0x00A8, r24
				UPRST = 0;
    64d0:	10 92 a8 00 	sts	0x00A8, r1
	  USB_Host_SuspendBus();

	Pipe_ResetPipe(PIPE_CONTROLPIPE);

	return ReturnStatus;
}
    64d4:	89 2f       	mov	r24, r25
    64d6:	df 91       	pop	r29
    64d8:	cf 91       	pop	r28
    64da:	1f 91       	pop	r17
    64dc:	0f 91       	pop	r16
    64de:	ff 90       	pop	r15
    64e0:	08 95       	ret

000064e2 <USB_Host_SetDeviceConfiguration>:

	return HOST_SENDCONTROL_Successful;
}

uint8_t USB_Host_SetDeviceConfiguration(const uint8_t ConfigNumber)
{
    64e2:	1f 93       	push	r17
    64e4:	18 2f       	mov	r17, r24
	uint8_t ErrorCode;

	USB_ControlRequest = (USB_Request_Header_t)
    64e6:	10 92 a4 0d 	sts	0x0DA4, r1
    64ea:	89 e0       	ldi	r24, 0x09	; 9
    64ec:	80 93 a5 0d 	sts	0x0DA5, r24
    64f0:	81 2f       	mov	r24, r17
    64f2:	90 e0       	ldi	r25, 0x00	; 0
    64f4:	90 93 a7 0d 	sts	0x0DA7, r25
    64f8:	80 93 a6 0d 	sts	0x0DA6, r24
    64fc:	10 92 a9 0d 	sts	0x0DA9, r1
    6500:	10 92 a8 0d 	sts	0x0DA8, r1
    6504:	10 92 ab 0d 	sts	0x0DAB, r1
    6508:	10 92 aa 0d 	sts	0x0DAA, r1
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    650c:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = 0,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);
	
	if ((ErrorCode = USB_Host_SendControlRequest(NULL)) == HOST_SENDCONTROL_Successful)
    6510:	80 e0       	ldi	r24, 0x00	; 0
    6512:	90 e0       	ldi	r25, 0x00	; 0
    6514:	c5 de       	rcall	.-630    	; 0x62a0 <USB_Host_SendControlRequest>
    6516:	88 23       	and	r24, r24
    6518:	49 f4       	brne	.+18     	; 0x652c <USB_Host_SetDeviceConfiguration+0x4a>
	{
		USB_Host_ConfigurationNumber = ConfigNumber;
    651a:	10 93 a2 0d 	sts	0x0DA2, r17
		USB_HostState                = (ConfigNumber) ? HOST_STATE_Configured : HOST_STATE_Addressed;
    651e:	11 23       	and	r17, r17
    6520:	11 f4       	brne	.+4      	; 0x6526 <USB_Host_SetDeviceConfiguration+0x44>
    6522:	9a e0       	ldi	r25, 0x0A	; 10
    6524:	01 c0       	rjmp	.+2      	; 0x6528 <USB_Host_SetDeviceConfiguration+0x46>
    6526:	9b e0       	ldi	r25, 0x0B	; 11
    6528:	90 93 ac 0d 	sts	0x0DAC, r25
	}

	return ErrorCode;
}
    652c:	1f 91       	pop	r17
    652e:	08 95       	ret

00006530 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    6530:	1f 93       	push	r17
	#if defined(USB_HOST_ONLY)
		USB_HostTask();
	#elif defined(USB_DEVICE_ONLY)
		USB_DeviceTask();
	#else
		if (USB_CurrentMode == USB_MODE_Device)
    6532:	80 91 cf 03 	lds	r24, 0x03CF
    6536:	81 30       	cpi	r24, 0x01	; 1
    6538:	81 f4       	brne	.+32     	; 0x655a <USB_USBTask+0x2a>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    653a:	8e b3       	in	r24, 0x1e	; 30
    653c:	88 23       	and	r24, r24
    653e:	d1 f0       	breq	.+52     	; 0x6574 <USB_USBTask+0x44>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    6540:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6544:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6548:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    654c:	83 ff       	sbrs	r24, 3
    654e:	01 c0       	rjmp	.+2      	; 0x6552 <USB_USBTask+0x22>
		  USB_Device_ProcessControlRequest();
    6550:	f0 dc       	rcall	.-1568   	; 0x5f32 <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    6552:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6554:	10 93 e9 00 	sts	0x00E9, r17
    6558:	0d c0       	rjmp	.+26     	; 0x6574 <USB_USBTask+0x44>
	#elif defined(USB_DEVICE_ONLY)
		USB_DeviceTask();
	#else
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
    655a:	80 91 cf 03 	lds	r24, 0x03CF
    655e:	82 30       	cpi	r24, 0x02	; 2
    6560:	49 f4       	brne	.+18     	; 0x6574 <USB_USBTask+0x44>
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return (UPNUM & PIPE_PIPENUM_MASK);
    6562:	10 91 a7 00 	lds	r17, 0x00A7
    6566:	17 70       	andi	r17, 0x07	; 7
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    6568:	10 92 a7 00 	sts	0x00A7, r1
{
	uint8_t PrevPipe = Pipe_GetCurrentPipe();

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	USB_Host_ProcessNextHostState();
    656c:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <USB_Host_ProcessNextHostState>
    6570:	10 93 a7 00 	sts	0x00A7, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    6574:	1f 91       	pop	r17
    6576:	08 95       	ret

00006578 <MS_Device_USBTask>:

	return true;
}

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6578:	cf 92       	push	r12
    657a:	df 92       	push	r13
    657c:	ef 92       	push	r14
    657e:	ff 92       	push	r15
    6580:	0f 93       	push	r16
    6582:	1f 93       	push	r17
    6584:	df 93       	push	r29
    6586:	cf 93       	push	r28
    6588:	00 d0       	rcall	.+0      	; 0x658a <MS_Device_USBTask+0x12>
    658a:	cd b7       	in	r28, 0x3d	; 61
    658c:	de b7       	in	r29, 0x3e	; 62
    658e:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    6590:	8e b3       	in	r24, 0x1e	; 30
    6592:	84 30       	cpi	r24, 0x04	; 4
    6594:	09 f0       	breq	.+2      	; 0x6598 <MS_Device_USBTask+0x20>
    6596:	07 c1       	rjmp	.+526    	; 0x67a6 <MS_Device_USBTask+0x22e>
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    6598:	f8 01       	movw	r30, r16
    659a:	95 81       	ldd	r25, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    659c:	90 93 e9 00 	sts	0x00E9, r25
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    65a0:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsReadWriteAllowed())
    65a4:	85 ff       	sbrs	r24, 5
    65a6:	c9 c0       	rjmp	.+402    	; 0x673a <MS_Device_USBTask+0x1c2>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    65a8:	90 93 e9 00 	sts	0x00E9, r25
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
	
	BytesProcessed = 0;
    65ac:	1a 82       	std	Y+2, r1	; 0x02
    65ae:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    65b0:	2a e0       	ldi	r18, 0x0A	; 10
    65b2:	e2 2e       	mov	r14, r18
    65b4:	f1 2c       	mov	r15, r1
    65b6:	e0 0e       	add	r14, r16
    65b8:	f1 1e       	adc	r15, r17
    65ba:	6e 01       	movw	r12, r28
    65bc:	08 94       	sec
    65be:	c1 1c       	adc	r12, r1
    65c0:	d1 1c       	adc	r13, r1
    65c2:	05 c0       	rjmp	.+10     	; 0x65ce <MS_Device_USBTask+0x56>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    65c4:	f8 01       	movw	r30, r16
    65c6:	86 a9       	ldd	r24, Z+54	; 0x36
    65c8:	88 23       	and	r24, r24
    65ca:	09 f0       	breq	.+2      	; 0x65ce <MS_Device_USBTask+0x56>
    65cc:	b6 c0       	rjmp	.+364    	; 0x673a <MS_Device_USBTask+0x1c2>
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
	
	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    65ce:	c7 01       	movw	r24, r14
    65d0:	6f e0       	ldi	r22, 0x0F	; 15
    65d2:	70 e0       	ldi	r23, 0x00	; 0
    65d4:	a6 01       	movw	r20, r12
    65d6:	f5 d9       	rcall	.-3094   	; 0x59c2 <Endpoint_Read_Stream_LE>
    65d8:	85 30       	cpi	r24, 0x05	; 5
    65da:	a1 f3       	breq	.-24     	; 0x65c4 <MS_Device_USBTask+0x4c>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    65dc:	f8 01       	movw	r30, r16
    65de:	82 85       	ldd	r24, Z+10	; 0x0a
    65e0:	93 85       	ldd	r25, Z+11	; 0x0b
    65e2:	a4 85       	ldd	r26, Z+12	; 0x0c
    65e4:	b5 85       	ldd	r27, Z+13	; 0x0d
    65e6:	85 55       	subi	r24, 0x55	; 85
    65e8:	93 45       	sbci	r25, 0x53	; 83
    65ea:	a2 44       	sbci	r26, 0x42	; 66
    65ec:	b3 44       	sbci	r27, 0x43	; 67
    65ee:	81 f4       	brne	.+32     	; 0x6610 <MS_Device_USBTask+0x98>
    65f0:	f8 01       	movw	r30, r16
    65f2:	97 89       	ldd	r25, Z+23	; 0x17
    65f4:	81 85       	ldd	r24, Z+9	; 0x09
    65f6:	98 17       	cp	r25, r24
    65f8:	58 f4       	brcc	.+22     	; 0x6610 <MS_Device_USBTask+0x98>
    65fa:	86 89       	ldd	r24, Z+22	; 0x16
    65fc:	90 e0       	ldi	r25, 0x00	; 0
    65fe:	8f 71       	andi	r24, 0x1F	; 31
    6600:	90 70       	andi	r25, 0x00	; 0
    6602:	89 2b       	or	r24, r25
    6604:	29 f4       	brne	.+10     	; 0x6610 <MS_Device_USBTask+0x98>
    6606:	80 8d       	ldd	r24, Z+24	; 0x18
    6608:	88 23       	and	r24, r24
    660a:	11 f0       	breq	.+4      	; 0x6610 <MS_Device_USBTask+0x98>
    660c:	81 31       	cpi	r24, 0x11	; 17
    660e:	78 f0       	brcs	.+30     	; 0x662e <MS_Device_USBTask+0xb6>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6610:	80 91 eb 00 	lds	r24, 0x00EB
    6614:	80 62       	ori	r24, 0x20	; 32
    6616:	80 93 eb 00 	sts	0x00EB, r24
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength >  16))
	{
		Endpoint_StallTransaction();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    661a:	f8 01       	movw	r30, r16
    661c:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    661e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6622:	80 91 eb 00 	lds	r24, 0x00EB
    6626:	80 62       	ori	r24, 0x20	; 32
    6628:	80 93 eb 00 	sts	0x00EB, r24
    662c:	86 c0       	rjmp	.+268    	; 0x673a <MS_Device_USBTask+0x1c2>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    662e:	1a 82       	std	Y+2, r1	; 0x02
    6630:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6632:	99 e1       	ldi	r25, 0x19	; 25
    6634:	e9 2e       	mov	r14, r25
    6636:	f1 2c       	mov	r15, r1
    6638:	e0 0e       	add	r14, r16
    663a:	f1 1e       	adc	r15, r17
    663c:	6e 01       	movw	r12, r28
    663e:	08 94       	sec
    6640:	c1 1c       	adc	r12, r1
    6642:	d1 1c       	adc	r13, r1
    6644:	05 c0       	rjmp	.+10     	; 0x6650 <MS_Device_USBTask+0xd8>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    6646:	f8 01       	movw	r30, r16
    6648:	86 a9       	ldd	r24, Z+54	; 0x36
    664a:	88 23       	and	r24, r24
    664c:	09 f0       	breq	.+2      	; 0x6650 <MS_Device_USBTask+0xd8>
    664e:	75 c0       	rjmp	.+234    	; 0x673a <MS_Device_USBTask+0x1c2>

		return false;
	}

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6650:	f8 01       	movw	r30, r16
    6652:	60 8d       	ldd	r22, Z+24	; 0x18
    6654:	70 e0       	ldi	r23, 0x00	; 0
    6656:	c7 01       	movw	r24, r14
    6658:	a6 01       	movw	r20, r12
    665a:	b3 d9       	rcall	.-3226   	; 0x59c2 <Endpoint_Read_Stream_LE>
    665c:	85 30       	cpi	r24, 0x05	; 5
    665e:	99 f3       	breq	.-26     	; 0x6646 <MS_Device_USBTask+0xce>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6660:	80 91 e8 00 	lds	r24, 0x00E8
    6664:	8b 77       	andi	r24, 0x7B	; 123
    6666:	80 93 e8 00 	sts	0x00E8, r24

	if (Endpoint_IsReadWriteAllowed())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    666a:	f8 01       	movw	r30, r16
    666c:	86 89       	ldd	r24, Z+22	; 0x16
    666e:	87 ff       	sbrs	r24, 7
    6670:	03 c0       	rjmp	.+6      	; 0x6678 <MS_Device_USBTask+0x100>
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    6672:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6674:	80 93 e9 00 	sts	0x00E9, r24

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    6678:	c8 01       	movw	r24, r16
    667a:	0e 94 9a 02 	call	0x534	; 0x534 <CALLBACK_MS_Device_SCSICommandReceived>

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    667e:	91 e0       	ldi	r25, 0x01	; 1
    6680:	98 27       	eor	r25, r24
    6682:	f8 01       	movw	r30, r16
    6684:	95 ab       	std	Z+53, r25	; 0x35
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    6686:	25 e5       	ldi	r18, 0x55	; 85
    6688:	33 e5       	ldi	r19, 0x53	; 83
    668a:	42 e4       	ldi	r20, 0x42	; 66
    668c:	53 e5       	ldi	r21, 0x53	; 83
    668e:	21 a7       	std	Z+41, r18	; 0x29
    6690:	32 a7       	std	Z+42, r19	; 0x2a
    6692:	43 a7       	std	Z+43, r20	; 0x2b
    6694:	54 a7       	std	Z+44, r21	; 0x2c
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    6696:	26 85       	ldd	r18, Z+14	; 0x0e
    6698:	37 85       	ldd	r19, Z+15	; 0x0f
    669a:	40 89       	ldd	r20, Z+16	; 0x10
    669c:	51 89       	ldd	r21, Z+17	; 0x11
    669e:	25 a7       	std	Z+45, r18	; 0x2d
    66a0:	36 a7       	std	Z+46, r19	; 0x2e
    66a2:	47 a7       	std	Z+47, r20	; 0x2f
    66a4:	50 ab       	std	Z+48, r21	; 0x30
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    66a6:	22 89       	ldd	r18, Z+18	; 0x12
    66a8:	33 89       	ldd	r19, Z+19	; 0x13
    66aa:	44 89       	ldd	r20, Z+20	; 0x14
    66ac:	55 89       	ldd	r21, Z+21	; 0x15
    66ae:	21 ab       	std	Z+49, r18	; 0x31
    66b0:	32 ab       	std	Z+50, r19	; 0x32
    66b2:	43 ab       	std	Z+51, r20	; 0x33
    66b4:	54 ab       	std	Z+52, r21	; 0x34

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    66b6:	88 23       	and	r24, r24
    66b8:	51 f4       	brne	.+20     	; 0x66ce <MS_Device_USBTask+0x156>
    66ba:	21 15       	cp	r18, r1
    66bc:	31 05       	cpc	r19, r1
    66be:	41 05       	cpc	r20, r1
    66c0:	51 05       	cpc	r21, r1
    66c2:	29 f0       	breq	.+10     	; 0x66ce <MS_Device_USBTask+0x156>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    66c4:	80 91 eb 00 	lds	r24, 0x00EB
    66c8:	80 62       	ori	r24, 0x20	; 32
    66ca:	80 93 eb 00 	sts	0x00EB, r24
	return true;
}

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    66ce:	f8 01       	movw	r30, r16
    66d0:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    66d2:	80 93 e9 00 	sts	0x00E9, r24
    66d6:	04 c0       	rjmp	.+8      	; 0x66e0 <MS_Device_USBTask+0x168>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    66d8:	f8 01       	movw	r30, r16
    66da:	86 a9       	ldd	r24, Z+54	; 0x36
    66dc:	88 23       	and	r24, r24
    66de:	69 f5       	brne	.+90     	; 0x673a <MS_Device_USBTask+0x1c2>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    66e0:	80 91 eb 00 	lds	r24, 0x00EB

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);

	while (Endpoint_IsStalled())
    66e4:	85 fd       	sbrc	r24, 5
    66e6:	f8 cf       	rjmp	.-16     	; 0x66d8 <MS_Device_USBTask+0x160>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    66e8:	f8 01       	movw	r30, r16
    66ea:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    66ec:	80 93 e9 00 	sts	0x00E9, r24
    66f0:	04 c0       	rjmp	.+8      	; 0x66fa <MS_Device_USBTask+0x182>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    66f2:	f8 01       	movw	r30, r16
    66f4:	86 a9       	ldd	r24, Z+54	; 0x36
    66f6:	88 23       	and	r24, r24
    66f8:	01 f5       	brne	.+64     	; 0x673a <MS_Device_USBTask+0x1c2>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    66fa:	80 91 eb 00 	lds	r24, 0x00EB
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);

	while (Endpoint_IsStalled())
    66fe:	85 fd       	sbrc	r24, 5
    6700:	f8 cf       	rjmp	.-16     	; 0x66f2 <MS_Device_USBTask+0x17a>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
    6702:	1a 82       	std	Y+2, r1	; 0x02
    6704:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    6706:	89 e2       	ldi	r24, 0x29	; 41
    6708:	e8 2e       	mov	r14, r24
    670a:	f1 2c       	mov	r15, r1
    670c:	e0 0e       	add	r14, r16
    670e:	f1 1e       	adc	r15, r17
    6710:	6e 01       	movw	r12, r28
    6712:	08 94       	sec
    6714:	c1 1c       	adc	r12, r1
    6716:	d1 1c       	adc	r13, r1
    6718:	04 c0       	rjmp	.+8      	; 0x6722 <MS_Device_USBTask+0x1aa>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    671a:	f8 01       	movw	r30, r16
    671c:	86 a9       	ldd	r24, Z+54	; 0x36
    671e:	88 23       	and	r24, r24
    6720:	61 f4       	brne	.+24     	; 0x673a <MS_Device_USBTask+0x1c2>
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    6722:	c7 01       	movw	r24, r14
    6724:	6d e0       	ldi	r22, 0x0D	; 13
    6726:	70 e0       	ldi	r23, 0x00	; 0
    6728:	a6 01       	movw	r20, r12
    672a:	e8 d9       	rcall	.-3120   	; 0x5afc <Endpoint_Write_Stream_LE>
    672c:	85 30       	cpi	r24, 0x05	; 5
    672e:	a9 f3       	breq	.-22     	; 0x671a <MS_Device_USBTask+0x1a2>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6730:	80 91 e8 00 	lds	r24, 0x00E8
    6734:	8e 77       	andi	r24, 0x7E	; 126
    6736:	80 93 e8 00 	sts	0x00E8, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    673a:	f8 01       	movw	r30, r16
    673c:	86 a9       	ldd	r24, Z+54	; 0x36
    673e:	88 23       	and	r24, r24
    6740:	91 f1       	breq	.+100    	; 0x67a6 <MS_Device_USBTask+0x22e>
	{
		Endpoint_ResetEndpoint(MSInterfaceInfo->Config.DataOUTEndpointNumber);
    6742:	45 81       	ldd	r20, Z+5	; 0x05
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    6744:	21 e0       	ldi	r18, 0x01	; 1
    6746:	30 e0       	ldi	r19, 0x00	; 0
    6748:	c9 01       	movw	r24, r18
    674a:	04 2e       	mov	r0, r20
    674c:	02 c0       	rjmp	.+4      	; 0x6752 <MS_Device_USBTask+0x1da>
    674e:	88 0f       	add	r24, r24
    6750:	99 1f       	adc	r25, r25
    6752:	0a 94       	dec	r0
    6754:	e2 f7       	brpl	.-8      	; 0x674e <MS_Device_USBTask+0x1d6>
    6756:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    675a:	10 92 ea 00 	sts	0x00EA, r1
		Endpoint_ResetEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
    675e:	91 81       	ldd	r25, Z+1	; 0x01
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    6760:	09 2e       	mov	r0, r25
    6762:	02 c0       	rjmp	.+4      	; 0x6768 <MS_Device_USBTask+0x1f0>
    6764:	22 0f       	add	r18, r18
    6766:	33 1f       	adc	r19, r19
    6768:	0a 94       	dec	r0
    676a:	e2 f7       	brpl	.-8      	; 0x6764 <MS_Device_USBTask+0x1ec>
    676c:	20 93 ea 00 	sts	0x00EA, r18
				UERST = 0;
    6770:	10 92 ea 00 	sts	0x00EA, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6774:	40 93 e9 00 	sts	0x00E9, r20
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6778:	80 91 eb 00 	lds	r24, 0x00EB
    677c:	80 61       	ori	r24, 0x10	; 16
    677e:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6782:	80 91 eb 00 	lds	r24, 0x00EB
    6786:	88 60       	ori	r24, 0x08	; 8
    6788:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    678c:	90 93 e9 00 	sts	0x00E9, r25
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6790:	80 91 eb 00 	lds	r24, 0x00EB
    6794:	80 61       	ori	r24, 0x10	; 16
    6796:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    679a:	80 91 eb 00 	lds	r24, 0x00EB
    679e:	88 60       	ori	r24, 0x08	; 8
    67a0:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpointNumber);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    67a4:	16 aa       	std	Z+54, r1	; 0x36
	}
}
    67a6:	0f 90       	pop	r0
    67a8:	0f 90       	pop	r0
    67aa:	cf 91       	pop	r28
    67ac:	df 91       	pop	r29
    67ae:	1f 91       	pop	r17
    67b0:	0f 91       	pop	r16
    67b2:	ff 90       	pop	r15
    67b4:	ef 90       	pop	r14
    67b6:	df 90       	pop	r13
    67b8:	cf 90       	pop	r12
    67ba:	08 95       	ret

000067bc <MS_Device_ConfigureEndpoints>:
			break;
	}
}

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    67bc:	1f 93       	push	r17
    67be:	cf 93       	push	r28
    67c0:	df 93       	push	r29
    67c2:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    67c4:	2a 96       	adiw	r28, 0x0a	; 10
    67c6:	8d e2       	ldi	r24, 0x2D	; 45
    67c8:	fe 01       	movw	r30, r28
    67ca:	11 92       	st	Z+, r1
    67cc:	8a 95       	dec	r24
    67ce:	e9 f7       	brne	.-6      	; 0x67ca <MS_Device_ConfigureEndpoints+0xe>
    67d0:	2a 97       	sbiw	r28, 0x0a	; 10
    67d2:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == MSInterfaceInfo->Config.DataINEndpointNumber)
    67d4:	89 81       	ldd	r24, Y+1	; 0x01
    67d6:	18 17       	cp	r17, r24
    67d8:	29 f4       	brne	.+10     	; 0x67e4 <MS_Device_ConfigureEndpoints+0x28>
		{
			Size         = MSInterfaceInfo->Config.DataINEndpointSize;
    67da:	6a 81       	ldd	r22, Y+2	; 0x02
    67dc:	7b 81       	ldd	r23, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = MSInterfaceInfo->Config.DataINEndpointDoubleBank;
    67de:	8c 81       	ldd	r24, Y+4	; 0x04
    67e0:	30 e8       	ldi	r19, 0x80	; 128
    67e2:	07 c0       	rjmp	.+14     	; 0x67f2 <MS_Device_ConfigureEndpoints+0x36>
		}
		else if (EndpointNum == MSInterfaceInfo->Config.DataOUTEndpointNumber)
    67e4:	8d 81       	ldd	r24, Y+5	; 0x05
    67e6:	18 17       	cp	r17, r24
    67e8:	01 f5       	brne	.+64     	; 0x682a <MS_Device_ConfigureEndpoints+0x6e>
		{
			Size         = MSInterfaceInfo->Config.DataOUTEndpointSize;
    67ea:	6e 81       	ldd	r22, Y+6	; 0x06
    67ec:	7f 81       	ldd	r23, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = MSInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    67ee:	88 85       	ldd	r24, Y+8	; 0x08
    67f0:	30 e0       	ldi	r19, 0x00	; 0
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    67f2:	88 23       	and	r24, r24
    67f4:	11 f4       	brne	.+4      	; 0x67fa <MS_Device_ConfigureEndpoints+0x3e>
    67f6:	40 e0       	ldi	r20, 0x00	; 0
    67f8:	01 c0       	rjmp	.+2      	; 0x67fc <MS_Device_ConfigureEndpoints+0x40>
    67fa:	44 e0       	ldi	r20, 0x04	; 4
    67fc:	20 e0       	ldi	r18, 0x00	; 0
    67fe:	88 e0       	ldi	r24, 0x08	; 8
    6800:	90 e0       	ldi	r25, 0x00	; 0
    6802:	03 c0       	rjmp	.+6      	; 0x680a <MS_Device_ConfigureEndpoints+0x4e>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    6804:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    6806:	88 0f       	add	r24, r24
    6808:	99 1f       	adc	r25, r25
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    680a:	86 17       	cp	r24, r22
    680c:	97 07       	cpc	r25, r23
    680e:	d0 f3       	brcs	.-12     	; 0x6804 <MS_Device_ConfigureEndpoints+0x48>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    6810:	60 e0       	ldi	r22, 0x00	; 0
    6812:	31 11       	cpse	r19, r1
    6814:	61 e0       	ldi	r22, 0x01	; 1
    6816:	60 68       	ori	r22, 0x80	; 128
    6818:	42 60       	ori	r20, 0x02	; 2
    681a:	22 95       	swap	r18
    681c:	20 7f       	andi	r18, 0xF0	; 240
    681e:	42 2b       	or	r20, r18
    6820:	81 2f       	mov	r24, r17
    6822:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <Endpoint_ConfigureEndpoint_Prv>
    6826:	88 23       	and	r24, r24
    6828:	21 f0       	breq	.+8      	; 0x6832 <MS_Device_ConfigureEndpoints+0x76>

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    682a:	1f 5f       	subi	r17, 0xFF	; 255
    682c:	17 30       	cpi	r17, 0x07	; 7
    682e:	91 f6       	brne	.-92     	; 0x67d4 <MS_Device_ConfigureEndpoints+0x18>
    6830:	81 e0       	ldi	r24, 0x01	; 1
			return false;
		}
	}

	return true;
}
    6832:	df 91       	pop	r29
    6834:	cf 91       	pop	r28
    6836:	1f 91       	pop	r17
    6838:	08 95       	ret

0000683a <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorage.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    683a:	cf 93       	push	r28
    683c:	df 93       	push	r29
    683e:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6840:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    6844:	83 ff       	sbrs	r24, 3
    6846:	31 c0       	rjmp	.+98     	; 0x68aa <MS_Device_ProcessControlRequest+0x70>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    6848:	88 81       	ld	r24, Y
    684a:	90 e0       	ldi	r25, 0x00	; 0
    684c:	20 91 a8 0d 	lds	r18, 0x0DA8
    6850:	30 91 a9 0d 	lds	r19, 0x0DA9
    6854:	28 17       	cp	r18, r24
    6856:	39 07       	cpc	r19, r25
    6858:	41 f5       	brne	.+80     	; 0x68aa <MS_Device_ProcessControlRequest+0x70>
	  return;

	switch (USB_ControlRequest.bRequest)
    685a:	80 91 a5 0d 	lds	r24, 0x0DA5
    685e:	8e 3f       	cpi	r24, 0xFE	; 254
    6860:	81 f0       	breq	.+32     	; 0x6882 <MS_Device_ProcessControlRequest+0x48>
    6862:	8f 3f       	cpi	r24, 0xFF	; 255
    6864:	11 f5       	brne	.+68     	; 0x68aa <MS_Device_ProcessControlRequest+0x70>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    6866:	80 91 a4 0d 	lds	r24, 0x0DA4
    686a:	81 32       	cpi	r24, 0x21	; 33
    686c:	f1 f4       	brne	.+60     	; 0x68aa <MS_Device_ProcessControlRequest+0x70>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    686e:	80 91 e8 00 	lds	r24, 0x00E8
    6872:	87 7f       	andi	r24, 0xF7	; 247
    6874:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    6878:	0e 94 82 26 	call	0x4d04	; 0x4d04 <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    687c:	81 e0       	ldi	r24, 0x01	; 1
    687e:	8e ab       	std	Y+54, r24	; 0x36
    6880:	14 c0       	rjmp	.+40     	; 0x68aa <MS_Device_ProcessControlRequest+0x70>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    6882:	80 91 a4 0d 	lds	r24, 0x0DA4
    6886:	81 3a       	cpi	r24, 0xA1	; 161
    6888:	81 f4       	brne	.+32     	; 0x68aa <MS_Device_ProcessControlRequest+0x70>
    688a:	80 91 e8 00 	lds	r24, 0x00E8
    688e:	87 7f       	andi	r24, 0xF7	; 247
    6890:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    6894:	89 85       	ldd	r24, Y+9	; 0x09
    6896:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6898:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    689c:	80 91 e8 00 	lds	r24, 0x00E8
    68a0:	8e 77       	andi	r24, 0x7E	; 126
    68a2:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    68a6:	0e 94 82 26 	call	0x4d04	; 0x4d04 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    68aa:	df 91       	pop	r29
    68ac:	cf 91       	pop	r28
    68ae:	08 95       	ret

000068b0 <RNDIS_Device_IsPacketReceived>:
			return false;
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    68b0:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    68b2:	8e b3       	in	r24, 0x1e	; 30
    68b4:	84 30       	cpi	r24, 0x04	; 4
    68b6:	99 f4       	brne	.+38     	; 0x68de <RNDIS_Device_IsPacketReceived+0x2e>
    68b8:	ea 56       	subi	r30, 0x6A	; 106
    68ba:	ff 4f       	sbci	r31, 0xFF	; 255
    68bc:	80 81       	ld	r24, Z
    68be:	e6 59       	subi	r30, 0x96	; 150
    68c0:	f0 40       	sbci	r31, 0x00	; 0
    68c2:	82 30       	cpi	r24, 0x02	; 2
    68c4:	61 f4       	brne	.+24     	; 0x68de <RNDIS_Device_IsPacketReceived+0x2e>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    68c6:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    68c8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    68cc:	80 91 e8 00 	lds	r24, 0x00E8
    68d0:	90 e0       	ldi	r25, 0x00	; 0
    68d2:	96 95       	lsr	r25
    68d4:	87 95       	ror	r24
    68d6:	96 95       	lsr	r25
    68d8:	87 95       	ror	r24
    68da:	81 70       	andi	r24, 0x01	; 1
    68dc:	08 95       	ret
	return Endpoint_IsOUTReceived();
    68de:	80 e0       	ldi	r24, 0x00	; 0
}
    68e0:	08 95       	ret

000068e2 <RNDIS_Device_SendPacket>:
}

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    68e2:	cf 92       	push	r12
    68e4:	df 92       	push	r13
    68e6:	ff 92       	push	r15
    68e8:	0f 93       	push	r16
    68ea:	1f 93       	push	r17
    68ec:	df 93       	push	r29
    68ee:	cf 93       	push	r28
    68f0:	cd b7       	in	r28, 0x3d	; 61
    68f2:	de b7       	in	r29, 0x3e	; 62
    68f4:	ac 97       	sbiw	r28, 0x2c	; 44
    68f6:	0f b6       	in	r0, 0x3f	; 63
    68f8:	f8 94       	cli
    68fa:	de bf       	out	0x3e, r29	; 62
    68fc:	0f be       	out	0x3f, r0	; 63
    68fe:	cd bf       	out	0x3d, r28	; 61
    6900:	fc 01       	movw	r30, r24
    6902:	6b 01       	movw	r12, r22
    6904:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6906:	8e b3       	in	r24, 0x1e	; 30
    6908:	84 30       	cpi	r24, 0x04	; 4
    690a:	09 f0       	breq	.+2      	; 0x690e <RNDIS_Device_SendPacket+0x2c>
    690c:	4a c0       	rjmp	.+148    	; 0x69a2 <RNDIS_Device_SendPacket+0xc0>
    690e:	ea 56       	subi	r30, 0x6A	; 106
    6910:	ff 4f       	sbci	r31, 0xFF	; 255
    6912:	80 81       	ld	r24, Z
    6914:	e6 59       	subi	r30, 0x96	; 150
    6916:	f0 40       	sbci	r31, 0x00	; 0
    6918:	82 30       	cpi	r24, 0x02	; 2
    691a:	09 f0       	breq	.+2      	; 0x691e <RNDIS_Device_SendPacket+0x3c>
    691c:	42 c0       	rjmp	.+132    	; 0x69a2 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpointNumber);
    691e:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6920:	80 93 e9 00 	sts	0x00E9, r24

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    6924:	0e 94 a1 26 	call	0x4d42	; 0x4d42 <Endpoint_WaitUntilReady>
    6928:	f8 2e       	mov	r15, r24
    692a:	88 23       	and	r24, r24
    692c:	e1 f5       	brne	.+120    	; 0x69a6 <RNDIS_Device_SendPacket+0xc4>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    692e:	fe 01       	movw	r30, r28
    6930:	31 96       	adiw	r30, 0x01	; 1
    6932:	8c e2       	ldi	r24, 0x2C	; 44
    6934:	df 01       	movw	r26, r30
    6936:	1d 92       	st	X+, r1
    6938:	8a 95       	dec	r24
    693a:	e9 f7       	brne	.-6      	; 0x6936 <RNDIS_Device_SendPacket+0x54>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    693c:	81 e0       	ldi	r24, 0x01	; 1
    693e:	90 e0       	ldi	r25, 0x00	; 0
    6940:	a0 e0       	ldi	r26, 0x00	; 0
    6942:	b0 e0       	ldi	r27, 0x00	; 0
    6944:	89 83       	std	Y+1, r24	; 0x01
    6946:	9a 83       	std	Y+2, r25	; 0x02
    6948:	ab 83       	std	Y+3, r26	; 0x03
    694a:	bc 83       	std	Y+4, r27	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    694c:	04 5d       	subi	r16, 0xD4	; 212
    694e:	1f 4f       	sbci	r17, 0xFF	; 255
    6950:	c8 01       	movw	r24, r16
    6952:	a0 e0       	ldi	r26, 0x00	; 0
    6954:	b0 e0       	ldi	r27, 0x00	; 0
    6956:	0c 52       	subi	r16, 0x2C	; 44
    6958:	10 40       	sbci	r17, 0x00	; 0
    695a:	8d 83       	std	Y+5, r24	; 0x05
    695c:	9e 83       	std	Y+6, r25	; 0x06
    695e:	af 83       	std	Y+7, r26	; 0x07
    6960:	b8 87       	std	Y+8, r27	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    6962:	84 e2       	ldi	r24, 0x24	; 36
    6964:	90 e0       	ldi	r25, 0x00	; 0
    6966:	a0 e0       	ldi	r26, 0x00	; 0
    6968:	b0 e0       	ldi	r27, 0x00	; 0
    696a:	89 87       	std	Y+9, r24	; 0x09
    696c:	9a 87       	std	Y+10, r25	; 0x0a
    696e:	ab 87       	std	Y+11, r26	; 0x0b
    6970:	bc 87       	std	Y+12, r27	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    6972:	c8 01       	movw	r24, r16
    6974:	a0 e0       	ldi	r26, 0x00	; 0
    6976:	b0 e0       	ldi	r27, 0x00	; 0
    6978:	8d 87       	std	Y+13, r24	; 0x0d
    697a:	9e 87       	std	Y+14, r25	; 0x0e
    697c:	af 87       	std	Y+15, r26	; 0x0f
    697e:	b8 8b       	std	Y+16, r27	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    6980:	cf 01       	movw	r24, r30
    6982:	6c e2       	ldi	r22, 0x2C	; 44
    6984:	70 e0       	ldi	r23, 0x00	; 0
    6986:	40 e0       	ldi	r20, 0x00	; 0
    6988:	50 e0       	ldi	r21, 0x00	; 0
    698a:	b8 d8       	rcall	.-3728   	; 0x5afc <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    698c:	c6 01       	movw	r24, r12
    698e:	b8 01       	movw	r22, r16
    6990:	40 e0       	ldi	r20, 0x00	; 0
    6992:	50 e0       	ldi	r21, 0x00	; 0
    6994:	b3 d8       	rcall	.-3738   	; 0x5afc <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6996:	80 91 e8 00 	lds	r24, 0x00E8
    699a:	8e 77       	andi	r24, 0x7E	; 126
    699c:	80 93 e8 00 	sts	0x00E8, r24
    69a0:	02 c0       	rjmp	.+4      	; 0x69a6 <RNDIS_Device_SendPacket+0xc4>
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    69a2:	32 e0       	ldi	r19, 0x02	; 2
    69a4:	f3 2e       	mov	r15, r19
}
    69a6:	8f 2d       	mov	r24, r15
    69a8:	ac 96       	adiw	r28, 0x2c	; 44
    69aa:	0f b6       	in	r0, 0x3f	; 63
    69ac:	f8 94       	cli
    69ae:	de bf       	out	0x3e, r29	; 62
    69b0:	0f be       	out	0x3f, r0	; 63
    69b2:	cd bf       	out	0x3d, r28	; 61
    69b4:	cf 91       	pop	r28
    69b6:	df 91       	pop	r29
    69b8:	1f 91       	pop	r17
    69ba:	0f 91       	pop	r16
    69bc:	ff 90       	pop	r15
    69be:	df 90       	pop	r13
    69c0:	cf 90       	pop	r12
    69c2:	08 95       	ret

000069c4 <RNDIS_Device_USBTask>:

	return true;
}

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    69c4:	0f 93       	push	r16
    69c6:	1f 93       	push	r17
    69c8:	df 93       	push	r29
    69ca:	cf 93       	push	r28
    69cc:	cd b7       	in	r28, 0x3d	; 61
    69ce:	de b7       	in	r29, 0x3e	; 62
    69d0:	28 97       	sbiw	r28, 0x08	; 8
    69d2:	0f b6       	in	r0, 0x3f	; 63
    69d4:	f8 94       	cli
    69d6:	de bf       	out	0x3e, r29	; 62
    69d8:	0f be       	out	0x3f, r0	; 63
    69da:	cd bf       	out	0x3d, r28	; 61
    69dc:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    69de:	8e b3       	in	r24, 0x1e	; 30
    69e0:	84 30       	cpi	r24, 0x04	; 4
    69e2:	49 f5       	brne	.+82     	; 0x6a36 <RNDIS_Device_USBTask+0x72>
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpointNumber);
    69e4:	f8 01       	movw	r30, r16
    69e6:	81 85       	ldd	r24, Z+9	; 0x09
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    69e8:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    69ec:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    69f0:	80 ff       	sbrs	r24, 0
    69f2:	21 c0       	rjmp	.+66     	; 0x6a36 <RNDIS_Device_USBTask+0x72>
    69f4:	0b 56       	subi	r16, 0x6B	; 107
    69f6:	1f 4f       	sbci	r17, 0xFF	; 255
    69f8:	f8 01       	movw	r30, r16
    69fa:	80 81       	ld	r24, Z
    69fc:	05 59       	subi	r16, 0x95	; 149
    69fe:	10 40       	sbci	r17, 0x00	; 0
    6a00:	88 23       	and	r24, r24
    6a02:	c9 f0       	breq	.+50     	; 0x6a36 <RNDIS_Device_USBTask+0x72>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};
    6a04:	de 01       	movw	r26, r28
    6a06:	11 96       	adiw	r26, 0x01	; 1
    6a08:	e3 e4       	ldi	r30, 0x43	; 67
    6a0a:	f3 e0       	ldi	r31, 0x03	; 3
    6a0c:	88 e0       	ldi	r24, 0x08	; 8
    6a0e:	01 90       	ld	r0, Z+
    6a10:	0d 92       	st	X+, r0
    6a12:	81 50       	subi	r24, 0x01	; 1
    6a14:	e1 f7       	brne	.-8      	; 0x6a0e <RNDIS_Device_USBTask+0x4a>

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    6a16:	ce 01       	movw	r24, r28
    6a18:	01 96       	adiw	r24, 0x01	; 1
    6a1a:	68 e0       	ldi	r22, 0x08	; 8
    6a1c:	70 e0       	ldi	r23, 0x00	; 0
    6a1e:	40 e0       	ldi	r20, 0x00	; 0
    6a20:	50 e0       	ldi	r21, 0x00	; 0
    6a22:	6c d8       	rcall	.-3880   	; 0x5afc <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6a24:	80 91 e8 00 	lds	r24, 0x00E8
    6a28:	8e 77       	andi	r24, 0x7E	; 126
    6a2a:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    6a2e:	0b 56       	subi	r16, 0x6B	; 107
    6a30:	1f 4f       	sbci	r17, 0xFF	; 255
    6a32:	f8 01       	movw	r30, r16
    6a34:	10 82       	st	Z, r1
	}
}
    6a36:	28 96       	adiw	r28, 0x08	; 8
    6a38:	0f b6       	in	r0, 0x3f	; 63
    6a3a:	f8 94       	cli
    6a3c:	de bf       	out	0x3e, r29	; 62
    6a3e:	0f be       	out	0x3f, r0	; 63
    6a40:	cd bf       	out	0x3d, r28	; 61
    6a42:	cf 91       	pop	r28
    6a44:	df 91       	pop	r29
    6a46:	1f 91       	pop	r17
    6a48:	0f 91       	pop	r16
    6a4a:	08 95       	ret

00006a4c <RNDIS_Device_ReadPacket>:
}

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    6a4c:	ef 92       	push	r14
    6a4e:	ff 92       	push	r15
    6a50:	0f 93       	push	r16
    6a52:	1f 93       	push	r17
    6a54:	df 93       	push	r29
    6a56:	cf 93       	push	r28
    6a58:	cd b7       	in	r28, 0x3d	; 61
    6a5a:	de b7       	in	r29, 0x3e	; 62
    6a5c:	ac 97       	sbiw	r28, 0x2c	; 44
    6a5e:	0f b6       	in	r0, 0x3f	; 63
    6a60:	f8 94       	cli
    6a62:	de bf       	out	0x3e, r29	; 62
    6a64:	0f be       	out	0x3f, r0	; 63
    6a66:	cd bf       	out	0x3d, r28	; 61
    6a68:	fc 01       	movw	r30, r24
    6a6a:	7b 01       	movw	r14, r22
    6a6c:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6a6e:	8e b3       	in	r24, 0x1e	; 30
    6a70:	84 30       	cpi	r24, 0x04	; 4
    6a72:	e1 f5       	brne	.+120    	; 0x6aec <RNDIS_Device_ReadPacket+0xa0>
    6a74:	ea 56       	subi	r30, 0x6A	; 106
    6a76:	ff 4f       	sbci	r31, 0xFF	; 255
    6a78:	80 81       	ld	r24, Z
    6a7a:	e6 59       	subi	r30, 0x96	; 150
    6a7c:	f0 40       	sbci	r31, 0x00	; 0
    6a7e:	82 30       	cpi	r24, 0x02	; 2
    6a80:	a9 f5       	brne	.+106    	; 0x6aec <RNDIS_Device_ReadPacket+0xa0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    6a82:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    6a84:	80 93 e9 00 	sts	0x00E9, r24
	
	*PacketLength = 0;
    6a88:	fa 01       	movw	r30, r20
    6a8a:	11 82       	std	Z+1, r1	; 0x01
    6a8c:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6a8e:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    6a92:	82 ff       	sbrs	r24, 2
    6a94:	29 c0       	rjmp	.+82     	; 0x6ae8 <RNDIS_Device_ReadPacket+0x9c>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;	
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    6a96:	ce 01       	movw	r24, r28
    6a98:	01 96       	adiw	r24, 0x01	; 1
    6a9a:	6c e2       	ldi	r22, 0x2C	; 44
    6a9c:	70 e0       	ldi	r23, 0x00	; 0
    6a9e:	40 e0       	ldi	r20, 0x00	; 0
    6aa0:	50 e0       	ldi	r21, 0x00	; 0
    6aa2:	0e 94 e1 2c 	call	0x59c2	; 0x59c2 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    6aa6:	2d 85       	ldd	r18, Y+13	; 0x0d
    6aa8:	3e 85       	ldd	r19, Y+14	; 0x0e
    6aaa:	4f 85       	ldd	r20, Y+15	; 0x0f
    6aac:	58 89       	ldd	r21, Y+16	; 0x10
    6aae:	2d 3d       	cpi	r18, 0xDD	; 221
    6ab0:	f5 e0       	ldi	r31, 0x05	; 5
    6ab2:	3f 07       	cpc	r19, r31
    6ab4:	f0 e0       	ldi	r31, 0x00	; 0
    6ab6:	4f 07       	cpc	r20, r31
    6ab8:	f0 e0       	ldi	r31, 0x00	; 0
    6aba:	5f 07       	cpc	r21, r31
    6abc:	38 f0       	brcs	.+14     	; 0x6acc <RNDIS_Device_ReadPacket+0x80>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6abe:	80 91 eb 00 	lds	r24, 0x00EB
    6ac2:	80 62       	ori	r24, 0x20	; 32
    6ac4:	80 93 eb 00 	sts	0x00EB, r24
    6ac8:	80 e8       	ldi	r24, 0x80	; 128
    6aca:	11 c0       	rjmp	.+34     	; 0x6aee <RNDIS_Device_ReadPacket+0xa2>
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
	}
	
	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    6acc:	f8 01       	movw	r30, r16
    6ace:	31 83       	std	Z+1, r19	; 0x01
    6ad0:	20 83       	st	Z, r18

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    6ad2:	c7 01       	movw	r24, r14
    6ad4:	b9 01       	movw	r22, r18
    6ad6:	40 e0       	ldi	r20, 0x00	; 0
    6ad8:	50 e0       	ldi	r21, 0x00	; 0
    6ada:	0e 94 e1 2c 	call	0x59c2	; 0x59c2 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6ade:	80 91 e8 00 	lds	r24, 0x00E8
    6ae2:	8b 77       	andi	r24, 0x7B	; 123
    6ae4:	80 93 e8 00 	sts	0x00E8, r24
    6ae8:	80 e0       	ldi	r24, 0x00	; 0
    6aea:	01 c0       	rjmp	.+2      	; 0x6aee <RNDIS_Device_ReadPacket+0xa2>
	Endpoint_ClearOUT();
	
	return ENDPOINT_RWSTREAM_NoError;
    6aec:	82 e0       	ldi	r24, 0x02	; 2
}
    6aee:	ac 96       	adiw	r28, 0x2c	; 44
    6af0:	0f b6       	in	r0, 0x3f	; 63
    6af2:	f8 94       	cli
    6af4:	de bf       	out	0x3e, r29	; 62
    6af6:	0f be       	out	0x3f, r0	; 63
    6af8:	cd bf       	out	0x3d, r28	; 61
    6afa:	cf 91       	pop	r28
    6afc:	df 91       	pop	r29
    6afe:	1f 91       	pop	r17
    6b00:	0f 91       	pop	r16
    6b02:	ff 90       	pop	r15
    6b04:	ef 90       	pop	r14
    6b06:	08 95       	ret

00006b08 <RNDIS_Device_ConfigureEndpoints>:
			break;
	}
}

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    6b08:	1f 93       	push	r17
    6b0a:	cf 93       	push	r28
    6b0c:	df 93       	push	r29
    6b0e:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    6b10:	65 96       	adiw	r28, 0x15	; 21
    6b12:	86 e8       	ldi	r24, 0x86	; 134
    6b14:	fe 01       	movw	r30, r28
    6b16:	11 92       	st	Z+, r1
    6b18:	8a 95       	dec	r24
    6b1a:	e9 f7       	brne	.-6      	; 0x6b16 <RNDIS_Device_ConfigureEndpoints+0xe>
    6b1c:	65 97       	sbiw	r28, 0x15	; 21
    6b1e:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
    6b20:	89 81       	ldd	r24, Y+1	; 0x01
    6b22:	18 17       	cp	r17, r24
    6b24:	29 f4       	brne	.+10     	; 0x6b30 <RNDIS_Device_ConfigureEndpoints+0x28>
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
    6b26:	6a 81       	ldd	r22, Y+2	; 0x02
    6b28:	7b 81       	ldd	r23, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
    6b2a:	8c 81       	ldd	r24, Y+4	; 0x04
    6b2c:	52 e0       	ldi	r21, 0x02	; 2
    6b2e:	10 c0       	rjmp	.+32     	; 0x6b50 <RNDIS_Device_ConfigureEndpoints+0x48>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
    6b30:	8d 81       	ldd	r24, Y+5	; 0x05
    6b32:	18 17       	cp	r17, r24
    6b34:	31 f4       	brne	.+12     	; 0x6b42 <RNDIS_Device_ConfigureEndpoints+0x3a>
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
    6b36:	6e 81       	ldd	r22, Y+6	; 0x06
    6b38:	7f 81       	ldd	r23, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    6b3a:	88 85       	ldd	r24, Y+8	; 0x08
    6b3c:	52 e0       	ldi	r21, 0x02	; 2
    6b3e:	30 e0       	ldi	r19, 0x00	; 0
    6b40:	08 c0       	rjmp	.+16     	; 0x6b52 <RNDIS_Device_ConfigureEndpoints+0x4a>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
    6b42:	89 85       	ldd	r24, Y+9	; 0x09
    6b44:	18 17       	cp	r17, r24
    6b46:	41 f5       	brne	.+80     	; 0x6b98 <RNDIS_Device_ConfigureEndpoints+0x90>
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
    6b48:	6a 85       	ldd	r22, Y+10	; 0x0a
    6b4a:	7b 85       	ldd	r23, Y+11	; 0x0b
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_INTERRUPT;
			DoubleBanked = RNDISInterfaceInfo->Config.NotificationEndpointDoubleBank;
    6b4c:	8c 85       	ldd	r24, Y+12	; 0x0c
    6b4e:	53 e0       	ldi	r21, 0x03	; 3
    6b50:	30 e8       	ldi	r19, 0x80	; 128
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    6b52:	88 23       	and	r24, r24
    6b54:	11 f4       	brne	.+4      	; 0x6b5a <RNDIS_Device_ConfigureEndpoints+0x52>
    6b56:	40 e0       	ldi	r20, 0x00	; 0
    6b58:	01 c0       	rjmp	.+2      	; 0x6b5c <RNDIS_Device_ConfigureEndpoints+0x54>
    6b5a:	44 e0       	ldi	r20, 0x04	; 4
    6b5c:	20 e0       	ldi	r18, 0x00	; 0
    6b5e:	88 e0       	ldi	r24, 0x08	; 8
    6b60:	90 e0       	ldi	r25, 0x00	; 0
    6b62:	03 c0       	rjmp	.+6      	; 0x6b6a <RNDIS_Device_ConfigureEndpoints+0x62>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    6b64:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    6b66:	88 0f       	add	r24, r24
    6b68:	99 1f       	adc	r25, r25
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    6b6a:	86 17       	cp	r24, r22
    6b6c:	97 07       	cpc	r25, r23
    6b6e:	d0 f3       	brcs	.-12     	; 0x6b64 <RNDIS_Device_ConfigureEndpoints+0x5c>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    6b70:	85 2f       	mov	r24, r21
    6b72:	90 e0       	ldi	r25, 0x00	; 0
    6b74:	56 e0       	ldi	r21, 0x06	; 6
    6b76:	88 0f       	add	r24, r24
    6b78:	99 1f       	adc	r25, r25
    6b7a:	5a 95       	dec	r21
    6b7c:	e1 f7       	brne	.-8      	; 0x6b76 <RNDIS_Device_ConfigureEndpoints+0x6e>
    6b7e:	60 e0       	ldi	r22, 0x00	; 0
    6b80:	31 11       	cpse	r19, r1
    6b82:	61 e0       	ldi	r22, 0x01	; 1
    6b84:	68 2b       	or	r22, r24
    6b86:	42 60       	ori	r20, 0x02	; 2
    6b88:	22 95       	swap	r18
    6b8a:	20 7f       	andi	r18, 0xF0	; 240
    6b8c:	42 2b       	or	r20, r18
    6b8e:	81 2f       	mov	r24, r17
    6b90:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <Endpoint_ConfigureEndpoint_Prv>
    6b94:	88 23       	and	r24, r24
    6b96:	29 f0       	breq	.+10     	; 0x6ba2 <RNDIS_Device_ConfigureEndpoints+0x9a>

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    6b98:	1f 5f       	subi	r17, 0xFF	; 255
    6b9a:	17 30       	cpi	r17, 0x07	; 7
    6b9c:	09 f0       	breq	.+2      	; 0x6ba0 <RNDIS_Device_ConfigureEndpoints+0x98>
    6b9e:	c0 cf       	rjmp	.-128    	; 0x6b20 <RNDIS_Device_ConfigureEndpoints+0x18>
    6ba0:	81 e0       	ldi	r24, 0x01	; 1
			return false;
		}
	}

	return true;
}
    6ba2:	df 91       	pop	r29
    6ba4:	cf 91       	pop	r28
    6ba6:	1f 91       	pop	r17
    6ba8:	08 95       	ret

00006baa <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    6baa:	0f 93       	push	r16
    6bac:	1f 93       	push	r17
    6bae:	cf 93       	push	r28
    6bb0:	df 93       	push	r29
    6bb2:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6bb4:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    6bb8:	83 ff       	sbrs	r24, 3
    6bba:	b6 c2       	rjmp	.+1388   	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    6bbc:	88 81       	ld	r24, Y
    6bbe:	90 e0       	ldi	r25, 0x00	; 0
    6bc0:	20 91 a8 0d 	lds	r18, 0x0DA8
    6bc4:	30 91 a9 0d 	lds	r19, 0x0DA9
    6bc8:	28 17       	cp	r18, r24
    6bca:	39 07       	cpc	r19, r25
    6bcc:	09 f0       	breq	.+2      	; 0x6bd0 <RNDIS_Device_ProcessControlRequest+0x26>
    6bce:	ac c2       	rjmp	.+1368   	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
	  return;

	switch (USB_ControlRequest.bRequest)
    6bd0:	80 91 a5 0d 	lds	r24, 0x0DA5
    6bd4:	88 23       	and	r24, r24
    6bd6:	21 f0       	breq	.+8      	; 0x6be0 <RNDIS_Device_ProcessControlRequest+0x36>
    6bd8:	81 30       	cpi	r24, 0x01	; 1
    6bda:	09 f0       	breq	.+2      	; 0x6bde <RNDIS_Device_ProcessControlRequest+0x34>
    6bdc:	a5 c2       	rjmp	.+1354   	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
    6bde:	56 c2       	rjmp	.+1196   	; 0x708c <RNDIS_Device_ProcessControlRequest+0x4e2>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    6be0:	80 91 a4 0d 	lds	r24, 0x0DA4
    6be4:	81 32       	cpi	r24, 0x21	; 33
    6be6:	09 f0       	breq	.+2      	; 0x6bea <RNDIS_Device_ProcessControlRequest+0x40>
    6be8:	9f c2       	rjmp	.+1342   	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6bea:	80 91 e8 00 	lds	r24, 0x00E8
    6bee:	87 7f       	andi	r24, 0xF7	; 247
    6bf0:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    6bf4:	8e 01       	movw	r16, r28
    6bf6:	0b 5e       	subi	r16, 0xEB	; 235
    6bf8:	1f 4f       	sbci	r17, 0xFF	; 255
    6bfa:	60 91 aa 0d 	lds	r22, 0x0DAA
    6bfe:	70 91 ab 0d 	lds	r23, 0x0DAB
    6c02:	c8 01       	movw	r24, r16
    6c04:	0e 94 44 2c 	call	0x5888	; 0x5888 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6c08:	80 91 e8 00 	lds	r24, 0x00E8
    6c0c:	8e 77       	andi	r24, 0x7E	; 126
    6c0e:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    6c12:	8d 89       	ldd	r24, Y+21	; 0x15
    6c14:	9e 89       	ldd	r25, Y+22	; 0x16
    6c16:	af 89       	ldd	r26, Y+23	; 0x17
    6c18:	b8 8d       	ldd	r27, Y+24	; 0x18
    6c1a:	84 30       	cpi	r24, 0x04	; 4
    6c1c:	91 05       	cpc	r25, r1
    6c1e:	a1 05       	cpc	r26, r1
    6c20:	b1 05       	cpc	r27, r1
    6c22:	09 f4       	brne	.+2      	; 0x6c26 <RNDIS_Device_ProcessControlRequest+0x7c>
    6c24:	77 c0       	rjmp	.+238    	; 0x6d14 <RNDIS_Device_ProcessControlRequest+0x16a>
    6c26:	85 30       	cpi	r24, 0x05	; 5
    6c28:	91 05       	cpc	r25, r1
    6c2a:	a1 05       	cpc	r26, r1
    6c2c:	b1 05       	cpc	r27, r1
    6c2e:	58 f4       	brcc	.+22     	; 0x6c46 <RNDIS_Device_ProcessControlRequest+0x9c>
    6c30:	82 30       	cpi	r24, 0x02	; 2
    6c32:	91 05       	cpc	r25, r1
    6c34:	a1 05       	cpc	r26, r1
    6c36:	b1 05       	cpc	r27, r1
    6c38:	c1 f0       	breq	.+48     	; 0x6c6a <RNDIS_Device_ProcessControlRequest+0xc0>
    6c3a:	03 97       	sbiw	r24, 0x03	; 3
    6c3c:	a1 05       	cpc	r26, r1
    6c3e:	b1 05       	cpc	r27, r1
    6c40:	09 f0       	breq	.+2      	; 0x6c44 <RNDIS_Device_ProcessControlRequest+0x9a>
    6c42:	72 c2       	rjmp	.+1252   	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
    6c44:	5d c0       	rjmp	.+186    	; 0x6d00 <RNDIS_Device_ProcessControlRequest+0x156>
    6c46:	86 30       	cpi	r24, 0x06	; 6
    6c48:	91 05       	cpc	r25, r1
    6c4a:	a1 05       	cpc	r26, r1
    6c4c:	b1 05       	cpc	r27, r1
    6c4e:	09 f4       	brne	.+2      	; 0x6c52 <RNDIS_Device_ProcessControlRequest+0xa8>
    6c50:	e5 c1       	rjmp	.+970    	; 0x701c <RNDIS_Device_ProcessControlRequest+0x472>
    6c52:	86 30       	cpi	r24, 0x06	; 6
    6c54:	91 05       	cpc	r25, r1
    6c56:	a1 05       	cpc	r26, r1
    6c58:	b1 05       	cpc	r27, r1
    6c5a:	08 f4       	brcc	.+2      	; 0x6c5e <RNDIS_Device_ProcessControlRequest+0xb4>
    6c5c:	94 c1       	rjmp	.+808    	; 0x6f86 <RNDIS_Device_ProcessControlRequest+0x3dc>
    6c5e:	08 97       	sbiw	r24, 0x08	; 8
    6c60:	a1 05       	cpc	r26, r1
    6c62:	b1 05       	cpc	r27, r1
    6c64:	09 f0       	breq	.+2      	; 0x6c68 <RNDIS_Device_ProcessControlRequest+0xbe>
    6c66:	60 c2       	rjmp	.+1216   	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
    6c68:	f5 c1       	rjmp	.+1002   	; 0x7054 <RNDIS_Device_ProcessControlRequest+0x4aa>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6c6a:	cb 56       	subi	r28, 0x6B	; 107
    6c6c:	df 4f       	sbci	r29, 0xFF	; 255
    6c6e:	21 e0       	ldi	r18, 0x01	; 1
    6c70:	28 83       	st	Y, r18
    6c72:	c5 59       	subi	r28, 0x95	; 149
    6c74:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    6c76:	82 e0       	ldi	r24, 0x02	; 2
    6c78:	90 e0       	ldi	r25, 0x00	; 0
    6c7a:	a0 e0       	ldi	r26, 0x00	; 0
    6c7c:	b0 e8       	ldi	r27, 0x80	; 128
    6c7e:	8d 8b       	std	Y+21, r24	; 0x15
    6c80:	9e 8b       	std	Y+22, r25	; 0x16
    6c82:	af 8b       	std	Y+23, r26	; 0x17
    6c84:	b8 8f       	std	Y+24, r27	; 0x18
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    6c86:	84 e3       	ldi	r24, 0x34	; 52
    6c88:	90 e0       	ldi	r25, 0x00	; 0
    6c8a:	a0 e0       	ldi	r26, 0x00	; 0
    6c8c:	b0 e0       	ldi	r27, 0x00	; 0
    6c8e:	f8 01       	movw	r30, r16
    6c90:	84 83       	std	Z+4, r24	; 0x04
    6c92:	95 83       	std	Z+5, r25	; 0x05
    6c94:	a6 83       	std	Z+6, r26	; 0x06
    6c96:	b7 83       	std	Z+7, r27	; 0x07
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    6c98:	14 86       	std	Z+12, r1	; 0x0c
    6c9a:	15 86       	std	Z+13, r1	; 0x0d
    6c9c:	16 86       	std	Z+14, r1	; 0x0e
    6c9e:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    6ca0:	81 e0       	ldi	r24, 0x01	; 1
    6ca2:	90 e0       	ldi	r25, 0x00	; 0
    6ca4:	a0 e0       	ldi	r26, 0x00	; 0
    6ca6:	b0 e0       	ldi	r27, 0x00	; 0
    6ca8:	80 8b       	std	Z+16, r24	; 0x10
    6caa:	91 8b       	std	Z+17, r25	; 0x11
    6cac:	a2 8b       	std	Z+18, r26	; 0x12
    6cae:	b3 8b       	std	Z+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    6cb0:	14 8a       	std	Z+20, r1	; 0x14
    6cb2:	15 8a       	std	Z+21, r1	; 0x15
    6cb4:	16 8a       	std	Z+22, r1	; 0x16
    6cb6:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    6cb8:	80 8f       	std	Z+24, r24	; 0x18
    6cba:	91 8f       	std	Z+25, r25	; 0x19
    6cbc:	a2 8f       	std	Z+26, r26	; 0x1a
    6cbe:	b3 8f       	std	Z+27, r27	; 0x1b
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    6cc0:	14 8e       	std	Z+28, r1	; 0x1c
    6cc2:	15 8e       	std	Z+29, r1	; 0x1d
    6cc4:	16 8e       	std	Z+30, r1	; 0x1e
    6cc6:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    6cc8:	80 a3       	std	Z+32, r24	; 0x20
    6cca:	91 a3       	std	Z+33, r25	; 0x21
    6ccc:	a2 a3       	std	Z+34, r26	; 0x22
    6cce:	b3 a3       	std	Z+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    6cd0:	88 e0       	ldi	r24, 0x08	; 8
    6cd2:	96 e0       	ldi	r25, 0x06	; 6
    6cd4:	a0 e0       	ldi	r26, 0x00	; 0
    6cd6:	b0 e0       	ldi	r27, 0x00	; 0
    6cd8:	84 a3       	std	Z+36, r24	; 0x24
    6cda:	95 a3       	std	Z+37, r25	; 0x25
    6cdc:	a6 a3       	std	Z+38, r26	; 0x26
    6cde:	b7 a3       	std	Z+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    6ce0:	10 a6       	std	Z+40, r1	; 0x28
    6ce2:	11 a6       	std	Z+41, r1	; 0x29
    6ce4:	12 a6       	std	Z+42, r1	; 0x2a
    6ce6:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    6ce8:	14 a6       	std	Z+44, r1	; 0x2c
    6cea:	15 a6       	std	Z+45, r1	; 0x2d
    6cec:	16 a6       	std	Z+46, r1	; 0x2e
    6cee:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    6cf0:	10 aa       	std	Z+48, r1	; 0x30
    6cf2:	11 aa       	std	Z+49, r1	; 0x31
    6cf4:	12 aa       	std	Z+50, r1	; 0x32
    6cf6:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    6cf8:	ca 56       	subi	r28, 0x6A	; 106
    6cfa:	df 4f       	sbci	r29, 0xFF	; 255
    6cfc:	28 83       	st	Y, r18
    6cfe:	14 c2       	rjmp	.+1064   	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    6d00:	cb 56       	subi	r28, 0x6B	; 107
    6d02:	df 4f       	sbci	r29, 0xFF	; 255
    6d04:	19 92       	st	Y+, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    6d06:	f8 01       	movw	r30, r16
    6d08:	14 82       	std	Z+4, r1	; 0x04
    6d0a:	15 82       	std	Z+5, r1	; 0x05
    6d0c:	16 82       	std	Z+6, r1	; 0x06
    6d0e:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    6d10:	18 82       	st	Y, r1
    6d12:	0a c2       	rjmp	.+1044   	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6d14:	cb 56       	subi	r28, 0x6B	; 107
    6d16:	df 4f       	sbci	r29, 0xFF	; 255
    6d18:	81 e0       	ldi	r24, 0x01	; 1
    6d1a:	88 83       	st	Y, r24
    6d1c:	c5 59       	subi	r28, 0x95	; 149
    6d1e:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    6d20:	f8 01       	movw	r30, r16
    6d22:	24 85       	ldd	r18, Z+12	; 0x0c
    6d24:	35 85       	ldd	r19, Z+13	; 0x0d
    6d26:	46 85       	ldd	r20, Z+14	; 0x0e
    6d28:	57 85       	ldd	r21, Z+15	; 0x0f

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    6d2a:	be 01       	movw	r22, r28
    6d2c:	63 5d       	subi	r22, 0xD3	; 211
    6d2e:	7f 4f       	sbci	r23, 0xFF	; 255
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    6d30:	84 e0       	ldi	r24, 0x04	; 4
    6d32:	90 e0       	ldi	r25, 0x00	; 0
    6d34:	a0 e0       	ldi	r26, 0x00	; 0
    6d36:	b0 e8       	ldi	r27, 0x80	; 128
    6d38:	8d 8b       	std	Y+21, r24	; 0x15
    6d3a:	9e 8b       	std	Y+22, r25	; 0x16
    6d3c:	af 8b       	std	Y+23, r26	; 0x17
    6d3e:	b8 8f       	std	Y+24, r27	; 0x18
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    6d40:	2e 30       	cpi	r18, 0x0E	; 14
    6d42:	f1 e0       	ldi	r31, 0x01	; 1
    6d44:	3f 07       	cpc	r19, r31
    6d46:	f1 e0       	ldi	r31, 0x01	; 1
    6d48:	4f 07       	cpc	r20, r31
    6d4a:	f0 e0       	ldi	r31, 0x00	; 0
    6d4c:	5f 07       	cpc	r21, r31
    6d4e:	09 f4       	brne	.+2      	; 0x6d52 <RNDIS_Device_ProcessControlRequest+0x1a8>
    6d50:	e7 c0       	rjmp	.+462    	; 0x6f20 <RNDIS_Device_ProcessControlRequest+0x376>
    6d52:	2f 30       	cpi	r18, 0x0F	; 15
    6d54:	81 e0       	ldi	r24, 0x01	; 1
    6d56:	38 07       	cpc	r19, r24
    6d58:	81 e0       	ldi	r24, 0x01	; 1
    6d5a:	48 07       	cpc	r20, r24
    6d5c:	80 e0       	ldi	r24, 0x00	; 0
    6d5e:	58 07       	cpc	r21, r24
    6d60:	08 f0       	brcs	.+2      	; 0x6d64 <RNDIS_Device_ProcessControlRequest+0x1ba>
    6d62:	58 c0       	rjmp	.+176    	; 0x6e14 <RNDIS_Device_ProcessControlRequest+0x26a>
    6d64:	26 30       	cpi	r18, 0x06	; 6
    6d66:	e1 e0       	ldi	r30, 0x01	; 1
    6d68:	3e 07       	cpc	r19, r30
    6d6a:	e1 e0       	ldi	r30, 0x01	; 1
    6d6c:	4e 07       	cpc	r20, r30
    6d6e:	e0 e0       	ldi	r30, 0x00	; 0
    6d70:	5e 07       	cpc	r21, r30
    6d72:	09 f4       	brne	.+2      	; 0x6d76 <RNDIS_Device_ProcessControlRequest+0x1cc>
    6d74:	ae c0       	rjmp	.+348    	; 0x6ed2 <RNDIS_Device_ProcessControlRequest+0x328>
    6d76:	27 30       	cpi	r18, 0x07	; 7
    6d78:	f1 e0       	ldi	r31, 0x01	; 1
    6d7a:	3f 07       	cpc	r19, r31
    6d7c:	f1 e0       	ldi	r31, 0x01	; 1
    6d7e:	4f 07       	cpc	r20, r31
    6d80:	f0 e0       	ldi	r31, 0x00	; 0
    6d82:	5f 07       	cpc	r21, r31
    6d84:	f8 f4       	brcc	.+62     	; 0x6dc4 <RNDIS_Device_ProcessControlRequest+0x21a>
    6d86:	22 30       	cpi	r18, 0x02	; 2
    6d88:	81 e0       	ldi	r24, 0x01	; 1
    6d8a:	38 07       	cpc	r19, r24
    6d8c:	81 e0       	ldi	r24, 0x01	; 1
    6d8e:	48 07       	cpc	r20, r24
    6d90:	80 e0       	ldi	r24, 0x00	; 0
    6d92:	58 07       	cpc	r21, r24
    6d94:	09 f4       	brne	.+2      	; 0x6d98 <RNDIS_Device_ProcessControlRequest+0x1ee>
    6d96:	cd c0       	rjmp	.+410    	; 0x6f32 <RNDIS_Device_ProcessControlRequest+0x388>
    6d98:	23 30       	cpi	r18, 0x03	; 3
    6d9a:	e1 e0       	ldi	r30, 0x01	; 1
    6d9c:	3e 07       	cpc	r19, r30
    6d9e:	e1 e0       	ldi	r30, 0x01	; 1
    6da0:	4e 07       	cpc	r20, r30
    6da2:	e0 e0       	ldi	r30, 0x00	; 0
    6da4:	5e 07       	cpc	r21, r30
    6da6:	38 f4       	brcc	.+14     	; 0x6db6 <RNDIS_Device_ProcessControlRequest+0x20c>
    6da8:	21 50       	subi	r18, 0x01	; 1
    6daa:	31 40       	sbci	r19, 0x01	; 1
    6dac:	41 40       	sbci	r20, 0x01	; 1
    6dae:	50 40       	sbci	r21, 0x00	; 0
    6db0:	09 f0       	breq	.+2      	; 0x6db4 <RNDIS_Device_ProcessControlRequest+0x20a>
    6db2:	cf c0       	rjmp	.+414    	; 0x6f52 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6db4:	80 c0       	rjmp	.+256    	; 0x6eb6 <RNDIS_Device_ProcessControlRequest+0x30c>
    6db6:	25 50       	subi	r18, 0x05	; 5
    6db8:	31 40       	sbci	r19, 0x01	; 1
    6dba:	41 40       	sbci	r20, 0x01	; 1
    6dbc:	50 40       	sbci	r21, 0x00	; 0
    6dbe:	08 f0       	brcs	.+2      	; 0x6dc2 <RNDIS_Device_ProcessControlRequest+0x218>
    6dc0:	c8 c0       	rjmp	.+400    	; 0x6f52 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6dc2:	b7 c0       	rjmp	.+366    	; 0x6f32 <RNDIS_Device_ProcessControlRequest+0x388>
    6dc4:	2c 30       	cpi	r18, 0x0C	; 12
    6dc6:	81 e0       	ldi	r24, 0x01	; 1
    6dc8:	38 07       	cpc	r19, r24
    6dca:	81 e0       	ldi	r24, 0x01	; 1
    6dcc:	48 07       	cpc	r20, r24
    6dce:	80 e0       	ldi	r24, 0x00	; 0
    6dd0:	58 07       	cpc	r21, r24
    6dd2:	80 f4       	brcc	.+32     	; 0x6df4 <RNDIS_Device_ProcessControlRequest+0x24a>
    6dd4:	2a 30       	cpi	r18, 0x0A	; 10
    6dd6:	e1 e0       	ldi	r30, 0x01	; 1
    6dd8:	3e 07       	cpc	r19, r30
    6dda:	e1 e0       	ldi	r30, 0x01	; 1
    6ddc:	4e 07       	cpc	r20, r30
    6dde:	e0 e0       	ldi	r30, 0x00	; 0
    6de0:	5e 07       	cpc	r21, r30
    6de2:	08 f0       	brcs	.+2      	; 0x6de6 <RNDIS_Device_ProcessControlRequest+0x23c>
    6de4:	76 c0       	rjmp	.+236    	; 0x6ed2 <RNDIS_Device_ProcessControlRequest+0x328>
    6de6:	27 50       	subi	r18, 0x07	; 7
    6de8:	31 40       	sbci	r19, 0x01	; 1
    6dea:	41 40       	sbci	r20, 0x01	; 1
    6dec:	50 40       	sbci	r21, 0x00	; 0
    6dee:	09 f0       	breq	.+2      	; 0x6df2 <RNDIS_Device_ProcessControlRequest+0x248>
    6df0:	b0 c0       	rjmp	.+352    	; 0x6f52 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6df2:	81 c0       	rjmp	.+258    	; 0x6ef6 <RNDIS_Device_ProcessControlRequest+0x34c>
    6df4:	2c 30       	cpi	r18, 0x0C	; 12
    6df6:	81 e0       	ldi	r24, 0x01	; 1
    6df8:	38 07       	cpc	r19, r24
    6dfa:	81 e0       	ldi	r24, 0x01	; 1
    6dfc:	48 07       	cpc	r20, r24
    6dfe:	80 e0       	ldi	r24, 0x00	; 0
    6e00:	58 07       	cpc	r21, r24
    6e02:	09 f4       	brne	.+2      	; 0x6e06 <RNDIS_Device_ProcessControlRequest+0x25c>
    6e04:	61 c0       	rjmp	.+194    	; 0x6ec8 <RNDIS_Device_ProcessControlRequest+0x31e>
    6e06:	2d 50       	subi	r18, 0x0D	; 13
    6e08:	31 40       	sbci	r19, 0x01	; 1
    6e0a:	41 40       	sbci	r20, 0x01	; 1
    6e0c:	50 40       	sbci	r21, 0x00	; 0
    6e0e:	09 f0       	breq	.+2      	; 0x6e12 <RNDIS_Device_ProcessControlRequest+0x268>
    6e10:	a0 c0       	rjmp	.+320    	; 0x6f52 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6e12:	64 c0       	rjmp	.+200    	; 0x6edc <RNDIS_Device_ProcessControlRequest+0x332>
    6e14:	26 30       	cpi	r18, 0x06	; 6
    6e16:	f1 e0       	ldi	r31, 0x01	; 1
    6e18:	3f 07       	cpc	r19, r31
    6e1a:	f2 e0       	ldi	r31, 0x02	; 2
    6e1c:	4f 07       	cpc	r20, r31
    6e1e:	f0 e0       	ldi	r31, 0x00	; 0
    6e20:	5f 07       	cpc	r21, r31
    6e22:	10 f5       	brcc	.+68     	; 0x6e68 <RNDIS_Device_ProcessControlRequest+0x2be>
    6e24:	21 30       	cpi	r18, 0x01	; 1
    6e26:	61 e0       	ldi	r22, 0x01	; 1
    6e28:	36 07       	cpc	r19, r22
    6e2a:	62 e0       	ldi	r22, 0x02	; 2
    6e2c:	46 07       	cpc	r20, r22
    6e2e:	60 e0       	ldi	r22, 0x00	; 0
    6e30:	56 07       	cpc	r21, r22
    6e32:	08 f0       	brcs	.+2      	; 0x6e36 <RNDIS_Device_ProcessControlRequest+0x28c>
    6e34:	7e c0       	rjmp	.+252    	; 0x6f32 <RNDIS_Device_ProcessControlRequest+0x388>
    6e36:	24 31       	cpi	r18, 0x14	; 20
    6e38:	81 e0       	ldi	r24, 0x01	; 1
    6e3a:	38 07       	cpc	r19, r24
    6e3c:	81 e0       	ldi	r24, 0x01	; 1
    6e3e:	48 07       	cpc	r20, r24
    6e40:	80 e0       	ldi	r24, 0x00	; 0
    6e42:	58 07       	cpc	r21, r24
    6e44:	09 f4       	brne	.+2      	; 0x6e48 <RNDIS_Device_ProcessControlRequest+0x29e>
    6e46:	75 c0       	rjmp	.+234    	; 0x6f32 <RNDIS_Device_ProcessControlRequest+0x388>
    6e48:	22 30       	cpi	r18, 0x02	; 2
    6e4a:	e2 e0       	ldi	r30, 0x02	; 2
    6e4c:	3e 07       	cpc	r19, r30
    6e4e:	e1 e0       	ldi	r30, 0x01	; 1
    6e50:	4e 07       	cpc	r20, r30
    6e52:	e0 e0       	ldi	r30, 0x00	; 0
    6e54:	5e 07       	cpc	r21, r30
    6e56:	09 f4       	brne	.+2      	; 0x6e5a <RNDIS_Device_ProcessControlRequest+0x2b0>
    6e58:	6c c0       	rjmp	.+216    	; 0x6f32 <RNDIS_Device_ProcessControlRequest+0x388>
    6e5a:	21 51       	subi	r18, 0x11	; 17
    6e5c:	31 40       	sbci	r19, 0x01	; 1
    6e5e:	41 40       	sbci	r20, 0x01	; 1
    6e60:	50 40       	sbci	r21, 0x00	; 0
    6e62:	09 f0       	breq	.+2      	; 0x6e66 <RNDIS_Device_ProcessControlRequest+0x2bc>
    6e64:	76 c0       	rjmp	.+236    	; 0x6f52 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6e66:	6a c0       	rjmp	.+212    	; 0x6f3c <RNDIS_Device_ProcessControlRequest+0x392>
    6e68:	24 30       	cpi	r18, 0x04	; 4
    6e6a:	81 e0       	ldi	r24, 0x01	; 1
    6e6c:	38 07       	cpc	r19, r24
    6e6e:	81 e0       	ldi	r24, 0x01	; 1
    6e70:	48 07       	cpc	r20, r24
    6e72:	81 e0       	ldi	r24, 0x01	; 1
    6e74:	58 07       	cpc	r21, r24
    6e76:	09 f4       	brne	.+2      	; 0x6e7a <RNDIS_Device_ProcessControlRequest+0x2d0>
    6e78:	4e c0       	rjmp	.+156    	; 0x6f16 <RNDIS_Device_ProcessControlRequest+0x36c>
    6e7a:	25 30       	cpi	r18, 0x05	; 5
    6e7c:	e1 e0       	ldi	r30, 0x01	; 1
    6e7e:	3e 07       	cpc	r19, r30
    6e80:	e1 e0       	ldi	r30, 0x01	; 1
    6e82:	4e 07       	cpc	r20, r30
    6e84:	e1 e0       	ldi	r30, 0x01	; 1
    6e86:	5e 07       	cpc	r21, r30
    6e88:	58 f4       	brcc	.+22     	; 0x6ea0 <RNDIS_Device_ProcessControlRequest+0x2f6>
    6e8a:	21 50       	subi	r18, 0x01	; 1
    6e8c:	31 40       	sbci	r19, 0x01	; 1
    6e8e:	41 40       	sbci	r20, 0x01	; 1
    6e90:	51 40       	sbci	r21, 0x01	; 1
    6e92:	22 30       	cpi	r18, 0x02	; 2
    6e94:	31 05       	cpc	r19, r1
    6e96:	41 05       	cpc	r20, r1
    6e98:	51 05       	cpc	r21, r1
    6e9a:	08 f0       	brcs	.+2      	; 0x6e9e <RNDIS_Device_ProcessControlRequest+0x2f4>
    6e9c:	5a c0       	rjmp	.+180    	; 0x6f52 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6e9e:	30 c0       	rjmp	.+96     	; 0x6f00 <RNDIS_Device_ProcessControlRequest+0x356>
    6ea0:	21 50       	subi	r18, 0x01	; 1
    6ea2:	31 40       	sbci	r19, 0x01	; 1
    6ea4:	42 40       	sbci	r20, 0x02	; 2
    6ea6:	51 40       	sbci	r21, 0x01	; 1
    6ea8:	23 30       	cpi	r18, 0x03	; 3
    6eaa:	31 05       	cpc	r19, r1
    6eac:	41 05       	cpc	r20, r1
    6eae:	51 05       	cpc	r21, r1
    6eb0:	08 f0       	brcs	.+2      	; 0x6eb4 <RNDIS_Device_ProcessControlRequest+0x30a>
    6eb2:	4f c0       	rjmp	.+158    	; 0x6f52 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6eb4:	3e c0       	rjmp	.+124    	; 0x6f32 <RNDIS_Device_ProcessControlRequest+0x388>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    6eb6:	cb 01       	movw	r24, r22
    6eb8:	63 ea       	ldi	r22, 0xA3	; 163
    6eba:	73 e0       	ldi	r23, 0x03	; 3
    6ebc:	4c e6       	ldi	r20, 0x6C	; 108
    6ebe:	50 e0       	ldi	r21, 0x00	; 0
    6ec0:	93 d5       	rcall	.+2854   	; 0x79e8 <memcpy_P>
    6ec2:	cc e6       	ldi	r28, 0x6C	; 108
    6ec4:	d0 e0       	ldi	r29, 0x00	; 0
    6ec6:	13 c1       	rjmp	.+550    	; 0x70ee <RNDIS_Device_ProcessControlRequest+0x544>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    6ec8:	8f ef       	ldi	r24, 0xFF	; 255
    6eca:	9f ef       	ldi	r25, 0xFF	; 255
    6ecc:	af ef       	ldi	r26, 0xFF	; 255
    6ece:	b0 e0       	ldi	r27, 0x00	; 0
    6ed0:	39 c0       	rjmp	.+114    	; 0x6f44 <RNDIS_Device_ProcessControlRequest+0x39a>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    6ed2:	8c ed       	ldi	r24, 0xDC	; 220
    6ed4:	95 e0       	ldi	r25, 0x05	; 5
    6ed6:	a0 e0       	ldi	r26, 0x00	; 0
    6ed8:	b0 e0       	ldi	r27, 0x00	; 0
    6eda:	34 c0       	rjmp	.+104    	; 0x6f44 <RNDIS_Device_ProcessControlRequest+0x39a>

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    6edc:	ed 85       	ldd	r30, Y+13	; 0x0d
    6ede:	fe 85       	ldd	r31, Y+14	; 0x0e
    6ee0:	ef 01       	movw	r28, r30
    6ee2:	09 90       	ld	r0, Y+
    6ee4:	00 20       	and	r0, r0
    6ee6:	e9 f7       	brne	.-6      	; 0x6ee2 <RNDIS_Device_ProcessControlRequest+0x338>
    6ee8:	ce 1b       	sub	r28, r30
    6eea:	df 0b       	sbc	r29, r31

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    6eec:	cb 01       	movw	r24, r22
    6eee:	bf 01       	movw	r22, r30
    6ef0:	ae 01       	movw	r20, r28
    6ef2:	aa d5       	rcall	.+2900   	; 0x7a48 <memcpy>
    6ef4:	fc c0       	rjmp	.+504    	; 0x70ee <RNDIS_Device_ProcessControlRequest+0x544>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    6ef6:	80 ea       	ldi	r24, 0xA0	; 160
    6ef8:	96 e8       	ldi	r25, 0x86	; 134
    6efa:	a1 e0       	ldi	r26, 0x01	; 1
    6efc:	b0 e0       	ldi	r27, 0x00	; 0
    6efe:	22 c0       	rjmp	.+68     	; 0x6f44 <RNDIS_Device_ProcessControlRequest+0x39a>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    6f00:	db 01       	movw	r26, r22
    6f02:	fe 01       	movw	r30, r28
    6f04:	3f 96       	adiw	r30, 0x0f	; 15
    6f06:	86 e0       	ldi	r24, 0x06	; 6
    6f08:	01 90       	ld	r0, Z+
    6f0a:	0d 92       	st	X+, r0
    6f0c:	81 50       	subi	r24, 0x01	; 1
    6f0e:	e1 f7       	brne	.-8      	; 0x6f08 <RNDIS_Device_ProcessControlRequest+0x35e>
    6f10:	c6 e0       	ldi	r28, 0x06	; 6
    6f12:	d0 e0       	ldi	r29, 0x00	; 0
    6f14:	ec c0       	rjmp	.+472    	; 0x70ee <RNDIS_Device_ProcessControlRequest+0x544>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    6f16:	81 e0       	ldi	r24, 0x01	; 1
    6f18:	90 e0       	ldi	r25, 0x00	; 0
    6f1a:	a0 e0       	ldi	r26, 0x00	; 0
    6f1c:	b0 e0       	ldi	r27, 0x00	; 0
    6f1e:	12 c0       	rjmp	.+36     	; 0x6f44 <RNDIS_Device_ProcessControlRequest+0x39a>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    6f20:	c9 56       	subi	r28, 0x69	; 105
    6f22:	df 4f       	sbci	r29, 0xFF	; 255
    6f24:	88 81       	ld	r24, Y
    6f26:	99 81       	ldd	r25, Y+1	; 0x01
    6f28:	aa 81       	ldd	r26, Y+2	; 0x02
    6f2a:	bb 81       	ldd	r27, Y+3	; 0x03
    6f2c:	c7 59       	subi	r28, 0x97	; 151
    6f2e:	d0 40       	sbci	r29, 0x00	; 0
    6f30:	09 c0       	rjmp	.+18     	; 0x6f44 <RNDIS_Device_ProcessControlRequest+0x39a>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    6f32:	1d a6       	std	Y+45, r1	; 0x2d
    6f34:	1e a6       	std	Y+46, r1	; 0x2e
    6f36:	1f a6       	std	Y+47, r1	; 0x2f
    6f38:	18 aa       	std	Y+48, r1	; 0x30
    6f3a:	08 c0       	rjmp	.+16     	; 0x6f4c <RNDIS_Device_ProcessControlRequest+0x3a2>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    6f3c:	8c e5       	ldi	r24, 0x5C	; 92
    6f3e:	96 e0       	ldi	r25, 0x06	; 6
    6f40:	a0 e0       	ldi	r26, 0x00	; 0
    6f42:	b0 e0       	ldi	r27, 0x00	; 0
    6f44:	8d a7       	std	Y+45, r24	; 0x2d
    6f46:	9e a7       	std	Y+46, r25	; 0x2e
    6f48:	af a7       	std	Y+47, r26	; 0x2f
    6f4a:	b8 ab       	std	Y+48, r27	; 0x30
    6f4c:	c4 e0       	ldi	r28, 0x04	; 4
    6f4e:	d0 e0       	ldi	r29, 0x00	; 0
    6f50:	ce c0       	rjmp	.+412    	; 0x70ee <RNDIS_Device_ProcessControlRequest+0x544>
				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    6f52:	8b eb       	ldi	r24, 0xBB	; 187
    6f54:	90 e0       	ldi	r25, 0x00	; 0
    6f56:	a0 e0       	ldi	r26, 0x00	; 0
    6f58:	b0 ec       	ldi	r27, 0xC0	; 192
    6f5a:	f8 01       	movw	r30, r16
    6f5c:	84 87       	std	Z+12, r24	; 0x0c
    6f5e:	95 87       	std	Z+13, r25	; 0x0d
    6f60:	a6 87       	std	Z+14, r26	; 0x0e
    6f62:	b7 87       	std	Z+15, r27	; 0x0f
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    6f64:	88 e1       	ldi	r24, 0x18	; 24
    6f66:	90 e0       	ldi	r25, 0x00	; 0
    6f68:	a0 e0       	ldi	r26, 0x00	; 0
    6f6a:	b0 e0       	ldi	r27, 0x00	; 0
    6f6c:	84 83       	std	Z+4, r24	; 0x04
    6f6e:	95 83       	std	Z+5, r25	; 0x05
    6f70:	a6 83       	std	Z+6, r26	; 0x06
    6f72:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    6f74:	10 8a       	std	Z+16, r1	; 0x10
    6f76:	11 8a       	std	Z+17, r1	; 0x11
    6f78:	12 8a       	std	Z+18, r1	; 0x12
    6f7a:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    6f7c:	14 8a       	std	Z+20, r1	; 0x14
    6f7e:	15 8a       	std	Z+21, r1	; 0x15
    6f80:	16 8a       	std	Z+22, r1	; 0x16
    6f82:	17 8a       	std	Z+23, r1	; 0x17
    6f84:	d1 c0       	rjmp	.+418    	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6f86:	cb 56       	subi	r28, 0x6B	; 107
    6f88:	df 4f       	sbci	r29, 0xFF	; 255
    6f8a:	81 e0       	ldi	r24, 0x01	; 1
    6f8c:	88 83       	st	Y, r24
    6f8e:	c5 59       	subi	r28, 0x95	; 149
    6f90:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    6f92:	f8 01       	movw	r30, r16
    6f94:	24 85       	ldd	r18, Z+12	; 0x0c
    6f96:	35 85       	ldd	r19, Z+13	; 0x0d
    6f98:	46 85       	ldd	r20, Z+14	; 0x0e
    6f9a:	57 85       	ldd	r21, Z+15	; 0x0f

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    6f9c:	85 e0       	ldi	r24, 0x05	; 5
    6f9e:	90 e0       	ldi	r25, 0x00	; 0
    6fa0:	a0 e0       	ldi	r26, 0x00	; 0
    6fa2:	b0 e8       	ldi	r27, 0x80	; 128
    6fa4:	8d 8b       	std	Y+21, r24	; 0x15
    6fa6:	9e 8b       	std	Y+22, r25	; 0x16
    6fa8:	af 8b       	std	Y+23, r26	; 0x17
    6faa:	b8 8f       	std	Y+24, r27	; 0x18
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    6fac:	80 e1       	ldi	r24, 0x10	; 16
    6fae:	90 e0       	ldi	r25, 0x00	; 0
    6fb0:	a0 e0       	ldi	r26, 0x00	; 0
    6fb2:	b0 e0       	ldi	r27, 0x00	; 0
    6fb4:	84 83       	std	Z+4, r24	; 0x04
    6fb6:	95 83       	std	Z+5, r25	; 0x05
    6fb8:	a6 83       	std	Z+6, r26	; 0x06
    6fba:	b7 83       	std	Z+7, r27	; 0x07
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    6fbc:	84 89       	ldd	r24, Z+20	; 0x14
    6fbe:	95 89       	ldd	r25, Z+21	; 0x15
    6fc0:	a6 89       	ldd	r26, Z+22	; 0x16
    6fc2:	b7 89       	ldd	r27, Z+23	; 0x17
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    6fc4:	2e 30       	cpi	r18, 0x0E	; 14
    6fc6:	f1 e0       	ldi	r31, 0x01	; 1
    6fc8:	3f 07       	cpc	r19, r31
    6fca:	f1 e0       	ldi	r31, 0x01	; 1
    6fcc:	4f 07       	cpc	r20, r31
    6fce:	f0 e0       	ldi	r31, 0x00	; 0
    6fd0:	5f 07       	cpc	r21, r31
    6fd2:	51 f0       	breq	.+20     	; 0x6fe8 <RNDIS_Device_ProcessControlRequest+0x43e>
    6fd4:	23 50       	subi	r18, 0x03	; 3
    6fd6:	31 40       	sbci	r19, 0x01	; 1
    6fd8:	41 40       	sbci	r20, 0x01	; 1
    6fda:	51 40       	sbci	r21, 0x01	; 1
    6fdc:	a9 f0       	breq	.+42     	; 0x7008 <RNDIS_Device_ProcessControlRequest+0x45e>
    6fde:	8b eb       	ldi	r24, 0xBB	; 187
    6fe0:	90 e0       	ldi	r25, 0x00	; 0
    6fe2:	a0 e0       	ldi	r26, 0x00	; 0
    6fe4:	b0 ec       	ldi	r27, 0xC0	; 192
    6fe6:	14 c0       	rjmp	.+40     	; 0x7010 <RNDIS_Device_ProcessControlRequest+0x466>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    6fe8:	fe 01       	movw	r30, r28
    6fea:	e8 0f       	add	r30, r24
    6fec:	f9 1f       	adc	r31, r25
    6fee:	85 8d       	ldd	r24, Z+29	; 0x1d
    6ff0:	96 8d       	ldd	r25, Z+30	; 0x1e
    6ff2:	a7 8d       	ldd	r26, Z+31	; 0x1f
    6ff4:	b0 a1       	ldd	r27, Z+32	; 0x20
    6ff6:	c9 56       	subi	r28, 0x69	; 105
    6ff8:	df 4f       	sbci	r29, 0xFF	; 255
    6ffa:	88 83       	st	Y, r24
    6ffc:	99 83       	std	Y+1, r25	; 0x01
    6ffe:	aa 83       	std	Y+2, r26	; 0x02
    7000:	bb 83       	std	Y+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState   = le32_to_cpu((RNDISInterfaceInfo->State.CurrPacketFilter) ?
    7002:	fe 01       	movw	r30, r28
    7004:	82 e0       	ldi	r24, 0x02	; 2
    7006:	82 93       	st	-Z, r24
    7008:	80 e0       	ldi	r24, 0x00	; 0
    700a:	90 e0       	ldi	r25, 0x00	; 0
    700c:	a0 e0       	ldi	r26, 0x00	; 0
    700e:	b0 e0       	ldi	r27, 0x00	; 0
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    7010:	f8 01       	movw	r30, r16
    7012:	84 87       	std	Z+12, r24	; 0x0c
    7014:	95 87       	std	Z+13, r25	; 0x0d
    7016:	a6 87       	std	Z+14, r26	; 0x0e
    7018:	b7 87       	std	Z+15, r27	; 0x0f
    701a:	86 c0       	rjmp	.+268    	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    701c:	cb 56       	subi	r28, 0x6B	; 107
    701e:	df 4f       	sbci	r29, 0xFF	; 255
    7020:	81 e0       	ldi	r24, 0x01	; 1
    7022:	88 83       	st	Y, r24
    7024:	c5 59       	subi	r28, 0x95	; 149
    7026:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    7028:	86 e0       	ldi	r24, 0x06	; 6
    702a:	90 e0       	ldi	r25, 0x00	; 0
    702c:	a0 e0       	ldi	r26, 0x00	; 0
    702e:	b0 e8       	ldi	r27, 0x80	; 128
    7030:	8d 8b       	std	Y+21, r24	; 0x15
    7032:	9e 8b       	std	Y+22, r25	; 0x16
    7034:	af 8b       	std	Y+23, r26	; 0x17
    7036:	b8 8f       	std	Y+24, r27	; 0x18
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    7038:	80 e1       	ldi	r24, 0x10	; 16
    703a:	90 e0       	ldi	r25, 0x00	; 0
    703c:	a0 e0       	ldi	r26, 0x00	; 0
    703e:	b0 e0       	ldi	r27, 0x00	; 0
    7040:	f8 01       	movw	r30, r16
    7042:	84 83       	std	Z+4, r24	; 0x04
    7044:	95 83       	std	Z+5, r25	; 0x05
    7046:	a6 83       	std	Z+6, r26	; 0x06
    7048:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    704a:	10 86       	std	Z+8, r1	; 0x08
    704c:	11 86       	std	Z+9, r1	; 0x09
    704e:	12 86       	std	Z+10, r1	; 0x0a
    7050:	13 86       	std	Z+11, r1	; 0x0b
    7052:	17 c0       	rjmp	.+46     	; 0x7082 <RNDIS_Device_ProcessControlRequest+0x4d8>
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    7054:	cb 56       	subi	r28, 0x6B	; 107
    7056:	df 4f       	sbci	r29, 0xFF	; 255
    7058:	81 e0       	ldi	r24, 0x01	; 1
    705a:	88 83       	st	Y, r24
    705c:	c5 59       	subi	r28, 0x95	; 149
    705e:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    7060:	88 e0       	ldi	r24, 0x08	; 8
    7062:	90 e0       	ldi	r25, 0x00	; 0
    7064:	a0 e0       	ldi	r26, 0x00	; 0
    7066:	b0 e8       	ldi	r27, 0x80	; 128
    7068:	8d 8b       	std	Y+21, r24	; 0x15
    706a:	9e 8b       	std	Y+22, r25	; 0x16
    706c:	af 8b       	std	Y+23, r26	; 0x17
    706e:	b8 8f       	std	Y+24, r27	; 0x18
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    7070:	80 e1       	ldi	r24, 0x10	; 16
    7072:	90 e0       	ldi	r25, 0x00	; 0
    7074:	a0 e0       	ldi	r26, 0x00	; 0
    7076:	b0 e0       	ldi	r27, 0x00	; 0
    7078:	f8 01       	movw	r30, r16
    707a:	84 83       	std	Z+4, r24	; 0x04
    707c:	95 83       	std	Z+5, r25	; 0x05
    707e:	a6 83       	std	Z+6, r26	; 0x06
    7080:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    7082:	14 86       	std	Z+12, r1	; 0x0c
    7084:	15 86       	std	Z+13, r1	; 0x0d
    7086:	16 86       	std	Z+14, r1	; 0x0e
    7088:	17 86       	std	Z+15, r1	; 0x0f
    708a:	4e c0       	rjmp	.+156    	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    708c:	80 91 a4 0d 	lds	r24, 0x0DA4
    7090:	81 3a       	cpi	r24, 0xA1	; 161
    7092:	09 f0       	breq	.+2      	; 0x7096 <RNDIS_Device_ProcessControlRequest+0x4ec>
    7094:	49 c0       	rjmp	.+146    	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
    7096:	8e 01       	movw	r16, r28
    7098:	0b 5e       	subi	r16, 0xEB	; 235
    709a:	1f 4f       	sbci	r17, 0xFF	; 255

				if (!(MessageHeader->MessageLength))
    709c:	f8 01       	movw	r30, r16
    709e:	84 81       	ldd	r24, Z+4	; 0x04
    70a0:	95 81       	ldd	r25, Z+5	; 0x05
    70a2:	a6 81       	ldd	r26, Z+6	; 0x06
    70a4:	b7 81       	ldd	r27, Z+7	; 0x07
    70a6:	00 97       	sbiw	r24, 0x00	; 0
    70a8:	a1 05       	cpc	r26, r1
    70aa:	b1 05       	cpc	r27, r1
    70ac:	49 f4       	brne	.+18     	; 0x70c0 <RNDIS_Device_ProcessControlRequest+0x516>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    70ae:	1d 8a       	std	Y+21, r1	; 0x15
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    70b0:	81 e0       	ldi	r24, 0x01	; 1
    70b2:	90 e0       	ldi	r25, 0x00	; 0
    70b4:	a0 e0       	ldi	r26, 0x00	; 0
    70b6:	b0 e0       	ldi	r27, 0x00	; 0
    70b8:	84 83       	std	Z+4, r24	; 0x04
    70ba:	95 83       	std	Z+5, r25	; 0x05
    70bc:	a6 83       	std	Z+6, r26	; 0x06
    70be:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    70c0:	80 91 e8 00 	lds	r24, 0x00E8
    70c4:	87 7f       	andi	r24, 0xF7	; 247
    70c6:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    70ca:	f8 01       	movw	r30, r16
    70cc:	64 81       	ldd	r22, Z+4	; 0x04
    70ce:	75 81       	ldd	r23, Z+5	; 0x05
    70d0:	ce 01       	movw	r24, r28
    70d2:	45 96       	adiw	r24, 0x15	; 21
    70d4:	0e 94 e8 2b 	call	0x57d0	; 0x57d0 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    70d8:	80 91 e8 00 	lds	r24, 0x00E8
    70dc:	8b 77       	andi	r24, 0x7B	; 123
    70de:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    70e2:	f8 01       	movw	r30, r16
    70e4:	14 82       	std	Z+4, r1	; 0x04
    70e6:	15 82       	std	Z+5, r1	; 0x05
    70e8:	16 82       	std	Z+6, r1	; 0x06
    70ea:	17 82       	std	Z+7, r1	; 0x07
    70ec:	1d c0       	rjmp	.+58     	; 0x7128 <RNDIS_Device_ProcessControlRequest+0x57e>
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
			
			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    70ee:	f8 01       	movw	r30, r16
    70f0:	14 86       	std	Z+12, r1	; 0x0c
    70f2:	15 86       	std	Z+13, r1	; 0x0d
    70f4:	16 86       	std	Z+14, r1	; 0x0e
    70f6:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    70f8:	68 96       	adiw	r28, 0x18	; 24
    70fa:	ce 01       	movw	r24, r28
    70fc:	a0 e0       	ldi	r26, 0x00	; 0
    70fe:	b0 e0       	ldi	r27, 0x00	; 0
    7100:	68 97       	sbiw	r28, 0x18	; 24
    7102:	84 83       	std	Z+4, r24	; 0x04
    7104:	95 83       	std	Z+5, r25	; 0x05
    7106:	a6 83       	std	Z+6, r26	; 0x06
    7108:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    710a:	ce 01       	movw	r24, r28
    710c:	a0 e0       	ldi	r26, 0x00	; 0
    710e:	b0 e0       	ldi	r27, 0x00	; 0
    7110:	80 8b       	std	Z+16, r24	; 0x10
    7112:	91 8b       	std	Z+17, r25	; 0x11
    7114:	a2 8b       	std	Z+18, r26	; 0x12
    7116:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    7118:	80 e1       	ldi	r24, 0x10	; 16
    711a:	90 e0       	ldi	r25, 0x00	; 0
    711c:	a0 e0       	ldi	r26, 0x00	; 0
    711e:	b0 e0       	ldi	r27, 0x00	; 0
    7120:	84 8b       	std	Z+20, r24	; 0x14
    7122:	95 8b       	std	Z+21, r25	; 0x15
    7124:	a6 8b       	std	Z+22, r26	; 0x16
    7126:	b7 8b       	std	Z+23, r27	; 0x17
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    7128:	df 91       	pop	r29
    712a:	cf 91       	pop	r28
    712c:	1f 91       	pop	r17
    712e:	0f 91       	pop	r16
    7130:	08 95       	ret

00007132 <DCOMP_RNDIS_Host_NextRNDISControlInterface>:

	return RNDIS_ENUMERROR_NoError;
}

static uint8_t DCOMP_RNDIS_Host_NextRNDISControlInterface(void* const CurrentDescriptor)
{
    7132:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    7134:	81 81       	ldd	r24, Z+1	; 0x01
    7136:	84 30       	cpi	r24, 0x04	; 4
    7138:	59 f4       	brne	.+22     	; 0x7150 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCClass)    &&
    713a:	85 81       	ldd	r24, Z+5	; 0x05
    713c:	82 30       	cpi	r24, 0x02	; 2
    713e:	41 f4       	brne	.+16     	; 0x7150 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    7140:	86 81       	ldd	r24, Z+6	; 0x06
    7142:	82 30       	cpi	r24, 0x02	; 2
    7144:	29 f4       	brne	.+10     	; 0x7150 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    7146:	87 81       	ldd	r24, Z+7	; 0x07
    7148:	8f 3f       	cpi	r24, 0xFF	; 255
    714a:	11 f4       	brne	.+4      	; 0x7150 <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
    714c:	80 e0       	ldi	r24, 0x00	; 0
    714e:	08 95       	ret
    7150:	82 e0       	ldi	r24, 0x02	; 2
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    7152:	08 95       	ret

00007154 <DCOMP_RNDIS_Host_NextRNDISDataInterface>:

static uint8_t DCOMP_RNDIS_Host_NextRNDISDataInterface(void* const CurrentDescriptor)
{
    7154:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    7156:	81 81       	ldd	r24, Z+1	; 0x01
    7158:	84 30       	cpi	r24, 0x04	; 4
    715a:	41 f4       	brne	.+16     	; 0x716c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x18>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor,
		                                                         USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCDataClass)   &&
    715c:	85 81       	ldd	r24, Z+5	; 0x05
    715e:	8a 30       	cpi	r24, 0x0A	; 10
    7160:	29 f4       	brne	.+10     	; 0x716c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x18>
    7162:	86 81       	ldd	r24, Z+6	; 0x06
    7164:	88 23       	and	r24, r24
    7166:	11 f4       	brne	.+4      	; 0x716c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x18>
    7168:	87 81       	ldd	r24, Z+7	; 0x07
    716a:	81 11       	cpse	r24, r1
    716c:	82 e0       	ldi	r24, 0x02	; 2
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    716e:	08 95       	ret

00007170 <RNDIS_Host_IsPacketReceived>:

	return HOST_SENDCONTROL_Successful;
}

bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    7170:	fc 01       	movw	r30, r24
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    7172:	80 91 ac 0d 	lds	r24, 0x0DAC
    7176:	8b 30       	cpi	r24, 0x0B	; 11
    7178:	a1 f4       	brne	.+40     	; 0x71a2 <RNDIS_Host_IsPacketReceived+0x32>
    717a:	82 85       	ldd	r24, Z+10	; 0x0a
    717c:	88 23       	and	r24, r24
    717e:	89 f0       	breq	.+34     	; 0x71a2 <RNDIS_Host_IsPacketReceived+0x32>
	  return false;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipeNumber);
    7180:	80 81       	ld	r24, Z
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    7182:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    7186:	80 91 a9 00 	lds	r24, 0x00A9
    718a:	8f 7b       	andi	r24, 0xBF	; 191
    718c:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    7190:	90 91 a6 00 	lds	r25, 0x00A6
    7194:	91 70       	andi	r25, 0x01	; 1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7196:	80 91 a9 00 	lds	r24, 0x00A9
    719a:	80 64       	ori	r24, 0x40	; 64
    719c:	80 93 a9 00 	sts	0x00A9, r24
    71a0:	01 c0       	rjmp	.+2      	; 0x71a4 <RNDIS_Host_IsPacketReceived+0x34>

	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
    71a2:	90 e0       	ldi	r25, 0x00	; 0
}
    71a4:	89 2f       	mov	r24, r25
    71a6:	08 95       	ret

000071a8 <RNDIS_Host_SendPacket>:
}

uint8_t RNDIS_Host_SendPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              const uint16_t PacketLength)
{
    71a8:	cf 92       	push	r12
    71aa:	df 92       	push	r13
    71ac:	ff 92       	push	r15
    71ae:	0f 93       	push	r16
    71b0:	1f 93       	push	r17
    71b2:	df 93       	push	r29
    71b4:	cf 93       	push	r28
    71b6:	cd b7       	in	r28, 0x3d	; 61
    71b8:	de b7       	in	r29, 0x3e	; 62
    71ba:	ac 97       	sbiw	r28, 0x2c	; 44
    71bc:	0f b6       	in	r0, 0x3f	; 63
    71be:	f8 94       	cli
    71c0:	de bf       	out	0x3e, r29	; 62
    71c2:	0f be       	out	0x3f, r0	; 63
    71c4:	cd bf       	out	0x3d, r28	; 61
    71c6:	9c 01       	movw	r18, r24
    71c8:	6b 01       	movw	r12, r22
    71ca:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    71cc:	80 91 ac 0d 	lds	r24, 0x0DAC
    71d0:	8b 30       	cpi	r24, 0x0B	; 11
    71d2:	09 f0       	breq	.+2      	; 0x71d6 <RNDIS_Host_SendPacket+0x2e>
    71d4:	54 c0       	rjmp	.+168    	; 0x727e <RNDIS_Host_SendPacket+0xd6>
    71d6:	d9 01       	movw	r26, r18
    71d8:	1a 96       	adiw	r26, 0x0a	; 10
    71da:	8c 91       	ld	r24, X
    71dc:	88 23       	and	r24, r24
    71de:	09 f4       	brne	.+2      	; 0x71e2 <RNDIS_Host_SendPacket+0x3a>
    71e0:	4e c0       	rjmp	.+156    	; 0x727e <RNDIS_Host_SendPacket+0xd6>
	  return PIPE_READYWAIT_DeviceDisconnected;

	RNDIS_Packet_Message_t DeviceMessage;

	memset(&DeviceMessage, 0, sizeof(RNDIS_Packet_Message_t));
    71e2:	fe 01       	movw	r30, r28
    71e4:	31 96       	adiw	r30, 0x01	; 1
    71e6:	8c e2       	ldi	r24, 0x2C	; 44
    71e8:	df 01       	movw	r26, r30
    71ea:	1d 92       	st	X+, r1
    71ec:	8a 95       	dec	r24
    71ee:	e9 f7       	brne	.-6      	; 0x71ea <RNDIS_Host_SendPacket+0x42>
	DeviceMessage.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    71f0:	81 e0       	ldi	r24, 0x01	; 1
    71f2:	90 e0       	ldi	r25, 0x00	; 0
    71f4:	a0 e0       	ldi	r26, 0x00	; 0
    71f6:	b0 e0       	ldi	r27, 0x00	; 0
    71f8:	89 83       	std	Y+1, r24	; 0x01
    71fa:	9a 83       	std	Y+2, r25	; 0x02
    71fc:	ab 83       	std	Y+3, r26	; 0x03
    71fe:	bc 83       	std	Y+4, r27	; 0x04
	DeviceMessage.MessageLength = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    7200:	04 5d       	subi	r16, 0xD4	; 212
    7202:	1f 4f       	sbci	r17, 0xFF	; 255
    7204:	c8 01       	movw	r24, r16
    7206:	a0 e0       	ldi	r26, 0x00	; 0
    7208:	b0 e0       	ldi	r27, 0x00	; 0
    720a:	0c 52       	subi	r16, 0x2C	; 44
    720c:	10 40       	sbci	r17, 0x00	; 0
    720e:	8d 83       	std	Y+5, r24	; 0x05
    7210:	9e 83       	std	Y+6, r25	; 0x06
    7212:	af 83       	std	Y+7, r26	; 0x07
    7214:	b8 87       	std	Y+8, r27	; 0x08
	DeviceMessage.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    7216:	84 e2       	ldi	r24, 0x24	; 36
    7218:	90 e0       	ldi	r25, 0x00	; 0
    721a:	a0 e0       	ldi	r26, 0x00	; 0
    721c:	b0 e0       	ldi	r27, 0x00	; 0
    721e:	89 87       	std	Y+9, r24	; 0x09
    7220:	9a 87       	std	Y+10, r25	; 0x0a
    7222:	ab 87       	std	Y+11, r26	; 0x0b
    7224:	bc 87       	std	Y+12, r27	; 0x0c
	DeviceMessage.DataLength    = cpu_to_le32(PacketLength);
    7226:	c8 01       	movw	r24, r16
    7228:	a0 e0       	ldi	r26, 0x00	; 0
    722a:	b0 e0       	ldi	r27, 0x00	; 0
    722c:	8d 87       	std	Y+13, r24	; 0x0d
    722e:	9e 87       	std	Y+14, r25	; 0x0e
    7230:	af 87       	std	Y+15, r26	; 0x0f
    7232:	b8 8b       	std	Y+16, r27	; 0x10

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataOUTPipeNumber);
    7234:	d9 01       	movw	r26, r18
    7236:	12 96       	adiw	r26, 0x02	; 2
    7238:	8c 91       	ld	r24, X
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    723a:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    723e:	80 91 a9 00 	lds	r24, 0x00A9
    7242:	8f 7b       	andi	r24, 0xBF	; 191
    7244:	80 93 a9 00 	sts	0x00A9, r24
	Pipe_Unfreeze();

	if ((ErrorCode = Pipe_Write_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    7248:	cf 01       	movw	r24, r30
    724a:	6c e2       	ldi	r22, 0x2C	; 44
    724c:	70 e0       	ldi	r23, 0x00	; 0
    724e:	40 e0       	ldi	r20, 0x00	; 0
    7250:	50 e0       	ldi	r21, 0x00	; 0
    7252:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <Pipe_Write_Stream_LE>
    7256:	f8 2e       	mov	r15, r24
    7258:	88 23       	and	r24, r24
    725a:	99 f4       	brne	.+38     	; 0x7282 <RNDIS_Host_SendPacket+0xda>
	                                      NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	Pipe_Write_Stream_LE(Buffer, PacketLength, NULL);
    725c:	c6 01       	movw	r24, r12
    725e:	b8 01       	movw	r22, r16
    7260:	40 e0       	ldi	r20, 0x00	; 0
    7262:	50 e0       	ldi	r21, 0x00	; 0
    7264:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <Pipe_Write_Stream_LE>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    7268:	80 91 a6 00 	lds	r24, 0x00A6
    726c:	8b 77       	andi	r24, 0x7B	; 123
    726e:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7272:	80 91 a9 00 	lds	r24, 0x00A9
    7276:	80 64       	ori	r24, 0x40	; 64
    7278:	80 93 a9 00 	sts	0x00A9, r24
    727c:	02 c0       	rjmp	.+4      	; 0x7282 <RNDIS_Host_SendPacket+0xda>
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    727e:	82 e0       	ldi	r24, 0x02	; 2
    7280:	f8 2e       	mov	r15, r24
}
    7282:	8f 2d       	mov	r24, r15
    7284:	ac 96       	adiw	r28, 0x2c	; 44
    7286:	0f b6       	in	r0, 0x3f	; 63
    7288:	f8 94       	cli
    728a:	de bf       	out	0x3e, r29	; 62
    728c:	0f be       	out	0x3f, r0	; 63
    728e:	cd bf       	out	0x3d, r28	; 61
    7290:	cf 91       	pop	r28
    7292:	df 91       	pop	r29
    7294:	1f 91       	pop	r17
    7296:	0f 91       	pop	r16
    7298:	ff 90       	pop	r15
    729a:	df 90       	pop	r13
    729c:	cf 90       	pop	r12
    729e:	08 95       	ret

000072a0 <RNDIS_Host_ReadPacket>:
}

uint8_t RNDIS_Host_ReadPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              uint16_t* const PacketLength)
{
    72a0:	cf 92       	push	r12
    72a2:	df 92       	push	r13
    72a4:	ff 92       	push	r15
    72a6:	0f 93       	push	r16
    72a8:	1f 93       	push	r17
    72aa:	df 93       	push	r29
    72ac:	cf 93       	push	r28
    72ae:	cd b7       	in	r28, 0x3d	; 61
    72b0:	de b7       	in	r29, 0x3e	; 62
    72b2:	ac 97       	sbiw	r28, 0x2c	; 44
    72b4:	0f b6       	in	r0, 0x3f	; 63
    72b6:	f8 94       	cli
    72b8:	de bf       	out	0x3e, r29	; 62
    72ba:	0f be       	out	0x3f, r0	; 63
    72bc:	cd bf       	out	0x3d, r28	; 61
    72be:	fc 01       	movw	r30, r24
    72c0:	6b 01       	movw	r12, r22
    72c2:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    72c4:	80 91 ac 0d 	lds	r24, 0x0DAC
    72c8:	8b 30       	cpi	r24, 0x0B	; 11
    72ca:	09 f0       	breq	.+2      	; 0x72ce <RNDIS_Host_ReadPacket+0x2e>
    72cc:	53 c0       	rjmp	.+166    	; 0x7374 <RNDIS_Host_ReadPacket+0xd4>
    72ce:	82 85       	ldd	r24, Z+10	; 0x0a
    72d0:	88 23       	and	r24, r24
    72d2:	09 f4       	brne	.+2      	; 0x72d6 <RNDIS_Host_ReadPacket+0x36>
    72d4:	4f c0       	rjmp	.+158    	; 0x7374 <RNDIS_Host_ReadPacket+0xd4>
	  return PIPE_READYWAIT_DeviceDisconnected;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipeNumber);
    72d6:	80 81       	ld	r24, Z
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    72d8:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    72dc:	80 91 a9 00 	lds	r24, 0x00A9
    72e0:	8f 7b       	andi	r24, 0xBF	; 191
    72e2:	80 93 a9 00 	sts	0x00A9, r24
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    72e6:	80 91 a6 00 	lds	r24, 0x00A6
	Pipe_Unfreeze();

	if (!(Pipe_IsReadWriteAllowed()))
    72ea:	85 fd       	sbrc	r24, 5
    72ec:	13 c0       	rjmp	.+38     	; 0x7314 <RNDIS_Host_ReadPacket+0x74>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    72ee:	80 91 a6 00 	lds	r24, 0x00A6
	{
		if (Pipe_IsINReceived())
    72f2:	80 ff       	sbrs	r24, 0
    72f4:	05 c0       	rjmp	.+10     	; 0x7300 <RNDIS_Host_ReadPacket+0x60>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    72f6:	80 91 a6 00 	lds	r24, 0x00A6
    72fa:	8e 77       	andi	r24, 0x7E	; 126
    72fc:	80 93 a6 00 	sts	0x00A6, r24
		  Pipe_ClearIN();

		*PacketLength = 0;
    7300:	f8 01       	movw	r30, r16
    7302:	11 82       	std	Z+1, r1	; 0x01
    7304:	10 82       	st	Z, r1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7306:	80 91 a9 00 	lds	r24, 0x00A9
    730a:	80 64       	ori	r24, 0x40	; 64
    730c:	80 93 a9 00 	sts	0x00A9, r24
    7310:	ff 24       	eor	r15, r15
    7312:	32 c0       	rjmp	.+100    	; 0x7378 <RNDIS_Host_ReadPacket+0xd8>
		return PIPE_RWSTREAM_NoError;
	}

	RNDIS_Packet_Message_t DeviceMessage;

	if ((ErrorCode = Pipe_Read_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    7314:	ce 01       	movw	r24, r28
    7316:	01 96       	adiw	r24, 0x01	; 1
    7318:	6c e2       	ldi	r22, 0x2C	; 44
    731a:	70 e0       	ldi	r23, 0x00	; 0
    731c:	40 e0       	ldi	r20, 0x00	; 0
    731e:	50 e0       	ldi	r21, 0x00	; 0
    7320:	0e 94 0c 2e 	call	0x5c18	; 0x5c18 <Pipe_Read_Stream_LE>
    7324:	f8 2e       	mov	r15, r24
    7326:	88 23       	and	r24, r24
    7328:	39 f5       	brne	.+78     	; 0x7378 <RNDIS_Host_ReadPacket+0xd8>
	                                     NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	*PacketLength = (uint16_t)le32_to_cpu(DeviceMessage.DataLength);
    732a:	8d 85       	ldd	r24, Y+13	; 0x0d
    732c:	9e 85       	ldd	r25, Y+14	; 0x0e
    732e:	f8 01       	movw	r30, r16
    7330:	91 83       	std	Z+1, r25	; 0x01
    7332:	80 83       	st	Z, r24

	Pipe_Discard_Stream(DeviceMessage.DataOffset -
    7334:	89 85       	ldd	r24, Y+9	; 0x09
    7336:	9a 85       	ldd	r25, Y+10	; 0x0a
    7338:	84 97       	sbiw	r24, 0x24	; 36
    733a:	60 e0       	ldi	r22, 0x00	; 0
    733c:	70 e0       	ldi	r23, 0x00	; 0
    733e:	0e 94 b0 2e 	call	0x5d60	; 0x5d60 <Pipe_Discard_Stream>
	                    (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t)),
	                    NULL);

	Pipe_Read_Stream_LE(Buffer, *PacketLength, NULL);
    7342:	f8 01       	movw	r30, r16
    7344:	60 81       	ld	r22, Z
    7346:	71 81       	ldd	r23, Z+1	; 0x01
    7348:	c6 01       	movw	r24, r12
    734a:	40 e0       	ldi	r20, 0x00	; 0
    734c:	50 e0       	ldi	r21, 0x00	; 0
    734e:	0e 94 0c 2e 	call	0x5c18	; 0x5c18 <Pipe_Read_Stream_LE>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    7352:	80 91 f6 00 	lds	r24, 0x00F6
    7356:	90 91 f7 00 	lds	r25, 0x00F7

	if (!(Pipe_BytesInPipe()))
    735a:	89 2b       	or	r24, r25
    735c:	29 f4       	brne	.+10     	; 0x7368 <RNDIS_Host_ReadPacket+0xc8>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    735e:	80 91 a6 00 	lds	r24, 0x00A6
    7362:	8e 77       	andi	r24, 0x7E	; 126
    7364:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    7368:	80 91 a9 00 	lds	r24, 0x00A9
    736c:	80 64       	ori	r24, 0x40	; 64
    736e:	80 93 a9 00 	sts	0x00A9, r24
    7372:	02 c0       	rjmp	.+4      	; 0x7378 <RNDIS_Host_ReadPacket+0xd8>
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    7374:	92 e0       	ldi	r25, 0x02	; 2
    7376:	f9 2e       	mov	r15, r25
}
    7378:	8f 2d       	mov	r24, r15
    737a:	ac 96       	adiw	r28, 0x2c	; 44
    737c:	0f b6       	in	r0, 0x3f	; 63
    737e:	f8 94       	cli
    7380:	de bf       	out	0x3e, r29	; 62
    7382:	0f be       	out	0x3f, r0	; 63
    7384:	cd bf       	out	0x3d, r28	; 61
    7386:	cf 91       	pop	r28
    7388:	df 91       	pop	r29
    738a:	1f 91       	pop	r17
    738c:	0f 91       	pop	r16
    738e:	ff 90       	pop	r15
    7390:	df 90       	pop	r13
    7392:	cf 90       	pop	r12
    7394:	08 95       	ret

00007396 <RNDIS_SendEncapsulatedCommand>:

static uint8_t RNDIS_SendEncapsulatedCommand(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    7396:	fc 01       	movw	r30, r24
    7398:	83 85       	ldd	r24, Z+11	; 0x0b
    739a:	90 e0       	ldi	r25, 0x00	; 0
    739c:	21 e2       	ldi	r18, 0x21	; 33
    739e:	20 93 a4 0d 	sts	0x0DA4, r18
    73a2:	10 92 a5 0d 	sts	0x0DA5, r1
    73a6:	10 92 a7 0d 	sts	0x0DA7, r1
    73aa:	10 92 a6 0d 	sts	0x0DA6, r1
    73ae:	90 93 a9 0d 	sts	0x0DA9, r25
    73b2:	80 93 a8 0d 	sts	0x0DA8, r24
    73b6:	50 93 ab 0d 	sts	0x0DAB, r21
    73ba:	40 93 aa 0d 	sts	0x0DAA, r20
			 *  \param[in] PipeNumber  Index of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t PipeNumber)
			{
				UPNUM = PipeNumber;
    73be:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);
	
	return USB_Host_SendControlRequest(Buffer);
    73c2:	cb 01       	movw	r24, r22
    73c4:	0c 94 50 31 	jmp	0x62a0	; 0x62a0 <USB_Host_SendControlRequest>

000073c8 <RNDIS_GetEncapsulatedResponse>:

static uint8_t RNDIS_GetEncapsulatedResponse(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    73c8:	fc 01       	movw	r30, r24
    73ca:	83 85       	ldd	r24, Z+11	; 0x0b
    73cc:	90 e0       	ldi	r25, 0x00	; 0
    73ce:	21 ea       	ldi	r18, 0xA1	; 161
    73d0:	20 93 a4 0d 	sts	0x0DA4, r18
    73d4:	21 e0       	ldi	r18, 0x01	; 1
    73d6:	20 93 a5 0d 	sts	0x0DA5, r18
    73da:	10 92 a7 0d 	sts	0x0DA7, r1
    73de:	10 92 a6 0d 	sts	0x0DA6, r1
    73e2:	90 93 a9 0d 	sts	0x0DA9, r25
    73e6:	80 93 a8 0d 	sts	0x0DA8, r24
    73ea:	50 93 ab 0d 	sts	0x0DAB, r21
    73ee:	40 93 aa 0d 	sts	0x0DAA, r20
    73f2:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);
	
	return USB_Host_SendControlRequest(Buffer);
    73f6:	cb 01       	movw	r24, r22
    73f8:	0c 94 50 31 	jmp	0x62a0	; 0x62a0 <USB_Host_SendControlRequest>

000073fc <RNDIS_Host_QueryRNDISProperty>:

uint8_t RNDIS_Host_QueryRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                      const uint32_t Oid,
                                      void* Buffer,
                                      const uint16_t MaxLength)
{
    73fc:	4f 92       	push	r4
    73fe:	5f 92       	push	r5
    7400:	6f 92       	push	r6
    7402:	7f 92       	push	r7
    7404:	8f 92       	push	r8
    7406:	9f 92       	push	r9
    7408:	af 92       	push	r10
    740a:	bf 92       	push	r11
    740c:	cf 92       	push	r12
    740e:	df 92       	push	r13
    7410:	ef 92       	push	r14
    7412:	ff 92       	push	r15
    7414:	0f 93       	push	r16
    7416:	1f 93       	push	r17
    7418:	df 93       	push	r29
    741a:	cf 93       	push	r28
    741c:	cd b7       	in	r28, 0x3d	; 61
    741e:	de b7       	in	r29, 0x3e	; 62
    7420:	6c 97       	sbiw	r28, 0x1c	; 28
    7422:	0f b6       	in	r0, 0x3f	; 63
    7424:	f8 94       	cli
    7426:	de bf       	out	0x3e, r29	; 62
    7428:	0f be       	out	0x3f, r0	; 63
    742a:	cd bf       	out	0x3d, r28	; 61
    742c:	7c 01       	movw	r14, r24
    742e:	39 01       	movw	r6, r18
    7430:	48 01       	movw	r8, r16
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    7432:	4d b6       	in	r4, 0x3d	; 61
    7434:	5e b6       	in	r5, 0x3e	; 62

	struct
	{
		RNDIS_Query_Complete_t QueryMessageResponse;
		uint8_t                ContiguousBuffer[MaxLength];
	} QueryMessageResponseData;
    7436:	28 e1       	ldi	r18, 0x18	; 24
    7438:	a2 2e       	mov	r10, r18
    743a:	b1 2c       	mov	r11, r1
    743c:	a0 0e       	add	r10, r16
    743e:	b1 1e       	adc	r11, r17
    7440:	8d b7       	in	r24, 0x3d	; 61
    7442:	9e b7       	in	r25, 0x3e	; 62
    7444:	8a 19       	sub	r24, r10
    7446:	9b 09       	sbc	r25, r11
    7448:	0f b6       	in	r0, 0x3f	; 63
    744a:	f8 94       	cli
    744c:	9e bf       	out	0x3e, r25	; 62
    744e:	0f be       	out	0x3f, r0	; 63
    7450:	8d bf       	out	0x3d, r24	; 61
    7452:	cd b6       	in	r12, 0x3d	; 61
    7454:	de b6       	in	r13, 0x3e	; 62
    7456:	08 94       	sec
    7458:	c1 1c       	adc	r12, r1
    745a:	d1 1c       	adc	r13, r1

	QueryMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_QUERY_MSG);
    745c:	84 e0       	ldi	r24, 0x04	; 4
    745e:	90 e0       	ldi	r25, 0x00	; 0
    7460:	a0 e0       	ldi	r26, 0x00	; 0
    7462:	b0 e0       	ldi	r27, 0x00	; 0
    7464:	89 83       	std	Y+1, r24	; 0x01
    7466:	9a 83       	std	Y+2, r25	; 0x02
    7468:	ab 83       	std	Y+3, r26	; 0x03
    746a:	bc 83       	std	Y+4, r27	; 0x04
	QueryMessage.MessageLength  = CPU_TO_LE32(sizeof(RNDIS_Query_Message_t));
    746c:	8c e1       	ldi	r24, 0x1C	; 28
    746e:	90 e0       	ldi	r25, 0x00	; 0
    7470:	a0 e0       	ldi	r26, 0x00	; 0
    7472:	b0 e0       	ldi	r27, 0x00	; 0
    7474:	8d 83       	std	Y+5, r24	; 0x05
    7476:	9e 83       	std	Y+6, r25	; 0x06
    7478:	af 83       	std	Y+7, r26	; 0x07
    747a:	b8 87       	std	Y+8, r27	; 0x08
	QueryMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    747c:	f7 01       	movw	r30, r14
    747e:	86 89       	ldd	r24, Z+22	; 0x16
    7480:	97 89       	ldd	r25, Z+23	; 0x17
    7482:	a0 8d       	ldd	r26, Z+24	; 0x18
    7484:	b1 8d       	ldd	r27, Z+25	; 0x19
    7486:	89 87       	std	Y+9, r24	; 0x09
    7488:	9a 87       	std	Y+10, r25	; 0x0a
    748a:	ab 87       	std	Y+11, r26	; 0x0b
    748c:	bc 87       	std	Y+12, r27	; 0x0c
    748e:	01 96       	adiw	r24, 0x01	; 1
    7490:	a1 1d       	adc	r26, r1
    7492:	b1 1d       	adc	r27, r1
    7494:	86 8b       	std	Z+22, r24	; 0x16
    7496:	97 8b       	std	Z+23, r25	; 0x17
    7498:	a0 8f       	std	Z+24, r26	; 0x18
    749a:	b1 8f       	std	Z+25, r27	; 0x19

	QueryMessage.Oid            = cpu_to_le32(Oid);
    749c:	4d 87       	std	Y+13, r20	; 0x0d
    749e:	5e 87       	std	Y+14, r21	; 0x0e
    74a0:	6f 87       	std	Y+15, r22	; 0x0f
    74a2:	78 8b       	std	Y+16, r23	; 0x10
	QueryMessage.InformationBufferLength = CPU_TO_LE32(0);
    74a4:	19 8a       	std	Y+17, r1	; 0x11
    74a6:	1a 8a       	std	Y+18, r1	; 0x12
    74a8:	1b 8a       	std	Y+19, r1	; 0x13
    74aa:	1c 8a       	std	Y+20, r1	; 0x14
	QueryMessage.InformationBufferOffset = CPU_TO_LE32(0);
    74ac:	1d 8a       	std	Y+21, r1	; 0x15
    74ae:	1e 8a       	std	Y+22, r1	; 0x16
    74b0:	1f 8a       	std	Y+23, r1	; 0x17
    74b2:	18 8e       	std	Y+24, r1	; 0x18
	QueryMessage.DeviceVcHandle = CPU_TO_LE32(0);
    74b4:	19 8e       	std	Y+25, r1	; 0x19
    74b6:	1a 8e       	std	Y+26, r1	; 0x1a
    74b8:	1b 8e       	std	Y+27, r1	; 0x1b
    74ba:	1c 8e       	std	Y+28, r1	; 0x1c

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &QueryMessage,
    74bc:	c7 01       	movw	r24, r14
    74be:	be 01       	movw	r22, r28
    74c0:	6f 5f       	subi	r22, 0xFF	; 255
    74c2:	7f 4f       	sbci	r23, 0xFF	; 255
    74c4:	4c e1       	ldi	r20, 0x1C	; 28
    74c6:	50 e0       	ldi	r21, 0x00	; 0
    74c8:	66 df       	rcall	.-308    	; 0x7396 <RNDIS_SendEncapsulatedCommand>
    74ca:	18 2f       	mov	r17, r24
    74cc:	88 23       	and	r24, r24
    74ce:	d1 f4       	brne	.+52     	; 0x7504 <RNDIS_Host_QueryRNDISProperty+0x108>
	                                               sizeof(RNDIS_Query_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &QueryMessageResponseData,
    74d0:	c7 01       	movw	r24, r14
    74d2:	b6 01       	movw	r22, r12
    74d4:	a5 01       	movw	r20, r10
    74d6:	78 df       	rcall	.-272    	; 0x73c8 <RNDIS_GetEncapsulatedResponse>
    74d8:	18 2f       	mov	r17, r24
    74da:	88 23       	and	r24, r24
    74dc:	99 f4       	brne	.+38     	; 0x7504 <RNDIS_Host_QueryRNDISProperty+0x108>
	                                               sizeof(QueryMessageResponseData))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    74de:	f6 01       	movw	r30, r12
    74e0:	84 85       	ldd	r24, Z+12	; 0x0c
    74e2:	95 85       	ldd	r25, Z+13	; 0x0d
    74e4:	a6 85       	ldd	r26, Z+14	; 0x0e
    74e6:	b7 85       	ldd	r27, Z+15	; 0x0f
    74e8:	00 97       	sbiw	r24, 0x00	; 0
    74ea:	a1 05       	cpc	r26, r1
    74ec:	b1 05       	cpc	r27, r1
    74ee:	11 f0       	breq	.+4      	; 0x74f4 <RNDIS_Host_QueryRNDISProperty+0xf8>
    74f0:	10 e8       	ldi	r17, 0x80	; 128
    74f2:	08 c0       	rjmp	.+16     	; 0x7504 <RNDIS_Host_QueryRNDISProperty+0x108>
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);
    74f4:	88 e1       	ldi	r24, 0x18	; 24
    74f6:	90 e0       	ldi	r25, 0x00	; 0
    74f8:	c8 0e       	add	r12, r24
    74fa:	d9 1e       	adc	r13, r25
    74fc:	c3 01       	movw	r24, r6
    74fe:	b6 01       	movw	r22, r12
    7500:	a4 01       	movw	r20, r8
    7502:	a2 d2       	rcall	.+1348   	; 0x7a48 <memcpy>

	return HOST_SENDCONTROL_Successful;
}
    7504:	81 2f       	mov	r24, r17
    7506:	0f b6       	in	r0, 0x3f	; 63
    7508:	f8 94       	cli
    750a:	5e be       	out	0x3e, r5	; 62
    750c:	0f be       	out	0x3f, r0	; 63
    750e:	4d be       	out	0x3d, r4	; 61
    7510:	6c 96       	adiw	r28, 0x1c	; 28
    7512:	0f b6       	in	r0, 0x3f	; 63
    7514:	f8 94       	cli
    7516:	de bf       	out	0x3e, r29	; 62
    7518:	0f be       	out	0x3f, r0	; 63
    751a:	cd bf       	out	0x3d, r28	; 61
    751c:	cf 91       	pop	r28
    751e:	df 91       	pop	r29
    7520:	1f 91       	pop	r17
    7522:	0f 91       	pop	r16
    7524:	ff 90       	pop	r15
    7526:	ef 90       	pop	r14
    7528:	df 90       	pop	r13
    752a:	cf 90       	pop	r12
    752c:	bf 90       	pop	r11
    752e:	af 90       	pop	r10
    7530:	9f 90       	pop	r9
    7532:	8f 90       	pop	r8
    7534:	7f 90       	pop	r7
    7536:	6f 90       	pop	r6
    7538:	5f 90       	pop	r5
    753a:	4f 90       	pop	r4
    753c:	08 95       	ret

0000753e <RNDIS_Host_SetRNDISProperty>:

uint8_t RNDIS_Host_SetRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                    const uint32_t Oid,
                                    void* Buffer,
                                    const uint16_t Length)
{
    753e:	6f 92       	push	r6
    7540:	7f 92       	push	r7
    7542:	8f 92       	push	r8
    7544:	9f 92       	push	r9
    7546:	af 92       	push	r10
    7548:	bf 92       	push	r11
    754a:	cf 92       	push	r12
    754c:	df 92       	push	r13
    754e:	ef 92       	push	r14
    7550:	ff 92       	push	r15
    7552:	0f 93       	push	r16
    7554:	1f 93       	push	r17
    7556:	df 93       	push	r29
    7558:	cf 93       	push	r28
    755a:	cd b7       	in	r28, 0x3d	; 61
    755c:	de b7       	in	r29, 0x3e	; 62
    755e:	60 97       	sbiw	r28, 0x10	; 16
    7560:	0f b6       	in	r0, 0x3f	; 63
    7562:	f8 94       	cli
    7564:	de bf       	out	0x3e, r29	; 62
    7566:	0f be       	out	0x3f, r0	; 63
    7568:	cd bf       	out	0x3d, r28	; 61
    756a:	4c 01       	movw	r8, r24

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	return HOST_SENDCONTROL_Successful;
}
    756c:	6d b6       	in	r6, 0x3d	; 61
    756e:	7e b6       	in	r7, 0x3e	; 62

	struct
	{
		RNDIS_Set_Message_t SetMessage;
		uint8_t             ContiguousBuffer[Length];
	} SetMessageData;
    7570:	ec e1       	ldi	r30, 0x1C	; 28
    7572:	ce 2e       	mov	r12, r30
    7574:	d1 2c       	mov	r13, r1
    7576:	c0 0e       	add	r12, r16
    7578:	d1 1e       	adc	r13, r17
    757a:	8d b7       	in	r24, 0x3d	; 61
    757c:	9e b7       	in	r25, 0x3e	; 62
    757e:	8c 19       	sub	r24, r12
    7580:	9d 09       	sbc	r25, r13
    7582:	0f b6       	in	r0, 0x3f	; 63
    7584:	f8 94       	cli
    7586:	9e bf       	out	0x3e, r25	; 62
    7588:	0f be       	out	0x3f, r0	; 63
    758a:	8d bf       	out	0x3d, r24	; 61
    758c:	ad b6       	in	r10, 0x3d	; 61
    758e:	be b6       	in	r11, 0x3e	; 62
    7590:	08 94       	sec
    7592:	a1 1c       	adc	r10, r1
    7594:	b1 1c       	adc	r11, r1

	RNDIS_Set_Complete_t SetMessageResponse;

	SetMessageData.SetMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_SET_MSG);
    7596:	85 e0       	ldi	r24, 0x05	; 5
    7598:	90 e0       	ldi	r25, 0x00	; 0
    759a:	a0 e0       	ldi	r26, 0x00	; 0
    759c:	b0 e0       	ldi	r27, 0x00	; 0
    759e:	ed b7       	in	r30, 0x3d	; 61
    75a0:	fe b7       	in	r31, 0x3e	; 62
    75a2:	81 83       	std	Z+1, r24	; 0x01
    75a4:	92 83       	std	Z+2, r25	; 0x02
    75a6:	a3 83       	std	Z+3, r26	; 0x03
    75a8:	b4 83       	std	Z+4, r27	; 0x04
	SetMessageData.SetMessage.MessageLength  = cpu_to_le32(sizeof(RNDIS_Set_Message_t) + Length);
    75aa:	ee 24       	eor	r14, r14
    75ac:	ff 24       	eor	r15, r15
    75ae:	f5 01       	movw	r30, r10
    75b0:	c4 82       	std	Z+4, r12	; 0x04
    75b2:	d5 82       	std	Z+5, r13	; 0x05
    75b4:	e6 82       	std	Z+6, r14	; 0x06
    75b6:	f7 82       	std	Z+7, r15	; 0x07
	SetMessageData.SetMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    75b8:	f4 01       	movw	r30, r8
    75ba:	86 89       	ldd	r24, Z+22	; 0x16
    75bc:	97 89       	ldd	r25, Z+23	; 0x17
    75be:	a0 8d       	ldd	r26, Z+24	; 0x18
    75c0:	b1 8d       	ldd	r27, Z+25	; 0x19
    75c2:	f5 01       	movw	r30, r10
    75c4:	80 87       	std	Z+8, r24	; 0x08
    75c6:	91 87       	std	Z+9, r25	; 0x09
    75c8:	a2 87       	std	Z+10, r26	; 0x0a
    75ca:	b3 87       	std	Z+11, r27	; 0x0b
    75cc:	01 96       	adiw	r24, 0x01	; 1
    75ce:	a1 1d       	adc	r26, r1
    75d0:	b1 1d       	adc	r27, r1
    75d2:	f4 01       	movw	r30, r8
    75d4:	86 8b       	std	Z+22, r24	; 0x16
    75d6:	97 8b       	std	Z+23, r25	; 0x17
    75d8:	a0 8f       	std	Z+24, r26	; 0x18
    75da:	b1 8f       	std	Z+25, r27	; 0x19

	SetMessageData.SetMessage.Oid            = cpu_to_le32(Oid);
    75dc:	f5 01       	movw	r30, r10
    75de:	44 87       	std	Z+12, r20	; 0x0c
    75e0:	55 87       	std	Z+13, r21	; 0x0d
    75e2:	66 87       	std	Z+14, r22	; 0x0e
    75e4:	77 87       	std	Z+15, r23	; 0x0f
	SetMessageData.SetMessage.InformationBufferLength = cpu_to_le32(Length);
    75e6:	c8 01       	movw	r24, r16
    75e8:	a0 e0       	ldi	r26, 0x00	; 0
    75ea:	b0 e0       	ldi	r27, 0x00	; 0
    75ec:	80 8b       	std	Z+16, r24	; 0x10
    75ee:	91 8b       	std	Z+17, r25	; 0x11
    75f0:	a2 8b       	std	Z+18, r26	; 0x12
    75f2:	b3 8b       	std	Z+19, r27	; 0x13
	SetMessageData.SetMessage.InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Set_Message_t) - sizeof(RNDIS_Message_Header_t));
    75f4:	84 e1       	ldi	r24, 0x14	; 20
    75f6:	90 e0       	ldi	r25, 0x00	; 0
    75f8:	a0 e0       	ldi	r26, 0x00	; 0
    75fa:	b0 e0       	ldi	r27, 0x00	; 0
    75fc:	84 8b       	std	Z+20, r24	; 0x14
    75fe:	95 8b       	std	Z+21, r25	; 0x15
    7600:	a6 8b       	std	Z+22, r26	; 0x16
    7602:	b7 8b       	std	Z+23, r27	; 0x17
	SetMessageData.SetMessage.DeviceVcHandle = CPU_TO_LE32(0);
    7604:	10 8e       	std	Z+24, r1	; 0x18
    7606:	11 8e       	std	Z+25, r1	; 0x19
    7608:	12 8e       	std	Z+26, r1	; 0x1a
    760a:	13 8e       	std	Z+27, r1	; 0x1b

	memcpy(&SetMessageData.ContiguousBuffer, Buffer, Length);
    760c:	8d b7       	in	r24, 0x3d	; 61
    760e:	9e b7       	in	r25, 0x3e	; 62
    7610:	4d 96       	adiw	r24, 0x1d	; 29
    7612:	b9 01       	movw	r22, r18
    7614:	a8 01       	movw	r20, r16
    7616:	18 d2       	rcall	.+1072   	; 0x7a48 <memcpy>

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &SetMessageData,
    7618:	f5 01       	movw	r30, r10
    761a:	44 81       	ldd	r20, Z+4	; 0x04
    761c:	55 81       	ldd	r21, Z+5	; 0x05
    761e:	c4 01       	movw	r24, r8
    7620:	b5 01       	movw	r22, r10
    7622:	b9 de       	rcall	.-654    	; 0x7396 <RNDIS_SendEncapsulatedCommand>
    7624:	28 2f       	mov	r18, r24
    7626:	88 23       	and	r24, r24
    7628:	99 f4       	brne	.+38     	; 0x7650 <RNDIS_Host_SetRNDISProperty+0x112>
	                                               SetMessageData.SetMessage.MessageLength)) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &SetMessageResponse,
    762a:	c4 01       	movw	r24, r8
    762c:	be 01       	movw	r22, r28
    762e:	6f 5f       	subi	r22, 0xFF	; 255
    7630:	7f 4f       	sbci	r23, 0xFF	; 255
    7632:	40 e1       	ldi	r20, 0x10	; 16
    7634:	50 e0       	ldi	r21, 0x00	; 0
    7636:	c8 de       	rcall	.-624    	; 0x73c8 <RNDIS_GetEncapsulatedResponse>
    7638:	28 2f       	mov	r18, r24
    763a:	88 23       	and	r24, r24
    763c:	49 f4       	brne	.+18     	; 0x7650 <RNDIS_Host_SetRNDISProperty+0x112>
	                                               sizeof(RNDIS_Set_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    763e:	8d 85       	ldd	r24, Y+13	; 0x0d
    7640:	9e 85       	ldd	r25, Y+14	; 0x0e
    7642:	af 85       	ldd	r26, Y+15	; 0x0f
    7644:	b8 89       	ldd	r27, Y+16	; 0x10
    7646:	00 97       	sbiw	r24, 0x00	; 0
    7648:	a1 05       	cpc	r26, r1
    764a:	b1 05       	cpc	r27, r1
    764c:	09 f0       	breq	.+2      	; 0x7650 <RNDIS_Host_SetRNDISProperty+0x112>
    764e:	20 e8       	ldi	r18, 0x80	; 128
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	return HOST_SENDCONTROL_Successful;
}
    7650:	82 2f       	mov	r24, r18
    7652:	0f b6       	in	r0, 0x3f	; 63
    7654:	f8 94       	cli
    7656:	7e be       	out	0x3e, r7	; 62
    7658:	0f be       	out	0x3f, r0	; 63
    765a:	6d be       	out	0x3d, r6	; 61
    765c:	60 96       	adiw	r28, 0x10	; 16
    765e:	0f b6       	in	r0, 0x3f	; 63
    7660:	f8 94       	cli
    7662:	de bf       	out	0x3e, r29	; 62
    7664:	0f be       	out	0x3f, r0	; 63
    7666:	cd bf       	out	0x3d, r28	; 61
    7668:	cf 91       	pop	r28
    766a:	df 91       	pop	r29
    766c:	1f 91       	pop	r17
    766e:	0f 91       	pop	r16
    7670:	ff 90       	pop	r15
    7672:	ef 90       	pop	r14
    7674:	df 90       	pop	r13
    7676:	cf 90       	pop	r12
    7678:	bf 90       	pop	r11
    767a:	af 90       	pop	r10
    767c:	9f 90       	pop	r9
    767e:	8f 90       	pop	r8
    7680:	7f 90       	pop	r7
    7682:	6f 90       	pop	r6
    7684:	08 95       	ret

00007686 <RNDIS_Host_InitializeDevice>:

	return HOST_SENDCONTROL_Successful;
}

uint8_t RNDIS_Host_InitializeDevice(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    7686:	0f 93       	push	r16
    7688:	1f 93       	push	r17
    768a:	df 93       	push	r29
    768c:	cf 93       	push	r28
    768e:	cd b7       	in	r28, 0x3d	; 61
    7690:	de b7       	in	r29, 0x3e	; 62
    7692:	cc 54       	subi	r28, 0x4C	; 76
    7694:	d0 40       	sbci	r29, 0x00	; 0
    7696:	0f b6       	in	r0, 0x3f	; 63
    7698:	f8 94       	cli
    769a:	de bf       	out	0x3e, r29	; 62
    769c:	0f be       	out	0x3f, r0	; 63
    769e:	cd bf       	out	0x3d, r28	; 61
    76a0:	8c 01       	movw	r16, r24
	uint8_t ErrorCode;

	RNDIS_Initialize_Message_t  InitMessage;
	RNDIS_Initialize_Complete_t InitMessageResponse;

	InitMessage.MessageType     = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_MSG);
    76a2:	82 e0       	ldi	r24, 0x02	; 2
    76a4:	90 e0       	ldi	r25, 0x00	; 0
    76a6:	a0 e0       	ldi	r26, 0x00	; 0
    76a8:	b0 e0       	ldi	r27, 0x00	; 0
    76aa:	89 83       	std	Y+1, r24	; 0x01
    76ac:	9a 83       	std	Y+2, r25	; 0x02
    76ae:	ab 83       	std	Y+3, r26	; 0x03
    76b0:	bc 83       	std	Y+4, r27	; 0x04
	InitMessage.MessageLength   = CPU_TO_LE32(sizeof(RNDIS_Initialize_Message_t));
    76b2:	88 e1       	ldi	r24, 0x18	; 24
    76b4:	90 e0       	ldi	r25, 0x00	; 0
    76b6:	a0 e0       	ldi	r26, 0x00	; 0
    76b8:	b0 e0       	ldi	r27, 0x00	; 0
    76ba:	8d 83       	std	Y+5, r24	; 0x05
    76bc:	9e 83       	std	Y+6, r25	; 0x06
    76be:	af 83       	std	Y+7, r26	; 0x07
    76c0:	b8 87       	std	Y+8, r27	; 0x08
	InitMessage.RequestId       = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    76c2:	f8 01       	movw	r30, r16
    76c4:	86 89       	ldd	r24, Z+22	; 0x16
    76c6:	97 89       	ldd	r25, Z+23	; 0x17
    76c8:	a0 8d       	ldd	r26, Z+24	; 0x18
    76ca:	b1 8d       	ldd	r27, Z+25	; 0x19
    76cc:	89 87       	std	Y+9, r24	; 0x09
    76ce:	9a 87       	std	Y+10, r25	; 0x0a
    76d0:	ab 87       	std	Y+11, r26	; 0x0b
    76d2:	bc 87       	std	Y+12, r27	; 0x0c
    76d4:	01 96       	adiw	r24, 0x01	; 1
    76d6:	a1 1d       	adc	r26, r1
    76d8:	b1 1d       	adc	r27, r1
    76da:	86 8b       	std	Z+22, r24	; 0x16
    76dc:	97 8b       	std	Z+23, r25	; 0x17
    76de:	a0 8f       	std	Z+24, r26	; 0x18
    76e0:	b1 8f       	std	Z+25, r27	; 0x19

	InitMessage.MajorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    76e2:	81 e0       	ldi	r24, 0x01	; 1
    76e4:	90 e0       	ldi	r25, 0x00	; 0
    76e6:	a0 e0       	ldi	r26, 0x00	; 0
    76e8:	b0 e0       	ldi	r27, 0x00	; 0
    76ea:	8d 87       	std	Y+13, r24	; 0x0d
    76ec:	9e 87       	std	Y+14, r25	; 0x0e
    76ee:	af 87       	std	Y+15, r26	; 0x0f
    76f0:	b8 8b       	std	Y+16, r27	; 0x10
	InitMessage.MinorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    76f2:	19 8a       	std	Y+17, r1	; 0x11
    76f4:	1a 8a       	std	Y+18, r1	; 0x12
    76f6:	1b 8a       	std	Y+19, r1	; 0x13
    76f8:	1c 8a       	std	Y+20, r1	; 0x14
	InitMessage.MaxTransferSize = cpu_to_le32(RNDISInterfaceInfo->Config.HostMaxPacketSize);
    76fa:	86 81       	ldd	r24, Z+6	; 0x06
    76fc:	97 81       	ldd	r25, Z+7	; 0x07
    76fe:	a0 85       	ldd	r26, Z+8	; 0x08
    7700:	b1 85       	ldd	r27, Z+9	; 0x09
    7702:	8d 8b       	std	Y+21, r24	; 0x15
    7704:	9e 8b       	std	Y+22, r25	; 0x16
    7706:	af 8b       	std	Y+23, r26	; 0x17
    7708:	b8 8f       	std	Y+24, r27	; 0x18

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &InitMessage,
    770a:	c8 01       	movw	r24, r16
    770c:	be 01       	movw	r22, r28
    770e:	6f 5f       	subi	r22, 0xFF	; 255
    7710:	7f 4f       	sbci	r23, 0xFF	; 255
    7712:	48 e1       	ldi	r20, 0x18	; 24
    7714:	50 e0       	ldi	r21, 0x00	; 0
    7716:	3f de       	rcall	.-898    	; 0x7396 <RNDIS_SendEncapsulatedCommand>
    7718:	28 2f       	mov	r18, r24
    771a:	88 23       	and	r24, r24
    771c:	f9 f4       	brne	.+62     	; 0x775c <RNDIS_Host_InitializeDevice+0xd6>
	                                               sizeof(RNDIS_Initialize_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &InitMessageResponse,
    771e:	c8 01       	movw	r24, r16
    7720:	be 01       	movw	r22, r28
    7722:	67 5e       	subi	r22, 0xE7	; 231
    7724:	7f 4f       	sbci	r23, 0xFF	; 255
    7726:	44 e3       	ldi	r20, 0x34	; 52
    7728:	50 e0       	ldi	r21, 0x00	; 0
    772a:	4e de       	rcall	.-868    	; 0x73c8 <RNDIS_GetEncapsulatedResponse>
    772c:	28 2f       	mov	r18, r24
    772e:	88 23       	and	r24, r24
    7730:	a9 f4       	brne	.+42     	; 0x775c <RNDIS_Host_InitializeDevice+0xd6>
	                                               sizeof(RNDIS_Initialize_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    7732:	8d a1       	ldd	r24, Y+37	; 0x25
    7734:	9e a1       	ldd	r25, Y+38	; 0x26
    7736:	af a1       	ldd	r26, Y+39	; 0x27
    7738:	b8 a5       	ldd	r27, Y+40	; 0x28
    773a:	00 97       	sbiw	r24, 0x00	; 0
    773c:	a1 05       	cpc	r26, r1
    773e:	b1 05       	cpc	r27, r1
    7740:	11 f0       	breq	.+4      	; 0x7746 <RNDIS_Host_InitializeDevice+0xc0>
    7742:	20 e8       	ldi	r18, 0x80	; 128
    7744:	0b c0       	rjmp	.+22     	; 0x775c <RNDIS_Host_InitializeDevice+0xd6>
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);
    7746:	fe 01       	movw	r30, r28
    7748:	fd 96       	adiw	r30, 0x3d	; 61
    774a:	80 81       	ld	r24, Z
    774c:	91 81       	ldd	r25, Z+1	; 0x01
    774e:	a2 81       	ldd	r26, Z+2	; 0x02
    7750:	b3 81       	ldd	r27, Z+3	; 0x03
    7752:	f8 01       	movw	r30, r16
    7754:	82 8b       	std	Z+18, r24	; 0x12
    7756:	93 8b       	std	Z+19, r25	; 0x13
    7758:	a4 8b       	std	Z+20, r26	; 0x14
    775a:	b5 8b       	std	Z+21, r27	; 0x15

	return HOST_SENDCONTROL_Successful;
}
    775c:	82 2f       	mov	r24, r18
    775e:	c4 5b       	subi	r28, 0xB4	; 180
    7760:	df 4f       	sbci	r29, 0xFF	; 255
    7762:	0f b6       	in	r0, 0x3f	; 63
    7764:	f8 94       	cli
    7766:	de bf       	out	0x3e, r29	; 62
    7768:	0f be       	out	0x3f, r0	; 63
    776a:	cd bf       	out	0x3d, r28	; 61
    776c:	cf 91       	pop	r28
    776e:	df 91       	pop	r29
    7770:	1f 91       	pop	r17
    7772:	0f 91       	pop	r16
    7774:	08 95       	ret

00007776 <RNDIS_Host_ConfigurePipes>:
#include "RNDIS.h"

uint8_t RNDIS_Host_ConfigurePipes(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                  uint16_t ConfigDescriptorSize,
                                  void* ConfigDescriptorData)
{
    7776:	4f 92       	push	r4
    7778:	5f 92       	push	r5
    777a:	6f 92       	push	r6
    777c:	7f 92       	push	r7
    777e:	8f 92       	push	r8
    7780:	9f 92       	push	r9
    7782:	af 92       	push	r10
    7784:	bf 92       	push	r11
    7786:	cf 92       	push	r12
    7788:	df 92       	push	r13
    778a:	ef 92       	push	r14
    778c:	ff 92       	push	r15
    778e:	0f 93       	push	r16
    7790:	1f 93       	push	r17
    7792:	df 93       	push	r29
    7794:	cf 93       	push	r28
    7796:	00 d0       	rcall	.+0      	; 0x7798 <RNDIS_Host_ConfigurePipes+0x22>
    7798:	00 d0       	rcall	.+0      	; 0x779a <RNDIS_Host_ConfigurePipes+0x24>
    779a:	0f 92       	push	r0
    779c:	cd b7       	in	r28, 0x3d	; 61
    779e:	de b7       	in	r29, 0x3e	; 62
    77a0:	6c 01       	movw	r12, r24
    77a2:	7a 83       	std	Y+2, r23	; 0x02
    77a4:	69 83       	std	Y+1, r22	; 0x01
    77a6:	5c 83       	std	Y+4, r21	; 0x04
    77a8:	4b 83       	std	Y+3, r20	; 0x03
	USB_Descriptor_Endpoint_t*  DataINEndpoint        = NULL;
	USB_Descriptor_Endpoint_t*  DataOUTEndpoint       = NULL;
	USB_Descriptor_Endpoint_t*  NotificationEndpoint  = NULL;
	USB_Descriptor_Interface_t* RNDISControlInterface = NULL;

	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    77aa:	8a e0       	ldi	r24, 0x0A	; 10
    77ac:	90 e0       	ldi	r25, 0x00	; 0
    77ae:	c8 0e       	add	r12, r24
    77b0:	d9 1e       	adc	r13, r25
    77b2:	80 e1       	ldi	r24, 0x10	; 16
    77b4:	f6 01       	movw	r30, r12
    77b6:	11 92       	st	Z+, r1
    77b8:	8a 95       	dec	r24
    77ba:	e9 f7       	brne	.-6      	; 0x77b6 <RNDIS_Host_ConfigurePipes+0x40>
    77bc:	86 ef       	ldi	r24, 0xF6	; 246
    77be:	9f ef       	ldi	r25, 0xFF	; 255
    77c0:	c8 0e       	add	r12, r24
    77c2:	d9 1e       	adc	r13, r25

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
    77c4:	eb 81       	ldd	r30, Y+3	; 0x03
    77c6:	fc 81       	ldd	r31, Y+4	; 0x04
    77c8:	81 81       	ldd	r24, Z+1	; 0x01
    77ca:	82 30       	cpi	r24, 0x02	; 2
    77cc:	11 f0       	breq	.+4      	; 0x77d2 <RNDIS_Host_ConfigurePipes+0x5c>
    77ce:	81 e0       	ldi	r24, 0x01	; 1
    77d0:	9f c0       	rjmp	.+318    	; 0x7910 <RNDIS_Host_ConfigurePipes+0x19a>
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    77d2:	2f 01       	movw	r4, r30
    77d4:	66 24       	eor	r6, r6
    77d6:	77 24       	eor	r7, r7
    77d8:	88 24       	eor	r8, r8
    77da:	99 24       	eor	r9, r9
    77dc:	aa 24       	eor	r10, r10
    77de:	bb 24       	eor	r11, r11

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    77e0:	f3 e0       	ldi	r31, 0x03	; 3
    77e2:	ef 2e       	mov	r14, r31
    77e4:	f1 2c       	mov	r15, r1
    77e6:	ec 0e       	add	r14, r28
    77e8:	fd 1e       	adc	r15, r29
    77ea:	8e 01       	movw	r16, r28
    77ec:	0f 5f       	subi	r16, 0xFF	; 255
    77ee:	1f 4f       	sbci	r17, 0xFF	; 255
    77f0:	04 c0       	rjmp	.+8      	; 0x77fa <RNDIS_Host_ConfigurePipes+0x84>
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    77f2:	88 24       	eor	r8, r8
    77f4:	99 24       	eor	r9, r9
    77f6:	66 24       	eor	r6, r6
    77f8:	77 24       	eor	r7, r7

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    77fa:	41 14       	cp	r4, r1
    77fc:	51 04       	cpc	r5, r1
    77fe:	41 f0       	breq	.+16     	; 0x7810 <RNDIS_Host_ConfigurePipes+0x9a>
    7800:	c8 01       	movw	r24, r16
    7802:	b7 01       	movw	r22, r14
    7804:	4e e9       	ldi	r20, 0x9E	; 158
    7806:	5c e3       	ldi	r21, 0x3C	; 60
    7808:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <USB_GetNextDescriptorComp>
    780c:	88 23       	and	r24, r24
    780e:	c1 f0       	breq	.+48     	; 0x7840 <RNDIS_Host_ConfigurePipes+0xca>
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
		                              DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			if (NotificationEndpoint)
    7810:	a1 14       	cp	r10, r1
    7812:	b1 04       	cpc	r11, r1
    7814:	49 f0       	breq	.+18     	; 0x7828 <RNDIS_Host_ConfigurePipes+0xb2>
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    7816:	c8 01       	movw	r24, r16
    7818:	b7 01       	movw	r22, r14
    781a:	4a ea       	ldi	r20, 0xAA	; 170
    781c:	58 e3       	ldi	r21, 0x38	; 56
    781e:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <USB_GetNextDescriptorComp>
    7822:	88 23       	and	r24, r24
    7824:	31 f3       	breq	.-52     	; 0x77f2 <RNDIS_Host_ConfigurePipes+0x7c>
    7826:	73 c0       	rjmp	.+230    	; 0x790e <RNDIS_Host_ConfigurePipes+0x198>
				DataINEndpoint  = NULL;
				DataOUTEndpoint = NULL;
			}
			else
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    7828:	c8 01       	movw	r24, r16
    782a:	b7 01       	movw	r22, r14
    782c:	49 e9       	ldi	r20, 0x99	; 153
    782e:	58 e3       	ldi	r21, 0x38	; 56
    7830:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <USB_GetNextDescriptorComp>
    7834:	88 23       	and	r24, r24
    7836:	09 f0       	breq	.+2      	; 0x783a <RNDIS_Host_ConfigurePipes+0xc4>
    7838:	6a c0       	rjmp	.+212    	; 0x790e <RNDIS_Host_ConfigurePipes+0x198>
											  DCOMP_RNDIS_Host_NextRNDISControlInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
				}

				RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    783a:	4b 80       	ldd	r4, Y+3	; 0x03
    783c:	5c 80       	ldd	r5, Y+4	; 0x04
    783e:	0e c0       	rjmp	.+28     	; 0x785c <RNDIS_Host_ConfigurePipes+0xe6>
			}

			continue;
		}

		USB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Endpoint_t);
    7840:	eb 81       	ldd	r30, Y+3	; 0x03
    7842:	fc 81       	ldd	r31, Y+4	; 0x04

		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
    7844:	82 81       	ldd	r24, Z+2	; 0x02
    7846:	87 fd       	sbrc	r24, 7
    7848:	02 c0       	rjmp	.+4      	; 0x784e <RNDIS_Host_ConfigurePipes+0xd8>
    784a:	4f 01       	movw	r8, r30
    784c:	07 c0       	rjmp	.+14     	; 0x785c <RNDIS_Host_ConfigurePipes+0xe6>
		{
			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
    784e:	83 81       	ldd	r24, Z+3	; 0x03
    7850:	83 70       	andi	r24, 0x03	; 3
    7852:	83 30       	cpi	r24, 0x03	; 3
    7854:	11 f0       	breq	.+4      	; 0x785a <RNDIS_Host_ConfigurePipes+0xe4>
    7856:	3f 01       	movw	r6, r30
    7858:	01 c0       	rjmp	.+2      	; 0x785c <RNDIS_Host_ConfigurePipes+0xe6>
    785a:	5f 01       	movw	r10, r30
	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
    785c:	61 14       	cp	r6, r1
    785e:	71 04       	cpc	r7, r1
    7860:	61 f2       	breq	.-104    	; 0x77fa <RNDIS_Host_ConfigurePipes+0x84>
    7862:	81 14       	cp	r8, r1
    7864:	91 04       	cpc	r9, r1
    7866:	49 f2       	breq	.-110    	; 0x77fa <RNDIS_Host_ConfigurePipes+0x84>
    7868:	a1 14       	cp	r10, r1
    786a:	b1 04       	cpc	r11, r1
    786c:	31 f2       	breq	.-116    	; 0x77fa <RNDIS_Host_ConfigurePipes+0x84>
    786e:	91 e0       	ldi	r25, 0x01	; 1
		uint8_t  Token;
		uint8_t  EndpointAddress;
		uint8_t  InterruptPeriod;
		bool     DoubleBanked;

		if (PipeNum == RNDISInterfaceInfo->Config.DataINPipeNumber)
    7870:	f6 01       	movw	r30, r12
    7872:	80 81       	ld	r24, Z
    7874:	98 17       	cp	r25, r24
    7876:	59 f4       	brne	.+22     	; 0x788e <RNDIS_Host_ConfigurePipes+0x118>
		{
			Size            = le16_to_cpu(DataINEndpoint->EndpointSize);
    7878:	f3 01       	movw	r30, r6
    787a:	04 81       	ldd	r16, Z+4	; 0x04
    787c:	15 81       	ldd	r17, Z+5	; 0x05
			EndpointAddress = DataINEndpoint->EndpointAddress;
    787e:	22 81       	ldd	r18, Z+2	; 0x02
			Token           = PIPE_TOKEN_IN;
			Type            = EP_TYPE_BULK;
			DoubleBanked    = RNDISInterfaceInfo->Config.DataINPipeDoubleBank;
    7880:	f6 01       	movw	r30, r12
    7882:	81 81       	ldd	r24, Z+1	; 0x01
			InterruptPeriod = 0;

			RNDISInterfaceInfo->State.DataINPipeSize = DataINEndpoint->EndpointSize;
    7884:	15 87       	std	Z+13, r17	; 0x0d
    7886:	04 87       	std	Z+12, r16	; 0x0c
    7888:	62 e0       	ldi	r22, 0x02	; 2
    788a:	40 e1       	ldi	r20, 0x10	; 16
    788c:	0e c0       	rjmp	.+28     	; 0x78aa <RNDIS_Host_ConfigurePipes+0x134>
		}
		else if (PipeNum == RNDISInterfaceInfo->Config.DataOUTPipeNumber)
    788e:	f6 01       	movw	r30, r12
    7890:	82 81       	ldd	r24, Z+2	; 0x02
    7892:	98 17       	cp	r25, r24
    7894:	61 f4       	brne	.+24     	; 0x78ae <RNDIS_Host_ConfigurePipes+0x138>
		{
			Size            = le16_to_cpu(DataOUTEndpoint->EndpointSize);
    7896:	f4 01       	movw	r30, r8
    7898:	04 81       	ldd	r16, Z+4	; 0x04
    789a:	15 81       	ldd	r17, Z+5	; 0x05
			EndpointAddress = DataOUTEndpoint->EndpointAddress;
    789c:	22 81       	ldd	r18, Z+2	; 0x02
			Token           = PIPE_TOKEN_OUT;
			Type            = EP_TYPE_BULK;
			DoubleBanked    = RNDISInterfaceInfo->Config.DataOUTPipeDoubleBank;
    789e:	f6 01       	movw	r30, r12
    78a0:	83 81       	ldd	r24, Z+3	; 0x03
			InterruptPeriod = 0;

			RNDISInterfaceInfo->State.DataOUTPipeSize = DataOUTEndpoint->EndpointSize;
    78a2:	17 87       	std	Z+15, r17	; 0x0f
    78a4:	06 87       	std	Z+14, r16	; 0x0e
    78a6:	62 e0       	ldi	r22, 0x02	; 2
    78a8:	40 e2       	ldi	r20, 0x20	; 32
    78aa:	ff 24       	eor	r15, r15
    78ac:	11 c0       	rjmp	.+34     	; 0x78d0 <RNDIS_Host_ConfigurePipes+0x15a>
		}
		else if (PipeNum == RNDISInterfaceInfo->Config.NotificationPipeNumber)
    78ae:	f6 01       	movw	r30, r12
    78b0:	84 81       	ldd	r24, Z+4	; 0x04
    78b2:	98 17       	cp	r25, r24
    78b4:	01 f5       	brne	.+64     	; 0x78f6 <RNDIS_Host_ConfigurePipes+0x180>
		{
			Size            = le16_to_cpu(NotificationEndpoint->EndpointSize);
    78b6:	f5 01       	movw	r30, r10
    78b8:	04 81       	ldd	r16, Z+4	; 0x04
    78ba:	15 81       	ldd	r17, Z+5	; 0x05
			EndpointAddress = NotificationEndpoint->EndpointAddress;
    78bc:	22 81       	ldd	r18, Z+2	; 0x02
			Token           = PIPE_TOKEN_IN;
			Type            = EP_TYPE_INTERRUPT;
			DoubleBanked    = RNDISInterfaceInfo->Config.NotificationPipeDoubleBank;
    78be:	f6 01       	movw	r30, r12
    78c0:	85 81       	ldd	r24, Z+5	; 0x05
			InterruptPeriod = NotificationEndpoint->PollingIntervalMS;
    78c2:	f5 01       	movw	r30, r10
    78c4:	f6 80       	ldd	r15, Z+6	; 0x06

			RNDISInterfaceInfo->State.NotificationPipeSize = NotificationEndpoint->EndpointSize;
    78c6:	f6 01       	movw	r30, r12
    78c8:	11 8b       	std	Z+17, r17	; 0x11
    78ca:	00 8b       	std	Z+16, r16	; 0x10
    78cc:	63 e0       	ldi	r22, 0x03	; 3
    78ce:	40 e1       	ldi	r20, 0x10	; 16
		else
		{
			continue;
		}
		
		if (!(Pipe_ConfigurePipe(PipeNum, Type, Token, EndpointAddress, Size,
    78d0:	88 23       	and	r24, r24
    78d2:	11 f4       	brne	.+4      	; 0x78d8 <RNDIS_Host_ConfigurePipes+0x162>
    78d4:	30 e0       	ldi	r19, 0x00	; 0
    78d6:	01 c0       	rjmp	.+2      	; 0x78da <RNDIS_Host_ConfigurePipes+0x164>
    78d8:	34 e0       	ldi	r19, 0x04	; 4
    78da:	89 2f       	mov	r24, r25
    78dc:	e3 2e       	mov	r14, r19
    78de:	9d 83       	std	Y+5, r25	; 0x05
    78e0:	0e 94 a4 28 	call	0x5148	; 0x5148 <Pipe_ConfigurePipe>
    78e4:	9d 81       	ldd	r25, Y+5	; 0x05
    78e6:	88 23       	and	r24, r24
    78e8:	11 f4       	brne	.+4      	; 0x78ee <RNDIS_Host_ConfigurePipes+0x178>
    78ea:	83 e0       	ldi	r24, 0x03	; 3
    78ec:	11 c0       	rjmp	.+34     	; 0x7910 <RNDIS_Host_ConfigurePipes+0x19a>
		                         DoubleBanked ? PIPE_BANK_DOUBLE : PIPE_BANK_SINGLE)))
		{
			return CDC_ENUMERROR_PipeConfigurationFailed;
		}
		
		if (InterruptPeriod)
    78ee:	ff 20       	and	r15, r15
    78f0:	11 f0       	breq	.+4      	; 0x78f6 <RNDIS_Host_ConfigurePipes+0x180>
			 *  \param[in] Milliseconds  Number of milliseconds between each pipe poll.
			 */
			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetInterruptPeriod(const uint8_t Milliseconds)
			{
				UPCFG2X = Milliseconds;
    78f2:	f0 92 ad 00 	sts	0x00AD, r15
		{
			DataOUTEndpoint = EndpointData;
		}
	}

	for (uint8_t PipeNum = 1; PipeNum < PIPE_TOTAL_PIPES; PipeNum++)
    78f6:	9f 5f       	subi	r25, 0xFF	; 255
    78f8:	97 30       	cpi	r25, 0x07	; 7
    78fa:	09 f0       	breq	.+2      	; 0x78fe <RNDIS_Host_ConfigurePipes+0x188>
    78fc:	b9 cf       	rjmp	.-142    	; 0x7870 <RNDIS_Host_ConfigurePipes+0xfa>
		
		if (InterruptPeriod)
		  Pipe_SetInterruptPeriod(InterruptPeriod);
	}

	RNDISInterfaceInfo->State.ControlInterfaceNumber = RNDISControlInterface->InterfaceNumber;
    78fe:	f2 01       	movw	r30, r4
    7900:	82 81       	ldd	r24, Z+2	; 0x02
    7902:	f6 01       	movw	r30, r12
    7904:	83 87       	std	Z+11, r24	; 0x0b
	RNDISInterfaceInfo->State.IsActive = true;
    7906:	81 e0       	ldi	r24, 0x01	; 1
    7908:	82 87       	std	Z+10, r24	; 0x0a
    790a:	80 e0       	ldi	r24, 0x00	; 0
    790c:	01 c0       	rjmp	.+2      	; 0x7910 <RNDIS_Host_ConfigurePipes+0x19a>

	return RNDIS_ENUMERROR_NoError;
    790e:	82 e0       	ldi	r24, 0x02	; 2
}
    7910:	0f 90       	pop	r0
    7912:	0f 90       	pop	r0
    7914:	0f 90       	pop	r0
    7916:	0f 90       	pop	r0
    7918:	0f 90       	pop	r0
    791a:	cf 91       	pop	r28
    791c:	df 91       	pop	r29
    791e:	1f 91       	pop	r17
    7920:	0f 91       	pop	r16
    7922:	ff 90       	pop	r15
    7924:	ef 90       	pop	r14
    7926:	df 90       	pop	r13
    7928:	cf 90       	pop	r12
    792a:	bf 90       	pop	r11
    792c:	af 90       	pop	r10
    792e:	9f 90       	pop	r9
    7930:	8f 90       	pop	r8
    7932:	7f 90       	pop	r7
    7934:	6f 90       	pop	r6
    7936:	5f 90       	pop	r5
    7938:	4f 90       	pop	r4
    793a:	08 95       	ret

0000793c <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint>:

	return DESCRIPTOR_SEARCH_NotFound;
}

static uint8_t DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint(void* const CurrentDescriptor)
{
    793c:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Endpoint)
    793e:	81 81       	ldd	r24, Z+1	; 0x01
    7940:	85 30       	cpi	r24, 0x05	; 5
    7942:	59 f4       	brne	.+22     	; 0x795a <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x1e>
	{
		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint_t);

		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
    7944:	83 81       	ldd	r24, Z+3	; 0x03
    7946:	83 70       	andi	r24, 0x03	; 3
    7948:	82 50       	subi	r24, 0x02	; 2
    794a:	82 30       	cpi	r24, 0x02	; 2
    794c:	50 f4       	brcc	.+20     	; 0x7962 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
    794e:	82 81       	ldd	r24, Z+2	; 0x02
    7950:	0e 94 16 29 	call	0x522c	; 0x522c <Pipe_IsEndpointBound>
    7954:	88 23       	and	r24, r24
    7956:	29 f4       	brne	.+10     	; 0x7962 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
    7958:	08 95       	ret
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}
	else if (Header->Type == DTYPE_Interface)
    795a:	84 30       	cpi	r24, 0x04	; 4
    795c:	11 f4       	brne	.+4      	; 0x7962 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
    795e:	81 e0       	ldi	r24, 0x01	; 1
    7960:	08 95       	ret
    7962:	82 e0       	ldi	r24, 0x02	; 2
	{
		return DESCRIPTOR_SEARCH_Fail;
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    7964:	08 95       	ret

00007966 <__mulsi3>:
    7966:	62 9f       	mul	r22, r18
    7968:	d0 01       	movw	r26, r0
    796a:	73 9f       	mul	r23, r19
    796c:	f0 01       	movw	r30, r0
    796e:	82 9f       	mul	r24, r18
    7970:	e0 0d       	add	r30, r0
    7972:	f1 1d       	adc	r31, r1
    7974:	64 9f       	mul	r22, r20
    7976:	e0 0d       	add	r30, r0
    7978:	f1 1d       	adc	r31, r1
    797a:	92 9f       	mul	r25, r18
    797c:	f0 0d       	add	r31, r0
    797e:	83 9f       	mul	r24, r19
    7980:	f0 0d       	add	r31, r0
    7982:	74 9f       	mul	r23, r20
    7984:	f0 0d       	add	r31, r0
    7986:	65 9f       	mul	r22, r21
    7988:	f0 0d       	add	r31, r0
    798a:	99 27       	eor	r25, r25
    798c:	72 9f       	mul	r23, r18
    798e:	b0 0d       	add	r27, r0
    7990:	e1 1d       	adc	r30, r1
    7992:	f9 1f       	adc	r31, r25
    7994:	63 9f       	mul	r22, r19
    7996:	b0 0d       	add	r27, r0
    7998:	e1 1d       	adc	r30, r1
    799a:	f9 1f       	adc	r31, r25
    799c:	bd 01       	movw	r22, r26
    799e:	cf 01       	movw	r24, r30
    79a0:	11 24       	eor	r1, r1
    79a2:	08 95       	ret

000079a4 <__udivmodsi4>:
    79a4:	a1 e2       	ldi	r26, 0x21	; 33
    79a6:	1a 2e       	mov	r1, r26
    79a8:	aa 1b       	sub	r26, r26
    79aa:	bb 1b       	sub	r27, r27
    79ac:	fd 01       	movw	r30, r26
    79ae:	0d c0       	rjmp	.+26     	; 0x79ca <__udivmodsi4_ep>

000079b0 <__udivmodsi4_loop>:
    79b0:	aa 1f       	adc	r26, r26
    79b2:	bb 1f       	adc	r27, r27
    79b4:	ee 1f       	adc	r30, r30
    79b6:	ff 1f       	adc	r31, r31
    79b8:	a2 17       	cp	r26, r18
    79ba:	b3 07       	cpc	r27, r19
    79bc:	e4 07       	cpc	r30, r20
    79be:	f5 07       	cpc	r31, r21
    79c0:	20 f0       	brcs	.+8      	; 0x79ca <__udivmodsi4_ep>
    79c2:	a2 1b       	sub	r26, r18
    79c4:	b3 0b       	sbc	r27, r19
    79c6:	e4 0b       	sbc	r30, r20
    79c8:	f5 0b       	sbc	r31, r21

000079ca <__udivmodsi4_ep>:
    79ca:	66 1f       	adc	r22, r22
    79cc:	77 1f       	adc	r23, r23
    79ce:	88 1f       	adc	r24, r24
    79d0:	99 1f       	adc	r25, r25
    79d2:	1a 94       	dec	r1
    79d4:	69 f7       	brne	.-38     	; 0x79b0 <__udivmodsi4_loop>
    79d6:	60 95       	com	r22
    79d8:	70 95       	com	r23
    79da:	80 95       	com	r24
    79dc:	90 95       	com	r25
    79de:	9b 01       	movw	r18, r22
    79e0:	ac 01       	movw	r20, r24
    79e2:	bd 01       	movw	r22, r26
    79e4:	cf 01       	movw	r24, r30
    79e6:	08 95       	ret

000079e8 <memcpy_P>:
    79e8:	fb 01       	movw	r30, r22
    79ea:	dc 01       	movw	r26, r24
    79ec:	02 c0       	rjmp	.+4      	; 0x79f2 <memcpy_P+0xa>
    79ee:	05 90       	lpm	r0, Z+
    79f0:	0d 92       	st	X+, r0
    79f2:	41 50       	subi	r20, 0x01	; 1
    79f4:	50 40       	sbci	r21, 0x00	; 0
    79f6:	d8 f7       	brcc	.-10     	; 0x79ee <memcpy_P+0x6>
    79f8:	08 95       	ret

000079fa <strcmp_P>:
    79fa:	fb 01       	movw	r30, r22
    79fc:	dc 01       	movw	r26, r24
    79fe:	8d 91       	ld	r24, X+
    7a00:	05 90       	lpm	r0, Z+
    7a02:	80 19       	sub	r24, r0
    7a04:	01 10       	cpse	r0, r1
    7a06:	d9 f3       	breq	.-10     	; 0x79fe <strcmp_P+0x4>
    7a08:	99 0b       	sbc	r25, r25
    7a0a:	08 95       	ret

00007a0c <strcpy_P>:
    7a0c:	fb 01       	movw	r30, r22
    7a0e:	dc 01       	movw	r26, r24
    7a10:	05 90       	lpm	r0, Z+
    7a12:	0d 92       	st	X+, r0
    7a14:	00 20       	and	r0, r0
    7a16:	e1 f7       	brne	.-8      	; 0x7a10 <strcpy_P+0x4>
    7a18:	08 95       	ret

00007a1a <strlcpy_P>:
    7a1a:	dc 01       	movw	r26, r24
    7a1c:	fb 01       	movw	r30, r22
    7a1e:	41 50       	subi	r20, 0x01	; 1
    7a20:	50 40       	sbci	r21, 0x00	; 0
    7a22:	58 f0       	brcs	.+22     	; 0x7a3a <strlcpy_P+0x20>
    7a24:	49 f0       	breq	.+18     	; 0x7a38 <strlcpy_P+0x1e>
    7a26:	05 90       	lpm	r0, Z+
    7a28:	0d 92       	st	X+, r0
    7a2a:	00 20       	and	r0, r0
    7a2c:	c1 f7       	brne	.-16     	; 0x7a1e <strlcpy_P+0x4>
    7a2e:	e6 1b       	sub	r30, r22
    7a30:	f7 0b       	sbc	r31, r23
    7a32:	31 97       	sbiw	r30, 0x01	; 1
    7a34:	cf 01       	movw	r24, r30
    7a36:	08 95       	ret
    7a38:	1c 92       	st	X, r1
    7a3a:	05 90       	lpm	r0, Z+
    7a3c:	00 20       	and	r0, r0
    7a3e:	e9 f7       	brne	.-6      	; 0x7a3a <strlcpy_P+0x20>
    7a40:	f6 cf       	rjmp	.-20     	; 0x7a2e <strlcpy_P+0x14>

00007a42 <strtok>:
    7a42:	40 ed       	ldi	r20, 0xD0	; 208
    7a44:	53 e0       	ldi	r21, 0x03	; 3
    7a46:	3f c0       	rjmp	.+126    	; 0x7ac6 <strtok_r>

00007a48 <memcpy>:
    7a48:	fb 01       	movw	r30, r22
    7a4a:	dc 01       	movw	r26, r24
    7a4c:	02 c0       	rjmp	.+4      	; 0x7a52 <memcpy+0xa>
    7a4e:	01 90       	ld	r0, Z+
    7a50:	0d 92       	st	X+, r0
    7a52:	41 50       	subi	r20, 0x01	; 1
    7a54:	50 40       	sbci	r21, 0x00	; 0
    7a56:	d8 f7       	brcc	.-10     	; 0x7a4e <memcpy+0x6>
    7a58:	08 95       	ret

00007a5a <memset>:
    7a5a:	dc 01       	movw	r26, r24
    7a5c:	01 c0       	rjmp	.+2      	; 0x7a60 <memset+0x6>
    7a5e:	6d 93       	st	X+, r22
    7a60:	41 50       	subi	r20, 0x01	; 1
    7a62:	50 40       	sbci	r21, 0x00	; 0
    7a64:	e0 f7       	brcc	.-8      	; 0x7a5e <memset+0x4>
    7a66:	08 95       	ret

00007a68 <strchr>:
    7a68:	fc 01       	movw	r30, r24
    7a6a:	81 91       	ld	r24, Z+
    7a6c:	86 17       	cp	r24, r22
    7a6e:	21 f0       	breq	.+8      	; 0x7a78 <strchr+0x10>
    7a70:	88 23       	and	r24, r24
    7a72:	d9 f7       	brne	.-10     	; 0x7a6a <strchr+0x2>
    7a74:	99 27       	eor	r25, r25
    7a76:	08 95       	ret
    7a78:	31 97       	sbiw	r30, 0x01	; 1
    7a7a:	cf 01       	movw	r24, r30
    7a7c:	08 95       	ret

00007a7e <strcmp>:
    7a7e:	fb 01       	movw	r30, r22
    7a80:	dc 01       	movw	r26, r24
    7a82:	8d 91       	ld	r24, X+
    7a84:	01 90       	ld	r0, Z+
    7a86:	80 19       	sub	r24, r0
    7a88:	01 10       	cpse	r0, r1
    7a8a:	d9 f3       	breq	.-10     	; 0x7a82 <strcmp+0x4>
    7a8c:	99 0b       	sbc	r25, r25
    7a8e:	08 95       	ret

00007a90 <strcpy>:
    7a90:	fb 01       	movw	r30, r22
    7a92:	dc 01       	movw	r26, r24
    7a94:	01 90       	ld	r0, Z+
    7a96:	0d 92       	st	X+, r0
    7a98:	00 20       	and	r0, r0
    7a9a:	e1 f7       	brne	.-8      	; 0x7a94 <strcpy+0x4>
    7a9c:	08 95       	ret

00007a9e <strlcpy>:
    7a9e:	dc 01       	movw	r26, r24
    7aa0:	fb 01       	movw	r30, r22
    7aa2:	41 50       	subi	r20, 0x01	; 1
    7aa4:	50 40       	sbci	r21, 0x00	; 0
    7aa6:	58 f0       	brcs	.+22     	; 0x7abe <strlcpy+0x20>
    7aa8:	49 f0       	breq	.+18     	; 0x7abc <strlcpy+0x1e>
    7aaa:	01 90       	ld	r0, Z+
    7aac:	0d 92       	st	X+, r0
    7aae:	00 20       	and	r0, r0
    7ab0:	c1 f7       	brne	.-16     	; 0x7aa2 <strlcpy+0x4>
    7ab2:	e6 1b       	sub	r30, r22
    7ab4:	f7 0b       	sbc	r31, r23
    7ab6:	31 97       	sbiw	r30, 0x01	; 1
    7ab8:	cf 01       	movw	r24, r30
    7aba:	08 95       	ret
    7abc:	1c 92       	st	X, r1
    7abe:	01 90       	ld	r0, Z+
    7ac0:	00 20       	and	r0, r0
    7ac2:	e9 f7       	brne	.-6      	; 0x7abe <strlcpy+0x20>
    7ac4:	f6 cf       	rjmp	.-20     	; 0x7ab2 <strlcpy+0x14>

00007ac6 <strtok_r>:
    7ac6:	fa 01       	movw	r30, r20
    7ac8:	a1 91       	ld	r26, Z+
    7aca:	b0 81       	ld	r27, Z
    7acc:	00 97       	sbiw	r24, 0x00	; 0
    7ace:	19 f4       	brne	.+6      	; 0x7ad6 <strtok_r+0x10>
    7ad0:	10 97       	sbiw	r26, 0x00	; 0
    7ad2:	e1 f0       	breq	.+56     	; 0x7b0c <strtok_r+0x46>
    7ad4:	cd 01       	movw	r24, r26
    7ad6:	dc 01       	movw	r26, r24
    7ad8:	cd 01       	movw	r24, r26
    7ada:	0d 90       	ld	r0, X+
    7adc:	00 20       	and	r0, r0
    7ade:	11 f4       	brne	.+4      	; 0x7ae4 <strtok_r+0x1e>
    7ae0:	c0 01       	movw	r24, r0
    7ae2:	13 c0       	rjmp	.+38     	; 0x7b0a <strtok_r+0x44>
    7ae4:	fb 01       	movw	r30, r22
    7ae6:	21 91       	ld	r18, Z+
    7ae8:	22 23       	and	r18, r18
    7aea:	19 f0       	breq	.+6      	; 0x7af2 <strtok_r+0x2c>
    7aec:	20 15       	cp	r18, r0
    7aee:	d9 f7       	brne	.-10     	; 0x7ae6 <strtok_r+0x20>
    7af0:	f3 cf       	rjmp	.-26     	; 0x7ad8 <strtok_r+0x12>
    7af2:	fb 01       	movw	r30, r22
    7af4:	21 91       	ld	r18, Z+
    7af6:	20 15       	cp	r18, r0
    7af8:	19 f4       	brne	.+6      	; 0x7b00 <strtok_r+0x3a>
    7afa:	1e 92       	st	-X, r1
    7afc:	11 96       	adiw	r26, 0x01	; 1
    7afe:	06 c0       	rjmp	.+12     	; 0x7b0c <strtok_r+0x46>
    7b00:	22 23       	and	r18, r18
    7b02:	c1 f7       	brne	.-16     	; 0x7af4 <strtok_r+0x2e>
    7b04:	0d 90       	ld	r0, X+
    7b06:	00 20       	and	r0, r0
    7b08:	a1 f7       	brne	.-24     	; 0x7af2 <strtok_r+0x2c>
    7b0a:	d0 01       	movw	r26, r0
    7b0c:	fa 01       	movw	r30, r20
    7b0e:	a1 93       	st	Z+, r26
    7b10:	b0 83       	st	Z, r27
    7b12:	08 95       	ret

00007b14 <sprintf_P>:
    7b14:	0f 93       	push	r16
    7b16:	1f 93       	push	r17
    7b18:	df 93       	push	r29
    7b1a:	cf 93       	push	r28
    7b1c:	cd b7       	in	r28, 0x3d	; 61
    7b1e:	de b7       	in	r29, 0x3e	; 62
    7b20:	2e 97       	sbiw	r28, 0x0e	; 14
    7b22:	0f b6       	in	r0, 0x3f	; 63
    7b24:	f8 94       	cli
    7b26:	de bf       	out	0x3e, r29	; 62
    7b28:	0f be       	out	0x3f, r0	; 63
    7b2a:	cd bf       	out	0x3d, r28	; 61
    7b2c:	0d 89       	ldd	r16, Y+21	; 0x15
    7b2e:	1e 89       	ldd	r17, Y+22	; 0x16
    7b30:	8e e0       	ldi	r24, 0x0E	; 14
    7b32:	8c 83       	std	Y+4, r24	; 0x04
    7b34:	1a 83       	std	Y+2, r17	; 0x02
    7b36:	09 83       	std	Y+1, r16	; 0x01
    7b38:	8f ef       	ldi	r24, 0xFF	; 255
    7b3a:	9f e7       	ldi	r25, 0x7F	; 127
    7b3c:	9e 83       	std	Y+6, r25	; 0x06
    7b3e:	8d 83       	std	Y+5, r24	; 0x05
    7b40:	9e 01       	movw	r18, r28
    7b42:	27 5e       	subi	r18, 0xE7	; 231
    7b44:	3f 4f       	sbci	r19, 0xFF	; 255
    7b46:	ce 01       	movw	r24, r28
    7b48:	01 96       	adiw	r24, 0x01	; 1
    7b4a:	6f 89       	ldd	r22, Y+23	; 0x17
    7b4c:	78 8d       	ldd	r23, Y+24	; 0x18
    7b4e:	a9 01       	movw	r20, r18
    7b50:	11 d0       	rcall	.+34     	; 0x7b74 <vfprintf>
    7b52:	2f 81       	ldd	r18, Y+7	; 0x07
    7b54:	38 85       	ldd	r19, Y+8	; 0x08
    7b56:	02 0f       	add	r16, r18
    7b58:	13 1f       	adc	r17, r19
    7b5a:	f8 01       	movw	r30, r16
    7b5c:	10 82       	st	Z, r1
    7b5e:	2e 96       	adiw	r28, 0x0e	; 14
    7b60:	0f b6       	in	r0, 0x3f	; 63
    7b62:	f8 94       	cli
    7b64:	de bf       	out	0x3e, r29	; 62
    7b66:	0f be       	out	0x3f, r0	; 63
    7b68:	cd bf       	out	0x3d, r28	; 61
    7b6a:	cf 91       	pop	r28
    7b6c:	df 91       	pop	r29
    7b6e:	1f 91       	pop	r17
    7b70:	0f 91       	pop	r16
    7b72:	08 95       	ret

00007b74 <vfprintf>:
    7b74:	2f 92       	push	r2
    7b76:	3f 92       	push	r3
    7b78:	4f 92       	push	r4
    7b7a:	5f 92       	push	r5
    7b7c:	6f 92       	push	r6
    7b7e:	7f 92       	push	r7
    7b80:	8f 92       	push	r8
    7b82:	9f 92       	push	r9
    7b84:	af 92       	push	r10
    7b86:	bf 92       	push	r11
    7b88:	cf 92       	push	r12
    7b8a:	df 92       	push	r13
    7b8c:	ef 92       	push	r14
    7b8e:	ff 92       	push	r15
    7b90:	0f 93       	push	r16
    7b92:	1f 93       	push	r17
    7b94:	df 93       	push	r29
    7b96:	cf 93       	push	r28
    7b98:	cd b7       	in	r28, 0x3d	; 61
    7b9a:	de b7       	in	r29, 0x3e	; 62
    7b9c:	2b 97       	sbiw	r28, 0x0b	; 11
    7b9e:	0f b6       	in	r0, 0x3f	; 63
    7ba0:	f8 94       	cli
    7ba2:	de bf       	out	0x3e, r29	; 62
    7ba4:	0f be       	out	0x3f, r0	; 63
    7ba6:	cd bf       	out	0x3d, r28	; 61
    7ba8:	3c 01       	movw	r6, r24
    7baa:	2b 01       	movw	r4, r22
    7bac:	5a 01       	movw	r10, r20
    7bae:	fc 01       	movw	r30, r24
    7bb0:	17 82       	std	Z+7, r1	; 0x07
    7bb2:	16 82       	std	Z+6, r1	; 0x06
    7bb4:	83 81       	ldd	r24, Z+3	; 0x03
    7bb6:	81 fd       	sbrc	r24, 1
    7bb8:	03 c0       	rjmp	.+6      	; 0x7bc0 <vfprintf+0x4c>
    7bba:	6f ef       	ldi	r22, 0xFF	; 255
    7bbc:	7f ef       	ldi	r23, 0xFF	; 255
    7bbe:	b9 c1       	rjmp	.+882    	; 0x7f32 <vfprintf+0x3be>
    7bc0:	9a e0       	ldi	r25, 0x0A	; 10
    7bc2:	89 2e       	mov	r8, r25
    7bc4:	1e 01       	movw	r2, r28
    7bc6:	08 94       	sec
    7bc8:	21 1c       	adc	r2, r1
    7bca:	31 1c       	adc	r3, r1
    7bcc:	f3 01       	movw	r30, r6
    7bce:	23 81       	ldd	r18, Z+3	; 0x03
    7bd0:	f2 01       	movw	r30, r4
    7bd2:	23 fd       	sbrc	r18, 3
    7bd4:	85 91       	lpm	r24, Z+
    7bd6:	23 ff       	sbrs	r18, 3
    7bd8:	81 91       	ld	r24, Z+
    7bda:	2f 01       	movw	r4, r30
    7bdc:	88 23       	and	r24, r24
    7bde:	09 f4       	brne	.+2      	; 0x7be2 <vfprintf+0x6e>
    7be0:	a5 c1       	rjmp	.+842    	; 0x7f2c <vfprintf+0x3b8>
    7be2:	85 32       	cpi	r24, 0x25	; 37
    7be4:	39 f4       	brne	.+14     	; 0x7bf4 <vfprintf+0x80>
    7be6:	23 fd       	sbrc	r18, 3
    7be8:	85 91       	lpm	r24, Z+
    7bea:	23 ff       	sbrs	r18, 3
    7bec:	81 91       	ld	r24, Z+
    7bee:	2f 01       	movw	r4, r30
    7bf0:	85 32       	cpi	r24, 0x25	; 37
    7bf2:	21 f4       	brne	.+8      	; 0x7bfc <vfprintf+0x88>
    7bf4:	90 e0       	ldi	r25, 0x00	; 0
    7bf6:	b3 01       	movw	r22, r6
    7bf8:	cc d1       	rcall	.+920    	; 0x7f92 <fputc>
    7bfa:	e8 cf       	rjmp	.-48     	; 0x7bcc <vfprintf+0x58>
    7bfc:	98 2f       	mov	r25, r24
    7bfe:	ff 24       	eor	r15, r15
    7c00:	ee 24       	eor	r14, r14
    7c02:	99 24       	eor	r9, r9
    7c04:	ff e1       	ldi	r31, 0x1F	; 31
    7c06:	ff 15       	cp	r31, r15
    7c08:	d0 f0       	brcs	.+52     	; 0x7c3e <vfprintf+0xca>
    7c0a:	9b 32       	cpi	r25, 0x2B	; 43
    7c0c:	69 f0       	breq	.+26     	; 0x7c28 <vfprintf+0xb4>
    7c0e:	9c 32       	cpi	r25, 0x2C	; 44
    7c10:	28 f4       	brcc	.+10     	; 0x7c1c <vfprintf+0xa8>
    7c12:	90 32       	cpi	r25, 0x20	; 32
    7c14:	59 f0       	breq	.+22     	; 0x7c2c <vfprintf+0xb8>
    7c16:	93 32       	cpi	r25, 0x23	; 35
    7c18:	91 f4       	brne	.+36     	; 0x7c3e <vfprintf+0xca>
    7c1a:	0e c0       	rjmp	.+28     	; 0x7c38 <vfprintf+0xc4>
    7c1c:	9d 32       	cpi	r25, 0x2D	; 45
    7c1e:	49 f0       	breq	.+18     	; 0x7c32 <vfprintf+0xbe>
    7c20:	90 33       	cpi	r25, 0x30	; 48
    7c22:	69 f4       	brne	.+26     	; 0x7c3e <vfprintf+0xca>
    7c24:	41 e0       	ldi	r20, 0x01	; 1
    7c26:	24 c0       	rjmp	.+72     	; 0x7c70 <vfprintf+0xfc>
    7c28:	52 e0       	ldi	r21, 0x02	; 2
    7c2a:	f5 2a       	or	r15, r21
    7c2c:	84 e0       	ldi	r24, 0x04	; 4
    7c2e:	f8 2a       	or	r15, r24
    7c30:	28 c0       	rjmp	.+80     	; 0x7c82 <vfprintf+0x10e>
    7c32:	98 e0       	ldi	r25, 0x08	; 8
    7c34:	f9 2a       	or	r15, r25
    7c36:	25 c0       	rjmp	.+74     	; 0x7c82 <vfprintf+0x10e>
    7c38:	e0 e1       	ldi	r30, 0x10	; 16
    7c3a:	fe 2a       	or	r15, r30
    7c3c:	22 c0       	rjmp	.+68     	; 0x7c82 <vfprintf+0x10e>
    7c3e:	f7 fc       	sbrc	r15, 7
    7c40:	29 c0       	rjmp	.+82     	; 0x7c94 <vfprintf+0x120>
    7c42:	89 2f       	mov	r24, r25
    7c44:	80 53       	subi	r24, 0x30	; 48
    7c46:	8a 30       	cpi	r24, 0x0A	; 10
    7c48:	70 f4       	brcc	.+28     	; 0x7c66 <vfprintf+0xf2>
    7c4a:	f6 fe       	sbrs	r15, 6
    7c4c:	05 c0       	rjmp	.+10     	; 0x7c58 <vfprintf+0xe4>
    7c4e:	98 9c       	mul	r9, r8
    7c50:	90 2c       	mov	r9, r0
    7c52:	11 24       	eor	r1, r1
    7c54:	98 0e       	add	r9, r24
    7c56:	15 c0       	rjmp	.+42     	; 0x7c82 <vfprintf+0x10e>
    7c58:	e8 9c       	mul	r14, r8
    7c5a:	e0 2c       	mov	r14, r0
    7c5c:	11 24       	eor	r1, r1
    7c5e:	e8 0e       	add	r14, r24
    7c60:	f0 e2       	ldi	r31, 0x20	; 32
    7c62:	ff 2a       	or	r15, r31
    7c64:	0e c0       	rjmp	.+28     	; 0x7c82 <vfprintf+0x10e>
    7c66:	9e 32       	cpi	r25, 0x2E	; 46
    7c68:	29 f4       	brne	.+10     	; 0x7c74 <vfprintf+0x100>
    7c6a:	f6 fc       	sbrc	r15, 6
    7c6c:	5f c1       	rjmp	.+702    	; 0x7f2c <vfprintf+0x3b8>
    7c6e:	40 e4       	ldi	r20, 0x40	; 64
    7c70:	f4 2a       	or	r15, r20
    7c72:	07 c0       	rjmp	.+14     	; 0x7c82 <vfprintf+0x10e>
    7c74:	9c 36       	cpi	r25, 0x6C	; 108
    7c76:	19 f4       	brne	.+6      	; 0x7c7e <vfprintf+0x10a>
    7c78:	50 e8       	ldi	r21, 0x80	; 128
    7c7a:	f5 2a       	or	r15, r21
    7c7c:	02 c0       	rjmp	.+4      	; 0x7c82 <vfprintf+0x10e>
    7c7e:	98 36       	cpi	r25, 0x68	; 104
    7c80:	49 f4       	brne	.+18     	; 0x7c94 <vfprintf+0x120>
    7c82:	f2 01       	movw	r30, r4
    7c84:	23 fd       	sbrc	r18, 3
    7c86:	95 91       	lpm	r25, Z+
    7c88:	23 ff       	sbrs	r18, 3
    7c8a:	91 91       	ld	r25, Z+
    7c8c:	2f 01       	movw	r4, r30
    7c8e:	99 23       	and	r25, r25
    7c90:	09 f0       	breq	.+2      	; 0x7c94 <vfprintf+0x120>
    7c92:	b8 cf       	rjmp	.-144    	; 0x7c04 <vfprintf+0x90>
    7c94:	89 2f       	mov	r24, r25
    7c96:	85 54       	subi	r24, 0x45	; 69
    7c98:	83 30       	cpi	r24, 0x03	; 3
    7c9a:	18 f0       	brcs	.+6      	; 0x7ca2 <vfprintf+0x12e>
    7c9c:	80 52       	subi	r24, 0x20	; 32
    7c9e:	83 30       	cpi	r24, 0x03	; 3
    7ca0:	38 f4       	brcc	.+14     	; 0x7cb0 <vfprintf+0x13c>
    7ca2:	44 e0       	ldi	r20, 0x04	; 4
    7ca4:	50 e0       	ldi	r21, 0x00	; 0
    7ca6:	a4 0e       	add	r10, r20
    7ca8:	b5 1e       	adc	r11, r21
    7caa:	5f e3       	ldi	r21, 0x3F	; 63
    7cac:	59 83       	std	Y+1, r21	; 0x01
    7cae:	0f c0       	rjmp	.+30     	; 0x7cce <vfprintf+0x15a>
    7cb0:	93 36       	cpi	r25, 0x63	; 99
    7cb2:	31 f0       	breq	.+12     	; 0x7cc0 <vfprintf+0x14c>
    7cb4:	93 37       	cpi	r25, 0x73	; 115
    7cb6:	79 f0       	breq	.+30     	; 0x7cd6 <vfprintf+0x162>
    7cb8:	93 35       	cpi	r25, 0x53	; 83
    7cba:	09 f0       	breq	.+2      	; 0x7cbe <vfprintf+0x14a>
    7cbc:	52 c0       	rjmp	.+164    	; 0x7d62 <vfprintf+0x1ee>
    7cbe:	1f c0       	rjmp	.+62     	; 0x7cfe <vfprintf+0x18a>
    7cc0:	f5 01       	movw	r30, r10
    7cc2:	80 81       	ld	r24, Z
    7cc4:	89 83       	std	Y+1, r24	; 0x01
    7cc6:	42 e0       	ldi	r20, 0x02	; 2
    7cc8:	50 e0       	ldi	r21, 0x00	; 0
    7cca:	a4 0e       	add	r10, r20
    7ccc:	b5 1e       	adc	r11, r21
    7cce:	61 01       	movw	r12, r2
    7cd0:	01 e0       	ldi	r16, 0x01	; 1
    7cd2:	10 e0       	ldi	r17, 0x00	; 0
    7cd4:	11 c0       	rjmp	.+34     	; 0x7cf8 <vfprintf+0x184>
    7cd6:	f5 01       	movw	r30, r10
    7cd8:	c0 80       	ld	r12, Z
    7cda:	d1 80       	ldd	r13, Z+1	; 0x01
    7cdc:	f6 fc       	sbrc	r15, 6
    7cde:	03 c0       	rjmp	.+6      	; 0x7ce6 <vfprintf+0x172>
    7ce0:	6f ef       	ldi	r22, 0xFF	; 255
    7ce2:	7f ef       	ldi	r23, 0xFF	; 255
    7ce4:	02 c0       	rjmp	.+4      	; 0x7cea <vfprintf+0x176>
    7ce6:	69 2d       	mov	r22, r9
    7ce8:	70 e0       	ldi	r23, 0x00	; 0
    7cea:	42 e0       	ldi	r20, 0x02	; 2
    7cec:	50 e0       	ldi	r21, 0x00	; 0
    7cee:	a4 0e       	add	r10, r20
    7cf0:	b5 1e       	adc	r11, r21
    7cf2:	c6 01       	movw	r24, r12
    7cf4:	43 d1       	rcall	.+646    	; 0x7f7c <strnlen>
    7cf6:	8c 01       	movw	r16, r24
    7cf8:	5f e7       	ldi	r21, 0x7F	; 127
    7cfa:	f5 22       	and	r15, r21
    7cfc:	13 c0       	rjmp	.+38     	; 0x7d24 <vfprintf+0x1b0>
    7cfe:	f5 01       	movw	r30, r10
    7d00:	c0 80       	ld	r12, Z
    7d02:	d1 80       	ldd	r13, Z+1	; 0x01
    7d04:	f6 fc       	sbrc	r15, 6
    7d06:	03 c0       	rjmp	.+6      	; 0x7d0e <vfprintf+0x19a>
    7d08:	6f ef       	ldi	r22, 0xFF	; 255
    7d0a:	7f ef       	ldi	r23, 0xFF	; 255
    7d0c:	02 c0       	rjmp	.+4      	; 0x7d12 <vfprintf+0x19e>
    7d0e:	69 2d       	mov	r22, r9
    7d10:	70 e0       	ldi	r23, 0x00	; 0
    7d12:	42 e0       	ldi	r20, 0x02	; 2
    7d14:	50 e0       	ldi	r21, 0x00	; 0
    7d16:	a4 0e       	add	r10, r20
    7d18:	b5 1e       	adc	r11, r21
    7d1a:	c6 01       	movw	r24, r12
    7d1c:	24 d1       	rcall	.+584    	; 0x7f66 <strnlen_P>
    7d1e:	8c 01       	movw	r16, r24
    7d20:	50 e8       	ldi	r21, 0x80	; 128
    7d22:	f5 2a       	or	r15, r21
    7d24:	f3 fe       	sbrs	r15, 3
    7d26:	06 c0       	rjmp	.+12     	; 0x7d34 <vfprintf+0x1c0>
    7d28:	18 c0       	rjmp	.+48     	; 0x7d5a <vfprintf+0x1e6>
    7d2a:	80 e2       	ldi	r24, 0x20	; 32
    7d2c:	90 e0       	ldi	r25, 0x00	; 0
    7d2e:	b3 01       	movw	r22, r6
    7d30:	30 d1       	rcall	.+608    	; 0x7f92 <fputc>
    7d32:	ea 94       	dec	r14
    7d34:	8e 2d       	mov	r24, r14
    7d36:	90 e0       	ldi	r25, 0x00	; 0
    7d38:	08 17       	cp	r16, r24
    7d3a:	19 07       	cpc	r17, r25
    7d3c:	b0 f3       	brcs	.-20     	; 0x7d2a <vfprintf+0x1b6>
    7d3e:	0d c0       	rjmp	.+26     	; 0x7d5a <vfprintf+0x1e6>
    7d40:	f6 01       	movw	r30, r12
    7d42:	f7 fc       	sbrc	r15, 7
    7d44:	85 91       	lpm	r24, Z+
    7d46:	f7 fe       	sbrs	r15, 7
    7d48:	81 91       	ld	r24, Z+
    7d4a:	6f 01       	movw	r12, r30
    7d4c:	90 e0       	ldi	r25, 0x00	; 0
    7d4e:	b3 01       	movw	r22, r6
    7d50:	20 d1       	rcall	.+576    	; 0x7f92 <fputc>
    7d52:	e1 10       	cpse	r14, r1
    7d54:	ea 94       	dec	r14
    7d56:	01 50       	subi	r16, 0x01	; 1
    7d58:	10 40       	sbci	r17, 0x00	; 0
    7d5a:	01 15       	cp	r16, r1
    7d5c:	11 05       	cpc	r17, r1
    7d5e:	81 f7       	brne	.-32     	; 0x7d40 <vfprintf+0x1cc>
    7d60:	e2 c0       	rjmp	.+452    	; 0x7f26 <vfprintf+0x3b2>
    7d62:	94 36       	cpi	r25, 0x64	; 100
    7d64:	11 f0       	breq	.+4      	; 0x7d6a <vfprintf+0x1f6>
    7d66:	99 36       	cpi	r25, 0x69	; 105
    7d68:	61 f5       	brne	.+88     	; 0x7dc2 <vfprintf+0x24e>
    7d6a:	f7 fe       	sbrs	r15, 7
    7d6c:	08 c0       	rjmp	.+16     	; 0x7d7e <vfprintf+0x20a>
    7d6e:	f5 01       	movw	r30, r10
    7d70:	20 81       	ld	r18, Z
    7d72:	31 81       	ldd	r19, Z+1	; 0x01
    7d74:	42 81       	ldd	r20, Z+2	; 0x02
    7d76:	53 81       	ldd	r21, Z+3	; 0x03
    7d78:	84 e0       	ldi	r24, 0x04	; 4
    7d7a:	90 e0       	ldi	r25, 0x00	; 0
    7d7c:	0a c0       	rjmp	.+20     	; 0x7d92 <vfprintf+0x21e>
    7d7e:	f5 01       	movw	r30, r10
    7d80:	80 81       	ld	r24, Z
    7d82:	91 81       	ldd	r25, Z+1	; 0x01
    7d84:	9c 01       	movw	r18, r24
    7d86:	44 27       	eor	r20, r20
    7d88:	37 fd       	sbrc	r19, 7
    7d8a:	40 95       	com	r20
    7d8c:	54 2f       	mov	r21, r20
    7d8e:	82 e0       	ldi	r24, 0x02	; 2
    7d90:	90 e0       	ldi	r25, 0x00	; 0
    7d92:	a8 0e       	add	r10, r24
    7d94:	b9 1e       	adc	r11, r25
    7d96:	9f e6       	ldi	r25, 0x6F	; 111
    7d98:	f9 22       	and	r15, r25
    7d9a:	57 ff       	sbrs	r21, 7
    7d9c:	09 c0       	rjmp	.+18     	; 0x7db0 <vfprintf+0x23c>
    7d9e:	50 95       	com	r21
    7da0:	40 95       	com	r20
    7da2:	30 95       	com	r19
    7da4:	21 95       	neg	r18
    7da6:	3f 4f       	sbci	r19, 0xFF	; 255
    7da8:	4f 4f       	sbci	r20, 0xFF	; 255
    7daa:	5f 4f       	sbci	r21, 0xFF	; 255
    7dac:	e0 e8       	ldi	r30, 0x80	; 128
    7dae:	fe 2a       	or	r15, r30
    7db0:	ca 01       	movw	r24, r20
    7db2:	b9 01       	movw	r22, r18
    7db4:	a1 01       	movw	r20, r2
    7db6:	2a e0       	ldi	r18, 0x0A	; 10
    7db8:	30 e0       	ldi	r19, 0x00	; 0
    7dba:	17 d1       	rcall	.+558    	; 0x7fea <__ultoa_invert>
    7dbc:	d8 2e       	mov	r13, r24
    7dbe:	d2 18       	sub	r13, r2
    7dc0:	3f c0       	rjmp	.+126    	; 0x7e40 <vfprintf+0x2cc>
    7dc2:	95 37       	cpi	r25, 0x75	; 117
    7dc4:	29 f4       	brne	.+10     	; 0x7dd0 <vfprintf+0x25c>
    7dc6:	1f 2d       	mov	r17, r15
    7dc8:	1f 7e       	andi	r17, 0xEF	; 239
    7dca:	2a e0       	ldi	r18, 0x0A	; 10
    7dcc:	30 e0       	ldi	r19, 0x00	; 0
    7dce:	1d c0       	rjmp	.+58     	; 0x7e0a <vfprintf+0x296>
    7dd0:	1f 2d       	mov	r17, r15
    7dd2:	19 7f       	andi	r17, 0xF9	; 249
    7dd4:	9f 36       	cpi	r25, 0x6F	; 111
    7dd6:	61 f0       	breq	.+24     	; 0x7df0 <vfprintf+0x27c>
    7dd8:	90 37       	cpi	r25, 0x70	; 112
    7dda:	20 f4       	brcc	.+8      	; 0x7de4 <vfprintf+0x270>
    7ddc:	98 35       	cpi	r25, 0x58	; 88
    7dde:	09 f0       	breq	.+2      	; 0x7de2 <vfprintf+0x26e>
    7de0:	a5 c0       	rjmp	.+330    	; 0x7f2c <vfprintf+0x3b8>
    7de2:	0f c0       	rjmp	.+30     	; 0x7e02 <vfprintf+0x28e>
    7de4:	90 37       	cpi	r25, 0x70	; 112
    7de6:	39 f0       	breq	.+14     	; 0x7df6 <vfprintf+0x282>
    7de8:	98 37       	cpi	r25, 0x78	; 120
    7dea:	09 f0       	breq	.+2      	; 0x7dee <vfprintf+0x27a>
    7dec:	9f c0       	rjmp	.+318    	; 0x7f2c <vfprintf+0x3b8>
    7dee:	04 c0       	rjmp	.+8      	; 0x7df8 <vfprintf+0x284>
    7df0:	28 e0       	ldi	r18, 0x08	; 8
    7df2:	30 e0       	ldi	r19, 0x00	; 0
    7df4:	0a c0       	rjmp	.+20     	; 0x7e0a <vfprintf+0x296>
    7df6:	10 61       	ori	r17, 0x10	; 16
    7df8:	14 fd       	sbrc	r17, 4
    7dfa:	14 60       	ori	r17, 0x04	; 4
    7dfc:	20 e1       	ldi	r18, 0x10	; 16
    7dfe:	30 e0       	ldi	r19, 0x00	; 0
    7e00:	04 c0       	rjmp	.+8      	; 0x7e0a <vfprintf+0x296>
    7e02:	14 fd       	sbrc	r17, 4
    7e04:	16 60       	ori	r17, 0x06	; 6
    7e06:	20 e1       	ldi	r18, 0x10	; 16
    7e08:	32 e0       	ldi	r19, 0x02	; 2
    7e0a:	17 ff       	sbrs	r17, 7
    7e0c:	08 c0       	rjmp	.+16     	; 0x7e1e <vfprintf+0x2aa>
    7e0e:	f5 01       	movw	r30, r10
    7e10:	60 81       	ld	r22, Z
    7e12:	71 81       	ldd	r23, Z+1	; 0x01
    7e14:	82 81       	ldd	r24, Z+2	; 0x02
    7e16:	93 81       	ldd	r25, Z+3	; 0x03
    7e18:	44 e0       	ldi	r20, 0x04	; 4
    7e1a:	50 e0       	ldi	r21, 0x00	; 0
    7e1c:	08 c0       	rjmp	.+16     	; 0x7e2e <vfprintf+0x2ba>
    7e1e:	f5 01       	movw	r30, r10
    7e20:	80 81       	ld	r24, Z
    7e22:	91 81       	ldd	r25, Z+1	; 0x01
    7e24:	bc 01       	movw	r22, r24
    7e26:	80 e0       	ldi	r24, 0x00	; 0
    7e28:	90 e0       	ldi	r25, 0x00	; 0
    7e2a:	42 e0       	ldi	r20, 0x02	; 2
    7e2c:	50 e0       	ldi	r21, 0x00	; 0
    7e2e:	a4 0e       	add	r10, r20
    7e30:	b5 1e       	adc	r11, r21
    7e32:	a1 01       	movw	r20, r2
    7e34:	da d0       	rcall	.+436    	; 0x7fea <__ultoa_invert>
    7e36:	d8 2e       	mov	r13, r24
    7e38:	d2 18       	sub	r13, r2
    7e3a:	8f e7       	ldi	r24, 0x7F	; 127
    7e3c:	f8 2e       	mov	r15, r24
    7e3e:	f1 22       	and	r15, r17
    7e40:	f6 fe       	sbrs	r15, 6
    7e42:	0b c0       	rjmp	.+22     	; 0x7e5a <vfprintf+0x2e6>
    7e44:	5e ef       	ldi	r21, 0xFE	; 254
    7e46:	f5 22       	and	r15, r21
    7e48:	d9 14       	cp	r13, r9
    7e4a:	38 f4       	brcc	.+14     	; 0x7e5a <vfprintf+0x2e6>
    7e4c:	f4 fe       	sbrs	r15, 4
    7e4e:	07 c0       	rjmp	.+14     	; 0x7e5e <vfprintf+0x2ea>
    7e50:	f2 fc       	sbrc	r15, 2
    7e52:	05 c0       	rjmp	.+10     	; 0x7e5e <vfprintf+0x2ea>
    7e54:	8f ee       	ldi	r24, 0xEF	; 239
    7e56:	f8 22       	and	r15, r24
    7e58:	02 c0       	rjmp	.+4      	; 0x7e5e <vfprintf+0x2ea>
    7e5a:	1d 2d       	mov	r17, r13
    7e5c:	01 c0       	rjmp	.+2      	; 0x7e60 <vfprintf+0x2ec>
    7e5e:	19 2d       	mov	r17, r9
    7e60:	f4 fe       	sbrs	r15, 4
    7e62:	0d c0       	rjmp	.+26     	; 0x7e7e <vfprintf+0x30a>
    7e64:	fe 01       	movw	r30, r28
    7e66:	ed 0d       	add	r30, r13
    7e68:	f1 1d       	adc	r31, r1
    7e6a:	80 81       	ld	r24, Z
    7e6c:	80 33       	cpi	r24, 0x30	; 48
    7e6e:	19 f4       	brne	.+6      	; 0x7e76 <vfprintf+0x302>
    7e70:	99 ee       	ldi	r25, 0xE9	; 233
    7e72:	f9 22       	and	r15, r25
    7e74:	08 c0       	rjmp	.+16     	; 0x7e86 <vfprintf+0x312>
    7e76:	1f 5f       	subi	r17, 0xFF	; 255
    7e78:	f2 fe       	sbrs	r15, 2
    7e7a:	05 c0       	rjmp	.+10     	; 0x7e86 <vfprintf+0x312>
    7e7c:	03 c0       	rjmp	.+6      	; 0x7e84 <vfprintf+0x310>
    7e7e:	8f 2d       	mov	r24, r15
    7e80:	86 78       	andi	r24, 0x86	; 134
    7e82:	09 f0       	breq	.+2      	; 0x7e86 <vfprintf+0x312>
    7e84:	1f 5f       	subi	r17, 0xFF	; 255
    7e86:	0f 2d       	mov	r16, r15
    7e88:	f3 fc       	sbrc	r15, 3
    7e8a:	13 c0       	rjmp	.+38     	; 0x7eb2 <vfprintf+0x33e>
    7e8c:	f0 fe       	sbrs	r15, 0
    7e8e:	0e c0       	rjmp	.+28     	; 0x7eac <vfprintf+0x338>
    7e90:	1e 15       	cp	r17, r14
    7e92:	10 f0       	brcs	.+4      	; 0x7e98 <vfprintf+0x324>
    7e94:	9d 2c       	mov	r9, r13
    7e96:	0a c0       	rjmp	.+20     	; 0x7eac <vfprintf+0x338>
    7e98:	9d 2c       	mov	r9, r13
    7e9a:	9e 0c       	add	r9, r14
    7e9c:	91 1a       	sub	r9, r17
    7e9e:	1e 2d       	mov	r17, r14
    7ea0:	05 c0       	rjmp	.+10     	; 0x7eac <vfprintf+0x338>
    7ea2:	80 e2       	ldi	r24, 0x20	; 32
    7ea4:	90 e0       	ldi	r25, 0x00	; 0
    7ea6:	b3 01       	movw	r22, r6
    7ea8:	74 d0       	rcall	.+232    	; 0x7f92 <fputc>
    7eaa:	1f 5f       	subi	r17, 0xFF	; 255
    7eac:	1e 15       	cp	r17, r14
    7eae:	c8 f3       	brcs	.-14     	; 0x7ea2 <vfprintf+0x32e>
    7eb0:	04 c0       	rjmp	.+8      	; 0x7eba <vfprintf+0x346>
    7eb2:	1e 15       	cp	r17, r14
    7eb4:	10 f4       	brcc	.+4      	; 0x7eba <vfprintf+0x346>
    7eb6:	e1 1a       	sub	r14, r17
    7eb8:	01 c0       	rjmp	.+2      	; 0x7ebc <vfprintf+0x348>
    7eba:	ee 24       	eor	r14, r14
    7ebc:	04 ff       	sbrs	r16, 4
    7ebe:	0e c0       	rjmp	.+28     	; 0x7edc <vfprintf+0x368>
    7ec0:	80 e3       	ldi	r24, 0x30	; 48
    7ec2:	90 e0       	ldi	r25, 0x00	; 0
    7ec4:	b3 01       	movw	r22, r6
    7ec6:	65 d0       	rcall	.+202    	; 0x7f92 <fputc>
    7ec8:	02 ff       	sbrs	r16, 2
    7eca:	1b c0       	rjmp	.+54     	; 0x7f02 <vfprintf+0x38e>
    7ecc:	01 fd       	sbrc	r16, 1
    7ece:	03 c0       	rjmp	.+6      	; 0x7ed6 <vfprintf+0x362>
    7ed0:	88 e7       	ldi	r24, 0x78	; 120
    7ed2:	90 e0       	ldi	r25, 0x00	; 0
    7ed4:	0e c0       	rjmp	.+28     	; 0x7ef2 <vfprintf+0x37e>
    7ed6:	88 e5       	ldi	r24, 0x58	; 88
    7ed8:	90 e0       	ldi	r25, 0x00	; 0
    7eda:	0b c0       	rjmp	.+22     	; 0x7ef2 <vfprintf+0x37e>
    7edc:	80 2f       	mov	r24, r16
    7ede:	86 78       	andi	r24, 0x86	; 134
    7ee0:	81 f0       	breq	.+32     	; 0x7f02 <vfprintf+0x38e>
    7ee2:	01 ff       	sbrs	r16, 1
    7ee4:	02 c0       	rjmp	.+4      	; 0x7eea <vfprintf+0x376>
    7ee6:	8b e2       	ldi	r24, 0x2B	; 43
    7ee8:	01 c0       	rjmp	.+2      	; 0x7eec <vfprintf+0x378>
    7eea:	80 e2       	ldi	r24, 0x20	; 32
    7eec:	f7 fc       	sbrc	r15, 7
    7eee:	8d e2       	ldi	r24, 0x2D	; 45
    7ef0:	90 e0       	ldi	r25, 0x00	; 0
    7ef2:	b3 01       	movw	r22, r6
    7ef4:	4e d0       	rcall	.+156    	; 0x7f92 <fputc>
    7ef6:	05 c0       	rjmp	.+10     	; 0x7f02 <vfprintf+0x38e>
    7ef8:	80 e3       	ldi	r24, 0x30	; 48
    7efa:	90 e0       	ldi	r25, 0x00	; 0
    7efc:	b3 01       	movw	r22, r6
    7efe:	49 d0       	rcall	.+146    	; 0x7f92 <fputc>
    7f00:	9a 94       	dec	r9
    7f02:	d9 14       	cp	r13, r9
    7f04:	c8 f3       	brcs	.-14     	; 0x7ef8 <vfprintf+0x384>
    7f06:	da 94       	dec	r13
    7f08:	f1 01       	movw	r30, r2
    7f0a:	ed 0d       	add	r30, r13
    7f0c:	f1 1d       	adc	r31, r1
    7f0e:	80 81       	ld	r24, Z
    7f10:	90 e0       	ldi	r25, 0x00	; 0
    7f12:	b3 01       	movw	r22, r6
    7f14:	3e d0       	rcall	.+124    	; 0x7f92 <fputc>
    7f16:	dd 20       	and	r13, r13
    7f18:	b1 f7       	brne	.-20     	; 0x7f06 <vfprintf+0x392>
    7f1a:	05 c0       	rjmp	.+10     	; 0x7f26 <vfprintf+0x3b2>
    7f1c:	80 e2       	ldi	r24, 0x20	; 32
    7f1e:	90 e0       	ldi	r25, 0x00	; 0
    7f20:	b3 01       	movw	r22, r6
    7f22:	37 d0       	rcall	.+110    	; 0x7f92 <fputc>
    7f24:	ea 94       	dec	r14
    7f26:	ee 20       	and	r14, r14
    7f28:	c9 f7       	brne	.-14     	; 0x7f1c <vfprintf+0x3a8>
    7f2a:	50 ce       	rjmp	.-864    	; 0x7bcc <vfprintf+0x58>
    7f2c:	f3 01       	movw	r30, r6
    7f2e:	66 81       	ldd	r22, Z+6	; 0x06
    7f30:	77 81       	ldd	r23, Z+7	; 0x07
    7f32:	cb 01       	movw	r24, r22
    7f34:	2b 96       	adiw	r28, 0x0b	; 11
    7f36:	0f b6       	in	r0, 0x3f	; 63
    7f38:	f8 94       	cli
    7f3a:	de bf       	out	0x3e, r29	; 62
    7f3c:	0f be       	out	0x3f, r0	; 63
    7f3e:	cd bf       	out	0x3d, r28	; 61
    7f40:	cf 91       	pop	r28
    7f42:	df 91       	pop	r29
    7f44:	1f 91       	pop	r17
    7f46:	0f 91       	pop	r16
    7f48:	ff 90       	pop	r15
    7f4a:	ef 90       	pop	r14
    7f4c:	df 90       	pop	r13
    7f4e:	cf 90       	pop	r12
    7f50:	bf 90       	pop	r11
    7f52:	af 90       	pop	r10
    7f54:	9f 90       	pop	r9
    7f56:	8f 90       	pop	r8
    7f58:	7f 90       	pop	r7
    7f5a:	6f 90       	pop	r6
    7f5c:	5f 90       	pop	r5
    7f5e:	4f 90       	pop	r4
    7f60:	3f 90       	pop	r3
    7f62:	2f 90       	pop	r2
    7f64:	08 95       	ret

00007f66 <strnlen_P>:
    7f66:	fc 01       	movw	r30, r24
    7f68:	05 90       	lpm	r0, Z+
    7f6a:	61 50       	subi	r22, 0x01	; 1
    7f6c:	70 40       	sbci	r23, 0x00	; 0
    7f6e:	01 10       	cpse	r0, r1
    7f70:	d8 f7       	brcc	.-10     	; 0x7f68 <strnlen_P+0x2>
    7f72:	80 95       	com	r24
    7f74:	90 95       	com	r25
    7f76:	8e 0f       	add	r24, r30
    7f78:	9f 1f       	adc	r25, r31
    7f7a:	08 95       	ret

00007f7c <strnlen>:
    7f7c:	fc 01       	movw	r30, r24
    7f7e:	61 50       	subi	r22, 0x01	; 1
    7f80:	70 40       	sbci	r23, 0x00	; 0
    7f82:	01 90       	ld	r0, Z+
    7f84:	01 10       	cpse	r0, r1
    7f86:	d8 f7       	brcc	.-10     	; 0x7f7e <strnlen+0x2>
    7f88:	80 95       	com	r24
    7f8a:	90 95       	com	r25
    7f8c:	8e 0f       	add	r24, r30
    7f8e:	9f 1f       	adc	r25, r31
    7f90:	08 95       	ret

00007f92 <fputc>:
    7f92:	0f 93       	push	r16
    7f94:	1f 93       	push	r17
    7f96:	cf 93       	push	r28
    7f98:	df 93       	push	r29
    7f9a:	8c 01       	movw	r16, r24
    7f9c:	eb 01       	movw	r28, r22
    7f9e:	8b 81       	ldd	r24, Y+3	; 0x03
    7fa0:	81 ff       	sbrs	r24, 1
    7fa2:	1b c0       	rjmp	.+54     	; 0x7fda <fputc+0x48>
    7fa4:	82 ff       	sbrs	r24, 2
    7fa6:	0d c0       	rjmp	.+26     	; 0x7fc2 <fputc+0x30>
    7fa8:	2e 81       	ldd	r18, Y+6	; 0x06
    7faa:	3f 81       	ldd	r19, Y+7	; 0x07
    7fac:	8c 81       	ldd	r24, Y+4	; 0x04
    7fae:	9d 81       	ldd	r25, Y+5	; 0x05
    7fb0:	28 17       	cp	r18, r24
    7fb2:	39 07       	cpc	r19, r25
    7fb4:	64 f4       	brge	.+24     	; 0x7fce <fputc+0x3c>
    7fb6:	e8 81       	ld	r30, Y
    7fb8:	f9 81       	ldd	r31, Y+1	; 0x01
    7fba:	01 93       	st	Z+, r16
    7fbc:	f9 83       	std	Y+1, r31	; 0x01
    7fbe:	e8 83       	st	Y, r30
    7fc0:	06 c0       	rjmp	.+12     	; 0x7fce <fputc+0x3c>
    7fc2:	e8 85       	ldd	r30, Y+8	; 0x08
    7fc4:	f9 85       	ldd	r31, Y+9	; 0x09
    7fc6:	80 2f       	mov	r24, r16
    7fc8:	09 95       	icall
    7fca:	89 2b       	or	r24, r25
    7fcc:	31 f4       	brne	.+12     	; 0x7fda <fputc+0x48>
    7fce:	8e 81       	ldd	r24, Y+6	; 0x06
    7fd0:	9f 81       	ldd	r25, Y+7	; 0x07
    7fd2:	01 96       	adiw	r24, 0x01	; 1
    7fd4:	9f 83       	std	Y+7, r25	; 0x07
    7fd6:	8e 83       	std	Y+6, r24	; 0x06
    7fd8:	02 c0       	rjmp	.+4      	; 0x7fde <fputc+0x4c>
    7fda:	0f ef       	ldi	r16, 0xFF	; 255
    7fdc:	1f ef       	ldi	r17, 0xFF	; 255
    7fde:	c8 01       	movw	r24, r16
    7fe0:	df 91       	pop	r29
    7fe2:	cf 91       	pop	r28
    7fe4:	1f 91       	pop	r17
    7fe6:	0f 91       	pop	r16
    7fe8:	08 95       	ret

00007fea <__ultoa_invert>:
    7fea:	fa 01       	movw	r30, r20
    7fec:	aa 27       	eor	r26, r26
    7fee:	28 30       	cpi	r18, 0x08	; 8
    7ff0:	51 f1       	breq	.+84     	; 0x8046 <__ultoa_invert+0x5c>
    7ff2:	20 31       	cpi	r18, 0x10	; 16
    7ff4:	81 f1       	breq	.+96     	; 0x8056 <__ultoa_invert+0x6c>
    7ff6:	e8 94       	clt
    7ff8:	6f 93       	push	r22
    7ffa:	6e 7f       	andi	r22, 0xFE	; 254
    7ffc:	6e 5f       	subi	r22, 0xFE	; 254
    7ffe:	7f 4f       	sbci	r23, 0xFF	; 255
    8000:	8f 4f       	sbci	r24, 0xFF	; 255
    8002:	9f 4f       	sbci	r25, 0xFF	; 255
    8004:	af 4f       	sbci	r26, 0xFF	; 255
    8006:	b1 e0       	ldi	r27, 0x01	; 1
    8008:	3e d0       	rcall	.+124    	; 0x8086 <__ultoa_invert+0x9c>
    800a:	b4 e0       	ldi	r27, 0x04	; 4
    800c:	3c d0       	rcall	.+120    	; 0x8086 <__ultoa_invert+0x9c>
    800e:	67 0f       	add	r22, r23
    8010:	78 1f       	adc	r23, r24
    8012:	89 1f       	adc	r24, r25
    8014:	9a 1f       	adc	r25, r26
    8016:	a1 1d       	adc	r26, r1
    8018:	68 0f       	add	r22, r24
    801a:	79 1f       	adc	r23, r25
    801c:	8a 1f       	adc	r24, r26
    801e:	91 1d       	adc	r25, r1
    8020:	a1 1d       	adc	r26, r1
    8022:	6a 0f       	add	r22, r26
    8024:	71 1d       	adc	r23, r1
    8026:	81 1d       	adc	r24, r1
    8028:	91 1d       	adc	r25, r1
    802a:	a1 1d       	adc	r26, r1
    802c:	20 d0       	rcall	.+64     	; 0x806e <__ultoa_invert+0x84>
    802e:	09 f4       	brne	.+2      	; 0x8032 <__ultoa_invert+0x48>
    8030:	68 94       	set
    8032:	3f 91       	pop	r19
    8034:	2a e0       	ldi	r18, 0x0A	; 10
    8036:	26 9f       	mul	r18, r22
    8038:	11 24       	eor	r1, r1
    803a:	30 19       	sub	r19, r0
    803c:	30 5d       	subi	r19, 0xD0	; 208
    803e:	31 93       	st	Z+, r19
    8040:	de f6       	brtc	.-74     	; 0x7ff8 <__ultoa_invert+0xe>
    8042:	cf 01       	movw	r24, r30
    8044:	08 95       	ret
    8046:	46 2f       	mov	r20, r22
    8048:	47 70       	andi	r20, 0x07	; 7
    804a:	40 5d       	subi	r20, 0xD0	; 208
    804c:	41 93       	st	Z+, r20
    804e:	b3 e0       	ldi	r27, 0x03	; 3
    8050:	0f d0       	rcall	.+30     	; 0x8070 <__ultoa_invert+0x86>
    8052:	c9 f7       	brne	.-14     	; 0x8046 <__ultoa_invert+0x5c>
    8054:	f6 cf       	rjmp	.-20     	; 0x8042 <__ultoa_invert+0x58>
    8056:	46 2f       	mov	r20, r22
    8058:	4f 70       	andi	r20, 0x0F	; 15
    805a:	40 5d       	subi	r20, 0xD0	; 208
    805c:	4a 33       	cpi	r20, 0x3A	; 58
    805e:	18 f0       	brcs	.+6      	; 0x8066 <__ultoa_invert+0x7c>
    8060:	49 5d       	subi	r20, 0xD9	; 217
    8062:	31 fd       	sbrc	r19, 1
    8064:	40 52       	subi	r20, 0x20	; 32
    8066:	41 93       	st	Z+, r20
    8068:	02 d0       	rcall	.+4      	; 0x806e <__ultoa_invert+0x84>
    806a:	a9 f7       	brne	.-22     	; 0x8056 <__ultoa_invert+0x6c>
    806c:	ea cf       	rjmp	.-44     	; 0x8042 <__ultoa_invert+0x58>
    806e:	b4 e0       	ldi	r27, 0x04	; 4
    8070:	a6 95       	lsr	r26
    8072:	97 95       	ror	r25
    8074:	87 95       	ror	r24
    8076:	77 95       	ror	r23
    8078:	67 95       	ror	r22
    807a:	ba 95       	dec	r27
    807c:	c9 f7       	brne	.-14     	; 0x8070 <__ultoa_invert+0x86>
    807e:	00 97       	sbiw	r24, 0x00	; 0
    8080:	61 05       	cpc	r22, r1
    8082:	71 05       	cpc	r23, r1
    8084:	08 95       	ret
    8086:	9b 01       	movw	r18, r22
    8088:	ac 01       	movw	r20, r24
    808a:	0a 2e       	mov	r0, r26
    808c:	06 94       	lsr	r0
    808e:	57 95       	ror	r21
    8090:	47 95       	ror	r20
    8092:	37 95       	ror	r19
    8094:	27 95       	ror	r18
    8096:	ba 95       	dec	r27
    8098:	c9 f7       	brne	.-14     	; 0x808c <__ultoa_invert+0xa2>
    809a:	62 0f       	add	r22, r18
    809c:	73 1f       	adc	r23, r19
    809e:	84 1f       	adc	r24, r20
    80a0:	95 1f       	adc	r25, r21
    80a2:	a0 1d       	adc	r26, r0
    80a4:	08 95       	ret

000080a6 <_exit>:
    80a6:	f8 94       	cli

000080a8 <__stop_program>:
    80a8:	ff cf       	rjmp	.-2      	; 0x80a8 <__stop_program>
